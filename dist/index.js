import React, { Children, isValidElement, cloneElement, Component, createRef, useState, useMemo, Fragment, useRef } from 'react';
import ReactDOM from 'react-dom';

function _arrayWithHoles$3(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$3(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$1$6(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$1$6(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$6(o, minLen);
}

function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$3(arr, i) {
  return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$1$6(arr, i) || _nonIterableRest$3();
}

function _typeof$P(obj) {
  "@babel/helpers - typeof";

  return _typeof$P = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$P(obj);
}

function classNames() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args) {
    var classes = [];

    for (var i = 0; i < args.length; i++) {
      var className = args[i];
      if (!className) continue;

      var type = _typeof$P(className);

      if (type === 'string' || type === 'number') {
        classes.push(className);
      } else if (type === 'object') {
        var _classes = Array.isArray(className) ? className : Object.entries(className).map(function (_ref) {
          var _ref2 = _slicedToArray$3(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];

          return !!value ? key : null;
        });

        classes = _classes.length ? classes.concat(_classes.filter(function (c) {
          return !!c;
        })) : classes;
      }
    }

    return classes.join(' ');
  }

  return undefined;
}

function _classCallCheck$R(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$R(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$R(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$R(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$R(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _createForOfIteratorHelper$c(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$o(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$o(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$o(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$o(o, minLen);
}

function _arrayLikeToArray$o(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var DomHandler$1 = /*#__PURE__*/function () {
  function DomHandler() {
    _classCallCheck$R(this, DomHandler);
  }

  _createClass$R(DomHandler, null, [{
    key: "innerWidth",
    value: function innerWidth(el) {
      if (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
      }

      return 0;
    }
  }, {
    key: "width",
    value: function width(el) {
      if (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
      }

      return 0;
    }
  }, {
    key: "getBrowserLanguage",
    value: function getBrowserLanguage() {
      return navigator.userLanguage || navigator.languages && navigator.languages.length && navigator.languages[0] || navigator.language || navigator.browserLanguage || navigator.systemLanguage || 'en';
    }
  }, {
    key: "getWindowScrollTop",
    value: function getWindowScrollTop() {
      var doc = document.documentElement;
      return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    }
  }, {
    key: "getWindowScrollLeft",
    value: function getWindowScrollLeft() {
      var doc = document.documentElement;
      return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    }
  }, {
    key: "getOuterWidth",
    value: function getOuterWidth(el, margin) {
      if (el) {
        var width = el.offsetWidth || el.getBoundingClientRect().width;

        if (margin) {
          var style = getComputedStyle(el);
          width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }

        return width;
      }

      return 0;
    }
  }, {
    key: "getOuterHeight",
    value: function getOuterHeight(el, margin) {
      if (el) {
        var height = el.offsetHeight || el.getBoundingClientRect().height;

        if (margin) {
          var style = getComputedStyle(el);
          height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }

        return height;
      }

      return 0;
    }
  }, {
    key: "getClientHeight",
    value: function getClientHeight(el, margin) {
      if (el) {
        var height = el.clientHeight;

        if (margin) {
          var style = getComputedStyle(el);
          height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }

        return height;
      }

      return 0;
    }
  }, {
    key: "getClientWidth",
    value: function getClientWidth(el, margin) {
      if (el) {
        var width = el.clientWidth;

        if (margin) {
          var style = getComputedStyle(el);
          width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }

        return width;
      }

      return 0;
    }
  }, {
    key: "getViewport",
    value: function getViewport() {
      var win = window,
          d = document,
          e = d.documentElement,
          g = d.getElementsByTagName('body')[0],
          w = win.innerWidth || e.clientWidth || g.clientWidth,
          h = win.innerHeight || e.clientHeight || g.clientHeight;
      return {
        width: w,
        height: h
      };
    }
  }, {
    key: "getOffset",
    value: function getOffset(el) {
      if (el) {
        var rect = el.getBoundingClientRect();
        return {
          top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
          left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0)
        };
      }

      return {
        top: 'auto',
        left: 'auto'
      };
    }
  }, {
    key: "index",
    value: function index(element) {
      if (element) {
        var children = element.parentNode.childNodes;
        var num = 0;

        for (var i = 0; i < children.length; i++) {
          if (children[i] === element) return num;
          if (children[i].nodeType === 1) num++;
        }
      }

      return -1;
    }
  }, {
    key: "addMultipleClasses",
    value: function addMultipleClasses(element, className) {
      if (element && className) {
        if (element.classList) {
          var styles = className.split(' ');

          for (var i = 0; i < styles.length; i++) {
            element.classList.add(styles[i]);
          }
        } else {
          var _styles = className.split(' ');

          for (var _i = 0; _i < _styles.length; _i++) {
            element.className += ' ' + _styles[_i];
          }
        }
      }
    }
  }, {
    key: "removeMultipleClasses",
    value: function removeMultipleClasses(element, className) {
      if (element && className) {
        if (element.classList) {
          var styles = className.split(' ');

          for (var i = 0; i < styles.length; i++) {
            element.classList.remove(styles[i]);
          }
        } else {
          var _styles2 = className.split(' ');

          for (var _i2 = 0; _i2 < _styles2.length; _i2++) {
            element.className = element.className.replace(new RegExp('(^|\\b)' + _styles2[_i2].split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
          }
        }
      }
    }
  }, {
    key: "addClass",
    value: function addClass(element, className) {
      if (element && className) {
        if (element.classList) element.classList.add(className);else element.className += ' ' + className;
      }
    }
  }, {
    key: "removeClass",
    value: function removeClass(element, className) {
      if (element && className) {
        if (element.classList) element.classList.remove(className);else element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
      }
    }
  }, {
    key: "hasClass",
    value: function hasClass(element, className) {
      if (element) {
        if (element.classList) return element.classList.contains(className);else return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);
      }
    }
  }, {
    key: "find",
    value: function find(element, selector) {
      return element ? Array.from(element.querySelectorAll(selector)) : [];
    }
  }, {
    key: "findSingle",
    value: function findSingle(element, selector) {
      if (element) {
        return element.querySelector(selector);
      }

      return null;
    }
  }, {
    key: "getHeight",
    value: function getHeight(el) {
      if (el) {
        var height = el.offsetHeight;
        var style = getComputedStyle(el);
        height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
        return height;
      }

      return 0;
    }
  }, {
    key: "getWidth",
    value: function getWidth(el) {
      if (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
        return width;
      }

      return 0;
    }
  }, {
    key: "alignOverlay",
    value: function alignOverlay(overlay, target, appendTo) {
      var calculateMinWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (overlay && target) {
        if (appendTo === 'self') {
          this.relativePosition(overlay, target);
        } else {
          calculateMinWidth && (overlay.style.minWidth = DomHandler.getOuterWidth(target) + 'px');
          this.absolutePosition(overlay, target);
        }
      }
    }
  }, {
    key: "absolutePosition",
    value: function absolutePosition(element, target) {
      if (element) {
        var elementDimensions = element.offsetParent ? {
          width: element.offsetWidth,
          height: element.offsetHeight
        } : this.getHiddenElementDimensions(element);
        var elementOuterHeight = elementDimensions.height;
        var elementOuterWidth = elementDimensions.width;
        var targetOuterHeight = target.offsetHeight;
        var targetOuterWidth = target.offsetWidth;
        var targetOffset = target.getBoundingClientRect();
        var windowScrollTop = this.getWindowScrollTop();
        var windowScrollLeft = this.getWindowScrollLeft();
        var viewport = this.getViewport();
        var top, left;

        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
          top = targetOffset.top + windowScrollTop - elementOuterHeight;

          if (top < 0) {
            top = windowScrollTop;
          }

          element.style.transformOrigin = 'bottom';
        } else {
          top = targetOuterHeight + targetOffset.top + windowScrollTop;
          element.style.transformOrigin = 'top';
        }

        if (targetOffset.left + targetOuterWidth + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);else left = targetOffset.left + windowScrollLeft;
        element.style.top = top + 'px';
        element.style.left = left + 'px';
      }
    }
  }, {
    key: "relativePosition",
    value: function relativePosition(element, target) {
      if (element) {
        var elementDimensions = element.offsetParent ? {
          width: element.offsetWidth,
          height: element.offsetHeight
        } : this.getHiddenElementDimensions(element);
        var targetHeight = target.offsetHeight;
        var targetOffset = target.getBoundingClientRect();
        var viewport = this.getViewport();
        var top, left;

        if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {
          top = -1 * elementDimensions.height;

          if (targetOffset.top + top < 0) {
            top = -1 * targetOffset.top;
          }

          element.style.transformOrigin = 'bottom';
        } else {
          top = targetHeight;
          element.style.transformOrigin = 'top';
        }

        if (elementDimensions.width > viewport.width) {
          // element wider then viewport and cannot fit on screen (align at left side of viewport)
          left = targetOffset.left * -1;
        } else if (targetOffset.left + elementDimensions.width > viewport.width) {
          // element wider then viewport but can be fit on screen (align at right side of viewport)
          left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;
        } else {
          // element fits on screen (align with target)
          left = 0;
        }

        element.style.top = top + 'px';
        element.style.left = left + 'px';
      }
    }
  }, {
    key: "flipfitCollision",
    value: function flipfitCollision(element, target) {
      var _this = this;

      var my = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'left top';
      var at = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'left bottom';
      var callback = arguments.length > 4 ? arguments[4] : undefined;
      var targetOffset = target.getBoundingClientRect();
      var viewport = this.getViewport();
      var myArr = my.split(' ');
      var atArr = at.split(' ');

      var getPositionValue = function getPositionValue(arr, isOffset) {
        return isOffset ? +arr.substring(arr.search(/(\+|-)/g)) || 0 : arr.substring(0, arr.search(/(\+|-)/g)) || arr;
      };

      var position = {
        my: {
          x: getPositionValue(myArr[0]),
          y: getPositionValue(myArr[1] || myArr[0]),
          offsetX: getPositionValue(myArr[0], true),
          offsetY: getPositionValue(myArr[1] || myArr[0], true)
        },
        at: {
          x: getPositionValue(atArr[0]),
          y: getPositionValue(atArr[1] || atArr[0]),
          offsetX: getPositionValue(atArr[0], true),
          offsetY: getPositionValue(atArr[1] || atArr[0], true)
        }
      };
      var myOffset = {
        left: function left() {
          var totalOffset = position.my.offsetX + position.at.offsetX;
          return totalOffset + targetOffset.left + (position.my.x === 'left' ? 0 : -1 * (position.my.x === 'center' ? _this.getOuterWidth(element) / 2 : _this.getOuterWidth(element)));
        },
        top: function top() {
          var totalOffset = position.my.offsetY + position.at.offsetY;
          return totalOffset + targetOffset.top + (position.my.y === 'top' ? 0 : -1 * (position.my.y === 'center' ? _this.getOuterHeight(element) / 2 : _this.getOuterHeight(element)));
        }
      };
      var alignWithAt = {
        count: {
          x: 0,
          y: 0
        },
        left: function left() {
          var left = myOffset.left();
          var scrollLeft = DomHandler.getWindowScrollLeft();
          element.style.left = left + scrollLeft + 'px';

          if (this.count.x === 2) {
            element.style.left = scrollLeft + 'px';
            this.count.x = 0;
          } else if (left < 0) {
            this.count.x++;
            position.my.x = 'left';
            position.at.x = 'right';
            position.my.offsetX *= -1;
            position.at.offsetX *= -1;
            this.right();
          }
        },
        right: function right() {
          var left = myOffset.left() + DomHandler.getOuterWidth(target);
          var scrollLeft = DomHandler.getWindowScrollLeft();
          element.style.left = left + scrollLeft + 'px';

          if (this.count.x === 2) {
            element.style.left = viewport.width - DomHandler.getOuterWidth(element) + scrollLeft + 'px';
            this.count.x = 0;
          } else if (left + DomHandler.getOuterWidth(element) > viewport.width) {
            this.count.x++;
            position.my.x = 'right';
            position.at.x = 'left';
            position.my.offsetX *= -1;
            position.at.offsetX *= -1;
            this.left();
          }
        },
        top: function top() {
          var top = myOffset.top();
          var scrollTop = DomHandler.getWindowScrollTop();
          element.style.top = top + scrollTop + 'px';

          if (this.count.y === 2) {
            element.style.left = scrollTop + 'px';
            this.count.y = 0;
          } else if (top < 0) {
            this.count.y++;
            position.my.y = 'top';
            position.at.y = 'bottom';
            position.my.offsetY *= -1;
            position.at.offsetY *= -1;
            this.bottom();
          }
        },
        bottom: function bottom() {
          var top = myOffset.top() + DomHandler.getOuterHeight(target);
          var scrollTop = DomHandler.getWindowScrollTop();
          element.style.top = top + scrollTop + 'px';

          if (this.count.y === 2) {
            element.style.left = viewport.height - DomHandler.getOuterHeight(element) + scrollTop + 'px';
            this.count.y = 0;
          } else if (top + DomHandler.getOuterHeight(target) > viewport.height) {
            this.count.y++;
            position.my.y = 'bottom';
            position.at.y = 'top';
            position.my.offsetY *= -1;
            position.at.offsetY *= -1;
            this.top();
          }
        },
        center: function center(axis) {
          if (axis === 'y') {
            var top = myOffset.top() + DomHandler.getOuterHeight(target) / 2;
            element.style.top = top + DomHandler.getWindowScrollTop() + 'px';

            if (top < 0) {
              this.bottom();
            } else if (top + DomHandler.getOuterHeight(target) > viewport.height) {
              this.top();
            }
          } else {
            var left = myOffset.left() + DomHandler.getOuterWidth(target) / 2;
            element.style.left = left + DomHandler.getWindowScrollLeft() + 'px';

            if (left < 0) {
              this.left();
            } else if (left + DomHandler.getOuterWidth(element) > viewport.width) {
              this.right();
            }
          }
        }
      };
      alignWithAt[position.at.x]('x');
      alignWithAt[position.at.y]('y');

      if (this.isFunction(callback)) {
        callback(position);
      }
    }
  }, {
    key: "findCollisionPosition",
    value: function findCollisionPosition(position) {
      if (position) {
        var isAxisY = position === 'top' || position === 'bottom';
        var myXPosition = position === 'left' ? 'right' : 'left';
        var myYPosition = position === 'top' ? 'bottom' : 'top';

        if (isAxisY) {
          return {
            axis: 'y',
            my: "center ".concat(myYPosition),
            at: "center ".concat(position)
          };
        }

        return {
          axis: 'x',
          my: "".concat(myXPosition, " center"),
          at: "".concat(position, " center")
        };
      }
    }
  }, {
    key: "getParents",
    value: function getParents(element) {
      var parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return element['parentNode'] === null ? parents : this.getParents(element.parentNode, parents.concat([element.parentNode]));
    }
  }, {
    key: "getScrollableParents",
    value: function getScrollableParents(element) {
      var scrollableParents = [];

      if (element) {
        var parents = this.getParents(element);
        var overflowRegex = /(auto|scroll)/;

        var overflowCheck = function overflowCheck(node) {
          var styleDeclaration = node ? getComputedStyle(node) : null;
          return styleDeclaration && (overflowRegex.test(styleDeclaration.getPropertyValue('overflow')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowX')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowY')));
        };

        var _iterator = _createForOfIteratorHelper$c(parents),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var parent = _step.value;
            var scrollSelectors = parent.nodeType === 1 && parent.dataset['scrollselectors'];

            if (scrollSelectors) {
              var selectors = scrollSelectors.split(',');

              var _iterator2 = _createForOfIteratorHelper$c(selectors),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var selector = _step2.value;
                  var el = this.findSingle(parent, selector);

                  if (el && overflowCheck(el)) {
                    scrollableParents.push(el);
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }

            if (parent.nodeType !== 9 && overflowCheck(parent)) {
              scrollableParents.push(parent);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return scrollableParents;
    }
  }, {
    key: "getHiddenElementOuterHeight",
    value: function getHiddenElementOuterHeight(element) {
      if (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        var elementHeight = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementHeight;
      }

      return 0;
    }
  }, {
    key: "getHiddenElementOuterWidth",
    value: function getHiddenElementOuterWidth(element) {
      if (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        var elementWidth = element.offsetWidth;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementWidth;
      }

      return 0;
    }
  }, {
    key: "getHiddenElementDimensions",
    value: function getHiddenElementDimensions(element) {
      var dimensions = {};

      if (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        dimensions.width = element.offsetWidth;
        dimensions.height = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
      }

      return dimensions;
    }
  }, {
    key: "fadeIn",
    value: function fadeIn(element, duration) {
      if (element) {
        element.style.opacity = 0;
        var last = +new Date();
        var opacity = 0;

        var tick = function tick() {
          opacity = +element.style.opacity + (new Date().getTime() - last) / duration;
          element.style.opacity = opacity;
          last = +new Date();

          if (+opacity < 1) {
            window.requestAnimationFrame && requestAnimationFrame(tick) || setTimeout(tick, 16);
          }
        };

        tick();
      }
    }
  }, {
    key: "fadeOut",
    value: function fadeOut(element, duration) {
      if (element) {
        var opacity = 1,
            interval = 50,
            gap = interval / duration;
        var fading = setInterval(function () {
          opacity -= gap;

          if (opacity <= 0) {
            opacity = 0;
            clearInterval(fading);
          }

          element.style.opacity = opacity;
        }, interval);
      }
    }
  }, {
    key: "getUserAgent",
    value: function getUserAgent() {
      return navigator.userAgent;
    }
  }, {
    key: "isIOS",
    value: function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window['MSStream'];
    }
  }, {
    key: "isAndroid",
    value: function isAndroid() {
      return /(android)/i.test(navigator.userAgent);
    }
  }, {
    key: "isTouchDevice",
    value: function isTouchDevice() {
      return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    }
  }, {
    key: "isFunction",
    value: function isFunction(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
    }
  }, {
    key: "appendChild",
    value: function appendChild(element, target) {
      if (this.isElement(target)) target.appendChild(element);else if (target.el && target.el.nativeElement) target.el.nativeElement.appendChild(element);else throw new Error('Cannot append ' + target + ' to ' + element);
    }
  }, {
    key: "removeChild",
    value: function removeChild(element, target) {
      if (this.isElement(target)) target.removeChild(element);else if (target.el && target.el.nativeElement) target.el.nativeElement.removeChild(element);else throw new Error('Cannot remove ' + element + ' from ' + target);
    }
  }, {
    key: "isElement",
    value: function isElement(obj) {
      return (typeof HTMLElement === "undefined" ? "undefined" : _typeof$P(HTMLElement)) === "object" ? obj instanceof HTMLElement : obj && _typeof$P(obj) === "object" && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === "string";
    }
  }, {
    key: "scrollInView",
    value: function scrollInView(container, item) {
      var borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');
      var borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
      var paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');
      var paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
      var containerRect = container.getBoundingClientRect();
      var itemRect = item.getBoundingClientRect();
      var offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
      var scroll = container.scrollTop;
      var elementHeight = container.clientHeight;
      var itemHeight = this.getOuterHeight(item);

      if (offset < 0) {
        container.scrollTop = scroll + offset;
      } else if (offset + itemHeight > elementHeight) {
        container.scrollTop = scroll + offset - elementHeight + itemHeight;
      }
    }
  }, {
    key: "clearSelection",
    value: function clearSelection() {
      if (window.getSelection) {
        if (window.getSelection().empty) {
          window.getSelection().empty();
        } else if (window.getSelection().removeAllRanges && window.getSelection().rangeCount > 0 && window.getSelection().getRangeAt(0).getClientRects().length > 0) {
          window.getSelection().removeAllRanges();
        }
      } else if (document['selection'] && document['selection'].empty) {
        try {
          document['selection'].empty();
        } catch (error) {//ignore IE bug
        }
      }
    }
  }, {
    key: "calculateScrollbarWidth",
    value: function calculateScrollbarWidth(el) {
      if (el) {
        var style = getComputedStyle(el);
        return el.offsetWidth - el.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);
      } else {
        if (this.calculatedScrollbarWidth != null) return this.calculatedScrollbarWidth;
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "p-scrollbar-measure";
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        this.calculatedScrollbarWidth = scrollbarWidth;
        return scrollbarWidth;
      }
    }
  }, {
    key: "getBrowser",
    value: function getBrowser() {
      if (!this.browser) {
        var matched = this.resolveUserAgent();
        this.browser = {};

        if (matched.browser) {
          this.browser[matched.browser] = true;
          this.browser['version'] = matched.version;
        }

        if (this.browser['chrome']) {
          this.browser['webkit'] = true;
        } else if (this.browser['webkit']) {
          this.browser['safari'] = true;
        }
      }

      return this.browser;
    }
  }, {
    key: "resolveUserAgent",
    value: function resolveUserAgent() {
      var ua = navigator.userAgent.toLowerCase();
      var match = /(chrome)[ ]([\w.]+)/.exec(ua) || /(webkit)[ ]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
      return {
        browser: match[1] || "",
        version: match[2] || "0"
      };
    }
  }, {
    key: "isVisible",
    value: function isVisible(element) {
      return element && element.offsetParent != null;
    }
  }, {
    key: "isExist",
    value: function isExist(element) {
      return element !== null && typeof element !== 'undefined' && element.nodeName && element.parentNode;
    }
  }, {
    key: "hasDOM",
    value: function hasDOM() {
      return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
    }
  }, {
    key: "getFocusableElements",
    value: function getFocusableElements(element) {
      var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var focusableElements = DomHandler.find(element, "button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])".concat(selector, ",\n                [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector));
      var visibleFocusableElements = [];

      var _iterator3 = _createForOfIteratorHelper$c(focusableElements),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var focusableElement = _step3.value;
          if (getComputedStyle(focusableElement).display !== "none" && getComputedStyle(focusableElement).visibility !== "hidden") visibleFocusableElements.push(focusableElement);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return visibleFocusableElements;
    }
  }, {
    key: "getFirstFocusableElement",
    value: function getFirstFocusableElement(element, selector) {
      var focusableElements = DomHandler.getFocusableElements(element, selector);
      return focusableElements.length > 0 ? focusableElements[0] : null;
    }
  }, {
    key: "getLastFocusableElement",
    value: function getLastFocusableElement(element, selector) {
      var focusableElements = DomHandler.getFocusableElements(element, selector);
      return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
    }
  }, {
    key: "getCursorOffset",
    value: function getCursorOffset(el, prevText, nextText, currentText) {
      if (el) {
        var style = getComputedStyle(el);
        var ghostDiv = document.createElement('div');
        ghostDiv.style.position = 'absolute';
        ghostDiv.style.top = '0px';
        ghostDiv.style.left = '0px';
        ghostDiv.style.visibility = 'hidden';
        ghostDiv.style.pointerEvents = 'none';
        ghostDiv.style.overflow = style.overflow;
        ghostDiv.style.width = style.width;
        ghostDiv.style.height = style.height;
        ghostDiv.style.padding = style.padding;
        ghostDiv.style.border = style.border;
        ghostDiv.style.overflowWrap = style.overflowWrap;
        ghostDiv.style.whiteSpace = style.whiteSpace;
        ghostDiv.style.lineHeight = style.lineHeight;
        ghostDiv.innerHTML = prevText.replace(/\r\n|\r|\n/g, '<br />');
        var ghostSpan = document.createElement('span');
        ghostSpan.textContent = currentText;
        ghostDiv.appendChild(ghostSpan);
        var text = document.createTextNode(nextText);
        ghostDiv.appendChild(text);
        document.body.appendChild(ghostDiv);
        var offsetLeft = ghostSpan.offsetLeft,
            offsetTop = ghostSpan.offsetTop,
            clientHeight = ghostSpan.clientHeight;
        document.body.removeChild(ghostDiv);
        return {
          left: Math.abs(offsetLeft - el.scrollLeft),
          top: Math.abs(offsetTop - el.scrollTop) + clientHeight
        };
      }

      return {
        top: 'auto',
        left: 'auto'
      };
    }
  }, {
    key: "invokeElementMethod",
    value: function invokeElementMethod(element, methodName, args) {
      element[methodName].apply(element, args);
    }
  }, {
    key: "isClickable",
    value: function isClickable(element) {
      var targetNode = element.nodeName;
      var parentNode = element.parentElement && element.parentElement.nodeName;
      return targetNode === 'INPUT' || targetNode === 'TEXTAREA' || targetNode === 'BUTTON' || targetNode === 'A' || parentNode === 'INPUT' || parentNode === 'TEXTAREA' || parentNode === 'BUTTON' || parentNode === 'A' || this.hasClass(element, 'p-button') || this.hasClass(element.parentElement, 'p-button') || this.hasClass(element.parentElement, 'p-checkbox') || this.hasClass(element.parentElement, 'p-radiobutton');
    }
  }, {
    key: "applyStyle",
    value: function applyStyle(element, style) {
      if (typeof style === 'string') {
        element.style.cssText = this.style;
      } else {
        for (var prop in this.style) {
          element.style[prop] = style[prop];
        }
      }
    }
  }, {
    key: "exportCSV",
    value: function exportCSV(csv, filename) {
      var blob = new Blob([csv], {
        type: 'application/csv;charset=utf-8;'
      });

      if (window.navigator.msSaveOrOpenBlob) {
        navigator.msSaveOrOpenBlob(blob, filename + '.csv');
      } else {
        var isDownloaded = DomHandler.saveAs({
          name: filename + '.csv',
          src: URL.createObjectURL(blob)
        });

        if (!isDownloaded) {
          csv = 'data:text/csv;charset=utf-8,' + csv;
          window.open(encodeURI(csv));
        }
      }
    }
  }, {
    key: "saveAs",
    value: function saveAs(file) {
      if (file) {
        var link = document.createElement('a');

        if (link.download !== undefined) {
          var name = file.name,
              src = file.src;
          link.setAttribute('href', src);
          link.setAttribute('download', name);
          link.style.display = 'none';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          return true;
        }
      }

      return false;
    }
  }, {
    key: "createInlineStyle",
    value: function createInlineStyle(nonce) {
      var styleElement = document.createElement('style');

      try {
        if (!nonce) {
          nonce = process.env.REACT_APP_CSS_NONCE;
        }
      } catch (error) {// NOOP
      }

      nonce && styleElement.setAttribute('nonce', nonce);
      document.head.appendChild(styleElement);
      return styleElement;
    }
  }, {
    key: "removeInlineStyle",
    value: function removeInlineStyle(styleElement) {
      if (this.isExist(styleElement)) {
        try {
          document.head.removeChild(styleElement);
        } catch (error) {// style element may have already been removed in a fast refresh
        }

        styleElement = null;
      }

      return styleElement;
    }
  }]);

  return DomHandler;
}();

var ConnectedOverlayScrollHandler = /*#__PURE__*/function () {
  function ConnectedOverlayScrollHandler(element) {
    var listener = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

    _classCallCheck$R(this, ConnectedOverlayScrollHandler);

    this.element = element;
    this.listener = listener;
  }

  _createClass$R(ConnectedOverlayScrollHandler, [{
    key: "bindScrollListener",
    value: function bindScrollListener() {
      this.scrollableParents = DomHandler$1.getScrollableParents(this.element);

      for (var i = 0; i < this.scrollableParents.length; i++) {
        this.scrollableParents[i].addEventListener('scroll', this.listener);
      }
    }
  }, {
    key: "unbindScrollListener",
    value: function unbindScrollListener() {
      if (this.scrollableParents) {
        for (var i = 0; i < this.scrollableParents.length; i++) {
          this.scrollableParents[i].removeEventListener('scroll', this.listener);
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.unbindScrollListener();
      this.element = null;
      this.listener = null;
      this.scrollableParents = null;
    }
  }]);

  return ConnectedOverlayScrollHandler;
}();

function EventBus() {
  var allHandlers = new Map();
  return {
    on: function on(type, handler) {
      var handlers = allHandlers.get(type);
      if (!handlers) handlers = [handler];else handlers.push(handler);
      allHandlers.set(type, handlers);
    },
    off: function off(type, handler) {
      var handlers = allHandlers.get(type);
      handlers && handlers.splice(handlers.indexOf(handler) >>> 0, 1);
    },
    emit: function emit(type, evt) {
      var handlers = allHandlers.get(type);
      handlers && handlers.slice().forEach(function (handler) {
        return handler(evt);
      });
    }
  };
}

function _defineProperty$P(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$1$5(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1$5(Object(source), !0).forEach(function (key) {
      _defineProperty$P(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$5(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function mask(el, options) {
  var defaultOptions = {
    mask: null,
    slotChar: '_',
    autoClear: true,
    unmask: false,
    readOnly: false,
    onComplete: null,
    onChange: null,
    onFocus: null,
    onBlur: null
  };
  options = _objectSpread$1$5(_objectSpread$1$5({}, defaultOptions), options);
  var tests, partialPosition, len, firstNonMaskPos, defs, androidChrome, lastRequiredNonMaskPos, oldVal, focusText, caretTimeoutId, buffer, defaultBuffer;

  var caret = function caret(first, last) {
    var range, begin, end;

    if (!el.offsetParent || el !== document.activeElement) {
      return;
    }

    if (typeof first === 'number') {
      begin = first;
      end = typeof last === 'number' ? last : begin;

      if (el.setSelectionRange) {
        el.setSelectionRange(begin, end);
      } else if (el['createTextRange']) {
        range = el['createTextRange']();
        range.collapse(true);
        range.moveEnd('character', end);
        range.moveStart('character', begin);
        range.select();
      }
    } else {
      if (el.setSelectionRange) {
        begin = el.selectionStart;
        end = el.selectionEnd;
      } else if (document['selection'] && document['selection'].createRange) {
        range = document['selection'].createRange();
        begin = 0 - range.duplicate().moveStart('character', -100000);
        end = begin + range.text.length;
      }

      return {
        begin: begin,
        end: end
      };
    }
  };

  var isCompleted = function isCompleted() {
    for (var i = firstNonMaskPos; i <= lastRequiredNonMaskPos; i++) {
      if (tests[i] && buffer[i] === getPlaceholder(i)) {
        return false;
      }
    }

    return true;
  };

  var getPlaceholder = function getPlaceholder(i) {
    if (i < options.slotChar.length) {
      return options.slotChar.charAt(i);
    }

    return options.slotChar.charAt(0);
  };

  var getValue = function getValue() {
    return options.unmask ? getUnmaskedValue() : el && el.value;
  };

  var seekNext = function seekNext(pos) {
    while (++pos < len && !tests[pos]) {}

    return pos;
  };

  var seekPrev = function seekPrev(pos) {
    while (--pos >= 0 && !tests[pos]) {}

    return pos;
  };

  var shiftL = function shiftL(begin, end) {
    var i, j;

    if (begin < 0) {
      return;
    }

    for (i = begin, j = seekNext(end); i < len; i++) {
      if (tests[i]) {
        if (j < len && tests[i].test(buffer[j])) {
          buffer[i] = buffer[j];
          buffer[j] = getPlaceholder(j);
        } else {
          break;
        }

        j = seekNext(j);
      }
    }

    writeBuffer();
    caret(Math.max(firstNonMaskPos, begin));
  };

  var shiftR = function shiftR(pos) {
    var i, c, j, t;

    for (i = pos, c = getPlaceholder(pos); i < len; i++) {
      if (tests[i]) {
        j = seekNext(i);
        t = buffer[i];
        buffer[i] = c;

        if (j < len && tests[j].test(t)) {
          c = t;
        } else {
          break;
        }
      }
    }
  };

  var handleAndroidInput = function handleAndroidInput(e) {
    var curVal = el.value;
    var pos = caret();

    if (oldVal && oldVal.length && oldVal.length > curVal.length) {
      // a deletion or backspace happened
      checkVal(true);

      while (pos.begin > 0 && !tests[pos.begin - 1]) {
        pos.begin--;
      }

      if (pos.begin === 0) {
        while (pos.begin < firstNonMaskPos && !tests[pos.begin]) {
          pos.begin++;
        }
      }

      caret(pos.begin, pos.begin);
    } else {
      checkVal(true);

      while (pos.begin < len && !tests[pos.begin]) {
        pos.begin++;
      }

      caret(pos.begin, pos.begin);
    }

    if (options.onComplete && isCompleted()) {
      options.onComplete({
        originalEvent: e,
        value: getValue()
      });
    }
  };

  var onBlur = function onBlur(e) {
    checkVal();
    updateModel(e);

    if (options.onBlur) {
      options.onBlur(e);
    }

    if (el.value !== focusText) {
      var event = document.createEvent('HTMLEvents');
      event.initEvent('change', true, false);
      el.dispatchEvent(event);
    }
  };

  var onKeyDown = function onKeyDown(e) {
    if (options.readOnly) {
      return;
    }

    var k = e.which || e.keyCode,
        pos,
        begin,
        end;
    var iPhone = /iphone/i.test(DomHandler$1.getUserAgent());
    oldVal = el.value; //backspace, delete, and escape get special treatment

    if (k === 8 || k === 46 || iPhone && k === 127) {
      pos = caret();
      begin = pos.begin;
      end = pos.end;

      if (end - begin === 0) {
        begin = k !== 46 ? seekPrev(begin) : end = seekNext(begin - 1);
        end = k === 46 ? seekNext(end) : end;
      }

      clearBuffer(begin, end);
      shiftL(begin, end - 1);
      updateModel(e);
      e.preventDefault();
    } else if (k === 13) {
      // enter
      onBlur(e);
      updateModel(e);
    } else if (k === 27) {
      // escape
      el.value = focusText;
      caret(0, checkVal());
      updateModel(e);
      e.preventDefault();
    }
  };

  var onKeyPress = function onKeyPress(e) {
    if (options.readOnly) {
      return;
    }

    var k = e.which || e.keyCode,
        pos = caret(),
        p,
        c,
        next,
        completed;

    if (e.ctrlKey || e.altKey || e.metaKey || k < 32) {
      //Ignore
      return;
    } else if (k && k !== 13) {
      if (pos.end - pos.begin !== 0) {
        clearBuffer(pos.begin, pos.end);
        shiftL(pos.begin, pos.end - 1);
      }

      p = seekNext(pos.begin - 1);

      if (p < len) {
        c = String.fromCharCode(k);

        if (tests[p].test(c)) {
          shiftR(p);
          buffer[p] = c;
          writeBuffer();
          next = seekNext(p);

          if (/android/i.test(DomHandler$1.getUserAgent())) {
            //Path for CSP Violation on FireFox OS 1.1
            var proxy = function proxy() {
              caret(next);
            };

            setTimeout(proxy, 0);
          } else {
            caret(next);
          }

          if (pos.begin <= lastRequiredNonMaskPos) {
            completed = isCompleted();
          }
        }
      }

      e.preventDefault();
    }

    updateModel(e);

    if (options.onComplete && completed) {
      options.onComplete({
        originalEvent: e,
        value: getValue()
      });
    }
  };

  var clearBuffer = function clearBuffer(start, end) {
    var i;

    for (i = start; i < end && i < len; i++) {
      if (tests[i]) {
        buffer[i] = getPlaceholder(i);
      }
    }
  };

  var writeBuffer = function writeBuffer() {
    el.value = buffer.join('');
  };

  var checkVal = function checkVal(allow) {
    //try to place characters where they belong
    var test = el.value,
        lastMatch = -1,
        i,
        c,
        pos;

    for (i = 0, pos = 0; i < len; i++) {
      if (tests[i]) {
        buffer[i] = getPlaceholder(i);

        while (pos++ < test.length) {
          c = test.charAt(pos - 1);

          if (tests[i].test(c)) {
            buffer[i] = c;
            lastMatch = i;
            break;
          }
        }

        if (pos > test.length) {
          clearBuffer(i + 1, len);
          break;
        }
      } else {
        if (buffer[i] === test.charAt(pos)) {
          pos++;
        }

        if (i < partialPosition) {
          lastMatch = i;
        }
      }
    }

    if (allow) {
      writeBuffer();
    } else if (lastMatch + 1 < partialPosition) {
      if (options.autoClear || buffer.join('') === defaultBuffer) {
        // Invalid value. Remove it and replace it with the
        // mask, which is the default behavior.
        if (el.value) el.value = '';
        clearBuffer(0, len);
      } else {
        // Invalid value, but we opt to show the value to the
        // user and allow them to correct their mistake.
        writeBuffer();
      }
    } else {
      writeBuffer();
      el.value = el.value.substring(0, lastMatch + 1);
    }

    return partialPosition ? i : firstNonMaskPos;
  };

  var onFocus = function onFocus(e) {
    if (options.readOnly) {
      return;
    }

    clearTimeout(caretTimeoutId);
    var pos;
    focusText = el.value;
    pos = checkVal();
    caretTimeoutId = setTimeout(function () {
      if (el !== document.activeElement) {
        return;
      }

      writeBuffer();

      if (pos === options.mask.replace("?", "").length) {
        caret(0, pos);
      } else {
        caret(pos);
      }
    }, 10);

    if (options.onFocus) {
      options.onFocus(e);
    }
  };

  var onInput = function onInput(event) {
    if (androidChrome) handleAndroidInput(event);else handleInputChange(event);
  };

  var handleInputChange = function handleInputChange(e) {
    if (options.readOnly) {
      return;
    }

    var pos = checkVal(true);
    caret(pos);
    updateModel(e);

    if (options.onComplete && isCompleted()) {
      options.onComplete({
        originalEvent: e,
        value: getValue()
      });
    }
  };

  var getUnmaskedValue = function getUnmaskedValue() {
    var unmaskedBuffer = [];

    for (var i = 0; i < buffer.length; i++) {
      var c = buffer[i];

      if (tests[i] && c !== getPlaceholder(i)) {
        unmaskedBuffer.push(c);
      }
    }

    return unmaskedBuffer.join('');
  };

  var updateModel = function updateModel(e) {
    if (options.onChange) {
      var val = getValue().replace(options.slotChar, '');
      options.onChange({
        originalEvent: e,
        value: defaultBuffer !== val ? val : ''
      });
    }
  };

  var bindEvents = function bindEvents() {
    el.addEventListener('focus', onFocus);
    el.addEventListener('blur', onBlur);
    el.addEventListener('keydown', onKeyDown);
    el.addEventListener('keypress', onKeyPress);
    el.addEventListener('input', onInput);
    el.addEventListener('paste', handleInputChange);
  };

  var unbindEvents = function unbindEvents() {
    el.removeEventListener('focus', onFocus);
    el.removeEventListener('blur', onBlur);
    el.removeEventListener('keydown', onKeyDown);
    el.removeEventListener('keypress', onKeyPress);
    el.removeEventListener('input', onInput);
    el.removeEventListener('paste', handleInputChange);
  };

  var init = function init() {
    tests = [];
    partialPosition = options.mask.length;
    len = options.mask.length;
    firstNonMaskPos = null;
    defs = {
      '9': '[0-9]',
      'a': '[A-Za-z]',
      '*': '[A-Za-z0-9]'
    };
    var ua = DomHandler$1.getUserAgent();
    androidChrome = /chrome/i.test(ua) && /android/i.test(ua);
    var maskTokens = options.mask.split('');

    for (var i = 0; i < maskTokens.length; i++) {
      var c = maskTokens[i];

      if (c === '?') {
        len--;
        partialPosition = i;
      } else if (defs[c]) {
        tests.push(new RegExp(defs[c]));

        if (firstNonMaskPos === null) {
          firstNonMaskPos = tests.length - 1;
        }

        if (i < partialPosition) {
          lastRequiredNonMaskPos = tests.length - 1;
        }
      } else {
        tests.push(null);
      }
    }

    buffer = [];

    for (var _i = 0; _i < maskTokens.length; _i++) {
      var _c = maskTokens[_i];

      if (_c !== '?') {
        if (defs[_c]) buffer.push(getPlaceholder(_i));else buffer.push(_c);
      }
    }

    defaultBuffer = buffer.join('');
  };

  if (el && options.mask) {
    init();
    bindEvents();
  }

  return {
    init: init,
    bindEvents: bindEvents,
    unbindEvents: unbindEvents,
    updateModel: updateModel,
    getValue: getValue
  };
}

var ObjectUtils = /*#__PURE__*/function () {
  function ObjectUtils() {
    _classCallCheck$R(this, ObjectUtils);
  }

  _createClass$R(ObjectUtils, null, [{
    key: "equals",
    value: function equals(obj1, obj2, field) {
      if (field && obj1 && _typeof$P(obj1) === 'object' && obj2 && _typeof$P(obj2) === 'object') return this.resolveFieldData(obj1, field) === this.resolveFieldData(obj2, field);else return this.deepEquals(obj1, obj2);
    }
  }, {
    key: "deepEquals",
    value: function deepEquals(a, b) {
      if (a === b) return true;

      if (a && b && _typeof$P(a) == 'object' && _typeof$P(b) == 'object') {
        var arrA = Array.isArray(a),
            arrB = Array.isArray(b),
            i,
            length,
            key;

        if (arrA && arrB) {
          length = a.length;
          if (length !== b.length) return false;

          for (i = length; i-- !== 0;) {
            if (!this.deepEquals(a[i], b[i])) return false;
          }

          return true;
        }

        if (arrA !== arrB) return false;
        var dateA = a instanceof Date,
            dateB = b instanceof Date;
        if (dateA !== dateB) return false;
        if (dateA && dateB) return a.getTime() === b.getTime();
        var regexpA = a instanceof RegExp,
            regexpB = b instanceof RegExp;
        if (regexpA !== regexpB) return false;
        if (regexpA && regexpB) return a.toString() === b.toString();
        var keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;

        for (i = length; i-- !== 0;) {
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        }

        for (i = length; i-- !== 0;) {
          key = keys[i];
          if (!this.deepEquals(a[key], b[key])) return false;
        }

        return true;
      }
      /*eslint no-self-compare: "off"*/


      return a !== a && b !== b;
    }
  }, {
    key: "resolveFieldData",
    value: function resolveFieldData(data, field) {
      if (data && Object.keys(data).length && field) {
        if (this.isFunction(field)) {
          return field(data);
        } else if (field.indexOf('.') === -1) {
          return data[field];
        } else {
          var fields = field.split('.');
          var value = data;

          for (var i = 0, len = fields.length; i < len; ++i) {
            if (value == null) {
              return null;
            }

            value = value[fields[i]];
          }

          return value;
        }
      } else {
        return null;
      }
    }
  }, {
    key: "isFunction",
    value: function isFunction(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
    }
  }, {
    key: "findDiffKeys",
    value: function findDiffKeys(obj1, obj2) {
      if (!obj1 || !obj2) {
        return {};
      }

      return Object.keys(obj1).filter(function (key) {
        return !obj2.hasOwnProperty(key);
      }).reduce(function (result, current) {
        result[current] = obj1[current];
        return result;
      }, {});
    }
  }, {
    key: "reorderArray",
    value: function reorderArray(value, from, to) {
      var target;

      if (value && from !== to) {
        if (to >= value.length) {
          target = to - value.length;

          while (target-- + 1) {
            value.push(undefined);
          }
        }

        value.splice(to, 0, value.splice(from, 1)[0]);
      }
    }
  }, {
    key: "findIndexInList",
    value: function findIndexInList(value, list, dataKey) {
      var _this = this;

      if (list) {
        return dataKey ? list.findIndex(function (item) {
          return _this.equals(item, value, dataKey);
        }) : list.findIndex(function (item) {
          return item === value;
        });
      }

      return -1;
    }
  }, {
    key: "getJSXElement",
    value: function getJSXElement(obj) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }

      return this.isFunction(obj) ? obj.apply(void 0, params) : obj;
    }
  }, {
    key: "getPropValue",
    value: function getPropValue(obj) {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }

      return this.isFunction(obj) ? obj.apply(void 0, params) : obj;
    }
  }, {
    key: "getRefElement",
    value: function getRefElement(ref) {
      if (ref) {
        return _typeof$P(ref) === 'object' && ref.hasOwnProperty('current') ? ref.current : ref;
      }

      return null;
    }
  }, {
    key: "removeAccents",
    value: function removeAccents(str) {
      if (str && str.search(/[\xC0-\xFF]/g) > -1) {
        str = str.replace(/[\xC0-\xC5]/g, "A").replace(/[\xC6]/g, "AE").replace(/[\xC7]/g, "C").replace(/[\xC8-\xCB]/g, "E").replace(/[\xCC-\xCF]/g, "I").replace(/[\xD0]/g, "D").replace(/[\xD1]/g, "N").replace(/[\xD2-\xD6\xD8]/g, "O").replace(/[\xD9-\xDC]/g, "U").replace(/[\xDD]/g, "Y").replace(/[\xDE]/g, "P").replace(/[\xE0-\xE5]/g, "a").replace(/[\xE6]/g, "ae").replace(/[\xE7]/g, "c").replace(/[\xE8-\xEB]/g, "e").replace(/[\xEC-\xEF]/g, "i").replace(/[\xF1]/g, "n").replace(/[\xF2-\xF6\xF8]/g, "o").replace(/[\xF9-\xFC]/g, "u").replace(/[\xFE]/g, "p").replace(/[\xFD\xFF]/g, "y");
      }

      return str;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty(value) {
      return value === null || value === undefined || value === '' || Array.isArray(value) && value.length === 0 || !(value instanceof Date) && _typeof$P(value) === 'object' && Object.keys(value).length === 0;
    }
  }, {
    key: "isNotEmpty",
    value: function isNotEmpty(value) {
      return !this.isEmpty(value);
    }
    /**
     * Compare value1 and value2 ascending by default (1) or pass in order as -1 for descending.
     *
     * @param {any} value1 the first value
     * @param {any} value2 the second value
     * @param {number | undefined} order by default ascending (1) set to descending (-1)
     * @param {string | undefined} locale the locale to use (default to browser locale if null)
     * @returns either 0, 1 or -1 for comparing the two values
     */

  }, {
    key: "sort",
    value: function sort(value1, value2) {
      var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var locale = arguments.length > 3 ? arguments[3] : undefined;
      var result = null;
      if (value1 == null && value2 != null) result = -1;else if (value1 != null && value2 == null) result = 1;else if (value1 == null && value2 == null) result = 0;else if (typeof value1 === 'string' && typeof value2 === 'string') result = value1.localeCompare(value2, locale, {
        numeric: true
      });else result = value1 < value2 ? -1 : value1 > value2 ? 1 : 0;
      return order * result;
    }
  }]);

  return ObjectUtils;
}();

function _extends$d() {
  _extends$d = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$d.apply(this, arguments);
}

function ownKeys$t(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$t(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$t(Object(source), !0).forEach(function (key) {
      _defineProperty$P(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$t(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var IconUtils = /*#__PURE__*/function () {
  function IconUtils() {
    _classCallCheck$R(this, IconUtils);
  }

  _createClass$R(IconUtils, null, [{
    key: "getJSXIcon",
    value: function getJSXIcon(icon, iconProps, options) {
      var content = null;

      if (icon) {
        var iconType = _typeof$P(icon);

        var className = classNames(iconProps.className, iconType === 'string' && icon);
        content = /*#__PURE__*/React.createElement("span", _extends$d({}, iconProps, {
          className: className
        }));

        if (iconType !== 'string') {
          var defaultContentOptions = _objectSpread$t({
            iconProps: iconProps,
            element: content
          }, options);

          return ObjectUtils.getJSXElement(icon, defaultContentOptions);
        }
      }

      return content;
    }
  }]);

  return IconUtils;
}();

var lastId = 0;

function UniqueComponentId() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'pr_id_';
  lastId++;
  return "".concat(prefix).concat(lastId);
}

function _arrayWithoutHoles$f(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1$6(arr);
}

function _iterableToArray$f(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _nonIterableSpread$f() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$f(arr) {
  return _arrayWithoutHoles$f(arr) || _iterableToArray$f(arr) || _unsupportedIterableToArray$1$6(arr) || _nonIterableSpread$f();
}

function handler() {
  var zIndexes = [];

  var generateZIndex = function generateZIndex(key, autoZIndex) {
    var baseZIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 999;
    var lastZIndex = getLastZIndex(key, autoZIndex, baseZIndex);
    var newZIndex = lastZIndex.value + (lastZIndex.key === key ? 0 : baseZIndex) + 1;
    zIndexes.push({
      key: key,
      value: newZIndex
    });
    return newZIndex;
  };

  var revertZIndex = function revertZIndex(zIndex) {
    zIndexes = zIndexes.filter(function (obj) {
      return obj.value !== zIndex;
    });
  };

  var getCurrentZIndex = function getCurrentZIndex(key, autoZIndex) {
    return getLastZIndex(key, autoZIndex).value;
  };

  var getLastZIndex = function getLastZIndex(key, autoZIndex) {
    var baseZIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return _toConsumableArray$f(zIndexes).reverse().find(function (obj) {
      return autoZIndex ? true : obj.key === key;
    }) || {
      key: key,
      value: baseZIndex
    };
  };

  var getZIndex = function getZIndex(el) {
    return el ? parseInt(el.style.zIndex, 10) || 0 : 0;
  };

  return {
    get: getZIndex,
    set: function set(key, el, autoZIndex, baseZIndex) {
      if (el) {
        el.style.zIndex = String(generateZIndex(key, autoZIndex, baseZIndex));
      }
    },
    clear: function clear(el) {
      if (el) {
        revertZIndex(ZIndexUtils.get(el));
        el.style.zIndex = '';
      }
    },
    getCurrent: function getCurrent(key, autoZIndex) {
      return getCurrentZIndex(key, autoZIndex);
    }
  };
}

var ZIndexUtils = handler();

function _defineProperties$Q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$Q(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$Q(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$Q(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _classCallCheck$Q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperty$O(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var FilterMatchMode = Object.freeze({
  STARTS_WITH: 'startsWith',
  CONTAINS: 'contains',
  NOT_CONTAINS: 'notContains',
  ENDS_WITH: 'endsWith',
  EQUALS: 'equals',
  NOT_EQUALS: 'notEquals',
  IN: 'in',
  LESS_THAN: 'lt',
  LESS_THAN_OR_EQUAL_TO: 'lte',
  GREATER_THAN: 'gt',
  GREATER_THAN_OR_EQUAL_TO: 'gte',
  BETWEEN: 'between',
  DATE_IS: 'dateIs',
  DATE_IS_NOT: 'dateIsNot',
  DATE_BEFORE: 'dateBefore',
  DATE_AFTER: 'dateAfter',
  CUSTOM: 'custom'
});

var PrimeReact = /*#__PURE__*/_createClass$Q(function PrimeReact() {
  _classCallCheck$Q(this, PrimeReact);
});

_defineProperty$O(PrimeReact, "ripple", false);

_defineProperty$O(PrimeReact, "inputStyle", 'outlined');

_defineProperty$O(PrimeReact, "locale", 'en');

_defineProperty$O(PrimeReact, "appendTo", null);

_defineProperty$O(PrimeReact, "cssTransition", true);

_defineProperty$O(PrimeReact, "autoZIndex", true);

_defineProperty$O(PrimeReact, "nonce", null);

_defineProperty$O(PrimeReact, "zIndex", {
  modal: 1100,
  overlay: 1000,
  menu: 1000,
  tooltip: 1100,
  toast: 1200
});

_defineProperty$O(PrimeReact, "filterMatchModeOptions", {
  text: [FilterMatchMode.STARTS_WITH, FilterMatchMode.CONTAINS, FilterMatchMode.NOT_CONTAINS, FilterMatchMode.ENDS_WITH, FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS],
  numeric: [FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS, FilterMatchMode.LESS_THAN, FilterMatchMode.LESS_THAN_OR_EQUAL_TO, FilterMatchMode.GREATER_THAN, FilterMatchMode.GREATER_THAN_OR_EQUAL_TO],
  date: [FilterMatchMode.DATE_IS, FilterMatchMode.DATE_IS_NOT, FilterMatchMode.DATE_BEFORE, FilterMatchMode.DATE_AFTER]
});

function ownKeys$s(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$s(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$s(Object(source), !0).forEach(function (key) {
      _defineProperty$O(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$s(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var locales = {
  'en': {
    startsWith: 'Starts with',
    contains: 'Contains',
    notContains: 'Not contains',
    endsWith: 'Ends with',
    equals: 'Equals',
    notEquals: 'Not equals',
    noFilter: 'No Filter',
    lt: 'Less than',
    lte: 'Less than or equal to',
    gt: 'Greater than',
    gte: 'Greater than or equal to',
    dateIs: 'Date is',
    dateIsNot: 'Date is not',
    dateBefore: 'Date is before',
    dateAfter: 'Date is after',
    custom: 'Custom',
    clear: 'Clear',
    apply: 'Apply',
    matchAll: 'Match All',
    matchAny: 'Match Any',
    addRule: 'Add Rule',
    removeRule: 'Remove Rule',
    accept: 'Yes',
    reject: 'No',
    choose: 'Choose',
    upload: 'Upload',
    cancel: 'Cancel',
    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    today: 'Today',
    weekHeader: 'Wk',
    firstDayOfWeek: 0,
    dateFormat: 'mm/dd/yy',
    weak: 'Weak',
    medium: 'Medium',
    strong: 'Strong',
    passwordPrompt: 'Enter a password',
    emptyFilterMessage: 'No results found',
    emptyMessage: 'No available options'
  }
};

function locale(locale) {
  locale && (PrimeReact.locale = locale);
  return {
    locale: PrimeReact.locale,
    options: locales[PrimeReact.locale]
  };
}

function addLocale(locale, options) {
  locales[locale] = _objectSpread$s(_objectSpread$s({}, locales['en']), options);
}

function updateLocaleOption(key, value, locale) {
  localeOptions(locale)[key] = value;
}

function updateLocaleOptions(options, locale) {
  var _locale = locale || PrimeReact.locale;

  locales[_locale] = _objectSpread$s(_objectSpread$s({}, locales[_locale]), options);
}

function localeOption(key, locale) {
  var _locale = locale || PrimeReact.locale;

  try {
    return localeOptions(_locale)[key];
  } catch (error) {
    throw new Error("The ".concat(key, " option is not found in the current locale('").concat(_locale, "')."));
  }
}

function localeOptions(locale) {
  var _locale = locale || PrimeReact.locale;

  return locales[_locale];
}

var PrimeIcons = Object.freeze({
  ALIGN_CENTER: 'pi pi-align-center',
  ALIGN_JUSTIFY: 'pi pi-align-justify',
  ALIGN_LEFT: 'pi pi-align-left',
  ALIGN_RIGHT: 'pi pi-align-right',
  AMAZON: 'pi pi-amazon',
  ANDROID: 'pi pi-android',
  ANGLE_DOUBLE_DOWN: 'pi pi-angle-double-down',
  ANGLE_DOUBLE_LEFT: 'pi pi-angle-double-left',
  ANGLE_DOUBLE_RIGHT: 'pi pi-angle-double-right',
  ANGLE_DOUBLE_UP: 'pi pi-angle-double-up',
  ANGLE_DOWN: 'pi pi-angle-down',
  ANGLE_LEFT: 'pi pi-angle-left',
  ANGLE_RIGHT: 'pi pi-angle-right',
  ANGLE_UP: 'pi pi-angle-up',
  APPLE: 'pi pi-apple',
  ARROW_CIRCLE_DOWN: 'pi pi-arrow-circle-down',
  ARROW_CIRCLE_LEFT: 'pi pi-arrow-circle-left',
  ARROW_CIRCLE_RIGHT: 'pi pi-arrow-circle-right',
  ARROW_CIRCLE_UP: 'pi pi-arrow-circle-up',
  ARROW_DOWN: 'pi pi-arrow-down',
  ARROW_DOWN_LEFT: 'pi pi-arrow-down-left',
  ARROW_DOWN_RIGHT: 'pi pi-arrow-down-right',
  ARROW_LEFT: 'pi pi-arrow-left',
  ARROW_RIGHT: 'pi pi-arrow-right',
  ARROW_UP: 'pi pi-arrow-up',
  ARROW_UP_LEFT: 'pi pi-arrow-up-left',
  ARROW_UP_RIGHT: 'pi pi-arrow-up-right',
  ARROW_H: 'pi pi-arrow-h',
  ARROW_V: 'pi pi-arrow-v',
  AT: 'pi pi-at',
  BACKWARD: 'pi pi-backward',
  BAN: 'pi pi-ban',
  BARS: 'pi pi-bars',
  BELL: 'pi pi-bell',
  BOLT: 'pi pi-bolt',
  BOOK: 'pi pi-book',
  BOOKMARK: 'pi pi-bookmark',
  BOOKMARK_FILL: 'pi pi-bookmark-fill',
  BOX: 'pi pi-box',
  BRIEFCASE: 'pi pi-briefcase',
  BUILDING: 'pi pi-building',
  CALENDAR: 'pi pi-calendar',
  CALENDAR_MINUS: 'pi pi-calendar-minus',
  CALENDAR_PLUS: 'pi pi-calendar-plus',
  CALENDAR_TIMES: 'pi pi-calendar-times',
  CAMERA: 'pi pi-camera',
  CAR: 'pi pi-car',
  CARET_DOWN: 'pi pi-caret-down',
  CARET_LEFT: 'pi pi-caret-left',
  CARET_RIGHT: 'pi pi-caret-right',
  CARET_UP: 'pi pi-caret-up',
  CHART_BAR: 'pi pi-chart-bar',
  CHART_LINE: 'pi pi-chart-line',
  CHART_PIE: 'pi pi-chart-pie',
  CHECK: 'pi pi-check',
  CHECK_CIRCLE: 'pi pi-check-circle',
  CHECK_SQUARE: 'pi pi-check-square',
  CHEVRON_CIRCLE_DOWN: 'pi pi-chevron-circle-down',
  CHEVRON_CIRCLE_LEFT: 'pi pi-chevron-circle-left',
  CHEVRON_CIRCLE_RIGHT: 'pi pi-chevron-circle-right',
  CHEVRON_CIRCLE_UP: 'pi pi-chevron-circle-up',
  CHEVRON_DOWN: 'pi pi-chevron-down',
  CHEVRON_LEFT: 'pi pi-chevron-left',
  CHEVRON_RIGHT: 'pi pi-chevron-right',
  CHEVRON_UP: 'pi pi-chevron-up',
  CIRCLE: 'pi pi-circle',
  CIRCLE_FILL: 'pi pi-circle-fill',
  CLOCK: 'pi pi-clock',
  CLONE: 'pi pi-clone',
  CLOUD: 'pi pi-cloud',
  CLOUD_DOWNLOAD: 'pi pi-cloud-download',
  CLOUD_UPLOAD: 'pi pi-cloud-upload',
  CODE: 'pi pi-code',
  COG: 'pi pi-cog',
  COMMENT: 'pi pi-comment',
  COMMENTS: 'pi pi-comments',
  COMPASS: 'pi pi-compass',
  COPY: 'pi pi-copy',
  CREDIT_CARD: 'pi pi-credit-card',
  DATABASE: 'pi pi-database',
  DESKTOP: 'pi pi-desktop',
  DIRECTIONS: 'pi pi-directions',
  DIRECTIONS_ALT: 'pi pi-directions-alt',
  DISCORD: 'pi pi-discord',
  DOLLAR: 'pi pi-dollar',
  DOWNLOAD: 'pi pi-download',
  EJECT: 'pi pi-eject',
  ELLIPSIS_H: 'pi pi-ellipsis-h',
  ELLIPSIS_V: 'pi pi-ellipsis-v',
  ENVELOPE: 'pi pi-envelope',
  EURO: 'pi pi-euro',
  EXCLAMATION_CIRCLE: 'pi pi-exclamation-circle',
  EXCLAMATION_TRIANGLE: 'pi pi-exclamation-triangle',
  EXTERNAL_LINK: 'pi pi-external-link',
  EYE: 'pi pi-eye',
  EYE_SLASH: 'pi pi-eye-slash',
  FACEBOOK: 'pi pi-facebook',
  FAST_BACKWARD: 'pi pi-fast-backward',
  FAST_FORWARD: 'pi pi-fast-forward',
  FILE: 'pi pi-file',
  FILE_EXCEL: 'pi pi-file-excel',
  FILE_PDF: 'pi pi-file-pdf',
  FILTER: 'pi pi-filter',
  FILTER_FILL: 'pi pi-filter-fill',
  FILTER_SLASH: 'pi pi-filter-slash',
  FLAG: 'pi pi-flag',
  FLAG_FILL: 'pi pi-flag-fill',
  FOLDER: 'pi pi-folder',
  FOLDER_OPEN: 'pi pi-folder-open',
  FORWARD: 'pi pi-forward',
  GITHUB: 'pi pi-github',
  GLOBE: 'pi pi-globe',
  GOOGLE: 'pi pi-google',
  HASHTAG: 'pi pi-hashtag',
  HEART: 'pi pi-heart',
  HEART_FILL: 'pi pi-heart-fill',
  HISTORY: 'pi pi-history',
  HOME: 'pi pi-home',
  ID_CARD: 'pi pi-id-card',
  IMAGE: 'pi pi-image',
  IMAGES: 'pi pi-images',
  INBOX: 'pi pi-inbox',
  INFO: 'pi pi-info',
  INFO_CIRCLE: 'pi pi-info-circle',
  INSTAGRAM: 'pi pi-instagram',
  KEY: 'pi pi-key',
  LINK: 'pi pi-link',
  LINKEDIN: 'pi pi-linkedin',
  LIST: 'pi pi-list',
  LOCK: 'pi pi-lock',
  LOCK_OPEN: 'pi pi-lock-open',
  MAP: 'pi pi-map',
  MAP_MARKER: 'pi pi-map-marker',
  MICROSOFT: 'pi pi-microsoft',
  MINUS: 'pi pi-minus',
  MINUS_CIRCLE: 'pi pi-minus-circle',
  MOBILE: 'pi pi-mobile',
  MONEY_BILL: 'pi pi-money-bill',
  MOON: 'pi pi-moon',
  PALETTE: 'pi pi-palette',
  PAPERCLIP: 'pi pi-paperclip',
  PAUSE: 'pi pi-pause',
  PAYPAL: 'pi pi-paypal',
  PENCIL: 'pi pi-pencil',
  PERCENTAGE: 'pi pi-percentage',
  PHONE: 'pi pi-phone',
  PLAY: 'pi pi-play',
  PLUS: 'pi pi-plus',
  PLUS_CIRCLE: 'pi pi-plus-circle',
  POUND: 'pi pi-pound',
  POWER_OFF: 'pi pi-power-off',
  PRIME: 'pi pi-prime',
  PRINT: 'pi pi-print',
  QRCODE: 'pi pi-qrcode',
  QUESTION: 'pi pi-question',
  QUESTION_CIRCLE: 'pi pi-question-circle',
  REDDIT: 'pi pi-reddit',
  REFRESH: 'pi pi-refresh',
  REPLAY: 'pi pi-replay',
  REPLY: 'pi pi-reply',
  SAVE: 'pi pi-save',
  SEARCH: 'pi pi-search',
  SEARCH_MINUS: 'pi pi-search-minus',
  SEARCH_PLUS: 'pi pi-search-plus',
  SEND: 'pi pi-send',
  SERVER: 'pi pi-server',
  SHARE_ALT: 'pi pi-share-alt',
  SHIELD: 'pi pi-shield',
  SHOPPING_BAG: 'pi pi-shopping-bag',
  SHOPPING_CART: 'pi pi-shopping-cart',
  SIGN_IN: 'pi pi-sign-in',
  SIGN_OUT: 'pi pi-sign-out',
  SITEMAP: 'pi pi-sitemap',
  SLACK: 'pi pi-slack',
  SLIDERS_H: 'pi pi-sliders-h',
  SLIDERS_V: 'pi pi-sliders-v',
  SORT: 'pi pi-sort',
  SORT_ALPHA_DOWN: 'pi pi-sort-alpha-down',
  SORT_ALPHA_ALT_DOWN: 'pi pi-sort-alpha-alt-down',
  SORT_ALPHA_UP: 'pi pi-sort-alpha-up',
  SORT_ALPHA_ALT_UP: 'pi pi-sort-alpha-alt-up',
  SORT_ALT: 'pi pi-sort-alt',
  SORT_ALT_SLASH: 'pi pi-sort-slash',
  SORT_AMOUNT_DOWN: 'pi pi-sort-amount-down',
  SORT_AMOUNT_DOWN_ALT: 'pi pi-sort-amount-down-alt',
  SORT_AMOUNT_UP: 'pi pi-sort-amount-up',
  SORT_AMOUNT_UP_ALT: 'pi pi-sort-amount-up-alt',
  SORT_DOWN: 'pi pi-sort-down',
  SORT_NUMERIC_DOWN: 'pi pi-sort-numeric-down',
  SORT_NUMERIC_ALT_DOWN: 'pi pi-sort-numeric-alt-down',
  SORT_NUMERIC_UP: 'pi pi-sort-numeric-up',
  SORT_NUMERIC_ALT_UP: 'pi pi-sort-numeric-alt-up',
  SORT_UP: 'pi pi-sort-up',
  SPINNER: 'pi pi-spinner',
  STAR: 'pi pi-star',
  STAR_FILL: 'pi pi-star-fill',
  STEP_BACKWARD: 'pi pi-step-backward',
  STEP_BACKWARD_ALT: 'pi pi-step-backward-alt',
  STEP_FORWARD: 'pi pi-step-forward',
  STEP_FORWARD_ALT: 'pi pi-step-forward-alt',
  STOP: 'pi pi-stop',
  STOP_CIRCLE: 'pi pi-stop-circle',
  SUN: 'pi pi-sun',
  SYNC: 'pi pi-sync',
  TABLE: 'pi pi-table',
  TABLET: 'pi pi-tablet',
  TAG: 'pi pi-tag',
  TAGS: 'pi pi-tags',
  TELEGRAM: 'pi pi-telegram',
  TH_LARGE: 'pi pi-th-large',
  THUMBS_DOWN: 'pi pi-thumbs-down',
  THUMBS_UP: 'pi pi-thumbs-up',
  TICKET: 'pi pi-ticket',
  TIMES: 'pi pi-times',
  TIMES_CIRCLE: 'pi pi-times-circle',
  TRASH: 'pi pi-trash',
  TWITTER: 'pi pi-twitter',
  UNDO: 'pi pi-undo',
  UNLOCK: 'pi pi-unlock',
  UPLOAD: 'pi pi-upload',
  USER: 'pi pi-user',
  USER_EDIT: 'pi pi-user-edit',
  USER_MINUS: 'pi pi-user-minus',
  USER_PLUS: 'pi pi-user-plus',
  USERS: 'pi pi-users',
  VIDEO: 'pi pi-video',
  VIMEO: 'pi pi-vimeo',
  VOLUME_DOWN: 'pi pi-volume-down',
  VOLUME_OFF: 'pi pi-volume-off',
  VOLUME_UP: 'pi pi-volume-up',
  WALLET: 'pi pi-wallet',
  WHATSAPP: 'pi pi-whatsapp',
  WIFI: 'pi pi-wifi',
  WINDOW_MAXIMIZE: 'pi pi-window-maximize',
  WINDOW_MINIMIZE: 'pi pi-window-minimize',
  YOUTUBE: 'pi pi-youtube'
});
var MessageSeverity = Object.freeze({
  SUCCESS: 'success',
  INFO: 'info',
  WARN: 'warn',
  ERROR: 'error'
});
var FilterOperator = Object.freeze({
  AND: 'and',
  OR: 'or'
});

function _createForOfIteratorHelper$b(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$n(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$n(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$n(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$n(o, minLen);
}

function _arrayLikeToArray$n(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var FilterService = {
  filter: function filter(value, fields, filterValue, filterMatchMode, filterLocale) {
    var filteredItems = [];

    if (value) {
      var _iterator = _createForOfIteratorHelper$b(value),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;

          var _iterator2 = _createForOfIteratorHelper$b(fields),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var field = _step2.value;
              var fieldValue = ObjectUtils.resolveFieldData(item, field);

              if (this.filters[filterMatchMode](fieldValue, filterValue, filterLocale)) {
                filteredItems.push(item);
                break;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    return filteredItems;
  },
  filters: {
    startsWith: function startsWith(value, filter, filterLocale) {
      if (filter === undefined || filter === null || filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      var filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.slice(0, filterValue.length) === filterValue;
    },
    contains: function contains(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      var filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) !== -1;
    },
    notContains: function notContains(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      var filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) === -1;
    },
    endsWith: function endsWith(value, filter, filterLocale) {
      if (filter === undefined || filter === null || filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      var filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue, stringValue.length - filterValue.length) !== -1;
    },
    equals: function equals(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() === filter.getTime();else return ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale) === ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
    },
    notEquals: function notEquals(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return false;
      }

      if (value === undefined || value === null) {
        return true;
      }

      if (value.getTime && filter.getTime) return value.getTime() !== filter.getTime();else return ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale) !== ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
    },
    "in": function _in(value, filter) {
      if (filter === undefined || filter === null || filter.length === 0) {
        return true;
      }

      for (var i = 0; i < filter.length; i++) {
        if (ObjectUtils.equals(value, filter[i])) {
          return true;
        }
      }

      return false;
    },
    between: function between(value, filter) {
      if (filter == null || filter[0] == null || filter[1] == null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime) return filter[0].getTime() <= value.getTime() && value.getTime() <= filter[1].getTime();else return filter[0] <= value && value <= filter[1];
    },
    lt: function lt(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() < filter.getTime();else return value < filter;
    },
    lte: function lte(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() <= filter.getTime();else return value <= filter;
    },
    gt: function gt(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() > filter.getTime();else return value > filter;
    },
    gte: function gte(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() >= filter.getTime();else return value >= filter;
    },
    dateIs: function dateIs(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.toDateString() === filter.toDateString();
    },
    dateIsNot: function dateIsNot(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.toDateString() !== filter.toDateString();
    },
    dateBefore: function dateBefore(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.getTime() < filter.getTime();
    },
    dateAfter: function dateAfter(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.getTime() > filter.getTime();
    }
  },
  register: function register(rule, fn) {
    this.filters[rule] = fn;
  }
};

function _extends$c() {
  _extends$c = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$c.apply(this, arguments);
}

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _setPrototypeOf$O(o, p) {
  _setPrototypeOf$O = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$O(o, p);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$O(subClass, superClass);
}

var propTypes = {exports: {}};

var reactIs = {exports: {}};

var reactIs_production_min = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b = "function" === typeof Symbol && Symbol.for,
    c = b ? Symbol.for("react.element") : 60103,
    d = b ? Symbol.for("react.portal") : 60106,
    e = b ? Symbol.for("react.fragment") : 60107,
    f = b ? Symbol.for("react.strict_mode") : 60108,
    g = b ? Symbol.for("react.profiler") : 60114,
    h = b ? Symbol.for("react.provider") : 60109,
    k = b ? Symbol.for("react.context") : 60110,
    l = b ? Symbol.for("react.async_mode") : 60111,
    m = b ? Symbol.for("react.concurrent_mode") : 60111,
    n = b ? Symbol.for("react.forward_ref") : 60112,
    p = b ? Symbol.for("react.suspense") : 60113,
    q = b ? Symbol.for("react.suspense_list") : 60120,
    r = b ? Symbol.for("react.memo") : 60115,
    t = b ? Symbol.for("react.lazy") : 60116,
    v = b ? Symbol.for("react.block") : 60121,
    w = b ? Symbol.for("react.fundamental") : 60117,
    x = b ? Symbol.for("react.responder") : 60118,
    y = b ? Symbol.for("react.scope") : 60119;

function z(a) {
  if ("object" === typeof a && null !== a) {
    var u = a.$$typeof;

    switch (u) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;

          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;

              default:
                return u;
            }

        }

      case d:
        return u;
    }
  }
}

function A(a) {
  return z(a) === m;
}

reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;

reactIs_production_min.isAsyncMode = function (a) {
  return A(a) || z(a) === l;
};

reactIs_production_min.isConcurrentMode = A;

reactIs_production_min.isContextConsumer = function (a) {
  return z(a) === k;
};

reactIs_production_min.isContextProvider = function (a) {
  return z(a) === h;
};

reactIs_production_min.isElement = function (a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};

reactIs_production_min.isForwardRef = function (a) {
  return z(a) === n;
};

reactIs_production_min.isFragment = function (a) {
  return z(a) === e;
};

reactIs_production_min.isLazy = function (a) {
  return z(a) === t;
};

reactIs_production_min.isMemo = function (a) {
  return z(a) === r;
};

reactIs_production_min.isPortal = function (a) {
  return z(a) === d;
};

reactIs_production_min.isProfiler = function (a) {
  return z(a) === g;
};

reactIs_production_min.isStrictMode = function (a) {
  return z(a) === f;
};

reactIs_production_min.isSuspense = function (a) {
  return z(a) === p;
};

reactIs_production_min.isValidElementType = function (a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};

reactIs_production_min.typeOf = z;

var reactIs_development = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== "production") {
  (function () {
    // nor polyfill, then a plain number is used for performance.

    var hasSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
    // (unstable) APIs that have been removed. Can we remove the symbols?

    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
    var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
    var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
    var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
    var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
    var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

    function isValidElementType(type) {
      return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
    }

    function typeOf(object) {
      if (typeof object === 'object' && object !== null) {
        var $$typeof = object.$$typeof;

        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type = object.type;

            switch (type) {
              case REACT_ASYNC_MODE_TYPE:
              case REACT_CONCURRENT_MODE_TYPE:
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
                return type;

              default:
                var $$typeofType = type && type.$$typeof;

                switch ($$typeofType) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;

                  default:
                    return $$typeof;
                }

            }

          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }

      return undefined;
    } // AsyncMode is deprecated along with isAsyncMode


    var AsyncMode = REACT_ASYNC_MODE_TYPE;
    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
    var ContextConsumer = REACT_CONTEXT_TYPE;
    var ContextProvider = REACT_PROVIDER_TYPE;
    var Element = REACT_ELEMENT_TYPE;
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Fragment = REACT_FRAGMENT_TYPE;
    var Lazy = REACT_LAZY_TYPE;
    var Memo = REACT_MEMO_TYPE;
    var Portal = REACT_PORTAL_TYPE;
    var Profiler = REACT_PROFILER_TYPE;
    var StrictMode = REACT_STRICT_MODE_TYPE;
    var Suspense = REACT_SUSPENSE_TYPE;
    var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

    function isAsyncMode(object) {
      {
        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
          hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

          console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
        }
      }
      return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    }

    function isConcurrentMode(object) {
      return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    }

    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }

    function isContextProvider(object) {
      return typeOf(object) === REACT_PROVIDER_TYPE;
    }

    function isElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    function isForwardRef(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }

    function isFragment(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    }

    function isLazy(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    }

    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }

    function isPortal(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    }

    function isProfiler(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    }

    function isStrictMode(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }

    function isSuspense(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    }

    reactIs_development.AsyncMode = AsyncMode;
    reactIs_development.ConcurrentMode = ConcurrentMode;
    reactIs_development.ContextConsumer = ContextConsumer;
    reactIs_development.ContextProvider = ContextProvider;
    reactIs_development.Element = Element;
    reactIs_development.ForwardRef = ForwardRef;
    reactIs_development.Fragment = Fragment;
    reactIs_development.Lazy = Lazy;
    reactIs_development.Memo = Memo;
    reactIs_development.Portal = Portal;
    reactIs_development.Profiler = Profiler;
    reactIs_development.StrictMode = StrictMode;
    reactIs_development.Suspense = Suspense;
    reactIs_development.isAsyncMode = isAsyncMode;
    reactIs_development.isConcurrentMode = isConcurrentMode;
    reactIs_development.isContextConsumer = isContextConsumer;
    reactIs_development.isContextProvider = isContextProvider;
    reactIs_development.isElement = isElement;
    reactIs_development.isForwardRef = isForwardRef;
    reactIs_development.isFragment = isFragment;
    reactIs_development.isLazy = isLazy;
    reactIs_development.isMemo = isMemo;
    reactIs_development.isPortal = isPortal;
    reactIs_development.isProfiler = isProfiler;
    reactIs_development.isStrictMode = isStrictMode;
    reactIs_development.isSuspense = isSuspense;
    reactIs_development.isValidElementType = isValidElementType;
    reactIs_development.typeOf = typeOf;
  })();
}

if (process.env.NODE_ENV === 'production') {
  reactIs.exports = reactIs_production_min;
} else {
  reactIs.exports = reactIs_development;
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret$3 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
var ReactPropTypesSecret_1 = ReactPropTypesSecret$3;

var has$2 = Function.call.bind(Object.prototype.hasOwnProperty);

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var printWarning$1 = function () {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret$2 = ReactPropTypesSecret_1;

  var loggedTypeFailures = {};

  var has$1 = has$2;

  printWarning$1 = function (text) {
    var message = 'Warning: ' + text;

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {
      /**/
    }
  };
}
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */


function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (has$1(typeSpecs, typeSpecName)) {
        var error; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$2);
        } catch (ex) {
          error = ex;
        }

        if (error && !(error instanceof Error)) {
          printWarning$1((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
        }

        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;
          var stack = getStack ? getStack() : '';
          printWarning$1('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
        }
      }
    }
  }
}
/**
 * Resets warning cache when testing.
 *
 * @private
 */


checkPropTypes$1.resetWarningCache = function () {
  if (process.env.NODE_ENV !== 'production') {
    loggedTypeFailures = {};
  }
};

var checkPropTypes_1 = checkPropTypes$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactIs$1 = reactIs.exports;

var assign = objectAssign;

var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;

var has = has$2;

var checkPropTypes = checkPropTypes_1;

var printWarning = function () {};

if (process.env.NODE_ENV !== 'production') {
  printWarning = function (text) {
    var message = 'Warning: ' + text;

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

var factoryWithTypeCheckers = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */

  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);

    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }
  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */


  var ANONYMOUS = '<<anonymous>>'; // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.

  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bigint: createPrimitiveTypeChecker('bigint'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),
    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };
  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */

  /*eslint-disable no-self-compare*/

  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */


  function PropTypeError(message, data) {
    this.message = message;
    this.data = data && typeof data === 'object' ? data : {};
    this.stack = '';
  } // Make `instanceof Error` still work for returned errors.


  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }

    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret$1) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;

          if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }

      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }

          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }

        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'), {
          expectedType: expectedType
        });
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }

      var propValue = props[propName];

      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }

      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret$1);

        if (error instanceof Error) {
          return error;
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];

      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];

      if (!ReactIs$1.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (process.env.NODE_ENV !== 'production') {
        if (arguments.length > 1) {
          printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }

      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];

      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);

        if (type === 'symbol') {
          return String(value);
        }

        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }

    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }

      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }

      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$1);

          if (error instanceof Error) {
            return error;
          }
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];

      if (typeof checker !== 'function') {
        printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      var expectedTypes = [];

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret$1);

        if (checkerResult == null) {
          return null;
        }

        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
          expectedTypes.push(checkerResult.data.expectedType);
        }
      }

      var expectedTypesMessage = expectedTypes.length > 0 ? ', expected one of type [' + expectedTypes.join(', ') + ']' : '';
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
    }

    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function invalidValidatorError(componentName, location, propFullName, key, type) {
    return new PropTypeError((componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + type + '`.');
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }

      for (var key in shapeTypes) {
        var checker = shapeTypes[key];

        if (typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }

        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$1);

        if (error) {
          return error;
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      } // We need to check all keys in case some are required but missing from props.


      var allKeys = assign({}, props[propName], shapeTypes);

      for (var key in allKeys) {
        var checker = shapeTypes[key];

        if (has(shapeTypes, key) && typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }

        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }

        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$1);

        if (error) {
          return error;
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;

      case 'boolean':
        return !propValue;

      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }

        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);

        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;

          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;

              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;

      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    } // falsy value can't be a Symbol


    if (!propValue) {
      return false;
    } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'


    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    } // Fallback for non-spec compliant Symbols which are polyfilled.


    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  } // Equivalent of `typeof` but with special handling for array and regexp.


  function getPropType(propValue) {
    var propType = typeof propValue;

    if (Array.isArray(propValue)) {
      return 'array';
    }

    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }

    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }

    return propType;
  } // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.


  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }

    var propType = getPropType(propValue);

    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }

    return propType;
  } // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"


  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);

    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;

      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;

      default:
        return type;
    }
  } // Returns class name of the object, if any.


  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }

    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret = ReactPropTypesSecret_1;

function emptyFunction() {}

function emptyFunctionWithReset() {}

emptyFunctionWithReset.resetWarningCache = emptyFunction;

var factoryWithThrowingShims = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }

    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  }
  shim.isRequired = shim;

  function getShim() {
    return shim;
  }
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var ReactIs = reactIs.exports; // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod


  var throwOnDirectAccess = true;
  propTypes.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  propTypes.exports = factoryWithThrowingShims();
}

var PropTypes = propTypes.exports;

/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}

function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}

var config = {
  disabled: false
};

var timeoutsShape = process.env.NODE_ENV !== 'production' ? PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
  enter: PropTypes.number,
  exit: PropTypes.number,
  appear: PropTypes.number
}).isRequired]) : null;
var classNamesShape = process.env.NODE_ENV !== 'production' ? PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
  enter: PropTypes.string,
  exit: PropTypes.string,
  active: PropTypes.string
}), PropTypes.shape({
  enter: PropTypes.string,
  enterDone: PropTypes.string,
  enterActive: PropTypes.string,
  exit: PropTypes.string,
  exitDone: PropTypes.string,
  exitActive: PropTypes.string
})]) : null;

var TransitionGroupContext = React.createContext(null);

var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

var Transition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  } // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }
  ;

  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;

    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing],
        maybeNode = _ref2[0],
        maybeAppearing = _ref2[1];

    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }

    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(maybeNode, maybeAppearing);

      _this2.onTransitionEnd(enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };

  _proto.performExit = function performExit() {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? undefined : ReactDOM.findDOMNode(this); // no exit animation skip right to EXITED

    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(maybeNode);
      });
      return;
    }

    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(maybeNode);

      _this3.onTransitionEnd(timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
          maybeNode = _ref3[0],
          maybeNextCallback = _ref3[1];

      this.props.addEndListener(maybeNode, maybeNextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

    return (
      /*#__PURE__*/
      // allows for nested Transitions
      React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === 'function' ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };

  return Transition;
}(React.Component);

Transition.contextType = TransitionGroupContext;
Transition.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: PropTypes.shape({
    current: typeof Element === 'undefined' ? PropTypes.any : function (propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return PropTypes.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),

  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,

  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,

  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,

  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,

  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: PropTypes.bool,

  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,

  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,

  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener) pt = pt.isRequired;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return pt.apply(void 0, [props].concat(args));
  },

  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,

  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,

  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,

  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,

  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,

  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func
} : {}; // Name the function so it is clearer in the documentation

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition$1 = Transition;

var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return addClass(node, c);
  });
};

var removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return removeClass$1(node, c);
  });
};
/**
 * A transition component inspired by the excellent
 * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
 * use it if you're using CSS transitions or animations. It's built upon the
 * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
 * component, so it inherits all of its props.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` states of the transition. The first class is applied and then a
 * second `*-active` class in order to activate the CSS transition. After the
 * transition, matching `*-done` class names are applied to persist the
 * transition state.
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
 *         <div>
 *           {"I'll receive my-node-* classes"}
 *         </div>
 *       </CSSTransition>
 *       <button type="button" onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the `in` prop is set to `true`, the child component will first receive
 * the class `example-enter`, then the `example-enter-active` will be added in
 * the next tick. `CSSTransition` [forces a
 * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * between before adding the `example-enter-active`. This is an important trick
 * because it allows us to transition between `example-enter` and
 * `example-enter-active` even though they were added immediately one after
 * another. Most notably, this is what makes it possible for us to animate
 * _appearance_.
 *
 * ```css
 * .my-node-enter {
 *   opacity: 0;
 * }
 * .my-node-enter-active {
 *   opacity: 1;
 *   transition: opacity 200ms;
 * }
 * .my-node-exit {
 *   opacity: 1;
 * }
 * .my-node-exit-active {
 *   opacity: 0;
 *   transition: opacity 200ms;
 * }
 * ```
 *
 * `*-active` classes represent which styles you want to animate **to**, so it's
 * important to add `transition` declaration only to them, otherwise transitions
 * might not behave as intended! This might not be obvious when the transitions
 * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
 * the example above (minus `transition`), but it becomes apparent in more
 * complex transitions.
 *
 * **Note**: If you're using the
 * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
 * prop, make sure to define styles for `.appear-*` classes as well.
 */


var CSSTransition$1 = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };

    _this.onEnter = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument[0],
          appearing = _this$resolveArgument[1];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };

    _this.onEntering = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument2[0],
          appearing = _this$resolveArgument2[1];

      var type = appearing ? 'appear' : 'enter';

      _this.addClass(node, type, 'active');

      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };

    _this.onEntered = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument3[0],
          appearing = _this$resolveArgument3[1];

      var type = appearing ? 'appear' : 'enter';

      _this.removeClasses(node, type);

      _this.addClass(node, type, 'done');

      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };

    _this.onExit = function (maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument4[0];

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      _this.addClass(node, 'exit', 'base');

      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };

    _this.onExiting = function (maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument5[0];

      _this.addClass(node, 'exit', 'active');

      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };

    _this.onExited = function (maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument6[0];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, 'exit', 'done');

      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };

    _this.resolveArguments = function (maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
      : [maybeNode, maybeAppearing];
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === 'string';
      var prefix = isStringClassNames && classNames ? classNames + "-" : '';
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName: baseClassName,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.addClass = function addClass(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];

    var _this$getClassNames = this.getClassNames('enter'),
        doneClassName = _this$getClassNames.doneClassName;

    if (type === 'appear' && phase === 'done' && doneClassName) {
      className += " " + doneClassName;
    } // This is to force a repaint,
    // which is necessary in order to transition styles when adding a class name.


    if (phase === 'active') {
      /* eslint-disable no-unused-expressions */
      node && node.scrollTop;
    }

    if (className) {
      this.appliedClasses[type][phase] = className;

      _addClass(node, className);
    }
  };

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type],
        baseClassName = _this$appliedClasses$.base,
        activeClassName = _this$appliedClasses$.active,
        doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};

    if (baseClassName) {
      removeClass(node, baseClassName);
    }

    if (activeClassName) {
      removeClass(node, activeClassName);
    }

    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props;
        _this$props.classNames;
        var props = _objectWithoutPropertiesLoose$1(_this$props, ["classNames"]);

    return /*#__PURE__*/React.createElement(Transition$1, _extends$c({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(React.Component);

CSSTransition$1.defaultProps = {
  classNames: ''
};
CSSTransition$1.propTypes = process.env.NODE_ENV !== "production" ? _extends$c({}, Transition$1.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: PropTypes.func
}) : {};
var CSSTransition$1$1 = CSSTransition$1;

function _assertThisInitialized$O(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */

function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && isValidElement(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) Children.map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!isValidElement(child)) return;
    var hasPrev = (key in prevChildMapping);
    var hasNext = (key in nextChildMapping);
    var prevChild = prevChildMapping[key];
    var isLeaving = isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && isValidElement(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}

var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
};
/**
 * The `<TransitionGroup>` component manages a set of transition components
 * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
 * components, `<TransitionGroup>` is a state machine for managing the mounting
 * and unmounting of components over time.
 *
 * Consider the example below. As items are removed or added to the TodoList the
 * `in` prop is toggled automatically by the `<TransitionGroup>`.
 *
 * Note that `<TransitionGroup>`  does not define any animation behavior!
 * Exactly _how_ a list item animates is up to the individual transition
 * component. This means you can mix and match animations across different list
 * items.
 */

var TransitionGroup = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(_assertThisInitialized$O(_this)); // Initial children should all be entering, dependent on appear


    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  } // node is `undefined` when user provided `nodeRef` prop
  ;

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = _extends$c({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);

    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return /*#__PURE__*/React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }

    return /*#__PURE__*/React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /*#__PURE__*/React.createElement(Component, props, children));
  };

  return TransitionGroup;
}(React.Component);

TransitionGroup.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: PropTypes.any,

  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: PropTypes.node,

  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: PropTypes.bool,

  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: PropTypes.bool,

  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: PropTypes.bool,

  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: PropTypes.func
} : {};
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup$1 = TransitionGroup;

function _defineProperty$N(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck$P(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$P(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$P(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$P(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$P(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$N(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$N(o, p) {
  _setPrototypeOf$N = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$N(o, p);
}

function _inherits$O(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$N(subClass, superClass);
}

function _typeof$O(obj) {
  "@babel/helpers - typeof";

  return _typeof$O = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$O(obj);
}

function _possibleConstructorReturn$O(self, call) {
  if (call && (_typeof$O(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$N(self);
}

function _getPrototypeOf$O(o) {
  _getPrototypeOf$O = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$O(o);
}

function ownKeys$r(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$r(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$r(Object(source), !0).forEach(function (key) {
      _defineProperty$N(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$r(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$U(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$U();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$O(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$O(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$O(this, result);
  };
}

function _isNativeReflectConstruct$U() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var CSSTransition = /*#__PURE__*/function (_Component) {
  _inherits$O(CSSTransition, _Component);

  var _super = _createSuper$U(CSSTransition);

  function CSSTransition(props) {
    var _this;

    _classCallCheck$P(this, CSSTransition);

    _this = _super.call(this, props);
    _this.onEnter = _this.onEnter.bind(_assertThisInitialized$N(_this));
    _this.onEntering = _this.onEntering.bind(_assertThisInitialized$N(_this));
    _this.onEntered = _this.onEntered.bind(_assertThisInitialized$N(_this));
    _this.onExit = _this.onExit.bind(_assertThisInitialized$N(_this));
    _this.onExiting = _this.onExiting.bind(_assertThisInitialized$N(_this));
    _this.onExited = _this.onExited.bind(_assertThisInitialized$N(_this));
    return _this;
  }

  _createClass$P(CSSTransition, [{
    key: "disabled",
    get: function get() {
      return this.props.disabled || this.props.options && this.props.options.disabled || !PrimeReact.cssTransition;
    }
  }, {
    key: "onEnter",
    value: function onEnter(node, isAppearing) {
      this.props.onEnter && this.props.onEnter(node, isAppearing); // component

      this.props.options && this.props.options.onEnter && this.props.options.onEnter(node, isAppearing); // user option
    }
  }, {
    key: "onEntering",
    value: function onEntering(node, isAppearing) {
      this.props.onEntering && this.props.onEntering(node, isAppearing); // component

      this.props.options && this.props.options.onEntering && this.props.options.onEntering(node, isAppearing); // user option
    }
  }, {
    key: "onEntered",
    value: function onEntered(node, isAppearing) {
      this.props.onEntered && this.props.onEntered(node, isAppearing); // component

      this.props.options && this.props.options.onEntered && this.props.options.onEntered(node, isAppearing); // user option
    }
  }, {
    key: "onExit",
    value: function onExit(node) {
      this.props.onExit && this.props.onExit(node); // component

      this.props.options && this.props.options.onExit && this.props.options.onExit(node); // user option
    }
  }, {
    key: "onExiting",
    value: function onExiting(node) {
      this.props.onExiting && this.props.onExiting(node); // component

      this.props.options && this.props.options.onExiting && this.props.options.onExiting(node); // user option
    }
  }, {
    key: "onExited",
    value: function onExited(node) {
      this.props.onExited && this.props.onExited(node); // component

      this.props.options && this.props.options.onExited && this.props.options.onExited(node); // user option
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props["in"] !== prevProps["in"] && this.disabled) {
        // no animation
        var node = ObjectUtils.getRefElement(this.props.nodeRef);

        if (this.props["in"]) {
          this.onEnter(node, true);
          this.onEntering(node, true);
          this.onEntered(node, true);
        } else {
          this.onExit(node);
          this.onExiting(node);
          this.onExited(node);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      if (this.disabled) {
        return this.props["in"] ? this.props.children : null;
      } else {
        var immutableProps = {
          nodeRef: this.props.nodeRef,
          "in": this.props["in"],
          onEnter: this.onEnter,
          onEntering: this.onEntering,
          onEntered: this.onEntered,
          onExit: this.onExit,
          onExiting: this.onExiting,
          onExited: this.onExited
        };
        var mutableProps = {
          classNames: this.props.classNames,
          timeout: this.props.timeout,
          unmountOnExit: this.props.unmountOnExit
        };

        var props = _objectSpread$r(_objectSpread$r(_objectSpread$r({}, mutableProps), this.props.options || {}), immutableProps);

        return /*#__PURE__*/React.createElement(CSSTransition$1$1, props, this.props.children);
      }
    }
  }]);

  return CSSTransition;
}(Component);

function _arrayLikeToArray$m(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$e(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$m(arr);
}

function _iterableToArray$e(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$m(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$m(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$m(o, minLen);
}

function _nonIterableSpread$e() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$e(arr) {
  return _arrayWithoutHoles$e(arr) || _iterableToArray$e(arr) || _unsupportedIterableToArray$m(arr) || _nonIterableSpread$e();
}

function _defineProperties$O(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$O(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$O(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$O(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _classCallCheck$O(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _setPrototypeOf$M(o, p) {
  _setPrototypeOf$M = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$M(o, p);
}

function _inherits$N(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$M(subClass, superClass);
}

function _typeof$N(obj) {
  "@babel/helpers - typeof";

  return _typeof$N = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$N(obj);
}

function _assertThisInitialized$M(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$N(self, call) {
  if (call && (_typeof$N(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$M(self);
}

function _getPrototypeOf$N(o) {
  _getPrototypeOf$N = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$N(o);
}

function _defineProperty$M(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$q(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$q(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$q(Object(source), !0).forEach(function (key) {
      _defineProperty$M(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$q(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$T(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$T();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$N(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$N(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$N(this, result);
  };
}

function _isNativeReflectConstruct$T() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var AccordionTab = /*#__PURE__*/function (_Component) {
  _inherits$N(AccordionTab, _Component);

  var _super = _createSuper$T(AccordionTab);

  function AccordionTab() {
    _classCallCheck$O(this, AccordionTab);

    return _super.apply(this, arguments);
  }

  return _createClass$O(AccordionTab);
}(Component);

_defineProperty$M(AccordionTab, "defaultProps", {
  header: null,
  disabled: false,
  style: null,
  className: null,
  headerStyle: null,
  headerClassName: null,
  headerTemplate: null,
  contentStyle: null,
  contentClassName: null
});

var Accordion$1 = /*#__PURE__*/function (_Component2) {
  _inherits$N(Accordion, _Component2);

  var _super2 = _createSuper$T(Accordion);

  function Accordion(props) {
    var _this;

    _classCallCheck$O(this, Accordion);

    _this = _super2.call(this, props);
    var state = {
      id: _this.props.id
    };

    if (!_this.props.onTabChange) {
      state = _objectSpread$q(_objectSpread$q({}, state), {}, {
        activeIndex: props.activeIndex
      });
    }

    _this.state = state;
    return _this;
  }

  _createClass$O(Accordion, [{
    key: "shouldTabRender",
    value: function shouldTabRender(tab) {
      return tab && tab.type === AccordionTab;
    }
  }, {
    key: "onTabHeaderClick",
    value: function onTabHeaderClick(event, tab, index) {
      if (!tab.props.disabled) {
        var selected = this.isSelected(index);
        var newActiveIndex = null;

        if (this.props.multiple) {
          var indexes = (this.props.onTabChange ? this.props.activeIndex : this.state.activeIndex) || [];
          if (selected) indexes = indexes.filter(function (i) {
            return i !== index;
          });else indexes = [].concat(_toConsumableArray$e(indexes), [index]);
          newActiveIndex = indexes;
        } else {
          newActiveIndex = selected ? null : index;
        }

        var callback = selected ? this.props.onTabClose : this.props.onTabOpen;

        if (callback) {
          callback({
            originalEvent: event,
            index: index
          });
        }

        if (this.props.onTabChange) {
          this.props.onTabChange({
            originalEvent: event,
            index: newActiveIndex
          });
        } else {
          this.setState({
            activeIndex: newActiveIndex
          });
        }
      }

      event.preventDefault();
    }
  }, {
    key: "isSelected",
    value: function isSelected(index) {
      var activeIndex = this.props.onTabChange ? this.props.activeIndex : this.state.activeIndex;
      return this.props.multiple ? activeIndex && activeIndex.indexOf(index) >= 0 : activeIndex === index;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (!this.state.id) {
        this.setState({
          id: UniqueComponentId()
        });
      }
    }
  }, {
    key: "renderTabHeader",
    value: function renderTabHeader(tab, selected, index) {
      var _this2 = this;

      var style = _objectSpread$q(_objectSpread$q({}, tab.props.headerStyle || {}), tab.props.style || {});

      var className = classNames('p-accordion-header', {
        'p-highlight': selected,
        'p-disabled': tab.props.disabled
      }, tab.props.headerClassName, tab.props.className);
      var id = this.state.id + '_header_' + index;
      var ariaControls = this.state.id + '_content_' + index;
      var tabIndex = tab.props.disabled ? -1 : null;
      var header = tab.props.headerTemplate ? ObjectUtils.getJSXElement(tab.props.headerTemplate, tab.props) : /*#__PURE__*/React.createElement("span", {
        className: "p-accordion-header-text"
      }, tab.props.header);
      var icon = selected ? this.props.collapseIcon : this.props.expandIcon;
      return /*#__PURE__*/React.createElement("div", {
        className: className,
        style: style
      }, /*#__PURE__*/React.createElement("a", {
        href: '#' + ariaControls,
        id: id,
        className: "p-accordion-header-link",
        "aria-controls": ariaControls,
        role: "tab",
        "aria-expanded": selected,
        onClick: function onClick(event) {
          return _this2.onTabHeaderClick(event, tab, index);
        },
        tabIndex: tabIndex
      }, IconUtils.getJSXIcon(icon, {
        className: 'p-accordion-toggle-icon'
      }, {
        props: this.props,
        selected: selected
      }), header));
    }
  }, {
    key: "renderTabContent",
    value: function renderTabContent(tab, selected, index) {
      var style = _objectSpread$q(_objectSpread$q({}, tab.props.contentStyle || {}), tab.props.style || {});

      var className = classNames('p-toggleable-content', tab.props.contentClassName, tab.props.className);
      var id = this.state.id + '_content_' + index;
      var toggleableContentRef = /*#__PURE__*/React.createRef();
      return /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: toggleableContentRef,
        classNames: "p-toggleable-content",
        timeout: {
          enter: 1000,
          exit: 450
        },
        "in": selected,
        unmountOnExit: true,
        options: this.props.transitionOptions
      }, /*#__PURE__*/React.createElement("div", {
        ref: toggleableContentRef,
        id: id,
        className: className,
        style: style,
        role: "region",
        "aria-labelledby": this.state.id + '_header_' + index
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-accordion-content"
      }, tab.props.children)));
    }
  }, {
    key: "renderTab",
    value: function renderTab(tab, index) {
      var selected = this.isSelected(index);
      var tabHeader = this.renderTabHeader(tab, selected, index);
      var tabContent = this.renderTabContent(tab, selected, index);
      var tabClassName = classNames('p-accordion-tab', {
        'p-accordion-tab-active': selected
      });
      return /*#__PURE__*/React.createElement("div", {
        key: tab.props.header,
        className: tabClassName
      }, tabHeader, tabContent);
    }
  }, {
    key: "renderTabs",
    value: function renderTabs() {
      var _this3 = this;

      return React.Children.map(this.props.children, function (tab, index) {
        if (_this3.shouldTabRender(tab)) {
          return _this3.renderTab(tab, index);
        }
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var className = classNames('p-accordion p-component', this.props.className);
      var tabs = this.renderTabs();
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this4.container = el;
        },
        id: this.state.id,
        className: className,
        style: this.props.style
      }, tabs);
    }
  }]);

  return Accordion;
}(Component);

_defineProperty$M(Accordion$1, "defaultProps", {
  id: null,
  activeIndex: null,
  className: null,
  style: null,
  multiple: false,
  expandIcon: 'pi pi-chevron-right',
  collapseIcon: 'pi pi-chevron-down',
  transitionOptions: null,
  onTabOpen: null,
  onTabClose: null,
  onTabChange: null
});

var Accordion = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      activeIndex = _ref.activeIndex,
      onTabChange = _ref.onTabChange,
      onTabOpen = _ref.onTabOpen,
      onTabClose = _ref.onTabClose,
      style = _ref.style,
      className = _ref.className,
      multiple = _ref.multiple,
      children = _ref.children;
  return /*#__PURE__*/React.createElement(Accordion$1, {
    ref: ref,
    id: id,
    activeIndex: activeIndex,
    onTabChange: onTabChange,
    onTabOpen: onTabOpen,
    onTabClose: onTabClose,
    style: style,
    className: className,
    multiple: multiple
  }, children);
});

function _classCallCheck$N(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$N(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$N(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$N(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$N(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$L(o, p) {
  _setPrototypeOf$L = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$L(o, p);
}

function _inherits$M(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$L(subClass, superClass);
}

function _typeof$M(obj) {
  "@babel/helpers - typeof";

  return _typeof$M = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$M(obj);
}

function _assertThisInitialized$L(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$M(self, call) {
  if (call && (_typeof$M(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$L(self);
}

function _getPrototypeOf$M(o) {
  _getPrototypeOf$M = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$M(o);
}

function _defineProperty$L(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$S(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$S();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$M(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$M(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$M(this, result);
  };
}

function _isNativeReflectConstruct$S() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Avatar$1 = /*#__PURE__*/function (_Component) {
  _inherits$M(Avatar, _Component);

  var _super = _createSuper$S(Avatar);

  function Avatar() {
    _classCallCheck$N(this, Avatar);

    return _super.apply(this, arguments);
  }

  _createClass$N(Avatar, [{
    key: "renderContent",
    value: function renderContent() {
      var _this = this;

      if (this.props.label) {
        return /*#__PURE__*/React.createElement("span", {
          className: "p-avatar-text"
        }, this.props.label);
      } else if (this.props.icon) {
        return IconUtils.getJSXIcon(this.props.icon, {
          className: 'p-avatar-icon'
        }, {
          props: this.props
        });
      } else if (this.props.image) {
        var onError = function onError(e) {
          if (_this.props.onImageError) {
            _this.props.onImageError(e);
          }
        };

        return /*#__PURE__*/React.createElement("img", {
          src: this.props.image,
          alt: this.props.imageAlt,
          onError: onError
        });
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var containerClassName = classNames('p-avatar p-component', {
        'p-avatar-image': this.props.image != null,
        'p-avatar-circle': this.props.shape === 'circle',
        'p-avatar-lg': this.props.size === 'large',
        'p-avatar-xl': this.props.size === 'xlarge',
        'p-avatar-clickable': !!this.props.onClick
      }, this.props.className);
      var content = this.props.template ? ObjectUtils.getJSXElement(this.props.template, this.props) : this.renderContent();
      return /*#__PURE__*/React.createElement("div", {
        className: containerClassName,
        style: this.props.style,
        onClick: this.props.onClick
      }, content, this.props.children);
    }
  }]);

  return Avatar;
}(Component);

_defineProperty$L(Avatar$1, "defaultProps", {
  label: null,
  icon: null,
  image: null,
  size: 'normal',
  shape: 'square',
  style: null,
  className: null,
  template: null,
  imageAlt: 'avatar',
  onImageError: null,
  onClick: null
});

var Avatar = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var label = _ref.label,
      icon = _ref.icon,
      image = _ref.image,
      size = _ref.size,
      shape = _ref.shape,
      imageAlt = _ref.imageAlt,
      style = _ref.style,
      className = _ref.className,
      onImageError = _ref.onImageError,
      onClick = _ref.onClick,
      children = _ref.children;
  var avatarClassName = classNames(className, {
    "p-avatar-sm": size === "small"
  });
  return /*#__PURE__*/React.createElement(Avatar$1, {
    style: style,
    ref: ref,
    className: avatarClassName,
    label: label,
    icon: icon,
    image: image,
    size: size,
    shape: shape,
    imageAlt: imageAlt,
    onImageError: onImageError,
    onClick: onClick
  }, children);
});

function _classCallCheck$M(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$M(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$M(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$M(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$M(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$K(o, p) {
  _setPrototypeOf$K = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$K(o, p);
}

function _inherits$L(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$K(subClass, superClass);
}

function _typeof$L(obj) {
  "@babel/helpers - typeof";

  return _typeof$L = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$L(obj);
}

function _assertThisInitialized$K(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$L(self, call) {
  if (call && (_typeof$L(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$K(self);
}

function _getPrototypeOf$L(o) {
  _getPrototypeOf$L = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$L(o);
}

function _defineProperty$K(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$R(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$R();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$L(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$L(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$L(this, result);
  };
}

function _isNativeReflectConstruct$R() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Badge$1 = /*#__PURE__*/function (_Component) {
  _inherits$L(Badge, _Component);

  var _super = _createSuper$R(Badge);

  function Badge() {
    _classCallCheck$M(this, Badge);

    return _super.apply(this, arguments);
  }

  _createClass$M(Badge, [{
    key: "render",
    value: function render() {
      var badgeClassName = classNames('p-badge p-component', {
        'p-badge-no-gutter': this.props.value && String(this.props.value).length === 1,
        'p-badge-dot': !this.props.value,
        'p-badge-lg': this.props.size === 'large',
        'p-badge-xl': this.props.size === 'xlarge',
        'p-badge-info': this.props.severity === 'info',
        'p-badge-success': this.props.severity === 'success',
        'p-badge-warning': this.props.severity === 'warning',
        'p-badge-danger': this.props.severity === 'danger'
      }, this.props.className);
      return /*#__PURE__*/React.createElement("span", {
        className: badgeClassName,
        style: this.props.style
      }, this.props.value);
    }
  }]);

  return Badge;
}(Component);

_defineProperty$K(Badge$1, "defaultProps", {
  value: null,
  severity: null,
  size: null,
  style: null,
  className: null
});

var Badge = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var value = _ref.value,
      severity = _ref.severity,
      size = _ref.size,
      className = _ref.className,
      style = _ref.style;
  var badgeClassName = classNames(className, {
    "p-badge-sm": size === "small",
    "p-badge-secondary": severity === "secondary",
    "p-badge-help": severity === "help"
  });
  return /*#__PURE__*/React.createElement(Badge$1, {
    style: style,
    ref: ref,
    className: badgeClassName,
    value: value,
    severity: severity,
    size: size
  });
});

function _classCallCheck$L(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$L(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$L(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$L(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$L(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$J(o, p) {
  _setPrototypeOf$J = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$J(o, p);
}

function _inherits$K(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$J(subClass, superClass);
}

function _typeof$K(obj) {
  "@babel/helpers - typeof";

  return _typeof$K = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$K(obj);
}

function _assertThisInitialized$J(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$K(self, call) {
  if (call && (_typeof$K(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$J(self);
}

function _getPrototypeOf$K(o) {
  _getPrototypeOf$K = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$K(o);
}

function _defineProperty$J(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$Q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$Q();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$K(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$K(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$K(this, result);
  };
}

function _isNativeReflectConstruct$Q() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Portal = /*#__PURE__*/function (_Component) {
  _inherits$K(Portal, _Component);

  var _super = _createSuper$Q(Portal);

  function Portal(props) {
    var _this;

    _classCallCheck$L(this, Portal);

    _this = _super.call(this, props);
    var mounted = props.visible && DomHandler$1.hasDOM();
    _this.state = {
      mounted: mounted
    };
    return _this;
  }

  _createClass$L(Portal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (DomHandler$1.hasDOM() && !this.state.mounted) {
        this.setState({
          mounted: true
        }, this.props.onMounted);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.props.onUnmounted && this.props.onUnmounted();
    }
  }, {
    key: "render",
    value: function render() {
      var element = this.props.element || this.props.children;

      if (element && this.state.mounted) {
        var appendTo = this.props.appendTo || PrimeReact.appendTo || document.body;
        return appendTo === 'self' ? element : /*#__PURE__*/ReactDOM.createPortal(element, appendTo);
      }

      return null;
    }
  }]);

  return Portal;
}(Component);

_defineProperty$J(Portal, "defaultProps", {
  element: null,
  appendTo: null,
  visible: false,
  onMounted: null,
  onUnmounted: null
});

function _classCallCheck$K(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$K(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$K(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$K(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$K(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$I(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$I(o, p) {
  _setPrototypeOf$I = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$I(o, p);
}

function _inherits$J(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$I(subClass, superClass);
}

function _typeof$J(obj) {
  "@babel/helpers - typeof";

  return _typeof$J = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$J(obj);
}

function _possibleConstructorReturn$J(self, call) {
  if (call && (_typeof$J(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$I(self);
}

function _getPrototypeOf$J(o) {
  _getPrototypeOf$J = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$J(o);
}

function _defineProperty$I(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$P(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$P();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$J(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$J(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$J(this, result);
  };
}

function _isNativeReflectConstruct$P() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var BlockUI$1 = /*#__PURE__*/function (_Component) {
  _inherits$J(BlockUI, _Component);

  var _super = _createSuper$P(BlockUI);

  function BlockUI(props) {
    var _this;

    _classCallCheck$K(this, BlockUI);

    _this = _super.call(this, props);
    _this.state = {
      visible: props.blocked
    };
    _this.block = _this.block.bind(_assertThisInitialized$I(_this));
    _this.unblock = _this.unblock.bind(_assertThisInitialized$I(_this));
    _this.onPortalMounted = _this.onPortalMounted.bind(_assertThisInitialized$I(_this));
    return _this;
  }

  _createClass$K(BlockUI, [{
    key: "block",
    value: function block() {
      this.setState({
        visible: true
      });
    }
  }, {
    key: "unblock",
    value: function unblock() {
      var _this2 = this;

      var callback = function callback() {
        _this2.setState({
          visible: false
        }, function () {
          _this2.props.fullScreen && DomHandler$1.removeClass(document.body, 'p-overflow-hidden');
          _this2.props.onUnblocked && _this2.props.onUnblocked();
        });
      };

      if (this.mask) {
        DomHandler$1.addClass(this.mask, 'p-component-overlay-leave');
        this.mask.addEventListener('animationend', function () {
          ZIndexUtils.clear(_this2.mask);
          callback();
        });
      } else {
        callback();
      }
    }
  }, {
    key: "onPortalMounted",
    value: function onPortalMounted() {
      if (this.props.fullScreen) {
        DomHandler$1.addClass(document.body, 'p-overflow-hidden');
        document.activeElement.blur();
      }

      if (this.props.autoZIndex) {
        var key = this.props.fullScreen ? 'modal' : 'overlay';
        ZIndexUtils.set(key, this.mask, PrimeReact.autoZIndex, this.props.baseZIndex || PrimeReact.zIndex[key]);
      }

      this.props.onBlocked && this.props.onBlocked();
    }
  }, {
    key: "renderMask",
    value: function renderMask() {
      var _this3 = this;

      if (this.state.visible) {
        var className = classNames('p-blockui p-component-overlay p-component-overlay-enter', {
          'p-blockui-document': this.props.fullScreen
        }, this.props.className);
        var content = this.props.template ? ObjectUtils.getJSXElement(this.props.template, this.props) : null;
        var mask = /*#__PURE__*/React.createElement("div", {
          ref: function ref(el) {
            return _this3.mask = el;
          },
          className: className,
          style: this.props.style
        }, content);
        return /*#__PURE__*/React.createElement(Portal, {
          element: mask,
          appendTo: this.props.fullScreen ? document.body : 'self',
          onMounted: this.onPortalMounted
        });
      }

      return null;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.state.visible) {
        this.block();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (prevProps.blocked !== this.props.blocked) {
        this.props.blocked ? this.block() : this.unblock();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.props.fullScreen) {
        DomHandler$1.removeClass(document.body, 'p-overflow-hidden');
      }

      ZIndexUtils.clear(this.mask);
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var mask = this.renderMask();
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this4.container = el;
        },
        id: this.props.id,
        className: "p-blockui-container"
      }, this.props.children, mask);
    }
  }]);

  return BlockUI;
}(Component);

_defineProperty$I(BlockUI$1, "defaultProps", {
  id: null,
  blocked: false,
  fullScreen: false,
  baseZIndex: 0,
  autoZIndex: true,
  style: null,
  className: null,
  template: null,
  onBlocked: null,
  onUnblocked: null
});

var BlockUI = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      blocked = _ref.blocked,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 50 : _ref$baseZIndex,
      _ref$autoZIndex = _ref.autoZIndex,
      autoZIndex = _ref$autoZIndex === void 0 ? true : _ref$autoZIndex,
      className = _ref.className,
      style = _ref.style,
      children = _ref.children;
  return /*#__PURE__*/React.createElement(BlockUI$1, {
    ref: ref,
    id: id,
    blocked: blocked,
    baseZIndex: baseZIndex,
    autoZIndex: autoZIndex,
    className: className,
    style: style
  }, children);
});

function _classCallCheck$J(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$J(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$J(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$J(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$J(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$H(o, p) {
  _setPrototypeOf$H = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$H(o, p);
}

function _inherits$I(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$H(subClass, superClass);
}

function _typeof$I(obj) {
  "@babel/helpers - typeof";

  return _typeof$I = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$I(obj);
}

function _assertThisInitialized$H(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$I(self, call) {
  if (call && (_typeof$I(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$H(self);
}

function _getPrototypeOf$I(o) {
  _getPrototypeOf$I = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$I(o);
}

function _defineProperty$H(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$O(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$O();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$I(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$I(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$I(this, result);
  };
}

function _isNativeReflectConstruct$O() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var BreadCrumb$1 = /*#__PURE__*/function (_Component) {
  _inherits$I(BreadCrumb, _Component);

  var _super = _createSuper$O(BreadCrumb);

  function BreadCrumb() {
    _classCallCheck$J(this, BreadCrumb);

    return _super.apply(this, arguments);
  }

  _createClass$J(BreadCrumb, [{
    key: "itemClick",
    value: function itemClick(event, item) {
      if (item.disabled) {
        event.preventDefault();
        return;
      }

      if (!item.url) {
        event.preventDefault();
      }

      if (item.command) {
        item.command({
          originalEvent: event,
          item: item
        });
      }
    }
  }, {
    key: "renderHome",
    value: function renderHome() {
      var _this = this;

      if (this.props.home) {
        var className = classNames('p-breadcrumb-home', {
          'p-disabled': this.props.home.disabled
        }, this.props.home.className);
        var iconClassName = classNames('p-menuitem-icon', this.props.home.icon);
        return /*#__PURE__*/React.createElement("li", {
          className: className,
          style: this.props.home.style
        }, /*#__PURE__*/React.createElement("a", {
          href: this.props.home.url || '#',
          className: "p-menuitem-link",
          "aria-disabled": this.props.home.disabled,
          target: this.props.home.target,
          onClick: function onClick(event) {
            return _this.itemClick(event, _this.props.home);
          }
        }, /*#__PURE__*/React.createElement("span", {
          className: iconClassName
        })));
      }

      return null;
    }
  }, {
    key: "renderSeparator",
    value: function renderSeparator() {
      return /*#__PURE__*/React.createElement("li", {
        className: "p-breadcrumb-chevron pi pi-chevron-right"
      });
    }
  }, {
    key: "renderMenuitem",
    value: function renderMenuitem(item) {
      var _this2 = this;

      var className = classNames(item.className, {
        'p-disabled': item.disabled
      });
      var label = item.label && /*#__PURE__*/React.createElement("span", {
        className: "p-menuitem-text"
      }, item.label);
      var content = /*#__PURE__*/React.createElement("a", {
        href: item.url || '#',
        className: "p-menuitem-link",
        target: item.target,
        onClick: function onClick(event) {
          return _this2.itemClick(event, item);
        },
        "aria-disabled": item.disabled
      }, label);

      if (item.template) {
        var defaultContentOptions = {
          onClick: function onClick(event) {
            return _this2.itemClick(event, item);
          },
          className: 'p-menuitem-link',
          labelClassName: 'p-menuitem-text',
          element: content,
          props: this.props
        };
        content = ObjectUtils.getJSXElement(item.template, item, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement("li", {
        className: className,
        style: item.style
      }, content);
    }
  }, {
    key: "renderMenuitems",
    value: function renderMenuitems() {
      var _this3 = this;

      if (this.props.model) {
        var items = this.props.model.map(function (item, index) {
          var menuitem = _this3.renderMenuitem(item);

          var separator = index === _this3.props.model.length - 1 ? null : _this3.renderSeparator();
          return /*#__PURE__*/React.createElement(React.Fragment, {
            key: item.label + '_' + index
          }, menuitem, separator);
        });
        return items;
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-breadcrumb p-component', this.props.className);
      var home = this.renderHome();
      var items = this.renderMenuitems();
      var separator = this.renderSeparator();
      return /*#__PURE__*/React.createElement("nav", {
        id: this.props.id,
        className: className,
        style: this.props.style,
        "aria-label": "Breadcrumb"
      }, /*#__PURE__*/React.createElement("ul", null, home, separator, items));
    }
  }]);

  return BreadCrumb;
}(Component);

_defineProperty$H(BreadCrumb$1, "defaultProps", {
  id: null,
  model: null,
  home: null,
  style: null,
  className: null
});

var getPartsOfTime = function getPartsOfTime() {
  var currentMonth = new Date().getMonth();
  var currentDay = new Date().getDate();
  var currentYear = new Date().getFullYear();
  return {
    month: currentMonth,
    day: currentDay,
    year: currentYear
  };
};

function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$2(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$l(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$l(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$l(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$l(o, minLen);
}

function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$2(arr, i) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$l(arr, i) || _nonIterableRest$2();
}

var filterOptions = function filterOptions(options, paramsList) {
  if (!options) return null;
  var entries = Object.entries(options).filter(function (_ref) {
    var _ref2 = _slicedToArray$2(_ref, 1),
        key = _ref2[0];

    return paramsList.includes(key);
  });
  return Object.fromEntries(entries);
};

var POSSIBLE_PARAMS$1 = ["id", "disabled", "className", "style", "position", "at", "event", "showEvent", "hideEvent", "autoZIndex", "baseZIndex", "showDelay", "hideDelay", "autoHide", "showOnDisabled", "onShow", "onHide"];
var filterTooltipOptions = function filterTooltipOptions(options) {
  return filterOptions(options, POSSIBLE_PARAMS$1);
};

var POSSIBLE_PARAMS = ["label", "url", "command", "disabled", "style", "className"];
var BreadCrumb = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _home$disabled;

  var id = _ref.id,
      model = _ref.model,
      home = _ref.home,
      style = _ref.style,
      className = _ref.className;
  var breadCrumbModel = model.map(function (options) {
    return filterOptions(options, POSSIBLE_PARAMS);
  });
  var breadCrumbHome = {
    icon: home.icon || "pi pi-home",
    url: home.url,
    command: home.command,
    disabled: (_home$disabled = home.disabled) !== null && _home$disabled !== void 0 ? _home$disabled : false,
    style: home.style,
    className: home.className
  };
  return /*#__PURE__*/React.createElement(BreadCrumb$1, {
    ref: ref,
    id: id,
    model: breadCrumbModel,
    home: breadCrumbHome,
    style: style,
    className: className
  });
});

function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _classCallCheck$I(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$I(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$I(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$I(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$I(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$G(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$G(o, p) {
  _setPrototypeOf$G = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$G(o, p);
}

function _inherits$H(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$G(subClass, superClass);
}

function _typeof$H(obj) {
  "@babel/helpers - typeof";

  return _typeof$H = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$H(obj);
}

function _possibleConstructorReturn$H(self, call) {
  if (call && (_typeof$H(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$G(self);
}

function _getPrototypeOf$H(o) {
  _getPrototypeOf$H = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$H(o);
}

function _defineProperty$G(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$N(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$N();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$H(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$H(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$H(this, result);
  };
}

function _isNativeReflectConstruct$N() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function ownKeys$p(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$p(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$p(Object(source), !0).forEach(function (key) {
      _defineProperty$G(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$p(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function tip(props) {
  var appendTo = props.appendTo || document.body;
  var tooltipWrapper = document.createDocumentFragment();
  DomHandler$1.appendChild(tooltipWrapper, appendTo);
  props = _objectSpread$p(_objectSpread$p({}, props), props.options);
  var tooltipEl = /*#__PURE__*/React.createElement(Tooltip$1, props);
  ReactDOM.render(tooltipEl, tooltipWrapper);

  var updateTooltip = function updateTooltip(newProps) {
    props = _objectSpread$p(_objectSpread$p({}, props), newProps);
    ReactDOM.render( /*#__PURE__*/React.cloneElement(tooltipEl, props), tooltipWrapper);
  };

  return {
    destroy: function destroy() {
      ReactDOM.unmountComponentAtNode(tooltipWrapper);
    },
    updateContent: function updateContent(newContent) {
      console.warn("The 'updateContent' method has been deprecated on Tooltip. Use update(newProps) method.");
      updateTooltip({
        content: newContent
      });
    },
    update: function update(newProps) {
      updateTooltip(newProps);
    }
  };
}

var Tooltip$1 = /*#__PURE__*/function (_Component) {
  _inherits$H(Tooltip, _Component);

  var _super = _createSuper$N(Tooltip);

  function Tooltip(props) {
    var _this;

    _classCallCheck$I(this, Tooltip);

    _this = _super.call(this, props);
    _this.state = {
      visible: false,
      position: _this.props.position
    };
    _this.show = _this.show.bind(_assertThisInitialized$G(_this));
    _this.hide = _this.hide.bind(_assertThisInitialized$G(_this));
    _this.onMouseEnter = _this.onMouseEnter.bind(_assertThisInitialized$G(_this));
    _this.onMouseLeave = _this.onMouseLeave.bind(_assertThisInitialized$G(_this));
    return _this;
  }

  _createClass$I(Tooltip, [{
    key: "isTargetContentEmpty",
    value: function isTargetContentEmpty(target) {
      return !(this.props.content || this.getTargetOption(target, 'tooltip'));
    }
  }, {
    key: "isContentEmpty",
    value: function isContentEmpty(target) {
      return !(this.props.content || this.getTargetOption(target, 'tooltip') || this.props.children);
    }
  }, {
    key: "isMouseTrack",
    value: function isMouseTrack(target) {
      return this.getTargetOption(target, 'mousetrack') || this.props.mouseTrack;
    }
  }, {
    key: "isDisabled",
    value: function isDisabled(target) {
      return this.getTargetOption(target, 'disabled') === 'true' || this.hasTargetOption(target, 'disabled') || this.props.disabled;
    }
  }, {
    key: "isShowOnDisabled",
    value: function isShowOnDisabled(target) {
      return this.getTargetOption(target, 'showondisabled') || this.props.showOnDisabled;
    }
  }, {
    key: "isAutoHide",
    value: function isAutoHide() {
      return this.getTargetOption(this.currentTarget, 'autohide') || this.props.autoHide;
    }
  }, {
    key: "getTargetOption",
    value: function getTargetOption(target, option) {
      if (this.hasTargetOption(target, "data-pr-".concat(option))) {
        return target.getAttribute("data-pr-".concat(option));
      }

      return null;
    }
  }, {
    key: "hasTargetOption",
    value: function hasTargetOption(target, option) {
      return target && target.hasAttribute(option);
    }
  }, {
    key: "getEvents",
    value: function getEvents(target) {
      var showEvent = this.getTargetOption(target, 'showevent') || this.props.showEvent;
      var hideEvent = this.getTargetOption(target, 'hideevent') || this.props.hideEvent;

      if (this.isMouseTrack(target)) {
        showEvent = 'mousemove';
        hideEvent = 'mouseleave';
      } else {
        var event = this.getTargetOption(target, 'event') || this.props.event;

        if (event === 'focus') {
          showEvent = 'focus';
          hideEvent = 'blur';
        }
      }

      return {
        showEvent: showEvent,
        hideEvent: hideEvent
      };
    }
  }, {
    key: "getPosition",
    value: function getPosition(target) {
      return this.getTargetOption(target, 'position') || this.state.position;
    }
  }, {
    key: "getMouseTrackPosition",
    value: function getMouseTrackPosition(target) {
      var top = this.getTargetOption(target, 'mousetracktop') || this.props.mouseTrackTop;
      var left = this.getTargetOption(target, 'mousetrackleft') || this.props.mouseTrackLeft;
      return {
        top: top,
        left: left
      };
    }
  }, {
    key: "updateText",
    value: function updateText(target, callback) {
      if (this.tooltipTextEl) {
        var content = this.getTargetOption(target, 'tooltip') || this.props.content;

        if (content) {
          this.tooltipTextEl.innerHTML = ''; // remove children

          this.tooltipTextEl.appendChild(document.createTextNode(content));
          callback();
        } else if (this.props.children) {
          callback();
        }
      }
    }
  }, {
    key: "show",
    value: function show(e) {
      var _this2 = this;

      this.currentTarget = e.currentTarget;
      var disabled = this.isDisabled(this.currentTarget);
      var empty = this.isContentEmpty(this.isShowOnDisabled(this.currentTarget) && disabled ? this.currentTarget.firstChild : this.currentTarget);

      if (empty || disabled) {
        return;
      }

      var updateTooltipState = function updateTooltipState() {
        _this2.updateText(_this2.currentTarget, function () {
          if (_this2.props.autoZIndex && !ZIndexUtils.get(_this2.containerEl)) {
            ZIndexUtils.set('tooltip', _this2.containerEl, PrimeReact.autoZIndex, _this2.props.baseZIndex || PrimeReact.zIndex['tooltip']);
          }

          _this2.containerEl.style.left = '';
          _this2.containerEl.style.top = '';

          if (_this2.isMouseTrack(_this2.currentTarget) && !_this2.containerSize) {
            _this2.containerSize = {
              width: DomHandler$1.getOuterWidth(_this2.containerEl),
              height: DomHandler$1.getOuterHeight(_this2.containerEl)
            };
          }

          _this2.align(_this2.currentTarget, {
            x: e.pageX,
            y: e.pageY
          });
        });
      };

      if (this.state.visible) {
        this.applyDelay('updateDelay', updateTooltipState);
      } else {
        this.sendCallback(this.props.onBeforeShow, {
          originalEvent: e,
          target: this.currentTarget
        });
        this.applyDelay('showDelay', function () {
          _this2.setState({
            visible: true,
            position: _this2.getPosition(_this2.currentTarget)
          }, function () {
            updateTooltipState();

            _this2.sendCallback(_this2.props.onShow, {
              originalEvent: e,
              target: _this2.currentTarget
            });
          });

          _this2.bindDocumentResizeListener();

          _this2.bindScrollListener();

          DomHandler$1.addClass(_this2.currentTarget, _this2.getTargetOption(_this2.currentTarget, 'classname'));
        });
      }
    }
  }, {
    key: "hide",
    value: function hide(e) {
      var _this3 = this;

      this.clearTimeouts();

      if (this.state.visible) {
        DomHandler$1.removeClass(this.currentTarget, this.getTargetOption(this.currentTarget, 'classname'));
        this.sendCallback(this.props.onBeforeHide, {
          originalEvent: e,
          target: this.currentTarget
        });
        this.applyDelay('hideDelay', function () {
          ZIndexUtils.clear(_this3.containerEl);
          DomHandler$1.removeClass(_this3.containerEl, 'p-tooltip-active');

          if (!_this3.isAutoHide() && _this3.allowHide === false) {
            return;
          }

          _this3.setState({
            visible: false,
            position: _this3.props.position
          }, function () {
            if (_this3.tooltipTextEl) {
              ReactDOM.unmountComponentAtNode(_this3.tooltipTextEl);
            }

            _this3.unbindDocumentResizeListener();

            _this3.unbindScrollListener();

            _this3.currentTarget = null;
            _this3.scrollHandler = null;
            _this3.containerSize = null;
            _this3.allowHide = true;

            _this3.sendCallback(_this3.props.onHide, {
              originalEvent: e,
              target: _this3.currentTarget
            });
          });
        });
      }
    }
  }, {
    key: "align",
    value: function align(target, coordinate) {
      var _this4 = this;

      var left = 0,
          top = 0;

      if (this.isMouseTrack(target) && coordinate) {
        var containerSize = {
          width: DomHandler$1.getOuterWidth(this.containerEl),
          height: DomHandler$1.getOuterHeight(this.containerEl)
        };
        left = coordinate.x;
        top = coordinate.y;

        var _this$getMouseTrackPo = this.getMouseTrackPosition(target),
            mouseTrackTop = _this$getMouseTrackPo.top,
            mouseTrackLeft = _this$getMouseTrackPo.left;

        switch (this.state.position) {
          case 'left':
            left -= containerSize.width + mouseTrackLeft;
            top -= containerSize.height / 2 - mouseTrackTop;
            break;

          case 'right':
            left += mouseTrackLeft;
            top -= containerSize.height / 2 - mouseTrackTop;
            break;

          case 'top':
            left -= containerSize.width / 2 - mouseTrackLeft;
            top -= containerSize.height + mouseTrackTop;
            break;

          case 'bottom':
            left -= containerSize.width / 2 - mouseTrackLeft;
            top += mouseTrackTop;
            break;
        }

        if (left <= 0 || this.containerSize.width > containerSize.width) {
          this.containerEl.style.left = '0px';
          this.containerEl.style.right = window.innerWidth - containerSize.width - left + 'px';
        } else {
          this.containerEl.style.right = '';
          this.containerEl.style.left = left + 'px';
        }

        this.containerEl.style.top = top + 'px';
        DomHandler$1.addClass(this.containerEl, 'p-tooltip-active');
      } else {
        var pos = DomHandler$1.findCollisionPosition(this.state.position);
        var my = this.getTargetOption(target, 'my') || this.props.my || pos.my;
        var at = this.getTargetOption(target, 'at') || this.props.at || pos.at;
        this.containerEl.style.padding = '0px';
        DomHandler$1.flipfitCollision(this.containerEl, target, my, at, function (currentPosition) {
          var _currentPosition$at = currentPosition.at,
              atX = _currentPosition$at.x,
              atY = _currentPosition$at.y;
          var myX = currentPosition.my.x;
          var position = _this4.props.at ? atX !== 'center' && atX !== myX ? atX : atY : currentPosition.at["".concat(pos.axis)];
          _this4.containerEl.style.padding = '';

          _this4.setState({
            position: position
          }, function () {
            _this4.updateContainerPosition();

            DomHandler$1.addClass(_this4.containerEl, 'p-tooltip-active');
          });
        });
      }
    }
  }, {
    key: "updateContainerPosition",
    value: function updateContainerPosition() {
      if (this.containerEl) {
        var style = getComputedStyle(this.containerEl);
        if (this.state.position === 'left') this.containerEl.style.left = parseFloat(style.left) - parseFloat(style.paddingLeft) * 2 + 'px';else if (this.state.position === 'top') this.containerEl.style.top = parseFloat(style.top) - parseFloat(style.paddingTop) * 2 + 'px';
      }
    }
  }, {
    key: "onMouseEnter",
    value: function onMouseEnter() {
      if (!this.isAutoHide()) {
        this.allowHide = false;
      }
    }
  }, {
    key: "onMouseLeave",
    value: function onMouseLeave(e) {
      if (!this.isAutoHide()) {
        this.allowHide = true;
        this.hide(e);
      }
    }
  }, {
    key: "bindDocumentResizeListener",
    value: function bindDocumentResizeListener() {
      var _this5 = this;

      this.documentResizeListener = function (e) {
        if (!DomHandler$1.isTouchDevice()) {
          _this5.hide(e);
        }
      };

      window.addEventListener('resize', this.documentResizeListener);
    }
  }, {
    key: "unbindDocumentResizeListener",
    value: function unbindDocumentResizeListener() {
      if (this.documentResizeListener) {
        window.removeEventListener('resize', this.documentResizeListener);
        this.documentResizeListener = null;
      }
    }
  }, {
    key: "bindScrollListener",
    value: function bindScrollListener() {
      var _this6 = this;

      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.currentTarget, function (e) {
          if (_this6.state.visible) {
            _this6.hide(e);
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    }
  }, {
    key: "unbindScrollListener",
    value: function unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }
  }, {
    key: "bindTargetEvent",
    value: function bindTargetEvent(target) {
      if (target) {
        var _this$getEvents = this.getEvents(target),
            showEvent = _this$getEvents.showEvent,
            hideEvent = _this$getEvents.hideEvent;

        var currentTarget = this.getTarget(target);
        currentTarget.addEventListener(showEvent, this.show);
        currentTarget.addEventListener(hideEvent, this.hide);
      }
    }
  }, {
    key: "unbindTargetEvent",
    value: function unbindTargetEvent(target) {
      if (target) {
        var _this$getEvents2 = this.getEvents(target),
            showEvent = _this$getEvents2.showEvent,
            hideEvent = _this$getEvents2.hideEvent;

        var currentTarget = this.getTarget(target);
        currentTarget.removeEventListener(showEvent, this.show);
        currentTarget.removeEventListener(hideEvent, this.hide);
      }
    }
  }, {
    key: "applyDelay",
    value: function applyDelay(delayProp, callback) {
      this.clearTimeouts();
      var delay = this.getTargetOption(this.currentTarget, delayProp.toLowerCase()) || this.props[delayProp];

      if (!!delay) {
        this["".concat(delayProp, "Timeout")] = setTimeout(function () {
          return callback();
        }, delay);
      } else {
        callback();
      }
    }
  }, {
    key: "sendCallback",
    value: function sendCallback(callback) {
      if (callback) {
        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          params[_key - 1] = arguments[_key];
        }

        callback.apply(void 0, params);
      }
    }
  }, {
    key: "clearTimeouts",
    value: function clearTimeouts() {
      clearTimeout(this.showDelayTimeout);
      clearTimeout(this.updateDelayTimeout);
      clearTimeout(this.hideDelayTimeout);
    }
  }, {
    key: "getTarget",
    value: function getTarget(target) {
      if (target) {
        if (this.isShowOnDisabled(target)) {
          var wrapper = document.createElement('span');
          target.parentNode.insertBefore(wrapper, target);
          wrapper.appendChild(target);
          return wrapper;
        }

        return target;
      }

      return null;
    }
  }, {
    key: "updateTargetEvents",
    value: function updateTargetEvents(target) {
      this.unloadTargetEvents(target);
      this.loadTargetEvents(target);
    }
  }, {
    key: "loadTargetEvents",
    value: function loadTargetEvents(target) {
      this.setTargetEventOperations(target || this.props.target, 'bindTargetEvent');
    }
  }, {
    key: "unloadTargetEvents",
    value: function unloadTargetEvents(target) {
      this.setTargetEventOperations(target || this.props.target, 'unbindTargetEvent');
    }
  }, {
    key: "setTargetEventOperations",
    value: function setTargetEventOperations(target, operation) {
      var _this7 = this;

      if (target) {
        if (DomHandler$1.isElement(target)) {
          this[operation](target);
        } else {
          var setEvent = function setEvent(target) {
            var element = DomHandler$1.find(document, target);
            element.forEach(function (el) {
              _this7[operation](el);
            });
          };

          if (target instanceof Array) {
            target.forEach(function (t) {
              setEvent(t);
            });
          } else {
            setEvent(target);
          }
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.target) {
        this.loadTargetEvents();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this8 = this;

      if (prevProps.target !== this.props.target) {
        this.unloadTargetEvents(prevProps.target);
        this.loadTargetEvents();
      }

      if (this.state.visible) {
        if (prevProps.content !== this.props.content) {
          this.applyDelay('updateDelay', function () {
            _this8.updateText(_this8.currentTarget, function () {
              _this8.align(_this8.currentTarget);
            });
          });
        }

        if (this.currentTarget && this.isDisabled(this.currentTarget)) {
          this.hide();
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearTimeouts();
      this.unbindDocumentResizeListener();
      this.unloadTargetEvents();

      if (this.scrollHandler) {
        this.scrollHandler.destroy();
        this.scrollHandler = null;
      }

      ZIndexUtils.clear(this.containerEl);
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var _this9 = this;

      var tooltipClassName = classNames('p-tooltip p-component', _defineProperty$G({}, "p-tooltip-".concat(this.state.position), true), this.props.className);
      var isTargetContentEmpty = this.isTargetContentEmpty(this.currentTarget);
      return /*#__PURE__*/React.createElement("div", {
        id: this.props.id,
        ref: function ref(el) {
          return _this9.containerEl = el;
        },
        className: tooltipClassName,
        style: this.props.style,
        role: "tooltip",
        "aria-hidden": this.state.visible,
        onMouseEnter: this.onMouseEnter,
        onMouseLeave: this.onMouseLeave
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-tooltip-arrow"
      }), /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this9.tooltipTextEl = el;
        },
        className: "p-tooltip-text"
      }, isTargetContentEmpty && this.props.children));
    }
  }, {
    key: "render",
    value: function render() {
      if (this.state.visible) {
        var element = this.renderElement();
        return /*#__PURE__*/React.createElement(Portal, {
          element: element,
          appendTo: this.props.appendTo,
          visible: true
        });
      }

      return null;
    }
  }]);

  return Tooltip;
}(Component);

_defineProperty$G(Tooltip$1, "defaultProps", {
  id: null,
  target: null,
  content: null,
  disabled: false,
  className: null,
  style: null,
  appendTo: null,
  position: 'right',
  my: null,
  at: null,
  event: null,
  showEvent: 'mouseenter',
  hideEvent: 'mouseleave',
  autoZIndex: true,
  baseZIndex: 0,
  mouseTrack: false,
  mouseTrackTop: 5,
  mouseTrackLeft: 5,
  showDelay: 0,
  updateDelay: 0,
  hideDelay: 0,
  autoHide: true,
  showOnDisabled: false,
  onBeforeShow: null,
  onBeforeHide: null,
  onShow: null,
  onHide: null
});

function _classCallCheck$H(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$H(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$H(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$H(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$H(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$F(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$F(o, p) {
  _setPrototypeOf$F = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$F(o, p);
}

function _inherits$G(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$F(subClass, superClass);
}

function _typeof$G(obj) {
  "@babel/helpers - typeof";

  return _typeof$G = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$G(obj);
}

function _possibleConstructorReturn$G(self, call) {
  if (call && (_typeof$G(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$F(self);
}

function _getPrototypeOf$G(o) {
  _getPrototypeOf$G = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$G(o);
}

function _createSuper$M(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$M();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$G(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$G(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$G(this, result);
  };
}

function _isNativeReflectConstruct$M() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Ripple = /*#__PURE__*/function (_Component) {
  _inherits$G(Ripple, _Component);

  var _super = _createSuper$M(Ripple);

  function Ripple(props) {
    var _this;

    _classCallCheck$H(this, Ripple);

    _this = _super.call(this, props);
    _this.onMouseDown = _this.onMouseDown.bind(_assertThisInitialized$F(_this));
    return _this;
  }

  _createClass$H(Ripple, [{
    key: "getTarget",
    value: function getTarget() {
      return this.ink && this.ink.parentElement;
    }
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      if (this.target) {
        this.target.addEventListener('mousedown', this.onMouseDown);
      }
    }
  }, {
    key: "unbindEvents",
    value: function unbindEvents() {
      if (this.target) {
        this.target.removeEventListener('mousedown', this.onMouseDown);
      }
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event) {
      if (!this.ink || getComputedStyle(this.ink, null).display === 'none') {
        return;
      }

      DomHandler$1.removeClass(this.ink, 'p-ink-active');

      if (!DomHandler$1.getHeight(this.ink) && !DomHandler$1.getWidth(this.ink)) {
        var d = Math.max(DomHandler$1.getOuterWidth(this.target), DomHandler$1.getOuterHeight(this.target));
        this.ink.style.height = d + 'px';
        this.ink.style.width = d + 'px';
      }

      var offset = DomHandler$1.getOffset(this.target);
      var x = event.pageX - offset.left + document.body.scrollTop - DomHandler$1.getWidth(this.ink) / 2;
      var y = event.pageY - offset.top + document.body.scrollLeft - DomHandler$1.getHeight(this.ink) / 2;
      this.ink.style.top = y + 'px';
      this.ink.style.left = x + 'px';
      DomHandler$1.addClass(this.ink, 'p-ink-active');
    }
  }, {
    key: "onAnimationEnd",
    value: function onAnimationEnd(event) {
      DomHandler$1.removeClass(event.currentTarget, 'p-ink-active');
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.ink) {
        this.target = this.getTarget();
        this.bindEvents();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (this.ink && !this.target) {
        this.target = this.getTarget();
        this.bindEvents();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.ink) {
        this.target = null;
        this.unbindEvents();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      return PrimeReact.ripple ? /*#__PURE__*/React.createElement("span", {
        ref: function ref(el) {
          return _this2.ink = el;
        },
        className: "p-ink",
        onAnimationEnd: this.onAnimationEnd
      }) : null;
    }
  }]);

  return Ripple;
}(Component);

function _extends$b() {
  _extends$b = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$b.apply(this, arguments);
}

function _classCallCheck$G(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$G(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$G(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$G(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$G(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$E(o, p) {
  _setPrototypeOf$E = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$E(o, p);
}

function _inherits$F(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$E(subClass, superClass);
}

function _typeof$F(obj) {
  "@babel/helpers - typeof";

  return _typeof$F = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$F(obj);
}

function _assertThisInitialized$E(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$F(self, call) {
  if (call && (_typeof$F(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$E(self);
}

function _getPrototypeOf$F(o) {
  _getPrototypeOf$F = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$F(o);
}

function _defineProperty$F(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$o(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$o(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$o(Object(source), !0).forEach(function (key) {
      _defineProperty$F(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$o(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$L(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$L();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$F(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$F(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$F(this, result);
  };
}

function _isNativeReflectConstruct$L() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var ButtonComponent = /*#__PURE__*/function (_Component) {
  _inherits$F(ButtonComponent, _Component);

  var _super = _createSuper$L(ButtonComponent);

  function ButtonComponent(props) {
    var _this;

    _classCallCheck$G(this, ButtonComponent);

    _this = _super.call(this, props);
    _this.elementRef = /*#__PURE__*/createRef(_this.props.forwardRef);
    return _this;
  }

  _createClass$G(ButtonComponent, [{
    key: "updateForwardRef",
    value: function updateForwardRef() {
      var ref = this.props.forwardRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.elementRef.current);
        } else {
          ref.current = this.elementRef.current;
        }
      }
    }
  }, {
    key: "isDisabled",
    value: function isDisabled() {
      return this.props.disabled || this.props.loading;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateForwardRef();

      if (this.props.tooltip) {
        this.renderTooltip();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$o({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.elementRef.current,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "renderIcon",
    value: function renderIcon() {
      var icon = this.props.loading ? this.props.loadingIcon : this.props.icon;
      var className = classNames('p-button-icon p-c', {
        'p-button-loading-icon': this.props.loading,
        'p-button-icon-left': this.props.iconPos === 'left' && this.props.label,
        'p-button-icon-right': this.props.iconPos === 'right' && this.props.label,
        'p-button-icon-top': this.props.iconPos === 'top' && this.props.label,
        'p-button-icon-bottom': this.props.iconPos === 'bottom' && this.props.label
      });
      return IconUtils.getJSXIcon(icon, {
        className: className
      }, {
        props: this.props
      });
    }
  }, {
    key: "renderLabel",
    value: function renderLabel() {
      if (this.props.label) {
        return /*#__PURE__*/React.createElement("span", {
          className: "p-button-label p-c"
        }, this.props.label);
      }

      return !this.props.children && !this.props.label && /*#__PURE__*/React.createElement("span", {
        className: "p-button-label p-c",
        dangerouslySetInnerHTML: {
          __html: "&nbsp;"
        }
      });
    }
  }, {
    key: "renderBadge",
    value: function renderBadge() {
      if (this.props.badge) {
        var badgeClassName = classNames('p-badge', this.props.badgeClassName);
        return /*#__PURE__*/React.createElement("span", {
          className: badgeClassName
        }, this.props.badge);
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var disabled = this.isDisabled();
      var className = classNames('p-button p-component', this.props.className, _defineProperty$F({
        'p-button-icon-only': (this.props.icon || this.props.loading && this.props.loadingIcon) && !this.props.label,
        'p-button-vertical': (this.props.iconPos === 'top' || this.props.iconPos === 'bottom') && this.props.label,
        'p-disabled': disabled,
        'p-button-loading': this.props.loading,
        'p-button-loading-label-only': this.props.loading && !this.props.icon && this.props.label
      }, "p-button-loading-".concat(this.props.iconPos), this.props.loading && this.props.loadingIcon && this.props.label));
      var icon = this.renderIcon();
      var label = this.renderLabel();
      var badge = this.renderBadge();
      var buttonProps = ObjectUtils.findDiffKeys(this.props, ButtonComponent.defaultProps);
      return /*#__PURE__*/React.createElement("button", _extends$b({
        ref: this.elementRef
      }, buttonProps, {
        className: className,
        disabled: disabled
      }), icon, label, this.props.children, badge, /*#__PURE__*/React.createElement(Ripple, null));
    }
  }]);

  return ButtonComponent;
}(Component);

_defineProperty$F(ButtonComponent, "defaultProps", {
  label: null,
  icon: null,
  iconPos: 'left',
  badge: null,
  badgeClassName: null,
  tooltip: null,
  tooltipOptions: null,
  forwardRef: null,
  disabled: false,
  loading: false,
  loadingIcon: 'pi pi-spinner pi-spin'
});

var Button$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(ButtonComponent, _extends$b({
    forwardRef: ref
  }, props));
});

var _excluded$5 = ["badge", "badgeClassName", "tooltipOptions"];
var Button = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  _ref.badge;
      _ref.badgeClassName;
      var tooltipOptions = _ref.tooltipOptions,
      props = _objectWithoutProperties$1(_ref, _excluded$5);

  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(Button$1, _extends$c({}, props, {
    tooltipOptions: filteredTooltipOptions,
    ref: ref
  }));
});

function _classCallCheck$F(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$F(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$F(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$F(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$F(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$D(o, p) {
  _setPrototypeOf$D = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$D(o, p);
}

function _inherits$E(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$D(subClass, superClass);
}

function _typeof$E(obj) {
  "@babel/helpers - typeof";

  return _typeof$E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$E(obj);
}

function _assertThisInitialized$D(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$E(self, call) {
  if (call && (_typeof$E(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$D(self);
}

function _getPrototypeOf$E(o) {
  _getPrototypeOf$E = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$E(o);
}

function _defineProperty$E(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$K(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$K();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$E(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$E(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$E(this, result);
  };
}

function _isNativeReflectConstruct$K() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Card$1 = /*#__PURE__*/function (_Component) {
  _inherits$E(Card, _Component);

  var _super = _createSuper$K(Card);

  function Card() {
    _classCallCheck$F(this, Card);

    return _super.apply(this, arguments);
  }

  _createClass$F(Card, [{
    key: "renderHeader",
    value: function renderHeader() {
      if (this.props.header) {
        return /*#__PURE__*/React.createElement("div", {
          className: "p-card-header"
        }, ObjectUtils.getJSXElement(this.props.header, this.props));
      }

      return null;
    }
  }, {
    key: "renderBody",
    value: function renderBody() {
      var title = this.props.title && /*#__PURE__*/React.createElement("div", {
        className: "p-card-title"
      }, ObjectUtils.getJSXElement(this.props.title, this.props));
      var subTitle = this.props.subTitle && /*#__PURE__*/React.createElement("div", {
        className: "p-card-subtitle"
      }, ObjectUtils.getJSXElement(this.props.subTitle, this.props));
      var children = this.props.children && /*#__PURE__*/React.createElement("div", {
        className: "p-card-content"
      }, this.props.children);
      var footer = this.props.footer && /*#__PURE__*/React.createElement("div", {
        className: "p-card-footer"
      }, ObjectUtils.getJSXElement(this.props.footer, this.props));
      return /*#__PURE__*/React.createElement("div", {
        className: "p-card-body"
      }, title, subTitle, children, footer);
    }
  }, {
    key: "render",
    value: function render() {
      var header = this.renderHeader();
      var body = this.renderBody();
      var className = classNames('p-card p-component', this.props.className);
      return /*#__PURE__*/React.createElement("div", {
        className: className,
        style: this.props.style,
        id: this.props.id
      }, header, body);
    }
  }]);

  return Card;
}(Component);

_defineProperty$E(Card$1, "defaultProps", {
  id: null,
  header: null,
  footer: null,
  title: null,
  subTitle: null,
  style: null,
  className: null
});

var Card = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      header = _ref.header,
      footer = _ref.footer,
      title = _ref.title,
      subTitle = _ref.subTitle,
      style = _ref.style,
      className = _ref.className,
      children = _ref.children;
  return /*#__PURE__*/React.createElement(Card$1, {
    ref: ref,
    id: id,
    header: header,
    footer: footer,
    title: title,
    subTitle: subTitle,
    style: style,
    className: className
  }, children);
});

function _classCallCheck$E(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$E(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$E(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$E(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$E(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$C(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$C(o, p) {
  _setPrototypeOf$C = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$C(o, p);
}

function _inherits$D(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$C(subClass, superClass);
}

function _typeof$D(obj) {
  "@babel/helpers - typeof";

  return _typeof$D = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$D(obj);
}

function _possibleConstructorReturn$D(self, call) {
  if (call && (_typeof$D(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$C(self);
}

function _getPrototypeOf$D(o) {
  _getPrototypeOf$D = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$D(o);
}

function _defineProperty$D(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$n(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$n(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$n(Object(source), !0).forEach(function (key) {
      _defineProperty$D(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$n(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$J(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$J();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$D(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$D(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$D(this, result);
  };
}

function _isNativeReflectConstruct$J() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Checkbox$2 = /*#__PURE__*/function (_Component) {
  _inherits$D(Checkbox, _Component);

  var _super = _createSuper$J(Checkbox);

  function Checkbox(props) {
    var _this;

    _classCallCheck$E(this, Checkbox);

    _this = _super.call(this, props);
    _this.state = {
      focused: false
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized$C(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$C(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$C(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$C(_this));
    _this.inputRef = /*#__PURE__*/createRef(_this.props.inputRef);
    return _this;
  }

  _createClass$E(Checkbox, [{
    key: "onClick",
    value: function onClick(e) {
      if (!this.props.disabled && !this.props.readOnly && this.props.onChange) {
        var value = this.isChecked() ? this.props.falseValue : this.props.trueValue;
        this.props.onChange({
          originalEvent: e,
          value: this.props.value,
          checked: value,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            type: 'checkbox',
            name: this.props.name,
            id: this.props.id,
            value: this.props.value,
            checked: value
          }
        });
        this.inputRef.current.checked = !this.isChecked();
        this.inputRef.current.focus();
        e.preventDefault();
      }
    }
  }, {
    key: "updateInputRef",
    value: function updateInputRef() {
      var ref = this.props.inputRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.inputRef.current);
        } else {
          ref.current = this.inputRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateInputRef();

      if (this.props.tooltip) {
        this.renderTooltip();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this.inputRef.current.checked = this.isChecked();

      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$n({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }
    }
  }, {
    key: "onFocus",
    value: function onFocus() {
      this.setState({
        focused: true
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        focused: false
      });
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (event.key === 'Enter') {
        this.onClick(event);
        event.preventDefault();
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.element,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "isChecked",
    value: function isChecked() {
      return this.props.checked === this.props.trueValue;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var checked = this.isChecked();
      var containerClass = classNames('p-checkbox p-component', {
        'p-checkbox-checked': checked,
        'p-checkbox-disabled': this.props.disabled,
        'p-checkbox-focused': this.state.focused
      }, this.props.className);
      var boxClass = classNames('p-checkbox-box', {
        'p-highlight': checked,
        'p-disabled': this.props.disabled,
        'p-focus': this.state.focused
      });
      var icon = checked && this.props.icon;
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this2.element = el;
        },
        id: this.props.id,
        className: containerClass,
        style: this.props.style,
        onClick: this.onClick,
        onContextMenu: this.props.onContextMenu,
        onMouseDown: this.props.onMouseDown
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-hidden-accessible"
      }, /*#__PURE__*/React.createElement("input", {
        ref: this.inputRef,
        type: "checkbox",
        "aria-labelledby": this.props.ariaLabelledBy,
        id: this.props.inputId,
        name: this.props.name,
        tabIndex: this.props.tabIndex,
        defaultChecked: checked,
        onKeyDown: this.onKeyDown,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        disabled: this.props.disabled,
        readOnly: this.props.readOnly,
        required: this.props.required
      })), /*#__PURE__*/React.createElement("div", {
        className: boxClass,
        ref: function ref(el) {
          return _this2.box = el;
        },
        role: "checkbox",
        "aria-checked": checked
      }, IconUtils.getJSXIcon(icon, {
        className: 'p-checkbox-icon p-c'
      }, {
        props: this.props,
        checked: checked
      })));
    }
  }]);

  return Checkbox;
}(Component);

_defineProperty$D(Checkbox$2, "defaultProps", {
  id: null,
  inputRef: null,
  inputId: null,
  value: null,
  name: null,
  checked: false,
  trueValue: true,
  falseValue: false,
  style: null,
  className: null,
  disabled: false,
  required: false,
  readOnly: false,
  tabIndex: null,
  icon: 'pi pi-check',
  tooltip: null,
  tooltipOptions: null,
  ariaLabelledBy: null,
  onChange: null,
  onMouseDown: null,
  onContextMenu: null
});

var Checkbox$1 = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      inputRef = _ref.inputRef,
      inputId = _ref.inputId,
      value = _ref.value,
      name = _ref.name,
      checked = _ref.checked,
      style = _ref.style,
      className = _ref.className,
      disabled = _ref.disabled,
      required = _ref.required,
      readOnly = _ref.readOnly,
      tabIndex = _ref.tabIndex,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onChange = _ref.onChange;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(Checkbox$2, {
    ref: ref,
    id: id,
    inputRef: inputRef,
    inputId: inputId,
    value: value,
    name: name,
    checked: checked,
    style: style,
    className: className,
    disabled: disabled,
    required: required,
    readOnly: readOnly,
    tabIndex: tabIndex,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onChange: onChange
  });
});

function _classCallCheck$D(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$D(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$D(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$D(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$D(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$B(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$B(o, p) {
  _setPrototypeOf$B = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$B(o, p);
}

function _inherits$C(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$B(subClass, superClass);
}

function _typeof$C(obj) {
  "@babel/helpers - typeof";

  return _typeof$C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$C(obj);
}

function _possibleConstructorReturn$C(self, call) {
  if (call && (_typeof$C(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$B(self);
}

function _getPrototypeOf$C(o) {
  _getPrototypeOf$C = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$C(o);
}

function _defineProperty$C(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$I(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$I();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$C(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$C(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$C(this, result);
  };
}

function _isNativeReflectConstruct$I() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Chip$1 = /*#__PURE__*/function (_Component) {
  _inherits$C(Chip, _Component);

  var _super = _createSuper$I(Chip);

  function Chip(props) {
    var _this;

    _classCallCheck$D(this, Chip);

    _this = _super.call(this, props);
    _this.state = {
      visible: true
    };
    _this.close = _this.close.bind(_assertThisInitialized$B(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$B(_this));
    return _this;
  }

  _createClass$D(Chip, [{
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (event.keyCode === 13) {
        // enter
        this.close(event);
      }
    }
  }, {
    key: "close",
    value: function close(event) {
      var _this2 = this;

      event.persist();
      this.setState({
        visible: false
      }, function () {
        if (_this2.props.onRemove) {
          _this2.props.onRemove(event);
        }
      });
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this3 = this;

      var content = [];

      if (this.props.image) {
        var onError = function onError(e) {
          if (_this3.props.onImageError) {
            _this3.props.onImageError(e);
          }
        };

        content.push( /*#__PURE__*/React.createElement("img", {
          key: "image",
          src: this.props.image,
          alt: this.props.imageAlt,
          onError: onError
        }));
      } else if (this.props.icon) {
        content.push(IconUtils.getJSXIcon(this.props.icon, {
          key: 'icon',
          className: 'p-chip-icon'
        }, {
          props: this.props
        }));
      }

      if (this.props.label) {
        content.push( /*#__PURE__*/React.createElement("span", {
          key: "label",
          className: "p-chip-text"
        }, this.props.label));
      }

      if (this.props.removable) {
        content.push(IconUtils.getJSXIcon(this.props.removeIcon, {
          key: 'removeIcon',
          tabIndex: 0,
          className: 'p-chip-remove-icon',
          onClick: this.close,
          onKeyDown: this.onKeyDown
        }, {
          props: this.props
        }));
      }

      return content;
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var containerClassName = classNames('p-chip p-component', {
        'p-chip-image': this.props.image != null
      }, this.props.className);
      var content = this.props.template ? ObjectUtils.getJSXElement(this.props.template, this.props) : this.renderContent();
      return /*#__PURE__*/React.createElement("div", {
        className: containerClassName,
        style: this.props.style
      }, content);
    }
  }, {
    key: "render",
    value: function render() {
      return this.state.visible && this.renderElement();
    }
  }]);

  return Chip;
}(Component);

_defineProperty$C(Chip$1, "defaultProps", {
  label: null,
  icon: null,
  image: null,
  removable: false,
  removeIcon: 'pi pi-times-circle',
  className: null,
  style: null,
  template: null,
  imageAlt: 'chip',
  onImageError: null,
  onRemove: null
});

var Chip = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var label = _ref.label,
      icon = _ref.icon,
      removable = _ref.removable,
      style = _ref.style,
      className = _ref.className,
      onRemove = _ref.onRemove;
  return /*#__PURE__*/React.createElement(Chip$1, {
    ref: ref,
    label: label,
    icon: icon,
    removable: removable,
    style: style,
    className: className,
    onRemove: onRemove
  });
});

function _arrayLikeToArray$k(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$d(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$k(arr);
}

function _iterableToArray$d(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$k(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$k(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$k(o, minLen);
}

function _nonIterableSpread$d() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$d(arr) {
  return _arrayWithoutHoles$d(arr) || _iterableToArray$d(arr) || _unsupportedIterableToArray$k(arr) || _nonIterableSpread$d();
}

function _classCallCheck$C(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$C(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$C(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$C(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$C(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$A(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$A(o, p) {
  _setPrototypeOf$A = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$A(o, p);
}

function _inherits$B(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$A(subClass, superClass);
}

function _typeof$B(obj) {
  "@babel/helpers - typeof";

  return _typeof$B = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$B(obj);
}

function _possibleConstructorReturn$B(self, call) {
  if (call && (_typeof$B(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$A(self);
}

function _getPrototypeOf$B(o) {
  _getPrototypeOf$B = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$B(o);
}

function _defineProperty$B(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$m(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$m(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$m(Object(source), !0).forEach(function (key) {
      _defineProperty$B(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$m(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$H(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$H();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$B(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$B(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$B(this, result);
  };
}

function _isNativeReflectConstruct$H() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Chips$1 = /*#__PURE__*/function (_Component) {
  _inherits$B(Chips, _Component);

  var _super = _createSuper$H(Chips);

  function Chips(props) {
    var _this;

    _classCallCheck$C(this, Chips);

    _this = _super.call(this, props);
    _this.state = {
      focused: false
    };
    _this.onWrapperClick = _this.onWrapperClick.bind(_assertThisInitialized$A(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$A(_this));
    _this.onPaste = _this.onPaste.bind(_assertThisInitialized$A(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$A(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$A(_this));
    _this.inputRef = /*#__PURE__*/createRef(_this.props.inputRef);
    return _this;
  }

  _createClass$C(Chips, [{
    key: "removeItem",
    value: function removeItem(event, index) {
      if (this.props.disabled && this.props.readOnly) {
        return;
      }

      var values = _toConsumableArray$d(this.props.value);

      var removedItem = values.splice(index, 1);

      if (!this.isRemovable(removedItem, index)) {
        return;
      }

      if (this.props.onRemove) {
        this.props.onRemove({
          originalEvent: event,
          value: removedItem
        });
      }

      if (this.props.onChange) {
        this.props.onChange({
          originalEvent: event,
          value: values,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: values
          }
        });
      }
    }
  }, {
    key: "addItem",
    value: function addItem(event, item, preventDefault) {
      if (item && item.trim().length) {
        var values = this.props.value ? _toConsumableArray$d(this.props.value) : [];

        if (this.props.allowDuplicate || values.indexOf(item) === -1) {
          values.push(item);

          if (this.props.onAdd) {
            this.props.onAdd({
              originalEvent: event,
              value: item
            });
          }
        }

        this.updateInput(event, values, preventDefault);
      }
    }
  }, {
    key: "onWrapperClick",
    value: function onWrapperClick() {
      this.inputRef.current.focus();
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      var inputValue = event.target.value;
      var values = this.props.value || [];

      switch (event.which) {
        //backspace
        case 8:
          if (this.inputRef.current.value.length === 0 && values.length > 0) {
            this.removeItem(event, values.length - 1);
          }

          break;
        //enter

        case 13:
          if (inputValue && inputValue.trim().length && (!this.props.max || this.props.max > values.length)) {
            this.addItem(event, inputValue, true);
          }

          break;

        default:
          if (this.isMaxedOut()) {
            event.preventDefault();
          } else if (this.props.separator) {
            if (this.props.separator === ',' && event.which === 188) {
              this.addItem(event, inputValue, true);
            }
          }

          break;
      }
    }
  }, {
    key: "updateInput",
    value: function updateInput(event, items, preventDefault) {
      if (this.props.onChange) {
        this.props.onChange({
          originalEvent: event,
          value: items,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: items
          }
        });
      }

      this.inputRef.current.value = '';

      if (preventDefault) {
        event.preventDefault();
      }
    }
  }, {
    key: "onPaste",
    value: function onPaste(event) {
      var _this2 = this;

      if (this.props.separator) {
        var pastedData = (event.clipboardData || window['clipboardData']).getData('Text');

        if (pastedData) {
          var values = this.props.value || [];
          var pastedValues = pastedData.split(this.props.separator);
          pastedValues = pastedValues.filter(function (val) {
            return (_this2.props.allowDuplicate || values.indexOf(val) === -1) && val.trim().length;
          });
          values = [].concat(_toConsumableArray$d(values), _toConsumableArray$d(pastedValues));
          this.updateInput(event, values, true);
        }
      }
    }
  }, {
    key: "onFocus",
    value: function onFocus(event) {
      var _this3 = this;

      event.persist();
      this.setState({
        focused: true
      }, function () {
        if (_this3.props.onFocus) {
          _this3.props.onFocus(event);
        }
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur(event) {
      var _this4 = this;

      event.persist();
      this.setState({
        focused: false
      }, function () {
        if (_this4.props.onBlur) {
          _this4.props.onBlur(event);
        }
      });
    }
  }, {
    key: "isMaxedOut",
    value: function isMaxedOut() {
      return this.props.max && this.props.value && this.props.max === this.props.value.length;
    }
  }, {
    key: "isFilled",
    value: function isFilled() {
      return this.props.value && this.props.value.length || this.inputRef && this.inputRef.current && this.inputRef.current.value && this.inputRef.current.value.length;
    }
  }, {
    key: "isRemovable",
    value: function isRemovable(value, index) {
      return ObjectUtils.getPropValue(this.props.removable, {
        value: value,
        index: index,
        props: this.props
      });
    }
  }, {
    key: "updateInputRef",
    value: function updateInputRef() {
      var ref = this.props.inputRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.inputRef.current);
        } else {
          ref.current = this.inputRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateInputRef();

      if (this.props.tooltip) {
        this.renderTooltip();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var isValueSame = this.props.value && prevProps.value && prevProps.value.length === this.props.value.length;

      if (this.props.tooltip) {
        if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
          if (this.tooltip) this.tooltip.update(_objectSpread$m({
            content: this.props.tooltip
          }, this.props.tooltipOptions || {}));else this.renderTooltip();
        } else if (!isValueSame && this.tooltip) {
          this.tooltip.deactivate();
          this.tooltip.activate();
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.inputRef.current,
        targetContainer: this.listElement,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "renderRemoveIcon",
    value: function renderRemoveIcon(value, index) {
      var _this5 = this;

      if (!this.props.disabled && !this.props.readOnly && this.isRemovable(value, index)) {
        return /*#__PURE__*/React.createElement("span", {
          className: "p-chips-token-icon pi pi-times-circle",
          onClick: function onClick(event) {
            return _this5.removeItem(event, index);
          }
        });
      }

      return null;
    }
  }, {
    key: "renderItem",
    value: function renderItem(value, index) {
      var content = this.props.itemTemplate ? this.props.itemTemplate(value) : value;
      var icon = this.renderRemoveIcon(value, index);
      return /*#__PURE__*/React.createElement("li", {
        key: index,
        className: "p-chips-token p-highlight"
      }, /*#__PURE__*/React.createElement("span", {
        className: "p-chips-token-label"
      }, content), icon);
    }
  }, {
    key: "renderInputElement",
    value: function renderInputElement() {
      return /*#__PURE__*/React.createElement("li", {
        className: "p-chips-input-token"
      }, /*#__PURE__*/React.createElement("input", {
        ref: this.inputRef,
        placeholder: this.props.placeholder,
        type: "text",
        name: this.props.name,
        disabled: this.props.disabled || this.isMaxedOut(),
        onKeyDown: this.onKeyDown,
        onPaste: this.onPaste,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        "aria-labelledby": this.props.ariaLabelledBy,
        readOnly: this.props.readOnly
      }));
    }
  }, {
    key: "renderItems",
    value: function renderItems() {
      var _this6 = this;

      if (this.props.value) {
        return this.props.value.map(function (value, index) {
          return _this6.renderItem(value, index);
        });
      }

      return null;
    }
  }, {
    key: "renderList",
    value: function renderList() {
      var _this7 = this;

      var className = classNames('p-inputtext p-chips-multiple-container', {
        'p-disabled': this.props.disabled,
        'p-focus': this.state.focused
      });
      var items = this.renderItems();
      var inputElement = this.renderInputElement();
      return /*#__PURE__*/React.createElement("ul", {
        ref: function ref(el) {
          return _this7.listElement = el;
        },
        className: className,
        onClick: this.onWrapperClick
      }, items, inputElement);
    }
  }, {
    key: "render",
    value: function render() {
      var _this8 = this;

      var className = classNames('p-chips p-component p-inputwrapper', this.props.className, {
        'p-inputwrapper-filled': this.isFilled(),
        'p-inputwrapper-focus': this.state.focused
      });
      var list = this.renderList();
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this8.element = el;
        },
        id: this.props.id,
        className: className,
        style: this.props.style
      }, list);
    }
  }]);

  return Chips;
}(Component);

_defineProperty$B(Chips$1, "defaultProps", {
  id: null,
  inputRef: null,
  name: null,
  placeholder: null,
  value: null,
  max: null,
  disabled: null,
  readOnly: false,
  removable: true,
  style: null,
  className: null,
  tooltip: null,
  tooltipOptions: null,
  ariaLabelledBy: null,
  separator: null,
  allowDuplicate: true,
  itemTemplate: null,
  onAdd: null,
  onRemove: null,
  onChange: null,
  onFocus: null,
  onBlur: null
});

var SEPARATOR = ",";
var Chips = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      name = _ref.name,
      placeholder = _ref.placeholder,
      value = _ref.value,
      max = _ref.max,
      disabled = _ref.disabled,
      readOnly = _ref.readOnly,
      removable = _ref.removable,
      style = _ref.style,
      className = _ref.className,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      allowDuplicate = _ref.allowDuplicate,
      scrollable = _ref.scrollable,
      onAdd = _ref.onAdd,
      onRemove = _ref.onRemove,
      onChange = _ref.onChange,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur;
  var chipsClassName = classNames(className, {
    "p-chips_scrollable": scrollable
  });
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(Chips$1, {
    ref: ref,
    id: id,
    name: name,
    placeholder: placeholder,
    value: value,
    max: max,
    disabled: disabled,
    readOnly: readOnly,
    removable: removable,
    style: style,
    className: chipsClassName,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    separator: SEPARATOR,
    allowDuplicate: allowDuplicate,
    onAdd: onAdd,
    onRemove: onRemove,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur
  });
});

function _defineProperties$B(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$B(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$B(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$B(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _classCallCheck$B(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _setPrototypeOf$z(o, p) {
  _setPrototypeOf$z = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$z(o, p);
}

function _inherits$A(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$z(subClass, superClass);
}

function _typeof$A(obj) {
  "@babel/helpers - typeof";

  return _typeof$A = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$A(obj);
}

function _assertThisInitialized$z(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$A(self, call) {
  if (call && (_typeof$A(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$z(self);
}

function _getPrototypeOf$A(o) {
  _getPrototypeOf$A = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$A(o);
}

function _defineProperty$A(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$G(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$G();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$A(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$A(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$A(this, result);
  };
}

function _isNativeReflectConstruct$G() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Column = /*#__PURE__*/function (_Component) {
  _inherits$A(Column, _Component);

  var _super = _createSuper$G(Column);

  function Column() {
    _classCallCheck$B(this, Column);

    return _super.apply(this, arguments);
  }

  return _createClass$B(Column);
}(Component);

_defineProperty$A(Column, "defaultProps", {
  columnKey: null,
  field: null,
  sortField: null,
  filterField: null,
  exportField: null,
  header: null,
  body: null,
  footer: null,
  sortable: false,
  sortableDisabled: false,
  sortFunction: null,
  dataType: 'text',
  filter: false,
  filterMatchMode: null,
  filterPlaceholder: null,
  filterType: 'text',
  filterMaxLength: null,
  filterElement: null,
  filterFunction: null,
  filterHeaderStyle: null,
  filterHeaderClassName: null,
  showFilterMenu: true,
  showFilterOperator: true,
  showClearButton: true,
  showApplyButton: true,
  showFilterMatchModes: true,
  showFilterMenuOptions: true,
  showAddButton: true,
  filterMatchModeOptions: null,
  maxConstraints: 2,
  filterMenuClassName: null,
  filterMenuStyle: null,
  align: null,
  alignHeader: null,
  alignFrozen: 'left',
  hidden: false,
  onFilterClear: null,
  onFilterApplyClick: null,
  onFilterMatchModeChange: null,
  onFilterOperatorChange: null,
  onFilterConstraintAdd: null,
  onFilterConstraintRemove: null,
  filterClear: null,
  filterApply: null,
  filterHeader: null,
  filterFooter: null,
  style: null,
  className: null,
  headerStyle: null,
  headerClassName: null,
  bodyStyle: null,
  bodyClassName: null,
  footerStyle: null,
  footerClassName: null,
  expander: false,
  frozen: false,
  selectionMode: null,
  colSpan: null,
  rowSpan: null,
  editor: null,
  cellEditValidator: null,
  cellEditValidatorEvent: 'click',
  onBeforeCellEditHide: null,
  onBeforeCellEditShow: null,
  onCellEditInit: null,
  onCellEditComplete: null,
  onCellEditCancel: null,
  excludeGlobalFilter: false,
  rowReorder: false,
  rowReorderIcon: 'pi pi-bars',
  rowEditor: false,
  exportable: true,
  reorderable: true
});

function _defineProperties$A(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$A(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$A(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$A(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _classCallCheck$A(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _setPrototypeOf$y(o, p) {
  _setPrototypeOf$y = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$y(o, p);
}

function _inherits$z(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$y(subClass, superClass);
}

function _typeof$z(obj) {
  "@babel/helpers - typeof";

  return _typeof$z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$z(obj);
}

function _assertThisInitialized$y(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$z(self, call) {
  if (call && (_typeof$z(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$y(self);
}

function _getPrototypeOf$z(o) {
  _getPrototypeOf$z = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$z(o);
}

function _createSuper$F(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$F();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$z(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$z(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$z(this, result);
  };
}

function _isNativeReflectConstruct$F() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var ColumnGroup = /*#__PURE__*/function (_Component) {
  _inherits$z(ColumnGroup, _Component);

  var _super = _createSuper$F(ColumnGroup);

  function ColumnGroup() {
    _classCallCheck$A(this, ColumnGroup);

    return _super.apply(this, arguments);
  }

  return _createClass$A(ColumnGroup);
}(Component);

function _arrayLikeToArray$j(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$c(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$j(arr);
}

function _iterableToArray$c(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$j(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$j(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$j(o, minLen);
}

function _nonIterableSpread$c() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$c(arr) {
  return _arrayWithoutHoles$c(arr) || _iterableToArray$c(arr) || _unsupportedIterableToArray$j(arr) || _nonIterableSpread$c();
}

function _classCallCheck$z(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$z(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$z(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$z(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$z(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$x(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$x(o, p) {
  _setPrototypeOf$x = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$x(o, p);
}

function _inherits$y(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$x(subClass, superClass);
}

function _typeof$y(obj) {
  "@babel/helpers - typeof";

  return _typeof$y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$y(obj);
}

function _possibleConstructorReturn$y(self, call) {
  if (call && (_typeof$y(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$x(self);
}

function _getPrototypeOf$y(o) {
  _getPrototypeOf$y = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$y(o);
}

function _defineProperty$z(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$E(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$E();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$y(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$y(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$y(this, result);
  };
}

function _isNativeReflectConstruct$E() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Dialog$1 = /*#__PURE__*/function (_Component) {
  _inherits$y(Dialog, _Component);

  var _super = _createSuper$E(Dialog);

  function Dialog(props) {
    var _this;

    _classCallCheck$z(this, Dialog);

    _this = _super.call(this, props);
    _this.state = {
      id: props.id,
      maskVisible: false,
      visible: false
    };

    if (!_this.props.onMaximize) {
      _this.state.maximized = props.maximized;
    }

    _this.onClose = _this.onClose.bind(_assertThisInitialized$x(_this));
    _this.toggleMaximize = _this.toggleMaximize.bind(_assertThisInitialized$x(_this));
    _this.onDragStart = _this.onDragStart.bind(_assertThisInitialized$x(_this));
    _this.onResizeStart = _this.onResizeStart.bind(_assertThisInitialized$x(_this));
    _this.onMaskClick = _this.onMaskClick.bind(_assertThisInitialized$x(_this));
    _this.onEnter = _this.onEnter.bind(_assertThisInitialized$x(_this));
    _this.onEntered = _this.onEntered.bind(_assertThisInitialized$x(_this));
    _this.onExiting = _this.onExiting.bind(_assertThisInitialized$x(_this));
    _this.onExited = _this.onExited.bind(_assertThisInitialized$x(_this));
    _this.attributeSelector = UniqueComponentId();
    _this.dialogRef = /*#__PURE__*/React.createRef();
    return _this;
  }

  _createClass$z(Dialog, [{
    key: "onClose",
    value: function onClose(event) {
      this.props.onHide();
      event.preventDefault();
    }
  }, {
    key: "focus",
    value: function focus() {
      var activeElement = document.activeElement;
      var isActiveElementInDialog = activeElement && this.dialogRef && this.dialogRef.current.contains(activeElement);

      if (!isActiveElementInDialog && this.props.closable && this.props.showHeader) {
        this.closeElement.focus();
      }
    }
  }, {
    key: "onMaskClick",
    value: function onMaskClick(event) {
      if (this.props.dismissableMask && this.props.modal && this.mask === event.target) {
        this.onClose(event);
      }

      this.props.onMaskClick && this.props.onMaskClick(event);
    }
  }, {
    key: "toggleMaximize",
    value: function toggleMaximize(event) {
      var maximized = !this.maximized;

      if (this.props.onMaximize) {
        this.props.onMaximize({
          originalEvent: event,
          maximized: maximized
        });
      } else {
        this.setState({
          maximized: maximized
        }, this.changeScrollOnMaximizable);
      }

      event.preventDefault();
    }
  }, {
    key: "onDragStart",
    value: function onDragStart(event) {
      if (DomHandler$1.hasClass(event.target, 'p-dialog-header-icon') || DomHandler$1.hasClass(event.target.parentElement, 'p-dialog-header-icon')) {
        return;
      }

      if (this.props.draggable) {
        this.dragging = true;
        this.lastPageX = event.pageX;
        this.lastPageY = event.pageY;
        this.dialogEl.style.margin = '0';
        DomHandler$1.addClass(document.body, 'p-unselectable-text');

        if (this.props.onDragStart) {
          this.props.onDragStart(event);
        }
      }
    }
  }, {
    key: "onDrag",
    value: function onDrag(event) {
      if (this.dragging) {
        var width = DomHandler$1.getOuterWidth(this.dialogEl);
        var height = DomHandler$1.getOuterHeight(this.dialogEl);
        var deltaX = event.pageX - this.lastPageX;
        var deltaY = event.pageY - this.lastPageY;
        var offset = this.dialogEl.getBoundingClientRect();
        var leftPos = offset.left + deltaX;
        var topPos = offset.top + deltaY;
        var viewport = DomHandler$1.getViewport();
        this.dialogEl.style.position = 'fixed';

        if (this.props.keepInViewport) {
          if (leftPos >= this.props.minX && leftPos + width < viewport.width) {
            this.lastPageX = event.pageX;
            this.dialogEl.style.left = leftPos + 'px';
          }

          if (topPos >= this.props.minY && topPos + height < viewport.height) {
            this.lastPageY = event.pageY;
            this.dialogEl.style.top = topPos + 'px';
          }
        } else {
          this.lastPageX = event.pageX;
          this.dialogEl.style.left = leftPos + 'px';
          this.lastPageY = event.pageY;
          this.dialogEl.style.top = topPos + 'px';
        }

        if (this.props.onDrag) {
          this.props.onDrag(event);
        }
      }
    }
  }, {
    key: "onDragEnd",
    value: function onDragEnd(event) {
      if (this.dragging) {
        this.dragging = false;
        DomHandler$1.removeClass(document.body, 'p-unselectable-text');

        if (this.props.onDragEnd) {
          this.props.onDragEnd(event);
        }
      }
    }
  }, {
    key: "onResizeStart",
    value: function onResizeStart(event) {
      if (this.props.resizable) {
        this.resizing = true;
        this.lastPageX = event.pageX;
        this.lastPageY = event.pageY;
        DomHandler$1.addClass(document.body, 'p-unselectable-text');

        if (this.props.onResizeStart) {
          this.props.onResizeStart(event);
        }
      }
    }
  }, {
    key: "convertToPx",
    value: function convertToPx(value, property, viewport) {
      !viewport && (viewport = DomHandler$1.getViewport());
      var val = parseInt(value);

      if (/^(\d+|(\.\d+))(\.\d+)?%$/.test(value)) {
        return val * (viewport[property] / 100);
      }

      return val;
    }
  }, {
    key: "onResize",
    value: function onResize(event) {
      if (this.resizing) {
        var deltaX = event.pageX - this.lastPageX;
        var deltaY = event.pageY - this.lastPageY;
        var width = DomHandler$1.getOuterWidth(this.dialogEl);
        var height = DomHandler$1.getOuterHeight(this.dialogEl);
        var offset = this.dialogEl.getBoundingClientRect();
        var viewport = DomHandler$1.getViewport();
        var newWidth = width + deltaX;
        var newHeight = height + deltaY;
        var minWidth = this.convertToPx(this.dialogEl.style.minWidth, 'width', viewport);
        var minHeight = this.convertToPx(this.dialogEl.style.minHeight, 'height', viewport);
        var hasBeenDragged = !parseInt(this.dialogEl.style.top) || !parseInt(this.dialogEl.style.left);

        if (hasBeenDragged) {
          newWidth += deltaX;
          newHeight += deltaY;
        }

        if ((!minWidth || newWidth > minWidth) && offset.left + newWidth < viewport.width) {
          this.dialogEl.style.width = newWidth + 'px';
        }

        if ((!minHeight || newHeight > minHeight) && offset.top + newHeight < viewport.height) {
          this.dialogEl.style.height = newHeight + 'px';
        }

        this.lastPageX = event.pageX;
        this.lastPageY = event.pageY;

        if (this.props.onResize) {
          this.props.onResize(event);
        }
      }
    }
  }, {
    key: "onResizeEnd",
    value: function onResizeEnd(event) {
      if (this.resizing) {
        this.resizing = false;
        DomHandler$1.removeClass(document.body, 'p-unselectable-text');

        if (this.props.onResizeEnd) {
          this.props.onResizeEnd(event);
        }
      }
    }
  }, {
    key: "resetPosition",
    value: function resetPosition() {
      this.dialogEl.style.position = '';
      this.dialogEl.style.left = '';
      this.dialogEl.style.top = '';
      this.dialogEl.style.margin = '';
    }
  }, {
    key: "getPositionClass",
    value: function getPositionClass() {
      var _this2 = this;

      var positions = ['center', 'left', 'right', 'top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right'];
      var pos = positions.find(function (item) {
        return item === _this2.props.position || item.replace('-', '') === _this2.props.position;
      });
      return pos ? "p-dialog-".concat(pos) : '';
    }
  }, {
    key: "maximized",
    get: function get() {
      return this.props.onMaximize ? this.props.maximized : this.state.maximized;
    }
  }, {
    key: "dialogEl",
    get: function get() {
      return this.dialogRef.current;
    }
  }, {
    key: "onEnter",
    value: function onEnter() {
      this.dialogEl.setAttribute(this.attributeSelector, '');
    }
  }, {
    key: "onEntered",
    value: function onEntered() {
      if (this.props.onShow) {
        this.props.onShow();
      }

      if (this.props.focusOnShow) {
        this.focus();
      }

      this.enableDocumentSettings();
    }
  }, {
    key: "onExiting",
    value: function onExiting() {
      if (this.props.modal) {
        DomHandler$1.addClass(this.mask, 'p-component-overlay-leave');
      }
    }
  }, {
    key: "onExited",
    value: function onExited() {
      this.dragging = false;
      ZIndexUtils.clear(this.mask);
      this.setState({
        maskVisible: false
      });
      this.disableDocumentSettings();
    }
  }, {
    key: "enableDocumentSettings",
    value: function enableDocumentSettings() {
      this.bindGlobalListeners();

      if (this.props.blockScroll || this.props.maximizable && this.maximized) {
        DomHandler$1.addClass(document.body, 'p-overflow-hidden');
      }
    }
  }, {
    key: "disableDocumentSettings",
    value: function disableDocumentSettings() {
      this.unbindGlobalListeners();

      if (this.props.modal) {
        var hasBlockScroll = document.primeDialogParams && document.primeDialogParams.some(function (param) {
          return param.hasBlockScroll;
        });

        if (!hasBlockScroll) {
          DomHandler$1.removeClass(document.body, 'p-overflow-hidden');
        }
      } else if (this.props.blockScroll || this.props.maximizable && this.maximized) {
        DomHandler$1.removeClass(document.body, 'p-overflow-hidden');
      }
    }
  }, {
    key: "bindGlobalListeners",
    value: function bindGlobalListeners() {
      if (this.props.draggable) {
        this.bindDocumentDragListener();
      }

      if (this.props.resizable) {
        this.bindDocumentResizeListeners();
      }

      if (this.props.closable) {
        this.bindDocumentKeyDownListener();
      }
    }
  }, {
    key: "unbindGlobalListeners",
    value: function unbindGlobalListeners() {
      this.unbindDocumentDragListener();
      this.unbindDocumentResizeListeners();
      this.unbindDocumentKeyDownListener();
    }
  }, {
    key: "bindDocumentDragListener",
    value: function bindDocumentDragListener() {
      this.documentDragListener = this.onDrag.bind(this);
      this.documentDragEndListener = this.onDragEnd.bind(this);
      window.document.addEventListener('mousemove', this.documentDragListener);
      window.document.addEventListener('mouseup', this.documentDragEndListener);
    }
  }, {
    key: "unbindDocumentDragListener",
    value: function unbindDocumentDragListener() {
      if (this.documentDragListener && this.documentDragEndListener) {
        window.document.removeEventListener('mousemove', this.documentDragListener);
        window.document.removeEventListener('mouseup', this.documentDragEndListener);
        this.documentDragListener = null;
        this.documentDragEndListener = null;
      }
    }
  }, {
    key: "bindDocumentResizeListeners",
    value: function bindDocumentResizeListeners() {
      this.documentResizeListener = this.onResize.bind(this);
      this.documentResizeEndListener = this.onResizeEnd.bind(this);
      window.document.addEventListener('mousemove', this.documentResizeListener);
      window.document.addEventListener('mouseup', this.documentResizeEndListener);
    }
  }, {
    key: "unbindDocumentResizeListeners",
    value: function unbindDocumentResizeListeners() {
      if (this.documentResizeListener && this.documentResizeEndListener) {
        window.document.removeEventListener('mousemove', this.documentResizeListener);
        window.document.removeEventListener('mouseup', this.documentResizeEndListener);
        this.documentResizeListener = null;
        this.documentResizeEndListener = null;
      }
    }
  }, {
    key: "bindDocumentKeyDownListener",
    value: function bindDocumentKeyDownListener() {
      var _this3 = this;

      this.documentKeyDownListener = function (event) {
        var currentTarget = event.currentTarget;

        if (currentTarget && currentTarget.primeDialogParams) {
          var params = currentTarget.primeDialogParams;
          var paramLength = params.length;
          var dialogId = params[paramLength - 1] ? params[paramLength - 1].id : undefined;

          if (dialogId === _this3.state.id && _this3.props.closeOnEscape) {
            var dialog = document.getElementById(dialogId);

            if (event.which === 27) {
              _this3.onClose(event);

              event.stopImmediatePropagation();
              params.splice(paramLength - 1, 1);
            } else if (event.which === 9) {
              event.preventDefault();
              var focusableElements = DomHandler$1.getFocusableElements(dialog);

              if (focusableElements && focusableElements.length > 0) {
                if (!document.activeElement) {
                  focusableElements[0].focus();
                } else {
                  var focusedIndex = focusableElements.indexOf(document.activeElement);

                  if (event.shiftKey) {
                    if (focusedIndex === -1 || focusedIndex === 0) focusableElements[focusableElements.length - 1].focus();else focusableElements[focusedIndex - 1].focus();
                  } else {
                    if (focusedIndex === -1 || focusedIndex === focusableElements.length - 1) focusableElements[0].focus();else focusableElements[focusedIndex + 1].focus();
                  }
                }
              }
            }
          }
        }
      };

      var newParam = {
        id: this.state.id,
        hasBlockScroll: this.props.blockScroll
      };
      document.primeDialogParams = document.primeDialogParams ? [].concat(_toConsumableArray$c(document.primeDialogParams), [newParam]) : [newParam];
      document.addEventListener('keydown', this.documentKeyDownListener);
    }
  }, {
    key: "unbindDocumentKeyDownListener",
    value: function unbindDocumentKeyDownListener() {
      var _this4 = this;

      if (this.documentKeyDownListener) {
        document.removeEventListener('keydown', this.documentKeyDownListener);
        document.primeDialogParams = document.primeDialogParams && document.primeDialogParams.filter(function (param) {
          return param.id !== _this4.state.id;
        });
        this.documentKeyDownListener = null;
      }
    }
  }, {
    key: "createStyle",
    value: function createStyle() {
      if (!this.styleElement) {
        this.styleElement = DomHandler$1.createInlineStyle(PrimeReact.nonce);
        var innerHTML = '';

        for (var breakpoint in this.props.breakpoints) {
          innerHTML += "\n                    @media screen and (max-width: ".concat(breakpoint, ") {\n                        .p-dialog[").concat(this.attributeSelector, "] {\n                            width: ").concat(this.props.breakpoints[breakpoint], " !important;\n                        }\n                    }\n                ");
        }

        this.styleElement.innerHTML = innerHTML;
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this5 = this;

      if (!this.state.id) {
        this.setState({
          id: UniqueComponentId()
        });
      }

      if (this.props.visible) {
        this.setState({
          maskVisible: true
        }, function () {
          ZIndexUtils.set('modal', _this5.mask, PrimeReact.autoZIndex, _this5.props.baseZIndex || PrimeReact.zIndex['modal']);

          _this5.setState({
            visible: true
          });
        });
      }

      if (this.props.breakpoints) {
        this.createStyle();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this6 = this;

      if (this.props.visible && !this.state.maskVisible) {
        this.setState({
          maskVisible: true
        }, function () {
          ZIndexUtils.set('modal', _this6.mask, PrimeReact.autoZIndex, _this6.props.baseZIndex || PrimeReact.zIndex['modal']);
        });
      }

      if (this.props.visible !== this.state.visible && this.state.maskVisible) {
        this.setState({
          visible: this.props.visible
        });
      }

      if (prevProps.maximized !== this.props.maximized && this.props.onMaximize) {
        this.changeScrollOnMaximizable();
      }
    }
  }, {
    key: "changeScrollOnMaximizable",
    value: function changeScrollOnMaximizable() {
      if (!this.props.blockScroll) {
        var funcName = this.maximized ? 'addClass' : 'removeClass';
        DomHandler$1[funcName](document.body, 'p-overflow-hidden');
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.disableDocumentSettings();
      this.styleElement = DomHandler$1.removeInlineStyle(this.styleElement);
      ZIndexUtils.clear(this.mask);
    }
  }, {
    key: "renderCloseIcon",
    value: function renderCloseIcon() {
      var _this7 = this;

      if (this.props.closable) {
        return /*#__PURE__*/React.createElement("button", {
          ref: function ref(el) {
            return _this7.closeElement = el;
          },
          type: "button",
          className: "p-dialog-header-icon p-dialog-header-close p-link",
          "aria-label": this.props.ariaCloseIconLabel,
          onClick: this.onClose
        }, /*#__PURE__*/React.createElement("span", {
          className: "p-dialog-header-close-icon pi pi-times"
        }), /*#__PURE__*/React.createElement(Ripple, null));
      }

      return null;
    }
  }, {
    key: "renderMaximizeIcon",
    value: function renderMaximizeIcon() {
      var iconClassName = classNames('p-dialog-header-maximize-icon pi', {
        'pi-window-maximize': !this.maximized,
        'pi-window-minimize': this.maximized
      });

      if (this.props.maximizable) {
        return /*#__PURE__*/React.createElement("button", {
          type: "button",
          className: "p-dialog-header-icon p-dialog-header-maximize p-link",
          onClick: this.toggleMaximize
        }, /*#__PURE__*/React.createElement("span", {
          className: iconClassName
        }), /*#__PURE__*/React.createElement(Ripple, null));
      }

      return null;
    }
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      var _this8 = this;

      if (this.props.showHeader) {
        var closeIcon = this.renderCloseIcon();
        var maximizeIcon = this.renderMaximizeIcon();
        var icons = ObjectUtils.getJSXElement(this.props.icons, this.props);
        var header = ObjectUtils.getJSXElement(this.props.header, this.props);
        return /*#__PURE__*/React.createElement("div", {
          ref: function ref(el) {
            return _this8.headerEl = el;
          },
          className: "p-dialog-header",
          onMouseDown: this.onDragStart
        }, /*#__PURE__*/React.createElement("div", {
          id: this.state.id + '_header',
          className: "p-dialog-title"
        }, header), /*#__PURE__*/React.createElement("div", {
          className: "p-dialog-header-icons"
        }, icons, maximizeIcon, closeIcon));
      }

      return null;
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this9 = this;

      var contentClassName = classNames('p-dialog-content', this.props.contentClassName);
      return /*#__PURE__*/React.createElement("div", {
        id: this.state.id + '_content',
        ref: function ref(el) {
          return _this9.contentEl = el;
        },
        className: contentClassName,
        style: this.props.contentStyle
      }, this.props.children);
    }
  }, {
    key: "renderFooter",
    value: function renderFooter() {
      var _this10 = this;

      var footer = ObjectUtils.getJSXElement(this.props.footer, this.props);
      return footer && /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this10.footerElement = el;
        },
        className: "p-dialog-footer"
      }, footer);
    }
  }, {
    key: "renderResizer",
    value: function renderResizer() {
      if (this.props.resizable) {
        return /*#__PURE__*/React.createElement("div", {
          className: "p-resizable-handle",
          style: {
            zIndex: 90
          },
          onMouseDown: this.onResizeStart
        });
      }

      return null;
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var _this11 = this;

      var className = classNames('p-dialog p-component', this.props.className, {
        'p-dialog-rtl': this.props.rtl,
        'p-dialog-maximized': this.maximized
      });
      var maskClassName = classNames('p-dialog-mask', {
        'p-component-overlay p-component-overlay-enter': this.props.modal,
        'p-dialog-visible': this.state.maskVisible,
        'p-dialog-draggable': this.props.draggable,
        'p-dialog-resizable': this.props.resizable
      }, this.props.maskClassName, this.getPositionClass());
      var header = this.renderHeader();
      var content = this.renderContent();
      var footer = this.renderFooter();
      var resizer = this.renderResizer();
      var transitionTimeout = {
        enter: this.props.position === 'center' ? 150 : 300,
        exit: this.props.position === 'center' ? 150 : 300
      };
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this11.mask = el;
        },
        style: this.props.maskStyle,
        className: maskClassName,
        onClick: this.onMaskClick
      }, /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: this.dialogRef,
        classNames: "p-dialog",
        timeout: transitionTimeout,
        "in": this.state.visible,
        options: this.props.transitionOptions,
        unmountOnExit: true,
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onExiting: this.onExiting,
        onExited: this.onExited
      }, /*#__PURE__*/React.createElement("div", {
        ref: this.dialogRef,
        id: this.state.id,
        className: className,
        style: this.props.style,
        onClick: this.props.onClick,
        role: "dialog",
        "aria-labelledby": this.state.id + '_header',
        "aria-describedby": this.state.id + '_content',
        "aria-modal": this.props.modal
      }, header, content, footer, resizer)));
    }
  }, {
    key: "render",
    value: function render() {
      if (this.state.maskVisible) {
        var element = this.renderElement();
        return /*#__PURE__*/React.createElement(Portal, {
          element: element,
          appendTo: this.props.appendTo,
          visible: true
        });
      }

      return null;
    }
  }]);

  return Dialog;
}(Component);

_defineProperty$z(Dialog$1, "defaultProps", {
  id: null,
  header: null,
  footer: null,
  visible: false,
  position: 'center',
  draggable: true,
  resizable: true,
  modal: true,
  onHide: null,
  onShow: null,
  contentStyle: null,
  contentClassName: null,
  closeOnEscape: true,
  dismissableMask: false,
  rtl: false,
  closable: true,
  style: null,
  className: null,
  maskStyle: null,
  maskClassName: null,
  showHeader: true,
  appendTo: null,
  baseZIndex: 0,
  maximizable: false,
  blockScroll: false,
  icons: null,
  ariaCloseIconLabel: 'Close',
  focusOnShow: true,
  minX: 0,
  minY: 0,
  keepInViewport: true,
  maximized: false,
  breakpoints: null,
  transitionOptions: null,
  onMaximize: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  onResizeStart: null,
  onResize: null,
  onResizeEnd: null,
  onClick: null,
  onMaskClick: null
});

function _extends$a() {
  _extends$a = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$a.apply(this, arguments);
}

function _classCallCheck$y(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$y(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$y(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$y(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$y(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$w(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$w(o, p) {
  _setPrototypeOf$w = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$w(o, p);
}

function _inherits$x(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$w(subClass, superClass);
}

function _typeof$x(obj) {
  "@babel/helpers - typeof";

  return _typeof$x = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$x(obj);
}

function _possibleConstructorReturn$x(self, call) {
  if (call && (_typeof$x(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$w(self);
}

function _getPrototypeOf$x(o) {
  _getPrototypeOf$x = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$x(o);
}

function _defineProperty$y(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$D(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$D();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$x(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$x(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$x(this, result);
  };
}

function _isNativeReflectConstruct$D() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function ownKeys$l(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$l(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$l(Object(source), !0).forEach(function (key) {
      _defineProperty$y(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$l(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function confirmDialog$1(props) {
  var appendTo = props.appendTo || document.body;
  var confirmDialogWrapper = document.createDocumentFragment();
  DomHandler$1.appendChild(confirmDialogWrapper, appendTo);
  props = _objectSpread$l(_objectSpread$l({}, props), {
    visible: props.visible === undefined ? true : props.visible
  });
  var confirmDialogEl = /*#__PURE__*/React.createElement(ConfirmDialog, props);
  ReactDOM.render(confirmDialogEl, confirmDialogWrapper);

  var updateConfirmDialog = function updateConfirmDialog(newProps) {
    props = _objectSpread$l(_objectSpread$l({}, props), newProps);
    ReactDOM.render( /*#__PURE__*/React.cloneElement(confirmDialogEl, props), confirmDialogWrapper);
  };

  return {
    _destroy: function _destroy() {
      ReactDOM.unmountComponentAtNode(confirmDialogWrapper);
    },
    show: function show() {
      updateConfirmDialog({
        visible: true,
        onHide: function onHide() {
          updateConfirmDialog({
            visible: false
          }); // reset
        }
      });
    },
    hide: function hide() {
      updateConfirmDialog({
        visible: false
      });
    },
    update: function update(newProps) {
      updateConfirmDialog(newProps);
    }
  };
}

var ConfirmDialog = /*#__PURE__*/function (_Component) {
  _inherits$x(ConfirmDialog, _Component);

  var _super = _createSuper$D(ConfirmDialog);

  function ConfirmDialog(props) {
    var _this;

    _classCallCheck$y(this, ConfirmDialog);

    _this = _super.call(this, props);
    _this.state = {
      visible: props.visible
    };
    _this.reject = _this.reject.bind(_assertThisInitialized$w(_this));
    _this.accept = _this.accept.bind(_assertThisInitialized$w(_this));
    _this.hide = _this.hide.bind(_assertThisInitialized$w(_this));
    return _this;
  }

  _createClass$y(ConfirmDialog, [{
    key: "acceptLabel",
    value: function acceptLabel() {
      return this.props.acceptLabel || localeOption('accept');
    }
  }, {
    key: "rejectLabel",
    value: function rejectLabel() {
      return this.props.rejectLabel || localeOption('reject');
    }
  }, {
    key: "accept",
    value: function accept() {
      if (this.props.accept) {
        this.props.accept();
      }

      this.hide('accept');
    }
  }, {
    key: "reject",
    value: function reject() {
      if (this.props.reject) {
        this.props.reject();
      }

      this.hide('reject');
    }
  }, {
    key: "show",
    value: function show() {
      this.setState({
        visible: true
      });
    }
  }, {
    key: "hide",
    value: function hide(result) {
      var _this2 = this;

      this.setState({
        visible: false
      }, function () {
        if (_this2.props.onHide) {
          _this2.props.onHide(result);
        }
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.visible !== this.props.visible) {
        this.setState({
          visible: this.props.visible
        });
      }
    }
  }, {
    key: "renderFooter",
    value: function renderFooter() {
      var acceptClassName = classNames('p-confirm-dialog-accept', this.props.acceptClassName);
      var rejectClassName = classNames('p-confirm-dialog-reject', {
        'p-button-text': !this.props.rejectClassName
      }, this.props.rejectClassName);
      var content = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Button$1, {
        label: this.rejectLabel(),
        icon: this.props.rejectIcon,
        className: rejectClassName,
        onClick: this.reject
      }), /*#__PURE__*/React.createElement(Button$1, {
        label: this.acceptLabel(),
        icon: this.props.acceptIcon,
        className: acceptClassName,
        onClick: this.accept,
        autoFocus: true
      }));

      if (this.props.footer) {
        var defaultContentOptions = {
          accept: this.accept,
          reject: this.reject,
          acceptClassName: acceptClassName,
          rejectClassName: rejectClassName,
          acceptLabel: this.acceptLabel(),
          rejectLabel: this.rejectLabel(),
          element: content,
          props: this.props
        };
        return ObjectUtils.getJSXElement(this.props.footer, defaultContentOptions);
      }

      return content;
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var className = classNames('p-confirm-dialog', this.props.className);
      var dialogProps = ObjectUtils.findDiffKeys(this.props, ConfirmDialog.defaultProps);
      var message = ObjectUtils.getJSXElement(this.props.message, this.props);
      var footer = this.renderFooter();
      return /*#__PURE__*/React.createElement(Dialog$1, _extends$a({
        visible: this.state.visible
      }, dialogProps, {
        className: className,
        footer: footer,
        onHide: this.hide,
        breakpoints: this.props.breakpoints
      }), IconUtils.getJSXIcon(this.props.icon, {
        className: 'p-confirm-dialog-icon'
      }, {
        props: this.props
      }), /*#__PURE__*/React.createElement("span", {
        className: "p-confirm-dialog-message"
      }, message));
    }
  }, {
    key: "render",
    value: function render() {
      var element = this.renderElement();
      return /*#__PURE__*/React.createElement(Portal, {
        element: element,
        appendTo: this.props.appendTo
      });
    }
  }]);

  return ConfirmDialog;
}(Component);

_defineProperty$y(ConfirmDialog, "defaultProps", {
  visible: false,
  message: null,
  rejectLabel: null,
  acceptLabel: null,
  icon: null,
  rejectIcon: null,
  acceptIcon: null,
  rejectClassName: null,
  acceptClassName: null,
  className: null,
  appendTo: null,
  footer: null,
  breakpoints: null,
  onHide: null,
  accept: null,
  reject: null
});

var confirmDialog = function confirmDialog(_ref) {
  var message = _ref.message,
      acceptLabel = _ref.acceptLabel,
      rejectLabel = _ref.rejectLabel,
      icon = _ref.icon,
      acceptClassName = _ref.acceptClassName,
      rejectClassName = _ref.rejectClassName,
      accept = _ref.accept,
      reject = _ref.reject,
      id = _ref.id,
      header = _ref.header,
      footer = _ref.footer,
      visible = _ref.visible,
      onHide = _ref.onHide,
      onShow = _ref.onShow,
      contentStyle = _ref.contentStyle,
      contentClassName = _ref.contentClassName,
      style = _ref.style,
      className = _ref.className,
      showHeader = _ref.showHeader,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 100 : _ref$baseZIndex,
      breakpoints = _ref.breakpoints,
      onClick = _ref.onClick,
      onMaskClick = _ref.onMaskClick;
  var params = {
    // confirmDialog params
    message: message,
    acceptLabel: acceptLabel,
    rejectLabel: rejectLabel,
    icon: icon,
    acceptClassName: acceptClassName,
    rejectClassName: rejectClassName,
    accept: accept,
    reject: reject,
    // common dialog params
    id: id,
    header: header,
    footer: footer,
    visible: visible,
    onHide: onHide,
    onShow: onShow,
    contentStyle: contentStyle,
    contentClassName: contentClassName,
    style: style,
    className: className,
    showHeader: showHeader,
    baseZIndex: baseZIndex,
    breakpoints: breakpoints,
    onClick: onClick,
    onMaskClick: onMaskClick,
    // params below are unavailable for users
    draggable: false,
    resizable: false,
    modal: true,
    closeOnEscape: true,
    dismissableMask: true,
    rtl: false,
    closable: true,
    maximizable: false,
    blockScroll: true,
    keepInViewport: true,
    maximized: false
  };
  return confirmDialog$1(params);
};

var OverlayService = EventBus();

function _classCallCheck$x(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$x(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$x(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$x(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$x(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$v(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$v(o, p) {
  _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$v(o, p);
}

function _inherits$w(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$v(subClass, superClass);
}

function _typeof$w(obj) {
  "@babel/helpers - typeof";

  return _typeof$w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$w(obj);
}

function _possibleConstructorReturn$w(self, call) {
  if (call && (_typeof$w(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$v(self);
}

function _getPrototypeOf$w(o) {
  _getPrototypeOf$w = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$w(o);
}

function _defineProperty$x(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$C(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$C();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$w(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$w(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$w(this, result);
  };
}

function _isNativeReflectConstruct$C() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function ownKeys$k(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$k(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$k(Object(source), !0).forEach(function (key) {
      _defineProperty$x(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$k(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function confirmPopup$1(props) {
  var appendTo = props.appendTo || document.body;
  var confirmPopupWrapper = document.createDocumentFragment();
  DomHandler$1.appendChild(confirmPopupWrapper, appendTo);
  props = _objectSpread$k(_objectSpread$k({}, props), {
    visible: props.visible === undefined ? true : props.visible
  });
  var confirmPopupEl = /*#__PURE__*/React.createElement(ConfirmPopup, props);
  ReactDOM.render(confirmPopupEl, confirmPopupWrapper);

  var updateConfirmPopup = function updateConfirmPopup(newProps) {
    props = _objectSpread$k(_objectSpread$k({}, props), newProps);
    ReactDOM.render( /*#__PURE__*/React.cloneElement(confirmPopupEl, props), confirmPopupWrapper);
  };

  return {
    _destroy: function _destroy() {
      ReactDOM.unmountComponentAtNode(confirmPopupWrapper);
    },
    show: function show() {
      updateConfirmPopup({
        visible: true,
        onHide: function onHide() {
          updateConfirmPopup({
            visible: false
          }); // reset
        }
      });
    },
    hide: function hide() {
      updateConfirmPopup({
        visible: false
      });
    },
    update: function update(newProps) {
      updateConfirmPopup(newProps);
    }
  };
}

var ConfirmPopup = /*#__PURE__*/function (_Component) {
  _inherits$w(ConfirmPopup, _Component);

  var _super = _createSuper$C(ConfirmPopup);

  function ConfirmPopup(props) {
    var _this;

    _classCallCheck$x(this, ConfirmPopup);

    _this = _super.call(this, props);
    _this.state = {
      visible: false
    };
    _this.reject = _this.reject.bind(_assertThisInitialized$v(_this));
    _this.accept = _this.accept.bind(_assertThisInitialized$v(_this));
    _this.hide = _this.hide.bind(_assertThisInitialized$v(_this));
    _this.onCloseClick = _this.onCloseClick.bind(_assertThisInitialized$v(_this));
    _this.onPanelClick = _this.onPanelClick.bind(_assertThisInitialized$v(_this));
    _this.onEnter = _this.onEnter.bind(_assertThisInitialized$v(_this));
    _this.onEntered = _this.onEntered.bind(_assertThisInitialized$v(_this));
    _this.onExit = _this.onExit.bind(_assertThisInitialized$v(_this));
    _this.onExited = _this.onExited.bind(_assertThisInitialized$v(_this));
    _this.overlayRef = /*#__PURE__*/React.createRef();
    _this.acceptBtnRef = /*#__PURE__*/React.createRef();
    return _this;
  }

  _createClass$x(ConfirmPopup, [{
    key: "acceptLabel",
    value: function acceptLabel() {
      return this.props.acceptLabel || localeOption('accept');
    }
  }, {
    key: "rejectLabel",
    value: function rejectLabel() {
      return this.props.rejectLabel || localeOption('reject');
    }
  }, {
    key: "bindDocumentClickListener",
    value: function bindDocumentClickListener() {
      var _this2 = this;

      if (!this.documentClickListener && this.props.dismissable) {
        this.documentClickListener = function (event) {
          if (!_this2.isPanelClicked && _this2.isOutsideClicked(event.target)) {
            _this2.hide();
          }

          _this2.isPanelClicked = false;
        };

        document.addEventListener('click', this.documentClickListener);
      }
    }
  }, {
    key: "unbindDocumentClickListener",
    value: function unbindDocumentClickListener() {
      if (this.documentClickListener) {
        document.removeEventListener('click', this.documentClickListener);
        this.documentClickListener = null;
      }
    }
  }, {
    key: "bindScrollListener",
    value: function bindScrollListener() {
      var _this3 = this;

      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.props.target, function () {
          if (_this3.state.visible) {
            _this3.hide();
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    }
  }, {
    key: "unbindScrollListener",
    value: function unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }
  }, {
    key: "bindResizeListener",
    value: function bindResizeListener() {
      var _this4 = this;

      if (!this.resizeListener) {
        this.resizeListener = function () {
          if (_this4.state.visible && !DomHandler$1.isTouchDevice()) {
            _this4.hide();
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    }
  }, {
    key: "unbindResizeListener",
    value: function unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    }
  }, {
    key: "isOutsideClicked",
    value: function isOutsideClicked(target) {
      return this.overlayRef && this.overlayRef.current && !(this.overlayRef.current.isSameNode(target) || this.overlayRef.current.contains(target));
    }
  }, {
    key: "onCloseClick",
    value: function onCloseClick(event) {
      this.hide();
      event.preventDefault();
    }
  }, {
    key: "onPanelClick",
    value: function onPanelClick(event) {
      this.isPanelClicked = true;
      OverlayService.emit('overlay-click', {
        originalEvent: event,
        target: this.props.target
      });
    }
  }, {
    key: "accept",
    value: function accept() {
      if (this.props.accept) {
        this.props.accept();
      }

      this.hide('accept');
    }
  }, {
    key: "reject",
    value: function reject() {
      if (this.props.reject) {
        this.props.reject();
      }

      this.hide('reject');
    }
  }, {
    key: "show",
    value: function show() {
      var _this5 = this;

      this.setState({
        visible: true
      }, function () {
        _this5.overlayEventListener = function (e) {
          if (!_this5.isOutsideClicked(e.target)) {
            _this5.isPanelClicked = true;
          }
        };

        OverlayService.on('overlay-click', _this5.overlayEventListener);
      });
    }
  }, {
    key: "hide",
    value: function hide(result) {
      var _this6 = this;

      this.setState({
        visible: false
      }, function () {
        OverlayService.off('overlay-click', _this6.overlayEventListener);
        _this6.overlayEventListener = null;

        if (_this6.props.onHide) {
          _this6.props.onHide(result);
        }
      });
    }
  }, {
    key: "onEnter",
    value: function onEnter() {
      ZIndexUtils.set('overlay', this.overlayRef.current, PrimeReact.autoZIndex, PrimeReact.zIndex['overlay']);
      this.align();
    }
  }, {
    key: "onEntered",
    value: function onEntered() {
      this.bindDocumentClickListener();
      this.bindScrollListener();
      this.bindResizeListener();

      if (this.acceptBtnRef && this.acceptBtnRef.current) {
        this.acceptBtnRef.current.focus();
      }

      this.props.onShow && this.props.onShow();
    }
  }, {
    key: "onExit",
    value: function onExit() {
      this.unbindDocumentClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
    }
  }, {
    key: "onExited",
    value: function onExited() {
      ZIndexUtils.clear(this.overlayRef.current);
    }
  }, {
    key: "align",
    value: function align() {
      if (this.props.target) {
        DomHandler$1.absolutePosition(this.overlayRef.current, this.props.target);
        var containerOffset = DomHandler$1.getOffset(this.overlayRef.current);
        var targetOffset = DomHandler$1.getOffset(this.props.target);
        var arrowLeft = 0;

        if (containerOffset.left < targetOffset.left) {
          arrowLeft = targetOffset.left - containerOffset.left;
        }

        this.overlayRef.current.style.setProperty('--overlayArrowLeft', "".concat(arrowLeft, "px"));

        if (containerOffset.top < targetOffset.top) {
          DomHandler$1.addClass(this.overlayRef.current, 'p-confirm-popup-flipped');
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.visible) {
        this.setState({
          visible: true
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.visible !== this.props.visible) {
        this.setState({
          visible: this.props.visible
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindDocumentClickListener();
      this.unbindResizeListener();

      if (this.scrollHandler) {
        this.scrollHandler.destroy();
        this.scrollHandler = null;
      }

      if (this.overlayEventListener) {
        OverlayService.off('overlay-click', this.overlayEventListener);
        this.overlayEventListener = null;
      }

      ZIndexUtils.clear(this.overlayRef.current);
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var message = ObjectUtils.getJSXElement(this.props.message, this.props);
      return /*#__PURE__*/React.createElement("div", {
        className: "p-confirm-popup-content"
      }, IconUtils.getJSXIcon(this.props.icon, {
        className: 'p-confirm-popup-icon'
      }, {
        props: this.props
      }), /*#__PURE__*/React.createElement("span", {
        className: "p-confirm-popup-message"
      }, message));
    }
  }, {
    key: "renderFooter",
    value: function renderFooter() {
      var acceptClassName = classNames('p-confirm-popup-accept p-button-sm', this.props.acceptClassName);
      var rejectClassName = classNames('p-confirm-popup-reject p-button-sm', {
        'p-button-text': !this.props.rejectClassName
      }, this.props.rejectClassName);
      var content = /*#__PURE__*/React.createElement("div", {
        className: "p-confirm-popup-footer"
      }, /*#__PURE__*/React.createElement(Button$1, {
        label: this.rejectLabel(),
        icon: this.props.rejectIcon,
        className: rejectClassName,
        onClick: this.reject
      }), /*#__PURE__*/React.createElement(Button$1, {
        ref: this.acceptBtnRef,
        label: this.acceptLabel(),
        icon: this.props.acceptIcon,
        className: acceptClassName,
        onClick: this.accept
      }));

      if (this.props.footer) {
        var defaultContentOptions = {
          accept: this.accept,
          reject: this.reject,
          className: 'p-confirm-popup-footer',
          acceptClassName: acceptClassName,
          rejectClassName: rejectClassName,
          acceptLabel: this.acceptLabel(),
          rejectLabel: this.rejectLabel(),
          element: content,
          props: this.props
        };
        return ObjectUtils.getJSXElement(this.props.footer, defaultContentOptions);
      }

      return content;
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var className = classNames('p-confirm-popup p-component', this.props.className);
      var content = this.renderContent();
      var footer = this.renderFooter();
      return /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: this.overlayRef,
        classNames: "p-connected-overlay",
        "in": this.state.visible,
        timeout: {
          enter: 120,
          exit: 100
        },
        options: this.props.transitionOptions,
        unmountOnExit: true,
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onExit: this.onExit,
        onExited: this.onExited
      }, /*#__PURE__*/React.createElement("div", {
        ref: this.overlayRef,
        id: this.props.id,
        className: className,
        style: this.props.style,
        onClick: this.onPanelClick
      }, content, footer));
    }
  }, {
    key: "render",
    value: function render() {
      var element = this.renderElement();
      return /*#__PURE__*/React.createElement(Portal, {
        element: element,
        appendTo: this.props.appendTo,
        visible: this.props.visible
      });
    }
  }]);

  return ConfirmPopup;
}(Component);

_defineProperty$x(ConfirmPopup, "defaultProps", {
  target: null,
  visible: false,
  message: null,
  rejectLabel: null,
  acceptLabel: null,
  icon: null,
  rejectIcon: null,
  acceptIcon: null,
  rejectClassName: null,
  acceptClassName: null,
  className: null,
  style: null,
  appendTo: null,
  dismissable: true,
  footer: null,
  onShow: null,
  onHide: null,
  accept: null,
  reject: null,
  transitionOptions: null
});

var confirmPopup = function confirmPopup(_ref) {
  var target = _ref.target,
      message = _ref.message,
      rejectLabel = _ref.rejectLabel,
      acceptLabel = _ref.acceptLabel,
      icon = _ref.icon,
      rejectClassName = _ref.rejectClassName,
      acceptClassName = _ref.acceptClassName,
      className = _ref.className,
      style = _ref.style,
      footer = _ref.footer,
      onShow = _ref.onShow,
      onHide = _ref.onHide,
      accept = _ref.accept,
      reject = _ref.reject;
  var params = {
    target: target,
    message: message,
    rejectLabel: rejectLabel,
    acceptLabel: acceptLabel,
    icon: icon,
    rejectClassName: rejectClassName,
    acceptClassName: acceptClassName,
    className: className,
    style: style,
    footer: footer,
    onShow: onShow,
    onHide: onHide,
    accept: accept,
    reject: reject,
    dismissable: true
  };
  return confirmPopup$1(params);
};

var Dash = "";

function _classCallCheck$w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$w(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$w(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$w(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$w(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$u(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$u(o, p) {
  _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$u(o, p);
}

function _inherits$v(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$u(subClass, superClass);
}

function _typeof$v(obj) {
  "@babel/helpers - typeof";

  return _typeof$v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$v(obj);
}

function _possibleConstructorReturn$v(self, call) {
  if (call && (_typeof$v(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$u(self);
}

function _getPrototypeOf$v(o) {
  _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$v(o);
}

function _defineProperty$w(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$j(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$j(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$j(Object(source), !0).forEach(function (key) {
      _defineProperty$w(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$j(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$B(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$B();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$v(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$v(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$v(this, result);
  };
}

function _isNativeReflectConstruct$B() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var VirtualScroller = /*#__PURE__*/function (_Component) {
  _inherits$v(VirtualScroller, _Component);

  var _super = _createSuper$B(VirtualScroller);

  function VirtualScroller(props) {
    var _this;

    _classCallCheck$w(this, VirtualScroller);

    _this = _super.call(this, props);

    var isBoth = _this.isBoth();

    _this.state = {
      first: isBoth ? {
        rows: 0,
        cols: 0
      } : 0,
      last: isBoth ? {
        rows: 0,
        cols: 0
      } : 0,
      numItemsInViewport: isBoth ? {
        rows: 0,
        cols: 0
      } : 0,
      numToleratedItems: props.numToleratedItems,
      loading: props.loading,
      loaderArr: []
    };
    _this.onScroll = _this.onScroll.bind(_assertThisInitialized$u(_this));
    _this.lastScrollPos = isBoth ? {
      top: 0,
      left: 0
    } : 0;
    return _this;
  }

  _createClass$w(VirtualScroller, [{
    key: "scrollTo",
    value: function scrollTo(options) {
      this.el && this.el.scrollTo(options);
    }
  }, {
    key: "scrollToIndex",
    value: function scrollToIndex(index) {
      var _this2 = this;

      var behavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';
      var isBoth = this.isBoth();
      var isHorizontal = this.isHorizontal();
      var first = this.state.first;

      var _this$calculateNumIte = this.calculateNumItems(),
          numToleratedItems = _this$calculateNumIte.numToleratedItems;

      var itemSize = this.props.itemSize;
      var contentPos = this.getContentPosition();

      var calculateFirst = function calculateFirst() {
        var _index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        var _numT = arguments.length > 1 ? arguments[1] : undefined;

        return _index <= _numT ? 0 : _index;
      };

      var calculateCoord = function calculateCoord(_first, _size, _cpos) {
        return _first * _size + _cpos;
      };

      var scrollTo = function scrollTo() {
        var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return _this2.scrollTo({
          left: left,
          top: top,
          behavior: behavior
        });
      };

      if (isBoth) {
        var newFirst = {
          rows: calculateFirst(index[0], numToleratedItems[0]),
          cols: calculateFirst(index[1], numToleratedItems[1])
        };

        if (newFirst.rows !== first.rows || newFirst.cols !== first.cols) {
          scrollTo(calculateCoord(newFirst.cols, itemSize[1], contentPos.left), calculateCoord(newFirst.rows, itemSize[0], contentPos.top));
          this.setState({
            first: newFirst
          });
        }
      } else {
        var _newFirst = calculateFirst(index, numToleratedItems);

        if (_newFirst !== first) {
          isHorizontal ? scrollTo(calculateCoord(_newFirst, itemSize, contentPos.left), 0) : scrollTo(0, calculateCoord(_newFirst, itemSize, contentPos.top));
          this.setState({
            first: _newFirst
          });
        }
      }
    }
  }, {
    key: "scrollInView",
    value: function scrollInView(index, to) {
      var _this3 = this;

      var behavior = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'auto';

      if (to) {
        var isBoth = this.isBoth();
        var isHorizontal = this.isHorizontal();

        var _this$getRenderedRang = this.getRenderedRange(),
            first = _this$getRenderedRang.first,
            viewport = _this$getRenderedRang.viewport;

        var itemSize = this.props.itemSize;

        var scrollTo = function scrollTo() {
          var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          return _this3.scrollTo({
            left: left,
            top: top,
            behavior: behavior
          });
        };

        var isToStart = to === 'to-start';
        var isToEnd = to === 'to-end';

        if (isToStart) {
          if (isBoth) {
            if (viewport.first.rows - first.rows > index[0]) {
              scrollTo(viewport.first.cols * itemSize, (viewport.first.rows - 1) * itemSize);
            } else if (viewport.first.cols - first.cols > index[1]) {
              scrollTo((viewport.first.cols - 1) * itemSize, viewport.first.rows * itemSize);
            }
          } else {
            if (viewport.first - first > index) {
              var pos = (viewport.first - 1) * itemSize;
              isHorizontal ? scrollTo(pos, 0) : scrollTo(0, pos);
            }
          }
        } else if (isToEnd) {
          if (isBoth) {
            if (viewport.last.rows - first.rows <= index[0] + 1) {
              scrollTo(viewport.first.cols * itemSize, (viewport.first.rows + 1) * itemSize);
            } else if (viewport.last.cols - first.cols <= index[1] + 1) {
              scrollTo((viewport.first.cols + 1) * itemSize, viewport.first.rows * itemSize);
            }
          } else {
            if (viewport.last - first <= index + 1) {
              var _pos2 = (viewport.first + 1) * itemSize;

              isHorizontal ? scrollTo(_pos2, 0) : scrollTo(0, _pos2);
            }
          }
        }
      } else {
        this.scrollToIndex(index, behavior);
      }
    }
  }, {
    key: "getRows",
    value: function getRows() {
      return this.state.loading ? this.props.loaderDisabled ? this.state.loaderArr : [] : this.loadedItems();
    }
  }, {
    key: "getColumns",
    value: function getColumns() {
      if (this.props.columns) {
        var isBoth = this.isBoth();
        var isHorizontal = this.isHorizontal();

        if (isBoth || isHorizontal) {
          return this.state.loading && this.props.loaderDisabled ? isBoth ? this.state.loaderArr[0] : this.state.loaderArr : this.props.columns.slice(isBoth ? this.state.first.cols : this.state.first, isBoth ? this.state.last.cols : this.state.last);
        }
      }

      return this.props.columns;
    }
  }, {
    key: "getRenderedRange",
    value: function getRenderedRange() {
      var isBoth = this.isBoth();
      var isHorizontal = this.isHorizontal();
      var _this$state = this.state,
          first = _this$state.first,
          last = _this$state.last,
          numItemsInViewport = _this$state.numItemsInViewport;
      var itemSize = this.props.itemSize;

      var calculateFirstInViewport = function calculateFirstInViewport(_pos, _size) {
        return Math.floor(_pos / (_size || _pos));
      };

      var firstInViewport = first;
      var lastInViewport = 0;

      if (this.el) {
        var scrollTop = this.el.scrollTop;
        var scrollLeft = this.el.scrollLeft;

        if (isBoth) {
          firstInViewport = {
            rows: calculateFirstInViewport(scrollTop, itemSize[0]),
            cols: calculateFirstInViewport(scrollLeft, itemSize[1])
          };
          lastInViewport = {
            rows: firstInViewport.rows + numItemsInViewport.rows,
            cols: firstInViewport.cols + numItemsInViewport.cols
          };
        } else {
          var scrollPos = isHorizontal ? scrollLeft : scrollTop;
          firstInViewport = calculateFirstInViewport(scrollPos, itemSize);
          lastInViewport = firstInViewport + numItemsInViewport;
        }
      }

      return {
        first: first,
        last: last,
        viewport: {
          first: firstInViewport,
          last: lastInViewport
        }
      };
    }
  }, {
    key: "isVertical",
    value: function isVertical() {
      return this.props.orientation === 'vertical';
    }
  }, {
    key: "isHorizontal",
    value: function isHorizontal() {
      return this.props.orientation === 'horizontal';
    }
  }, {
    key: "isBoth",
    value: function isBoth() {
      return this.props.orientation === 'both';
    }
  }, {
    key: "calculateNumItems",
    value: function calculateNumItems() {
      var isBoth = this.isBoth();
      var isHorizontal = this.isHorizontal();
      var itemSize = this.props.itemSize;
      var contentPos = this.getContentPosition();
      var contentWidth = this.el ? this.el.offsetWidth - contentPos.left : 0;
      var contentHeight = this.el ? this.el.offsetHeight - contentPos.top : 0;

      var calculateNumItemsInViewport = function calculateNumItemsInViewport(_contentSize, _itemSize) {
        return Math.ceil(_contentSize / (_itemSize || _contentSize));
      };

      var calculateNumToleratedItems = function calculateNumToleratedItems(_numItems) {
        return Math.ceil(_numItems / 2);
      };

      var numItemsInViewport = isBoth ? {
        rows: calculateNumItemsInViewport(contentHeight, itemSize[0]),
        cols: calculateNumItemsInViewport(contentWidth, itemSize[1])
      } : calculateNumItemsInViewport(isHorizontal ? contentWidth : contentHeight, itemSize);
      var numToleratedItems = this.state.numToleratedItems || (isBoth ? [calculateNumToleratedItems(numItemsInViewport.rows), calculateNumToleratedItems(numItemsInViewport.cols)] : calculateNumToleratedItems(numItemsInViewport));
      return {
        numItemsInViewport: numItemsInViewport,
        numToleratedItems: numToleratedItems
      };
    }
  }, {
    key: "calculateOptions",
    value: function calculateOptions() {
      var _this4 = this;

      var isBoth = this.isBoth();
      var first = this.state.first;

      var _this$calculateNumIte2 = this.calculateNumItems(),
          numItemsInViewport = _this$calculateNumIte2.numItemsInViewport,
          numToleratedItems = _this$calculateNumIte2.numToleratedItems;

      var calculateLast = function calculateLast(_first, _num, _numT, _isCols) {
        return _this4.getLast(_first + _num + (_first < _numT ? 2 : 3) * _numT, _isCols);
      };

      var last = isBoth ? {
        rows: calculateLast(first.rows, numItemsInViewport.rows, numToleratedItems[0]),
        cols: calculateLast(first.cols, numItemsInViewport.cols, numToleratedItems[1], true)
      } : calculateLast(first, numItemsInViewport, numToleratedItems);
      var state = {
        numItemsInViewport: numItemsInViewport,
        last: last,
        numToleratedItems: numToleratedItems
      };

      if (this.props.showLoader) {
        state['loaderArr'] = isBoth ? Array.from({
          length: numItemsInViewport.rows
        }).map(function () {
          return Array.from({
            length: numItemsInViewport.cols
          });
        }) : Array.from({
          length: numItemsInViewport
        });
      }

      this.setState(state, function () {
        if (_this4.props.lazy) {
          _this4.props.onLazyLoad && _this4.props.onLazyLoad({
            first: _this4.state.first,
            last: _this4.state.last
          });
        }
      });
    }
  }, {
    key: "getLast",
    value: function getLast() {
      var last = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var isCols = arguments.length > 1 ? arguments[1] : undefined;

      if (this.props.items) {
        return Math.min(isCols ? (this.props.columns || this.props.items[0]).length : this.props.items.length, last);
      }

      return 0;
    }
  }, {
    key: "getContentPosition",
    value: function getContentPosition() {
      if (this.content) {
        var style = getComputedStyle(this.content);
        var left = parseInt(style.paddingLeft, 10) + Math.max(parseInt(style.left, 10), 0);
        var right = parseInt(style.paddingRight, 10) + Math.max(parseInt(style.right, 10), 0);
        var top = parseInt(style.paddingTop, 10) + Math.max(parseInt(style.top, 10), 0);
        var bottom = parseInt(style.paddingBottom, 10) + Math.max(parseInt(style.bottom, 10), 0);
        return {
          left: left,
          right: right,
          top: top,
          bottom: bottom,
          x: left + right,
          y: top + bottom
        };
      }

      return {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        x: 0,
        y: 0
      };
    }
  }, {
    key: "setSize",
    value: function setSize() {
      var _this5 = this;

      if (this.el) {
        var isBoth = this.isBoth();
        var isHorizontal = this.isHorizontal();
        var parentElement = this.el.parentElement;
        var width = this.props.scrollWidth || "".concat(this.el.offsetWidth || parentElement.offsetWidth, "px");
        var height = this.props.scrollHeight || "".concat(this.el.offsetHeight || parentElement.offsetHeight, "px");

        var setProp = function setProp(_name, _value) {
          return _this5.el.style[_name] = _value;
        };

        if (isBoth || isHorizontal) {
          setProp('height', height);
          setProp('width', width);
        } else {
          setProp('height', height);
        }
      }
    }
  }, {
    key: "setSpacerSize",
    value: function setSpacerSize() {
      var _this6 = this;

      var items = this.props.items;

      if (this.spacer && items) {
        var isBoth = this.isBoth();
        var isHorizontal = this.isHorizontal();
        var itemSize = this.props.itemSize;
        var contentPos = this.getContentPosition();

        var setProp = function setProp(_name, _value, _size) {
          var _cpos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

          return _this6.spacer.style[_name] = (_value || []).length * _size + _cpos + 'px';
        };

        if (isBoth) {
          setProp('height', items, itemSize[0], contentPos.y);
          setProp('width', this.props.columns || items[1], itemSize[1], contentPos.x);
        } else {
          isHorizontal ? setProp('width', this.props.columns || items, itemSize, contentPos.x) : setProp('height', items, itemSize, contentPos.y);
        }
      }
    }
  }, {
    key: "setContentPosition",
    value: function setContentPosition(pos) {
      var _this7 = this;

      if (this.content) {
        var isBoth = this.isBoth();
        var isHorizontal = this.isHorizontal();
        var first = pos ? pos.first : this.state.first;
        var itemSize = this.props.itemSize;

        var calculateTranslateVal = function calculateTranslateVal(_first, _size) {
          return _first * _size;
        };

        var setTransform = function setTransform() {
          var _x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

          var _y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          _this7.sticky && (_this7.sticky.style.top = "-".concat(_y, "px"));
          _this7.content.style.transform = "translate3d(".concat(_x, "px, ").concat(_y, "px, 0)");
        };

        if (isBoth) {
          setTransform(calculateTranslateVal(first.cols, itemSize[1]), calculateTranslateVal(first.rows, itemSize[0]));
        } else {
          var translateVal = calculateTranslateVal(first, itemSize);
          isHorizontal ? setTransform(translateVal, 0) : setTransform(0, translateVal);
        }
      }
    }
  }, {
    key: "onScrollPositionChange",
    value: function onScrollPositionChange(event) {
      var _this8 = this;

      var target = event.target;
      var isBoth = this.isBoth();
      var isHorizontal = this.isHorizontal();
      var _this$state2 = this.state,
          first = _this$state2.first,
          last = _this$state2.last,
          numItemsInViewport = _this$state2.numItemsInViewport,
          numToleratedItems = _this$state2.numToleratedItems;
      var itemSize = this.props.itemSize;
      var contentPos = this.getContentPosition();

      var calculateScrollPos = function calculateScrollPos(_pos, _cpos) {
        return _pos ? _pos > _cpos ? _pos - _cpos : _pos : 0;
      };

      var calculateCurrentIndex = function calculateCurrentIndex(_pos, _size) {
        return Math.floor(_pos / (_size || _pos));
      };

      var calculateTriggerIndex = function calculateTriggerIndex(_currentIndex, _first, _last, _num, _numT, _isScrollDownOrRight) {
        return _currentIndex <= _numT ? _numT : _isScrollDownOrRight ? _last - _num - _numT : _first + _numT - 1;
      };

      var calculateFirst = function calculateFirst(_currentIndex, _triggerIndex, _first, _last, _num, _numT, _isScrollDownOrRight) {
        if (_currentIndex <= _numT) return 0;else return Math.max(0, _isScrollDownOrRight ? _currentIndex < _triggerIndex ? _first : _currentIndex - _numT : _currentIndex > _triggerIndex ? _first : _currentIndex - 2 * _numT);
      };

      var calculateLast = function calculateLast(_currentIndex, _first, _last, _num, _numT, _isCols) {
        var lastValue = _first + _num + 2 * _numT;

        if (_currentIndex >= _numT) {
          lastValue += _numT + 1;
        }

        return _this8.getLast(lastValue, _isCols);
      };

      var scrollTop = calculateScrollPos(target.scrollTop, contentPos.top);
      var scrollLeft = calculateScrollPos(target.scrollLeft, contentPos.left);
      var newFirst = 0;
      var newLast = last;
      var isRangeChanged = false;

      if (isBoth) {
        var isScrollDown = this.lastScrollPos.top <= scrollTop;
        var isScrollRight = this.lastScrollPos.left <= scrollLeft;
        var currentIndex = {
          rows: calculateCurrentIndex(scrollTop, itemSize[0]),
          cols: calculateCurrentIndex(scrollLeft, itemSize[1])
        };
        var triggerIndex = {
          rows: calculateTriggerIndex(currentIndex.rows, first.rows, last.rows, numItemsInViewport.rows, numToleratedItems[0], isScrollDown),
          cols: calculateTriggerIndex(currentIndex.cols, first.cols, last.cols, numItemsInViewport.cols, numToleratedItems[1], isScrollRight)
        };
        newFirst = {
          rows: calculateFirst(currentIndex.rows, triggerIndex.rows, first.rows, last.rows, numItemsInViewport.rows, numToleratedItems[0], isScrollDown),
          cols: calculateFirst(currentIndex.cols, triggerIndex.cols, first.cols, last.cols, numItemsInViewport.cols, numToleratedItems[1], isScrollRight)
        };
        newLast = {
          rows: calculateLast(currentIndex.rows, newFirst.rows, last.rows, numItemsInViewport.rows, numToleratedItems[0]),
          cols: calculateLast(currentIndex.cols, newFirst.cols, last.cols, numItemsInViewport.cols, numToleratedItems[1], true)
        };
        isRangeChanged = newFirst.rows !== first.rows && newLast.rows !== last.rows || newFirst.cols !== first.cols && newLast.cols !== last.cols;
        this.lastScrollPos = {
          top: scrollTop,
          left: scrollLeft
        };
      } else {
        var scrollPos = isHorizontal ? scrollLeft : scrollTop;
        var isScrollDownOrRight = this.lastScrollPos <= scrollPos;

        var _currentIndex2 = calculateCurrentIndex(scrollPos, itemSize);

        var _triggerIndex2 = calculateTriggerIndex(_currentIndex2, first, last, numItemsInViewport, numToleratedItems, isScrollDownOrRight);

        newFirst = calculateFirst(_currentIndex2, _triggerIndex2, first, last, numItemsInViewport, numToleratedItems, isScrollDownOrRight);
        newLast = calculateLast(_currentIndex2, newFirst, last, numItemsInViewport, numToleratedItems);
        isRangeChanged = newFirst !== first && newLast !== last;
        this.lastScrollPos = scrollPos;
      }

      return {
        first: newFirst,
        last: newLast,
        isRangeChanged: isRangeChanged
      };
    }
  }, {
    key: "onScrollChange",
    value: function onScrollChange(event) {
      var _this9 = this;

      var _this$onScrollPositio = this.onScrollPositionChange(event),
          first = _this$onScrollPositio.first,
          last = _this$onScrollPositio.last,
          isRangeChanged = _this$onScrollPositio.isRangeChanged;

      if (isRangeChanged) {
        var newState = {
          first: first,
          last: last
        };
        this.setContentPosition(newState);
        this.setState(newState, function () {
          _this9.props.onScrollIndexChange && _this9.props.onScrollIndexChange(newState);

          if (_this9.props.lazy) {
            _this9.props.onLazyLoad && _this9.props.onLazyLoad(newState);
          }
        });
      }
    }
  }, {
    key: "onScroll",
    value: function onScroll(event) {
      var _this10 = this;

      this.props.onScroll && this.props.onScroll(event);

      if (this.props.delay) {
        if (this.scrollTimeout) {
          clearTimeout(this.scrollTimeout);
        }

        if (!this.state.loading && this.props.showLoader) {
          var _this$onScrollPositio2 = this.onScrollPositionChange(event),
              changed = _this$onScrollPositio2.isRangeChanged;

          changed && this.setState({
            loading: true
          });
        }

        this.scrollTimeout = setTimeout(function () {
          _this10.onScrollChange(event);

          if (_this10.state.loading && _this10.props.showLoader && !_this10.props.lazy) {
            _this10.setState({
              loading: false
            });
          }
        }, this.props.delay);
      } else {
        this.onScrollChange(event);
      }
    }
  }, {
    key: "getOptions",
    value: function getOptions(renderedIndex) {
      var first = this.state.first;
      var count = (this.props.items || []).length;
      var index = this.isBoth() ? first.rows + renderedIndex : first + renderedIndex;
      return {
        index: index,
        count: count,
        first: index === 0,
        last: index === count - 1,
        even: index % 2 === 0,
        odd: index % 2 !== 0,
        props: this.props
      };
    }
  }, {
    key: "loaderOptions",
    value: function loaderOptions(index, extOptions) {
      var count = this.state.loaderArr.length;
      return _objectSpread$j({
        index: index,
        count: count,
        first: index === 0,
        last: index === count - 1,
        even: index % 2 === 0,
        odd: index % 2 !== 0,
        props: this.props
      }, extOptions);
    }
  }, {
    key: "loadedItems",
    value: function loadedItems() {
      var _this11 = this;

      var items = this.props.items;

      if (items && !this.state.loading) {
        var isBoth = this.isBoth();
        var isHorizontal = this.isHorizontal();
        var _this$state3 = this.state,
            first = _this$state3.first,
            last = _this$state3.last;
        if (isBoth) return items.slice(first.rows, last.rows).map(function (item) {
          return _this11.props.columns ? item : item.slice(first.cols, last.cols);
        });else if (isHorizontal && this.props.columns) return items;else return items.slice(first, last);
      }

      return [];
    }
  }, {
    key: "isPropChanged",
    value: function isPropChanged(prevProps) {
      var _this12 = this;

      var props = ['itemSize', 'scrollHeight'];
      return props.some(function (p) {
        return !ObjectUtils.equals(prevProps[p], _this12.props[p]);
      });
    }
  }, {
    key: "init",
    value: function init() {
      this.setSize();
      this.calculateOptions();
      this.setSpacerSize();
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.init();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (!prevProps.items || prevProps.items.length !== (this.props.items || []).length || this.isPropChanged(prevProps)) {
        this.init();
      }

      if (this.props.lazy && prevProps.loading !== this.props.loading && this.state.loading !== this.props.loading) {
        this.setState({
          loading: this.props.loading
        });
      }

      if (prevProps.orientation !== this.props.orientation) {
        this.lastScrollPos = this.isBoth() ? {
          top: 0,
          left: 0
        } : 0;
      }
    }
  }, {
    key: "renderLoaderItem",
    value: function renderLoaderItem(index) {
      var extOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = this.loaderOptions(index, extOptions);
      var content = ObjectUtils.getJSXElement(this.props.loadingTemplate, options);
      return /*#__PURE__*/React.createElement(React.Fragment, {
        key: index
      }, content);
    }
  }, {
    key: "renderLoader",
    value: function renderLoader() {
      var _this13 = this;

      if (!this.props.loaderDisabled && this.props.showLoader && this.state.loading) {
        var className = classNames('p-virtualscroller-loader', {
          'p-component-overlay': !this.props.loadingTemplate
        });
        var content = /*#__PURE__*/React.createElement("i", {
          className: "p-virtualscroller-loading-icon pi pi-spinner pi-spin"
        });

        if (this.props.loadingTemplate) {
          var isBoth = this.isBoth();
          var numItemsInViewport = this.state.numItemsInViewport;
          content = this.state.loaderArr.map(function (_, index) {
            return _this13.renderLoaderItem(index, isBoth && {
              numCols: numItemsInViewport.cols
            });
          });
        }

        return /*#__PURE__*/React.createElement("div", {
          className: className
        }, content);
      }

      return null;
    }
  }, {
    key: "renderSpacer",
    value: function renderSpacer() {
      var _this14 = this;

      if (this.props.showSpacer) {
        return /*#__PURE__*/React.createElement("div", {
          ref: function ref(el) {
            return _this14.spacer = el;
          },
          className: "p-virtualscroller-spacer"
        });
      }

      return null;
    }
  }, {
    key: "renderItem",
    value: function renderItem(item, index) {
      var options = this.getOptions(index);
      var content = ObjectUtils.getJSXElement(this.props.itemTemplate, item, options);
      return /*#__PURE__*/React.createElement(React.Fragment, {
        key: options.index
      }, content);
    }
  }, {
    key: "renderItems",
    value: function renderItems(loadedItems) {
      var _this15 = this;

      return loadedItems.map(function (item, index) {
        return _this15.renderItem(item, index);
      });
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this16 = this;

      var loadedItems = this.loadedItems();
      var items = this.renderItems(loadedItems);
      var className = classNames('p-virtualscroller-content', {
        'p-virtualscroller-loading': this.state.loading
      });
      var content = /*#__PURE__*/React.createElement("div", {
        className: className,
        ref: function ref(el) {
          return _this16.content = el;
        }
      }, items);

      if (this.props.contentTemplate) {
        var defaultOptions = {
          className: className,
          contentRef: function contentRef(el) {
            return _this16.content = el;
          },
          spacerRef: function spacerRef(el) {
            return _this16.spacer = el;
          },
          stickyRef: function stickyRef(el) {
            return _this16.sticky = el;
          },
          items: loadedItems,
          getItemOptions: function getItemOptions(index) {
            return _this16.getOptions(index);
          },
          children: items,
          element: content,
          props: this.props,
          loading: this.state.loading,
          getLoaderOptions: function getLoaderOptions(index, ext) {
            return _this16.loaderOptions(index, ext);
          },
          loadingTemplate: this.props.loadingTemplate,
          itemSize: this.props.itemSize,
          rows: this.getRows(),
          columns: this.getColumns(),
          vertical: this.isVertical(),
          horizontal: this.isHorizontal(),
          both: this.isBoth()
        };
        return ObjectUtils.getJSXElement(this.props.contentTemplate, defaultOptions);
      }

      return content;
    }
  }, {
    key: "render",
    value: function render() {
      var _this17 = this;

      if (this.props.disabled) {
        var content = ObjectUtils.getJSXElement(this.props.contentTemplate, {
          items: this.props.items,
          rows: this.props.items,
          columns: this.props.columns
        });
        return /*#__PURE__*/React.createElement(React.Fragment, null, this.props.children, content);
      } else {
        var isBoth = this.isBoth();
        var isHorizontal = this.isHorizontal();
        var className = classNames('p-virtualscroller', {
          'p-both-scroll': isBoth,
          'p-horizontal-scroll': isHorizontal
        }, this.props.className);
        var loader = this.renderLoader();

        var _content = this.renderContent();

        var spacer = this.renderSpacer();
        return /*#__PURE__*/React.createElement("div", {
          ref: function ref(el) {
            return _this17.el = el;
          },
          className: className,
          tabIndex: 0,
          style: this.props.style,
          onScroll: this.onScroll
        }, _content, spacer, loader);
      }
    }
  }]);

  return VirtualScroller;
}(Component);

_defineProperty$w(VirtualScroller, "defaultProps", {
  id: null,
  style: null,
  className: null,
  items: null,
  itemSize: 0,
  scrollHeight: null,
  scrollWidth: null,
  orientation: 'vertical',
  numToleratedItems: null,
  delay: 0,
  lazy: false,
  disabled: false,
  loaderDisabled: false,
  columns: null,
  loading: false,
  showSpacer: true,
  showLoader: false,
  loadingTemplate: null,
  itemTemplate: null,
  contentTemplate: null,
  onScroll: null,
  onScrollIndexChange: null,
  onLazyLoad: null
});

function _extends$9() {
  _extends$9 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$9.apply(this, arguments);
}

function _classCallCheck$v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$v(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$v(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$v(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$v(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$t(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$t(o, p) {
  _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$t(o, p);
}

function _inherits$u(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$t(subClass, superClass);
}

function _typeof$u(obj) {
  "@babel/helpers - typeof";

  return _typeof$u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$u(obj);
}

function _possibleConstructorReturn$u(self, call) {
  if (call && (_typeof$u(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$t(self);
}

function _getPrototypeOf$u(o) {
  _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$u(o);
}

function _defineProperty$v(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$2$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2$4();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$u(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$u(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$u(this, result);
  };
}

function _isNativeReflectConstruct$2$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var DropdownItem = /*#__PURE__*/function (_Component) {
  _inherits$u(DropdownItem, _Component);

  var _super = _createSuper$2$4(DropdownItem);

  function DropdownItem(props) {
    var _this;

    _classCallCheck$v(this, DropdownItem);

    _this = _super.call(this, props);
    _this.onClick = _this.onClick.bind(_assertThisInitialized$t(_this));
    return _this;
  }

  _createClass$v(DropdownItem, [{
    key: "onClick",
    value: function onClick(event) {
      if (this.props.onClick) {
        this.props.onClick({
          originalEvent: event,
          option: this.props.option
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-dropdown-item', {
        'p-highlight': this.props.selected,
        'p-disabled': this.props.disabled,
        'p-dropdown-item-empty': !this.props.label || this.props.label.length === 0
      }, this.props.option.className);
      var content = this.props.template ? ObjectUtils.getJSXElement(this.props.template, this.props.option) : this.props.label;
      return /*#__PURE__*/React.createElement("li", {
        className: className,
        onClick: this.onClick,
        "aria-label": this.props.label,
        key: this.props.label,
        role: "option",
        "aria-selected": this.props.selected
      }, content, /*#__PURE__*/React.createElement(Ripple, null));
    }
  }]);

  return DropdownItem;
}(Component);

_defineProperty$v(DropdownItem, "defaultProps", {
  option: null,
  label: null,
  template: null,
  selected: false,
  disabled: false,
  onClick: null
});

function ownKeys$1$4(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1$4(Object(source), !0).forEach(function (key) {
      _defineProperty$v(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$4(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$1$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$a();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$u(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$u(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$u(this, result);
  };
}

function _isNativeReflectConstruct$1$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var DropdownPanelComponent = /*#__PURE__*/function (_Component) {
  _inherits$u(DropdownPanelComponent, _Component);

  var _super = _createSuper$1$a(DropdownPanelComponent);

  function DropdownPanelComponent(props) {
    var _this;

    _classCallCheck$v(this, DropdownPanelComponent);

    _this = _super.call(this, props);
    _this.onEnter = _this.onEnter.bind(_assertThisInitialized$t(_this));
    _this.onEntered = _this.onEntered.bind(_assertThisInitialized$t(_this));
    _this.onFilterInputChange = _this.onFilterInputChange.bind(_assertThisInitialized$t(_this));
    return _this;
  }

  _createClass$v(DropdownPanelComponent, [{
    key: "onEnter",
    value: function onEnter() {
      var _this2 = this;

      this.props.onEnter(function () {
        if (_this2.virtualScrollerRef) {
          var selectedIndex = _this2.props.getSelectedOptionIndex();

          if (selectedIndex !== -1) {
            _this2.virtualScrollerRef.scrollToIndex(selectedIndex);
          }
        }
      });
    }
  }, {
    key: "onEntered",
    value: function onEntered() {
      var _this3 = this;

      this.props.onEntered(function () {
        if (_this3.props.filter && _this3.props.filterInputAutoFocus) {
          _this3.filterInput.focus();
        }
      });
    }
  }, {
    key: "onFilterInputChange",
    value: function onFilterInputChange(event) {
      if (this.virtualScrollerRef) {
        this.virtualScrollerRef.scrollToIndex(0);
      }

      this.props.onFilterInputChange && this.props.onFilterInputChange(event);
    }
  }, {
    key: "isEmptyFilter",
    value: function isEmptyFilter() {
      return !(this.props.visibleOptions && this.props.visibleOptions.length) && this.props.hasFilter();
    }
  }, {
    key: "renderGroupChildren",
    value: function renderGroupChildren(optionGroup) {
      var _this4 = this;

      var groupChildren = this.props.getOptionGroupChildren(optionGroup);
      return groupChildren.map(function (option, j) {
        var optionLabel = _this4.props.getOptionLabel(option);

        var optionKey = j + '_' + _this4.props.getOptionRenderKey(option);

        var disabled = _this4.props.isOptionDisabled(option);

        return /*#__PURE__*/React.createElement(DropdownItem, {
          key: optionKey,
          label: optionLabel,
          option: option,
          template: _this4.props.itemTemplate,
          selected: _this4.props.isSelected(option),
          disabled: disabled,
          onClick: _this4.props.onOptionClick
        });
      });
    }
  }, {
    key: "renderEmptyMessage",
    value: function renderEmptyMessage(emptyMessage, isFilter) {
      var message = ObjectUtils.getJSXElement(emptyMessage, this.props) || localeOption(isFilter ? 'emptyFilterMessage' : 'emptyMessage');
      return /*#__PURE__*/React.createElement("li", {
        className: "p-dropdown-empty-message"
      }, message);
    }
  }, {
    key: "renderItem",
    value: function renderItem(option, index) {
      if (this.props.optionGroupLabel) {
        var groupContent = this.props.optionGroupTemplate ? ObjectUtils.getJSXElement(this.props.optionGroupTemplate, option, index) : this.props.getOptionGroupLabel(option);
        var groupChildrenContent = this.renderGroupChildren(option);
        var key = index + '_' + this.props.getOptionGroupRenderKey(option);
        return /*#__PURE__*/React.createElement(React.Fragment, {
          key: key
        }, /*#__PURE__*/React.createElement("li", {
          className: "p-dropdown-item-group"
        }, groupContent), groupChildrenContent);
      } else {
        var optionLabel = this.props.getOptionLabel(option);
        var optionKey = index + '_' + this.props.getOptionRenderKey(option);
        var disabled = this.props.isOptionDisabled(option);
        return /*#__PURE__*/React.createElement(DropdownItem, {
          key: optionKey,
          label: optionLabel,
          option: option,
          template: this.props.itemTemplate,
          selected: this.props.isSelected(option),
          disabled: disabled,
          onClick: this.props.onOptionClick
        });
      }
    }
  }, {
    key: "renderItems",
    value: function renderItems() {
      var _this5 = this;

      if (this.props.visibleOptions && this.props.visibleOptions.length) {
        return this.props.visibleOptions.map(function (option, index) {
          return _this5.renderItem(option, index);
        });
      } else if (this.props.hasFilter()) {
        return this.renderEmptyMessage(this.props.emptyFilterMessage, true);
      }

      return this.renderEmptyMessage(this.props.emptyMessage);
    }
  }, {
    key: "renderFilterClearIcon",
    value: function renderFilterClearIcon() {
      var _this6 = this;

      if (this.props.showFilterClear && this.props.filterValue) {
        return /*#__PURE__*/React.createElement("i", {
          className: "p-dropdown-filter-clear-icon pi pi-times",
          onClick: function onClick() {
            return _this6.props.onFilterClearIconClick(function () {
              return _this6.filterInput.focus();
            });
          }
        });
      }

      return null;
    }
  }, {
    key: "renderFilter",
    value: function renderFilter() {
      var _this7 = this;

      if (this.props.filter) {
        var clearIcon = this.renderFilterClearIcon();
        var containerClassName = classNames('p-dropdown-filter-container', {
          'p-dropdown-clearable-filter': !!clearIcon
        });
        return /*#__PURE__*/React.createElement("div", {
          className: "p-dropdown-header"
        }, /*#__PURE__*/React.createElement("div", {
          className: containerClassName
        }, /*#__PURE__*/React.createElement("input", {
          ref: function ref(el) {
            return _this7.filterInput = el;
          },
          type: "text",
          autoComplete: "off",
          className: "p-dropdown-filter p-inputtext p-component",
          placeholder: this.props.filterPlaceholder,
          onKeyDown: this.props.onFilterInputKeyDown,
          onChange: this.onFilterInputChange,
          value: this.props.filterValue
        }), clearIcon, /*#__PURE__*/React.createElement("i", {
          className: "p-dropdown-filter-icon pi pi-search"
        })));
      }

      return null;
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this8 = this;

      if (this.props.virtualScrollerOptions) {
        var virtualScrollerProps = _objectSpread$1$4(_objectSpread$1$4({}, this.props.virtualScrollerOptions), {
          style: _objectSpread$1$4(_objectSpread$1$4({}, this.props.virtualScrollerOptions.style), {
            height: this.props.scrollHeight
          }),
          className: classNames('p-dropdown-items-wrapper', this.props.virtualScrollerOptions.className),
          items: this.props.visibleOptions,
          onLazyLoad: function onLazyLoad(event) {
            return _this8.props.virtualScrollerOptions.onLazyLoad(_objectSpread$1$4(_objectSpread$1$4({}, event), {
              filter: _this8.props.filterValue
            }));
          },
          itemTemplate: function itemTemplate(item, options) {
            return item && _this8.renderItem(item, options.index);
          },
          contentTemplate: function contentTemplate(options) {
            var className = classNames('p-dropdown-items', options.className);
            var content = _this8.isEmptyFilter() ? _this8.renderEmptyMessage() : options.children;
            return /*#__PURE__*/React.createElement("ul", {
              ref: options.contentRef,
              className: className,
              role: "listbox"
            }, content);
          }
        });

        return /*#__PURE__*/React.createElement(VirtualScroller, _extends$9({
          ref: function ref(el) {
            return _this8.virtualScrollerRef = el;
          }
        }, virtualScrollerProps));
      } else {
        var items = this.renderItems();
        return /*#__PURE__*/React.createElement("div", {
          className: "p-dropdown-items-wrapper",
          style: {
            maxHeight: this.props.scrollHeight || 'auto'
          }
        }, /*#__PURE__*/React.createElement("ul", {
          className: "p-dropdown-items",
          role: "listbox"
        }, items));
      }
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var className = classNames('p-dropdown-panel p-component', this.props.panelClassName);
      var filter = this.renderFilter();
      var content = this.renderContent();
      return /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: this.props.forwardRef,
        classNames: "p-connected-overlay",
        "in": this.props["in"],
        timeout: {
          enter: 120,
          exit: 100
        },
        options: this.props.transitionOptions,
        unmountOnExit: true,
        onEnter: this.onEnter,
        onEntering: this.props.onEntering,
        onEntered: this.onEntered,
        onExit: this.props.onExit,
        onExited: this.props.onExited
      }, /*#__PURE__*/React.createElement("div", {
        ref: this.props.forwardRef,
        className: className,
        style: this.props.panelStyle,
        onClick: this.props.onClick
      }, filter, content));
    }
  }, {
    key: "render",
    value: function render() {
      var element = this.renderElement();
      return /*#__PURE__*/React.createElement(Portal, {
        element: element,
        appendTo: this.props.appendTo
      });
    }
  }]);

  return DropdownPanelComponent;
}(Component);

var DropdownPanel = /*#__PURE__*/React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(DropdownPanelComponent, _extends$9({
    forwardRef: ref
  }, props));
});

function ownKeys$i(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$i(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$i(Object(source), !0).forEach(function (key) {
      _defineProperty$v(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$i(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createForOfIteratorHelper$a(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$i(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$i(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$i(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$i(o, minLen);
}

function _arrayLikeToArray$i(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _createSuper$A(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$A();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$u(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$u(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$u(this, result);
  };
}

function _isNativeReflectConstruct$A() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Dropdown$1 = /*#__PURE__*/function (_Component) {
  _inherits$u(Dropdown, _Component);

  var _super = _createSuper$A(Dropdown);

  function Dropdown(props) {
    var _this;

    _classCallCheck$v(this, Dropdown);

    _this = _super.call(this, props);
    _this.state = {
      filter: '',
      focused: false,
      overlayVisible: false
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized$t(_this));
    _this.onInputFocus = _this.onInputFocus.bind(_assertThisInitialized$t(_this));
    _this.onInputBlur = _this.onInputBlur.bind(_assertThisInitialized$t(_this));
    _this.onInputKeyDown = _this.onInputKeyDown.bind(_assertThisInitialized$t(_this));
    _this.onEditableInputChange = _this.onEditableInputChange.bind(_assertThisInitialized$t(_this));
    _this.onEditableInputFocus = _this.onEditableInputFocus.bind(_assertThisInitialized$t(_this));
    _this.onOptionClick = _this.onOptionClick.bind(_assertThisInitialized$t(_this));
    _this.onFilterInputChange = _this.onFilterInputChange.bind(_assertThisInitialized$t(_this));
    _this.onFilterInputKeyDown = _this.onFilterInputKeyDown.bind(_assertThisInitialized$t(_this));
    _this.onFilterClearIconClick = _this.onFilterClearIconClick.bind(_assertThisInitialized$t(_this));
    _this.onPanelClick = _this.onPanelClick.bind(_assertThisInitialized$t(_this));
    _this.onOverlayEnter = _this.onOverlayEnter.bind(_assertThisInitialized$t(_this));
    _this.onOverlayEntered = _this.onOverlayEntered.bind(_assertThisInitialized$t(_this));
    _this.onOverlayExit = _this.onOverlayExit.bind(_assertThisInitialized$t(_this));
    _this.onOverlayExited = _this.onOverlayExited.bind(_assertThisInitialized$t(_this));
    _this.resetFilter = _this.resetFilter.bind(_assertThisInitialized$t(_this));
    _this.clear = _this.clear.bind(_assertThisInitialized$t(_this));
    _this.hasFilter = _this.hasFilter.bind(_assertThisInitialized$t(_this));
    _this.getOptionLabel = _this.getOptionLabel.bind(_assertThisInitialized$t(_this));
    _this.getOptionRenderKey = _this.getOptionRenderKey.bind(_assertThisInitialized$t(_this));
    _this.isOptionDisabled = _this.isOptionDisabled.bind(_assertThisInitialized$t(_this));
    _this.getOptionGroupChildren = _this.getOptionGroupChildren.bind(_assertThisInitialized$t(_this));
    _this.getOptionGroupLabel = _this.getOptionGroupLabel.bind(_assertThisInitialized$t(_this));
    _this.getOptionGroupRenderKey = _this.getOptionGroupRenderKey.bind(_assertThisInitialized$t(_this));
    _this.getSelectedOptionIndex = _this.getSelectedOptionIndex.bind(_assertThisInitialized$t(_this));
    _this.isSelected = _this.isSelected.bind(_assertThisInitialized$t(_this));
    _this.overlayRef = /*#__PURE__*/createRef();
    _this.inputRef = /*#__PURE__*/createRef(_this.props.inputRef);
    return _this;
  }

  _createClass$v(Dropdown, [{
    key: "onClick",
    value: function onClick(event) {
      if (this.props.disabled) {
        return;
      }

      if (DomHandler$1.hasClass(event.target, 'p-dropdown-clear-icon') || event.target.tagName === 'INPUT') {
        return;
      } else if (!this.overlayRef.current || !(this.overlayRef.current && this.overlayRef.current.contains(event.target))) {
        this.focusInput.focus();

        if (this.state.overlayVisible) {
          this.hideOverlay();
        } else {
          this.showOverlay();
        }
      }
    }
  }, {
    key: "onInputFocus",
    value: function onInputFocus(event) {
      var _this2 = this;

      event.persist();

      if (this.props.showOnFocus && !this.state.overlayVisible) {
        this.showOverlay();
      }

      this.setState({
        focused: true
      }, function () {
        if (_this2.props.onFocus) {
          _this2.props.onFocus(event);
        }
      });
    }
  }, {
    key: "onInputBlur",
    value: function onInputBlur(event) {
      var _this3 = this;

      event.persist();
      this.setState({
        focused: false
      }, function () {
        if (_this3.props.onBlur) {
          _this3.props.onBlur(event);
        }
      });
    }
  }, {
    key: "onPanelClick",
    value: function onPanelClick(event) {
      OverlayService.emit('overlay-click', {
        originalEvent: event,
        target: this.container
      });
    }
  }, {
    key: "onInputKeyDown",
    value: function onInputKeyDown(event) {
      switch (event.which) {
        //down
        case 40:
          this.onDownKey(event);
          break;
        //up

        case 38:
          this.onUpKey(event);
          break;
        //space

        case 32:
          if (this.state.overlayVisible) this.hideOverlay();else this.showOverlay();
          event.preventDefault();
          break;
        //enter

        case 13:
          this.hideOverlay();
          event.preventDefault();
          break;
        //escape and tab

        case 27:
        case 9:
          this.hideOverlay();
          break;

        default:
          this.search(event);
          break;
      }
    }
  }, {
    key: "onFilterInputKeyDown",
    value: function onFilterInputKeyDown(event) {
      switch (event.which) {
        //down
        case 40:
          this.onDownKey(event);
          break;
        //up

        case 38:
          this.onUpKey(event);
          break;
        //enter and escape

        case 13:
        case 27:
          this.hideOverlay();
          event.preventDefault();
          break;
      }
    }
  }, {
    key: "onUpKey",
    value: function onUpKey(event) {
      var visibleOptions = this.getVisibleOptions();

      if (visibleOptions) {
        var prevOption = this.findPrevOption(this.getSelectedOptionIndex());

        if (prevOption) {
          this.selectItem({
            originalEvent: event,
            option: prevOption
          });
        }
      }

      event.preventDefault();
    }
  }, {
    key: "onDownKey",
    value: function onDownKey(event) {
      var visibleOptions = this.getVisibleOptions();

      if (visibleOptions) {
        if (!this.state.overlayVisible && event.altKey) {
          this.showOverlay();
        } else {
          var nextOption = this.findNextOption(this.getSelectedOptionIndex());

          if (nextOption) {
            this.selectItem({
              originalEvent: event,
              option: nextOption
            });
          }
        }
      }

      event.preventDefault();
    }
  }, {
    key: "findNextOption",
    value: function findNextOption(index) {
      var visibleOptions = this.getVisibleOptions();

      if (this.props.optionGroupLabel) {
        var groupIndex = index === -1 ? 0 : index.group;
        var optionIndex = index === -1 ? -1 : index.option;
        var option = this.findNextOptionInList(this.getOptionGroupChildren(visibleOptions[groupIndex]), optionIndex);
        if (option) return option;else if (groupIndex + 1 !== visibleOptions.length) return this.findNextOption({
          group: groupIndex + 1,
          option: -1
        });else return null;
      } else {
        return this.findNextOptionInList(visibleOptions, index);
      }
    }
  }, {
    key: "findNextOptionInList",
    value: function findNextOptionInList(list, index) {
      var i = index + 1;

      if (i === list.length) {
        return null;
      }

      var option = list[i];
      if (this.isOptionDisabled(option)) return this.findNextOptionInList(i);else return option;
    }
  }, {
    key: "findPrevOption",
    value: function findPrevOption(index) {
      if (index === -1) {
        return null;
      }

      var visibleOptions = this.getVisibleOptions();

      if (this.props.optionGroupLabel) {
        var groupIndex = index.group;
        var optionIndex = index.option;
        var option = this.findPrevOptionInList(this.getOptionGroupChildren(visibleOptions[groupIndex]), optionIndex);
        if (option) return option;else if (groupIndex > 0) return this.findPrevOption({
          group: groupIndex - 1,
          option: this.getOptionGroupChildren(visibleOptions[groupIndex - 1]).length
        });else return null;
      } else {
        return this.findPrevOptionInList(visibleOptions, index);
      }
    }
  }, {
    key: "findPrevOptionInList",
    value: function findPrevOptionInList(list, index) {
      var i = index - 1;

      if (i < 0) {
        return null;
      }

      var option = list[i];
      if (this.isOptionDisabled(option)) return this.findPrevOption(i);else return option;
    }
  }, {
    key: "search",
    value: function search(event) {
      var _this4 = this;

      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }

      var _char = event.key;
      this.previousSearchChar = this.currentSearchChar;
      this.currentSearchChar = _char;
      if (this.previousSearchChar === this.currentSearchChar) this.searchValue = this.currentSearchChar;else this.searchValue = this.searchValue ? this.searchValue + _char : _char;

      if (this.searchValue) {
        var searchIndex = this.getSelectedOptionIndex();
        var newOption = this.props.optionGroupLabel ? this.searchOptionInGroup(searchIndex) : this.searchOption(++searchIndex);

        if (newOption) {
          this.selectItem({
            originalEvent: event,
            option: newOption
          });
          this.selectedOptionUpdated = true;
        }
      }

      this.searchTimeout = setTimeout(function () {
        _this4.searchValue = null;
      }, 250);
    }
  }, {
    key: "searchOption",
    value: function searchOption(index) {
      var option;

      if (this.searchValue) {
        var visibleOptions = this.getVisibleOptions();
        option = this.searchOptionInRange(index, visibleOptions.length);

        if (!option) {
          option = this.searchOptionInRange(0, index);
        }
      }

      return option;
    }
  }, {
    key: "searchOptionInRange",
    value: function searchOptionInRange(start, end) {
      var visibleOptions = this.getVisibleOptions();

      for (var i = start; i < end; i++) {
        var opt = visibleOptions[i];

        if (this.matchesSearchValue(opt)) {
          return opt;
        }
      }

      return null;
    }
  }, {
    key: "searchOptionInGroup",
    value: function searchOptionInGroup(index) {
      var searchIndex = index === -1 ? {
        group: 0,
        option: -1
      } : index;
      var visibleOptions = this.getVisibleOptions();

      for (var i = searchIndex.group; i < visibleOptions.length; i++) {
        var groupOptions = this.getOptionGroupChildren(visibleOptions[i]);

        for (var j = searchIndex.group === i ? searchIndex.option + 1 : 0; j < groupOptions.length; j++) {
          if (this.matchesSearchValue(groupOptions[j])) {
            return groupOptions[j];
          }
        }
      }

      for (var _i = 0; _i <= searchIndex.group; _i++) {
        var _groupOptions = this.getOptionGroupChildren(visibleOptions[_i]);

        for (var _j = 0; _j < (searchIndex.group === _i ? searchIndex.option : _groupOptions.length); _j++) {
          if (this.matchesSearchValue(_groupOptions[_j])) {
            return _groupOptions[_j];
          }
        }
      }

      return null;
    }
  }, {
    key: "matchesSearchValue",
    value: function matchesSearchValue(option) {
      var label = this.getOptionLabel(option).toLocaleLowerCase(this.props.filterLocale);
      return label.startsWith(this.searchValue.toLocaleLowerCase(this.props.filterLocale));
    }
  }, {
    key: "onEditableInputChange",
    value: function onEditableInputChange(event) {
      if (this.props.onChange) {
        this.props.onChange({
          originalEvent: event.originalEvent,
          value: event.target.value,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: event.target.value
          }
        });
      }
    }
  }, {
    key: "onEditableInputFocus",
    value: function onEditableInputFocus(event) {
      var _this5 = this;

      event.persist();
      this.setState({
        focused: true
      }, function () {
        _this5.hideOverlay();

        if (_this5.props.onFocus) {
          _this5.props.onFocus(event);
        }
      });
    }
  }, {
    key: "onOptionClick",
    value: function onOptionClick(event) {
      var option = event.option;

      if (!option.disabled) {
        this.selectItem(event);
        this.focusInput.focus();
      }

      this.hideOverlay();
    }
  }, {
    key: "onFilterInputChange",
    value: function onFilterInputChange(event) {
      var _this6 = this;

      var filter = event.target.value;
      this.setState({
        filter: filter
      }, function () {
        if (_this6.props.onFilter) {
          _this6.props.onFilter({
            originalEvent: event,
            filter: filter
          });
        }
      });
    }
  }, {
    key: "onFilterClearIconClick",
    value: function onFilterClearIconClick(callback) {
      this.resetFilter(callback);
    }
  }, {
    key: "resetFilter",
    value: function resetFilter(callback) {
      var _this7 = this;

      var filter = '';
      this.setState({
        filter: filter
      }, function () {
        _this7.props.onFilter && _this7.props.onFilter({
          filter: filter
        });
        callback && callback();
      });
    }
  }, {
    key: "clear",
    value: function clear(event) {
      if (this.props.onChange) {
        this.props.onChange({
          originalEvent: event,
          value: undefined,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: undefined
          }
        });
      }

      this.updateEditableLabel();
    }
  }, {
    key: "selectItem",
    value: function selectItem(event) {
      var currentSelectedOption = this.getSelectedOption();

      if (currentSelectedOption !== event.option) {
        this.updateEditableLabel(event.option);
        var optionValue = this.getOptionValue(event.option);

        if (this.props.onChange) {
          this.props.onChange({
            originalEvent: event.originalEvent,
            value: optionValue,
            stopPropagation: function stopPropagation() {},
            preventDefault: function preventDefault() {},
            target: {
              name: this.props.name,
              id: this.props.id,
              value: optionValue
            }
          });
        }
      }
    }
  }, {
    key: "getSelectedOption",
    value: function getSelectedOption() {
      var index = this.getSelectedOptionIndex();
      var visibleOptions = this.getVisibleOptions();
      return index !== -1 ? this.props.optionGroupLabel ? this.getOptionGroupChildren(visibleOptions[index.group])[index.option] : visibleOptions[index] : null;
    }
  }, {
    key: "getSelectedOptionIndex",
    value: function getSelectedOptionIndex() {
      var visibleOptions = this.getVisibleOptions();

      if (this.props.value != null && visibleOptions) {
        if (this.props.optionGroupLabel) {
          for (var i = 0; i < visibleOptions.length; i++) {
            var selectedOptionIndex = this.findOptionIndexInList(this.props.value, this.getOptionGroupChildren(visibleOptions[i]));

            if (selectedOptionIndex !== -1) {
              return {
                group: i,
                option: selectedOptionIndex
              };
            }
          }
        } else {
          return this.findOptionIndexInList(this.props.value, visibleOptions);
        }
      }

      return -1;
    }
  }, {
    key: "findOptionIndexInList",
    value: function findOptionIndexInList(value, list) {
      var key = this.equalityKey();

      for (var i = 0; i < list.length; i++) {
        if (ObjectUtils.equals(value, this.getOptionValue(list[i]), key)) {
          return i;
        }
      }

      return -1;
    }
  }, {
    key: "isSelected",
    value: function isSelected(option) {
      return ObjectUtils.equals(this.props.value, this.getOptionValue(option), this.equalityKey());
    }
  }, {
    key: "equalityKey",
    value: function equalityKey() {
      return this.props.optionValue ? null : this.props.dataKey;
    }
  }, {
    key: "showOverlay",
    value: function showOverlay() {
      this.setState({
        overlayVisible: true
      });
    }
  }, {
    key: "hideOverlay",
    value: function hideOverlay() {
      this.setState({
        overlayVisible: false
      });
    }
  }, {
    key: "onOverlayEnter",
    value: function onOverlayEnter(callback) {
      ZIndexUtils.set('overlay', this.overlayRef.current, PrimeReact.autoZIndex, PrimeReact.zIndex['overlay']);
      this.alignOverlay();
      callback && callback();
    }
  }, {
    key: "onOverlayEntered",
    value: function onOverlayEntered(callback) {
      callback && callback();
      this.bindDocumentClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.props.onShow && this.props.onShow();
    }
  }, {
    key: "onOverlayExit",
    value: function onOverlayExit() {
      this.unbindDocumentClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
    }
  }, {
    key: "onOverlayExited",
    value: function onOverlayExited() {
      if (this.props.filter && this.props.resetFilterOnHide) {
        this.resetFilter();
      }

      ZIndexUtils.clear(this.overlayRef.current);
      this.props.onHide && this.props.onHide();
    }
  }, {
    key: "alignOverlay",
    value: function alignOverlay() {
      DomHandler$1.alignOverlay(this.overlayRef.current, this.input.parentElement, this.props.appendTo || PrimeReact.appendTo);
    }
  }, {
    key: "scrollInView",
    value: function scrollInView() {
      var highlightItem = DomHandler$1.findSingle(this.overlayRef.current, 'li.p-highlight');

      if (highlightItem && highlightItem.scrollIntoView) {
        highlightItem.scrollIntoView({
          block: 'nearest',
          inline: 'start'
        });
      }
    }
  }, {
    key: "bindDocumentClickListener",
    value: function bindDocumentClickListener() {
      var _this8 = this;

      if (!this.documentClickListener) {
        this.documentClickListener = function (event) {
          if (_this8.state.overlayVisible && _this8.isOutsideClicked(event)) {
            _this8.hideOverlay();
          }
        };

        document.addEventListener('click', this.documentClickListener);
      }
    }
  }, {
    key: "unbindDocumentClickListener",
    value: function unbindDocumentClickListener() {
      if (this.documentClickListener) {
        document.removeEventListener('click', this.documentClickListener);
        this.documentClickListener = null;
      }
    }
  }, {
    key: "bindScrollListener",
    value: function bindScrollListener() {
      var _this9 = this;

      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.container, function () {
          if (_this9.state.overlayVisible) {
            _this9.hideOverlay();
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    }
  }, {
    key: "unbindScrollListener",
    value: function unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }
  }, {
    key: "bindResizeListener",
    value: function bindResizeListener() {
      var _this10 = this;

      if (!this.resizeListener) {
        this.resizeListener = function () {
          if (_this10.state.overlayVisible && !DomHandler$1.isTouchDevice()) {
            _this10.hideOverlay();
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    }
  }, {
    key: "unbindResizeListener",
    value: function unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    }
  }, {
    key: "isOutsideClicked",
    value: function isOutsideClicked(event) {
      return this.container && !(this.container.isSameNode(event.target) || this.isClearClicked(event) || this.container.contains(event.target) || this.overlayRef && this.overlayRef.current.contains(event.target));
    }
  }, {
    key: "isClearClicked",
    value: function isClearClicked(event) {
      return DomHandler$1.hasClass(event.target, 'p-dropdown-clear-icon') || DomHandler$1.hasClass(event.target, 'p-dropdown-filter-clear-icon');
    }
  }, {
    key: "updateEditableLabel",
    value: function updateEditableLabel(option) {
      if (this.input) {
        this.input.value = option ? this.getOptionLabel(option) : this.props.value || '';
      }
    }
  }, {
    key: "hasFilter",
    value: function hasFilter() {
      return this.state.filter && this.state.filter.trim().length > 0;
    }
  }, {
    key: "getOptionLabel",
    value: function getOptionLabel(option) {
      return this.props.optionLabel ? ObjectUtils.resolveFieldData(option, this.props.optionLabel) : option && option['label'] !== undefined ? option['label'] : option;
    }
  }, {
    key: "getOptionValue",
    value: function getOptionValue(option) {
      return this.props.optionValue ? ObjectUtils.resolveFieldData(option, this.props.optionValue) : option && option['value'] !== undefined ? option['value'] : option;
    }
  }, {
    key: "getOptionRenderKey",
    value: function getOptionRenderKey(option) {
      return this.props.dataKey ? ObjectUtils.resolveFieldData(option, this.props.dataKey) : this.getOptionLabel(option);
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled(option) {
      if (this.props.optionDisabled) {
        return ObjectUtils.isFunction(this.props.optionDisabled) ? this.props.optionDisabled(option) : ObjectUtils.resolveFieldData(option, this.props.optionDisabled);
      }

      return option && option['disabled'] !== undefined ? option['disabled'] : false;
    }
  }, {
    key: "getOptionGroupRenderKey",
    value: function getOptionGroupRenderKey(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.props.optionGroupLabel);
    }
  }, {
    key: "getOptionGroupLabel",
    value: function getOptionGroupLabel(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.props.optionGroupLabel);
    }
  }, {
    key: "getOptionGroupChildren",
    value: function getOptionGroupChildren(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.props.optionGroupChildren);
    }
  }, {
    key: "checkValidity",
    value: function checkValidity() {
      if (this.inputRef.current) {
        return this.inputRef.current.checkValidity();
      }

      return false;
    }
  }, {
    key: "isLazy",
    value: function isLazy() {
      return this.props.virtualScrollerOptions && this.props.virtualScrollerOptions.lazy;
    }
  }, {
    key: "getVisibleOptions",
    value: function getVisibleOptions() {
      if (this.hasFilter() && !this.isLazy()) {
        var filterValue = this.state.filter.trim().toLocaleLowerCase(this.props.filterLocale);
        var searchFields = this.props.filterBy ? this.props.filterBy.split(',') : [this.props.optionLabel || 'label'];

        if (this.props.optionGroupLabel) {
          var filteredGroups = [];

          var _iterator = _createForOfIteratorHelper$a(this.props.options),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var optgroup = _step.value;
              var filteredSubOptions = FilterService.filter(this.getOptionGroupChildren(optgroup), searchFields, filterValue, this.props.filterMatchMode, this.props.filterLocale);

              if (filteredSubOptions && filteredSubOptions.length) {
                filteredGroups.push(_objectSpread$i(_objectSpread$i({}, optgroup), {
                  items: filteredSubOptions
                }));
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return filteredGroups;
        } else {
          return FilterService.filter(this.props.options, searchFields, filterValue, this.props.filterMatchMode, this.props.filterLocale);
        }
      } else {
        return this.props.options;
      }
    }
  }, {
    key: "updateInputField",
    value: function updateInputField() {
      if (this.props.editable && this.input) {
        var selectedOption = this.getSelectedOption();
        var label = selectedOption ? this.getOptionLabel(selectedOption) : null;
        var value = label || this.props.value || '';
        this.input.value = value;
      }
    }
  }, {
    key: "updateInputRef",
    value: function updateInputRef() {
      var ref = this.props.inputRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.inputRef.current);
        } else {
          ref.current = this.inputRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateInputRef();

      if (this.props.autoFocus && this.focusInput) {
        this.focusInput.focus();
      }

      if (this.props.tooltip) {
        this.renderTooltip();
      }

      this.updateInputField();

      if (this.inputRef.current) {
        this.inputRef.current.selectedIndex = 1;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindDocumentClickListener();
      this.unbindResizeListener();

      if (this.scrollHandler) {
        this.scrollHandler.destroy();
        this.scrollHandler = null;
      }

      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }

      if (this.hideTimeout) {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = null;
      }

      ZIndexUtils.clear(this.overlayRef.current);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.state.overlayVisible) {
        if (this.props.filter) {
          this.alignOverlay();
        }

        if (prevProps.value !== this.props.value) {
          this.scrollInView();
        }
      }

      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$i({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }

      if (this.state.filter && (!this.props.options || this.props.options.length === 0)) {
        this.setState({
          filter: ''
        });
      }

      this.updateInputField();

      if (this.inputRef.current) {
        this.inputRef.current.selectedIndex = 1;
      }
    }
  }, {
    key: "renderHiddenSelect",
    value: function renderHiddenSelect(selectedOption) {
      var placeHolderOption = /*#__PURE__*/React.createElement("option", {
        value: ""
      }, this.props.placeholder);
      var option = selectedOption ? /*#__PURE__*/React.createElement("option", {
        value: selectedOption.value
      }, this.getOptionLabel(selectedOption)) : null;
      return /*#__PURE__*/React.createElement("div", {
        className: "p-hidden-accessible p-dropdown-hidden-select"
      }, /*#__PURE__*/React.createElement("select", {
        ref: this.inputRef,
        required: this.props.required,
        name: this.props.name,
        tabIndex: -1,
        "aria-hidden": "true"
      }, placeHolderOption, option));
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.container,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "renderKeyboardHelper",
    value: function renderKeyboardHelper() {
      var _this11 = this;

      return /*#__PURE__*/React.createElement("div", {
        className: "p-hidden-accessible"
      }, /*#__PURE__*/React.createElement("input", {
        ref: function ref(el) {
          return _this11.focusInput = el;
        },
        id: this.props.inputId,
        type: "text",
        readOnly: true,
        "aria-haspopup": "listbox",
        onFocus: this.onInputFocus,
        onBlur: this.onInputBlur,
        onKeyDown: this.onInputKeyDown,
        disabled: this.props.disabled,
        tabIndex: this.props.tabIndex,
        "aria-label": this.props.ariaLabel,
        "aria-labelledby": this.props.ariaLabelledBy
      }));
    }
  }, {
    key: "renderLabel",
    value: function renderLabel(selectedOption) {
      var _this12 = this;

      var label = ObjectUtils.isNotEmpty(selectedOption) ? this.getOptionLabel(selectedOption) : null;

      if (this.props.editable) {
        var value = label || this.props.value || '';
        return /*#__PURE__*/React.createElement("input", {
          ref: function ref(el) {
            return _this12.input = el;
          },
          type: "text",
          defaultValue: value,
          className: "p-dropdown-label p-inputtext",
          disabled: this.props.disabled,
          placeholder: this.props.placeholder,
          maxLength: this.props.maxLength,
          onInput: this.onEditableInputChange,
          onFocus: this.onEditableInputFocus,
          onBlur: this.onInputBlur,
          "aria-label": this.props.ariaLabel,
          "aria-labelledby": this.props.ariaLabelledBy,
          "aria-haspopup": "listbox"
        });
      } else {
        var className = classNames('p-dropdown-label p-inputtext', {
          'p-placeholder': label === null && this.props.placeholder,
          'p-dropdown-label-empty': label === null && !this.props.placeholder
        });
        var content = this.props.valueTemplate ? ObjectUtils.getJSXElement(this.props.valueTemplate, selectedOption, this.props) : label || this.props.placeholder || 'empty';
        return /*#__PURE__*/React.createElement("span", {
          ref: function ref(el) {
            return _this12.input = el;
          },
          className: className
        }, content);
      }
    }
  }, {
    key: "renderClearIcon",
    value: function renderClearIcon() {
      if (this.props.value != null && this.props.showClear && !this.props.disabled) {
        return /*#__PURE__*/React.createElement("i", {
          className: "p-dropdown-clear-icon pi pi-times",
          onClick: this.clear
        });
      }

      return null;
    }
  }, {
    key: "renderDropdownIcon",
    value: function renderDropdownIcon() {
      var _this13 = this;

      var iconClassName = classNames('p-dropdown-trigger-icon p-clickable', this.props.dropdownIcon);
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this13.trigger = el;
        },
        className: "p-dropdown-trigger",
        role: "button",
        "aria-haspopup": "listbox",
        "aria-expanded": this.state.overlayVisible
      }, /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this14 = this;

      var className = classNames('p-dropdown p-component p-inputwrapper', this.props.className, {
        'p-disabled': this.props.disabled,
        'p-focus': this.state.focused,
        'p-dropdown-clearable': this.props.showClear && !this.props.disabled,
        'p-inputwrapper-filled': this.props.value,
        'p-inputwrapper-focus': this.state.focused || this.state.overlayVisible
      });
      var visibleOptions = this.getVisibleOptions();
      var selectedOption = this.getSelectedOption();
      var appendTo = this.props.appendTo || PrimeReact.appendTo;
      var hiddenSelect = this.renderHiddenSelect(selectedOption);
      var keyboardHelper = this.renderKeyboardHelper();
      var labelElement = this.renderLabel(selectedOption);
      var dropdownIcon = this.renderDropdownIcon();
      var clearIcon = this.renderClearIcon();
      return /*#__PURE__*/React.createElement("div", {
        id: this.props.id,
        ref: function ref(el) {
          return _this14.container = el;
        },
        className: className,
        style: this.props.style,
        onClick: this.onClick,
        onMouseDown: this.props.onMouseDown,
        onContextMenu: this.props.onContextMenu
      }, keyboardHelper, hiddenSelect, labelElement, clearIcon, dropdownIcon, /*#__PURE__*/React.createElement(DropdownPanel, _extends$9({
        ref: this.overlayRef,
        visibleOptions: visibleOptions
      }, this.props, {
        appendTo: appendTo,
        onClick: this.onPanelClick,
        onOptionClick: this.onOptionClick,
        filterValue: this.state.filter,
        hasFilter: this.hasFilter,
        onFilterClearIconClick: this.onFilterClearIconClick,
        onFilterInputKeyDown: this.onFilterInputKeyDown,
        onFilterInputChange: this.onFilterInputChange,
        getOptionLabel: this.getOptionLabel,
        getOptionRenderKey: this.getOptionRenderKey,
        isOptionDisabled: this.isOptionDisabled,
        getOptionGroupChildren: this.getOptionGroupChildren,
        getOptionGroupLabel: this.getOptionGroupLabel,
        getOptionGroupRenderKey: this.getOptionGroupRenderKey,
        isSelected: this.isSelected,
        getSelectedOptionIndex: this.getSelectedOptionIndex,
        "in": this.state.overlayVisible,
        onEnter: this.onOverlayEnter,
        onEntered: this.onOverlayEntered,
        onExit: this.onOverlayExit,
        onExited: this.onOverlayExited
      })));
    }
  }]);

  return Dropdown;
}(Component);

_defineProperty$v(Dropdown$1, "defaultProps", {
  id: null,
  inputRef: null,
  name: null,
  value: null,
  options: null,
  optionLabel: null,
  optionValue: null,
  optionDisabled: null,
  optionGroupLabel: null,
  optionGroupChildren: null,
  optionGroupTemplate: null,
  valueTemplate: null,
  itemTemplate: null,
  style: null,
  className: null,
  virtualScrollerOptions: null,
  scrollHeight: '200px',
  filter: false,
  filterBy: null,
  filterMatchMode: 'contains',
  filterPlaceholder: null,
  filterLocale: undefined,
  emptyMessage: null,
  emptyFilterMessage: null,
  editable: false,
  placeholder: null,
  required: false,
  disabled: false,
  appendTo: null,
  tabIndex: null,
  autoFocus: false,
  filterInputAutoFocus: true,
  resetFilterOnHide: false,
  showFilterClear: false,
  panelClassName: null,
  panelStyle: null,
  dataKey: null,
  inputId: null,
  showClear: false,
  maxLength: null,
  tooltip: null,
  tooltipOptions: null,
  ariaLabel: null,
  ariaLabelledBy: null,
  transitionOptions: null,
  dropdownIcon: 'pi pi-chevron-down',
  showOnFocus: false,
  onChange: null,
  onFocus: null,
  onBlur: null,
  onMouseDown: null,
  onContextMenu: null,
  onShow: null,
  onHide: null,
  onFilter: null
});

function _classCallCheck$u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$u(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$u(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$u(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$u(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty$u(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var KeyFilter = /*#__PURE__*/function () {
  function KeyFilter() {
    _classCallCheck$u(this, KeyFilter);
  }

  _createClass$u(KeyFilter, null, [{
    key: "isNavKeyPress",
    value:
    /* eslint-disable */

    /* eslint-enable */
    function isNavKeyPress(e) {
      var k = e.keyCode;
      k = DomHandler$1.getBrowser().safari ? KeyFilter.SAFARI_KEYS[k] || k : k;
      return k >= 33 && k <= 40 || k === KeyFilter.KEYS.RETURN || k === KeyFilter.KEYS.TAB || k === KeyFilter.KEYS.ESC;
    }
  }, {
    key: "isSpecialKey",
    value: function isSpecialKey(e) {
      var k = e.keyCode;
      return k === 9 || k === 13 || k === 27 || k === 16 || k === 17 || k >= 18 && k <= 20 || DomHandler$1.getBrowser().opera && !e.shiftKey && (k === 8 || k >= 33 && k <= 35 || k >= 36 && k <= 39 || k >= 44 && k <= 45);
    }
  }, {
    key: "getKey",
    value: function getKey(e) {
      var k = e.keyCode || e.charCode;
      return DomHandler$1.getBrowser().safari ? KeyFilter.SAFARI_KEYS[k] || k : k;
    }
  }, {
    key: "getCharCode",
    value: function getCharCode(e) {
      return e.charCode || e.keyCode || e.which;
    }
  }, {
    key: "onKeyPress",
    value: function onKeyPress(e, keyfilter, validateOnly) {
      if (validateOnly) {
        return;
      }

      var regex = KeyFilter.DEFAULT_MASKS[keyfilter] ? KeyFilter.DEFAULT_MASKS[keyfilter] : keyfilter;
      var browser = DomHandler$1.getBrowser();

      if (e.ctrlKey || e.altKey) {
        return;
      }

      var k = this.getKey(e);

      if (browser.mozilla && (this.isNavKeyPress(e) || k === KeyFilter.KEYS.BACKSPACE || k === KeyFilter.KEYS.DELETE && e.charCode === 0)) {
        return;
      }

      var c = this.getCharCode(e);
      var cc = String.fromCharCode(c);

      if (browser.mozilla && (this.isSpecialKey(e) || !cc)) {
        return;
      }

      if (!regex.test(cc)) {
        e.preventDefault();
      }
    }
  }, {
    key: "validate",
    value: function validate(e, keyfilter) {
      var value = e.target.value,
          validatePattern = true;

      if (value && !keyfilter.test(value)) {
        validatePattern = false;
      }

      return validatePattern;
    }
  }]);

  return KeyFilter;
}();

_defineProperty$u(KeyFilter, "DEFAULT_MASKS", {
  pint: /[\d]/,
  "int": /[\d\-]/,
  pnum: /[\d\.]/,
  money: /[\d\.\s,]/,
  num: /[\d\-\.]/,
  hex: /[0-9a-f]/i,
  email: /[a-z0-9_\.\-@]/i,
  alpha: /[a-z_]/i,
  alphanum: /[a-z0-9_]/i
});

_defineProperty$u(KeyFilter, "KEYS", {
  TAB: 9,
  RETURN: 13,
  ESC: 27,
  BACKSPACE: 8,
  DELETE: 46
});

_defineProperty$u(KeyFilter, "SAFARI_KEYS", {
  63234: 37,
  // left
  63235: 39,
  // right
  63232: 38,
  // up
  63233: 40,
  // down
  63276: 33,
  // page up
  63277: 34,
  // page down
  63272: 46,
  // delete
  63273: 36,
  // home
  63275: 35 // end

});

function _extends$8() {
  _extends$8 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$8.apply(this, arguments);
}

function _classCallCheck$t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$t(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$t(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$t(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$t(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$s(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$s(o, p) {
  _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$s(o, p);
}

function _inherits$t(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$s(subClass, superClass);
}

function _typeof$t(obj) {
  "@babel/helpers - typeof";

  return _typeof$t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$t(obj);
}

function _possibleConstructorReturn$t(self, call) {
  if (call && (_typeof$t(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$s(self);
}

function _getPrototypeOf$t(o) {
  _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$t(o);
}

function _defineProperty$t(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$h(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$h(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$h(Object(source), !0).forEach(function (key) {
      _defineProperty$t(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$z(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$z();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$t(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$t(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$t(this, result);
  };
}

function _isNativeReflectConstruct$z() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var InputTextComponent = /*#__PURE__*/function (_Component) {
  _inherits$t(InputTextComponent, _Component);

  var _super = _createSuper$z(InputTextComponent);

  function InputTextComponent(props) {
    var _this;

    _classCallCheck$t(this, InputTextComponent);

    _this = _super.call(this, props);
    _this.onInput = _this.onInput.bind(_assertThisInitialized$s(_this));
    _this.onKeyPress = _this.onKeyPress.bind(_assertThisInitialized$s(_this));
    _this.elementRef = /*#__PURE__*/createRef(_this.props.forwardRef);
    return _this;
  }

  _createClass$t(InputTextComponent, [{
    key: "isFilled",
    value: function isFilled() {
      return this.props.value != null && this.props.value.toString().length > 0 || this.props.defaultValue != null && this.props.defaultValue.toString().length > 0 || this.elementRef && this.elementRef.current && this.elementRef.current.value != null && this.elementRef.current.value.toString().length > 0;
    }
  }, {
    key: "onKeyPress",
    value: function onKeyPress(event) {
      if (this.props.onKeyPress) {
        this.props.onKeyPress(event);
      }

      if (this.props.keyfilter) {
        KeyFilter.onKeyPress(event, this.props.keyfilter, this.props.validateOnly);
      }
    }
  }, {
    key: "onInput",
    value: function onInput(event) {
      var validatePattern = true;

      if (this.props.keyfilter && this.props.validateOnly) {
        validatePattern = KeyFilter.validate(event, this.props.keyfilter);
      }

      if (this.props.onInput) {
        this.props.onInput(event, validatePattern);
      }

      if (!this.props.onChange) {
        if (event.target.value.length > 0) DomHandler$1.addClass(event.target, 'p-filled');else DomHandler$1.removeClass(event.target, 'p-filled');
      }
    }
  }, {
    key: "updateForwardRef",
    value: function updateForwardRef() {
      var ref = this.props.forwardRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.elementRef.current);
        } else {
          ref.current = this.elementRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateForwardRef();

      if (this.props.tooltip) {
        this.renderTooltip();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$h({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.elementRef.current,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-inputtext p-component', {
        'p-disabled': this.props.disabled,
        'p-filled': this.isFilled()
      }, this.props.className);
      var inputProps = ObjectUtils.findDiffKeys(this.props, InputTextComponent.defaultProps);
      return /*#__PURE__*/React.createElement("input", _extends$8({
        ref: this.elementRef
      }, inputProps, {
        className: className,
        onInput: this.onInput,
        onKeyPress: this.onKeyPress
      }));
    }
  }]);

  return InputTextComponent;
}(Component);

_defineProperty$t(InputTextComponent, "defaultProps", {
  keyfilter: null,
  validateOnly: false,
  tooltip: null,
  tooltipOptions: null,
  onInput: null,
  onKeyPress: null,
  forwardRef: null
});

var InputText$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(InputTextComponent, _extends$8({
    forwardRef: ref
  }, props));
});

function _arrayLikeToArray$h(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$b(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$h(arr);
}

function _iterableToArray$b(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$h(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$h(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$h(o, minLen);
}

function _nonIterableSpread$b() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$b(arr) {
  return _arrayWithoutHoles$b(arr) || _iterableToArray$b(arr) || _unsupportedIterableToArray$h(arr) || _nonIterableSpread$b();
}

function _classCallCheck$s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$s(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$s(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$s(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$s(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$r(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$r(o, p) {
  _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$r(o, p);
}

function _inherits$s(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$r(subClass, superClass);
}

function _typeof$s(obj) {
  "@babel/helpers - typeof";

  return _typeof$s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$s(obj);
}

function _possibleConstructorReturn$s(self, call) {
  if (call && (_typeof$s(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$r(self);
}

function _getPrototypeOf$s(o) {
  _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$s(o);
}

function _defineProperty$s(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$g(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$g(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$g(Object(source), !0).forEach(function (key) {
      _defineProperty$s(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$g(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$y(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$y();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$s(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$s(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$s(this, result);
  };
}

function _isNativeReflectConstruct$y() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var InputNumber$1 = /*#__PURE__*/function (_Component) {
  _inherits$s(InputNumber, _Component);

  var _super = _createSuper$y(InputNumber);

  function InputNumber(props) {
    var _this;

    _classCallCheck$s(this, InputNumber);

    _this = _super.call(this, props);
    _this.state = {
      focused: false
    };

    _this.constructParser();

    _this.onInput = _this.onInput.bind(_assertThisInitialized$r(_this));
    _this.onInputKeyDown = _this.onInputKeyDown.bind(_assertThisInitialized$r(_this));
    _this.onInputKeyPress = _this.onInputKeyPress.bind(_assertThisInitialized$r(_this));
    _this.onInputClick = _this.onInputClick.bind(_assertThisInitialized$r(_this));
    _this.onInputBlur = _this.onInputBlur.bind(_assertThisInitialized$r(_this));
    _this.onInputFocus = _this.onInputFocus.bind(_assertThisInitialized$r(_this));
    _this.onPaste = _this.onPaste.bind(_assertThisInitialized$r(_this));
    _this.onUpButtonMouseLeave = _this.onUpButtonMouseLeave.bind(_assertThisInitialized$r(_this));
    _this.onUpButtonMouseDown = _this.onUpButtonMouseDown.bind(_assertThisInitialized$r(_this));
    _this.onUpButtonMouseUp = _this.onUpButtonMouseUp.bind(_assertThisInitialized$r(_this));
    _this.onUpButtonKeyDown = _this.onUpButtonKeyDown.bind(_assertThisInitialized$r(_this));
    _this.onUpButtonKeyUp = _this.onUpButtonKeyUp.bind(_assertThisInitialized$r(_this));
    _this.onDownButtonMouseLeave = _this.onDownButtonMouseLeave.bind(_assertThisInitialized$r(_this));
    _this.onDownButtonMouseDown = _this.onDownButtonMouseDown.bind(_assertThisInitialized$r(_this));
    _this.onDownButtonMouseUp = _this.onDownButtonMouseUp.bind(_assertThisInitialized$r(_this));
    _this.onDownButtonKeyDown = _this.onDownButtonKeyDown.bind(_assertThisInitialized$r(_this));
    _this.onDownButtonKeyUp = _this.onDownButtonKeyUp.bind(_assertThisInitialized$r(_this));
    _this.inputRef = /*#__PURE__*/createRef(_this.props.inputRef);
    return _this;
  }

  _createClass$s(InputNumber, [{
    key: "getOptions",
    value: function getOptions() {
      return {
        localeMatcher: this.props.localeMatcher,
        style: this.props.mode,
        currency: this.props.currency,
        currencyDisplay: this.props.currencyDisplay,
        useGrouping: this.props.useGrouping,
        minimumFractionDigits: this.props.minFractionDigits,
        maximumFractionDigits: this.props.maxFractionDigits
      };
    }
  }, {
    key: "constructParser",
    value: function constructParser() {
      this.numberFormat = new Intl.NumberFormat(this.props.locale, this.getOptions());

      var numerals = _toConsumableArray$b(new Intl.NumberFormat(this.props.locale, {
        useGrouping: false
      }).format(9876543210)).reverse();

      var index = new Map(numerals.map(function (d, i) {
        return [d, i];
      }));
      this._numeral = new RegExp("[".concat(numerals.join(''), "]"), 'g');
      this._group = this.getGroupingExpression();
      this._minusSign = this.getMinusSignExpression();
      this._currency = this.getCurrencyExpression();
      this._decimal = this.getDecimalExpression();
      this._suffix = this.getSuffixExpression();
      this._prefix = this.getPrefixExpression();

      this._index = function (d) {
        return index.get(d);
      };
    }
  }, {
    key: "escapeRegExp",
    value: function escapeRegExp(text) {
      return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    }
  }, {
    key: "getDecimalExpression",
    value: function getDecimalExpression() {
      var formatter = new Intl.NumberFormat(this.props.locale, _objectSpread$g(_objectSpread$g({}, this.getOptions()), {}, {
        useGrouping: false
      }));
      return new RegExp("[".concat(formatter.format(1.1).replace(this._currency, '').trim().replace(this._numeral, ''), "]"), 'g');
    }
  }, {
    key: "getGroupingExpression",
    value: function getGroupingExpression() {
      var formatter = new Intl.NumberFormat(this.props.locale, {
        useGrouping: true
      });
      this.groupChar = formatter.format(1000000).trim().replace(this._numeral, '').charAt(0);
      return new RegExp("[".concat(this.groupChar, "]"), 'g');
    }
  }, {
    key: "getMinusSignExpression",
    value: function getMinusSignExpression() {
      var formatter = new Intl.NumberFormat(this.props.locale, {
        useGrouping: false
      });
      return new RegExp("[".concat(formatter.format(-1).trim().replace(this._numeral, ''), "]"), 'g');
    }
  }, {
    key: "getCurrencyExpression",
    value: function getCurrencyExpression() {
      if (this.props.currency) {
        var formatter = new Intl.NumberFormat(this.props.locale, {
          style: 'currency',
          currency: this.props.currency,
          currencyDisplay: this.props.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        });
        return new RegExp("[".concat(formatter.format(1).replace(/\s/g, '').replace(this._numeral, '').replace(this._group, ''), "]"), 'g');
      }

      return new RegExp("[]", 'g');
    }
  }, {
    key: "getPrefixExpression",
    value: function getPrefixExpression() {
      if (this.props.prefix) {
        this.prefixChar = this.props.prefix;
      } else {
        var formatter = new Intl.NumberFormat(this.props.locale, {
          style: this.props.mode,
          currency: this.props.currency,
          currencyDisplay: this.props.currencyDisplay
        });
        this.prefixChar = formatter.format(1).split('1')[0];
      }

      return new RegExp("".concat(this.escapeRegExp(this.prefixChar || '')), 'g');
    }
  }, {
    key: "getSuffixExpression",
    value: function getSuffixExpression() {
      if (this.props.suffix) {
        this.suffixChar = this.props.suffix;
      } else {
        var formatter = new Intl.NumberFormat(this.props.locale, {
          style: this.props.mode,
          currency: this.props.currency,
          currencyDisplay: this.props.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        });
        this.suffixChar = formatter.format(1).split('1')[1];
      }

      return new RegExp("".concat(this.escapeRegExp(this.suffixChar || '')), 'g');
    }
  }, {
    key: "formatValue",
    value: function formatValue(value) {
      if (value != null) {
        if (value === '-') {
          // Minus sign
          return value;
        }

        if (this.props.format) {
          var formatter = new Intl.NumberFormat(this.props.locale, this.getOptions());
          var formattedValue = formatter.format(value);

          if (this.props.prefix) {
            formattedValue = this.props.prefix + formattedValue;
          }

          if (this.props.suffix) {
            formattedValue = formattedValue + this.props.suffix;
          }

          return formattedValue;
        }

        return value.toString();
      }

      return '';
    }
  }, {
    key: "parseValue",
    value: function parseValue(text) {
      var filteredText = text.replace(this._suffix, '').replace(this._prefix, '').trim().replace(/\s/g, '').replace(this._currency, '').replace(this._group, '').replace(this._minusSign, '-').replace(this._decimal, '.').replace(this._numeral, this._index);

      if (filteredText) {
        if (filteredText === '-') // Minus sign
          return filteredText;
        var parsedValue = +filteredText;
        return isNaN(parsedValue) ? null : parsedValue;
      }

      return null;
    }
  }, {
    key: "repeat",
    value: function repeat(event, interval, dir) {
      var _this2 = this;

      var i = interval || 500;
      this.clearTimer();
      this.timer = setTimeout(function () {
        _this2.repeat(event, 40, dir);
      }, i);
      this.spin(event, dir);
    }
  }, {
    key: "spin",
    value: function spin(event, dir) {
      if (this.inputRef && this.inputRef.current) {
        var step = this.props.step * dir;
        var currentValue = this.parseValue(this.inputRef.current.value) || 0;
        var newValue = this.validateValue(currentValue + step);
        this.updateInput(newValue, null, 'spin');
        this.updateModel(event, newValue);
        this.handleOnChange(event, currentValue, newValue);
      }
    }
  }, {
    key: "onUpButtonMouseDown",
    value: function onUpButtonMouseDown(event) {
      if (!this.props.disabled && !this.props.readOnly) {
        this.inputRef.current.focus();
        this.repeat(event, null, 1);
        event.preventDefault();
      }
    }
  }, {
    key: "onUpButtonMouseUp",
    value: function onUpButtonMouseUp() {
      if (!this.props.disabled && !this.props.readOnly) {
        this.clearTimer();
      }
    }
  }, {
    key: "onUpButtonMouseLeave",
    value: function onUpButtonMouseLeave() {
      if (!this.props.disabled && !this.props.readOnly) {
        this.clearTimer();
      }
    }
  }, {
    key: "onUpButtonKeyUp",
    value: function onUpButtonKeyUp() {
      if (!this.props.disabled && !this.props.readOnly) {
        this.clearTimer();
      }
    }
  }, {
    key: "onUpButtonKeyDown",
    value: function onUpButtonKeyDown(event) {
      if (!this.props.disabled && !this.props.readOnly && (event.keyCode === 32 || event.keyCode === 13)) {
        this.repeat(event, null, 1);
      }
    }
  }, {
    key: "onDownButtonMouseDown",
    value: function onDownButtonMouseDown(event) {
      if (!this.props.disabled && !this.props.readOnly) {
        this.inputRef.current.focus();
        this.repeat(event, null, -1);
        event.preventDefault();
      }
    }
  }, {
    key: "onDownButtonMouseUp",
    value: function onDownButtonMouseUp() {
      if (!this.props.disabled && !this.props.readOnly) {
        this.clearTimer();
      }
    }
  }, {
    key: "onDownButtonMouseLeave",
    value: function onDownButtonMouseLeave() {
      if (!this.props.disabled && !this.props.readOnly) {
        this.clearTimer();
      }
    }
  }, {
    key: "onDownButtonKeyUp",
    value: function onDownButtonKeyUp() {
      if (!this.props.disabled && !this.props.readOnly) {
        this.clearTimer();
      }
    }
  }, {
    key: "onDownButtonKeyDown",
    value: function onDownButtonKeyDown(event) {
      if (!this.props.disabled && !this.props.readOnly && (event.keyCode === 32 || event.keyCode === 13)) {
        this.repeat(event, null, -1);
      }
    }
  }, {
    key: "onInput",
    value: function onInput(event) {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }

      if (this.isSpecialChar) {
        event.target.value = this.lastValue;
      }

      this.isSpecialChar = false;
    }
  }, {
    key: "onInputKeyDown",
    value: function onInputKeyDown(event) {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }

      this.lastValue = event.target.value;

      if (event.shiftKey || event.altKey) {
        this.isSpecialChar = true;
        return;
      }

      var selectionStart = event.target.selectionStart;
      var selectionEnd = event.target.selectionEnd;
      var inputValue = event.target.value;
      var newValueStr = null;

      if (event.altKey) {
        event.preventDefault();
      }

      switch (event.which) {
        //up
        case 38:
          this.spin(event, 1);
          event.preventDefault();
          break;
        //down

        case 40:
          this.spin(event, -1);
          event.preventDefault();
          break;
        //left

        case 37:
          if (!this.isNumeralChar(inputValue.charAt(selectionStart - 1))) {
            event.preventDefault();
          }

          break;
        //right

        case 39:
          if (!this.isNumeralChar(inputValue.charAt(selectionStart))) {
            event.preventDefault();
          }

          break;
        //enter

        case 13:
          newValueStr = this.validateValue(this.parseValue(inputValue));
          this.inputRef.current.value = this.formatValue(newValueStr);
          this.inputRef.current.setAttribute('aria-valuenow', newValueStr);
          this.updateModel(event, newValueStr);
          break;
        //backspace

        case 8:
          event.preventDefault();

          if (selectionStart === selectionEnd) {
            var deleteChar = inputValue.charAt(selectionStart - 1);

            var _this$getDecimalCharI = this.getDecimalCharIndexes(inputValue),
                decimalCharIndex = _this$getDecimalCharI.decimalCharIndex,
                decimalCharIndexWithoutPrefix = _this$getDecimalCharI.decimalCharIndexWithoutPrefix;

            if (this.isNumeralChar(deleteChar)) {
              var decimalLength = this.getDecimalLength(inputValue);

              if (this._group.test(deleteChar)) {
                this._group.lastIndex = 0;
                newValueStr = inputValue.slice(0, selectionStart - 2) + inputValue.slice(selectionStart - 1);
              } else if (this._decimal.test(deleteChar)) {
                this._decimal.lastIndex = 0;

                if (decimalLength) {
                  this.inputRef.current.setSelectionRange(selectionStart - 1, selectionStart - 1);
                } else {
                  newValueStr = inputValue.slice(0, selectionStart - 1) + inputValue.slice(selectionStart);
                }
              } else if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
                var insertedText = this.isDecimalMode() && (this.props.minFractionDigits || 0) < decimalLength ? '' : '0';
                newValueStr = inputValue.slice(0, selectionStart - 1) + insertedText + inputValue.slice(selectionStart);
              } else if (decimalCharIndexWithoutPrefix === 1) {
                newValueStr = inputValue.slice(0, selectionStart - 1) + '0' + inputValue.slice(selectionStart);
                newValueStr = this.parseValue(newValueStr) > 0 ? newValueStr : '';
              } else {
                newValueStr = inputValue.slice(0, selectionStart - 1) + inputValue.slice(selectionStart);
              }
            }

            this.updateValue(event, newValueStr, null, 'delete-single');
          } else {
            newValueStr = this.deleteRange(inputValue, selectionStart, selectionEnd);
            this.updateValue(event, newValueStr, null, 'delete-range');
          }

          break;
        // del

        case 46:
          event.preventDefault();

          if (selectionStart === selectionEnd) {
            var _deleteChar = inputValue.charAt(selectionStart);

            var _this$getDecimalCharI2 = this.getDecimalCharIndexes(inputValue),
                _decimalCharIndex = _this$getDecimalCharI2.decimalCharIndex,
                _decimalCharIndexWithoutPrefix = _this$getDecimalCharI2.decimalCharIndexWithoutPrefix;

            if (this.isNumeralChar(_deleteChar)) {
              var _decimalLength = this.getDecimalLength(inputValue);

              if (this._group.test(_deleteChar)) {
                this._group.lastIndex = 0;
                newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 2);
              } else if (this._decimal.test(_deleteChar)) {
                this._decimal.lastIndex = 0;

                if (_decimalLength) {
                  this.$refs.input.$el.setSelectionRange(selectionStart + 1, selectionStart + 1);
                } else {
                  newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 1);
                }
              } else if (_decimalCharIndex > 0 && selectionStart > _decimalCharIndex) {
                var _insertedText = this.isDecimalMode() && (this.props.minFractionDigits || 0) < _decimalLength ? '' : '0';

                newValueStr = inputValue.slice(0, selectionStart) + _insertedText + inputValue.slice(selectionStart + 1);
              } else if (_decimalCharIndexWithoutPrefix === 1) {
                newValueStr = inputValue.slice(0, selectionStart) + '0' + inputValue.slice(selectionStart + 1);
                newValueStr = this.parseValue(newValueStr) > 0 ? newValueStr : '';
              } else {
                newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 1);
              }
            }

            this.updateValue(event, newValueStr, null, 'delete-back-single');
          } else {
            newValueStr = this.deleteRange(inputValue, selectionStart, selectionEnd);
            this.updateValue(event, newValueStr, null, 'delete-range');
          }

          break;
      }

      if (this.props.onKeyDown) {
        this.props.onKeyDown(event);
      }
    }
  }, {
    key: "onInputKeyPress",
    value: function onInputKeyPress(event) {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }

      var code = event.which || event.keyCode;

      if (code !== 13) {
        // to submit a form
        event.preventDefault();
      }

      var _char = String.fromCharCode(code);

      var isDecimalSign = this.isDecimalSign(_char);
      var isMinusSign = this.isMinusSign(_char);

      if (48 <= code && code <= 57 || isMinusSign || isDecimalSign) {
        this.insert(event, _char, {
          isDecimalSign: isDecimalSign,
          isMinusSign: isMinusSign
        });
      }
    }
  }, {
    key: "onPaste",
    value: function onPaste(event) {
      event.preventDefault();

      if (this.props.disabled || this.props.readOnly) {
        return;
      }

      var data = (event.clipboardData || window['clipboardData']).getData('Text');

      if (data) {
        var filteredData = this.parseValue(data);

        if (filteredData != null) {
          this.insert(event, filteredData.toString());
        }
      }
    }
  }, {
    key: "allowMinusSign",
    value: function allowMinusSign() {
      return this.props.min === null || this.props.min < 0;
    }
  }, {
    key: "isMinusSign",
    value: function isMinusSign(_char2) {
      if (this._minusSign.test(_char2) || _char2 === '-') {
        this._minusSign.lastIndex = 0;
        return true;
      }

      return false;
    }
  }, {
    key: "isDecimalSign",
    value: function isDecimalSign(_char3) {
      if (this._decimal.test(_char3)) {
        this._decimal.lastIndex = 0;
        return true;
      }

      return false;
    }
  }, {
    key: "isDecimalMode",
    value: function isDecimalMode() {
      return this.props.mode === 'decimal';
    }
  }, {
    key: "getDecimalCharIndexes",
    value: function getDecimalCharIndexes(val) {
      var decimalCharIndex = val.search(this._decimal);
      this._decimal.lastIndex = 0;
      var filteredVal = val.replace(this._prefix, '').trim().replace(/\s/g, '').replace(this._currency, '');
      var decimalCharIndexWithoutPrefix = filteredVal.search(this._decimal);
      this._decimal.lastIndex = 0;
      return {
        decimalCharIndex: decimalCharIndex,
        decimalCharIndexWithoutPrefix: decimalCharIndexWithoutPrefix
      };
    }
  }, {
    key: "getCharIndexes",
    value: function getCharIndexes(val) {
      var decimalCharIndex = val.search(this._decimal);
      this._decimal.lastIndex = 0;
      var minusCharIndex = val.search(this._minusSign);
      this._minusSign.lastIndex = 0;
      var suffixCharIndex = val.search(this._suffix);
      this._suffix.lastIndex = 0;
      var currencyCharIndex = val.search(this._currency);
      this._currency.lastIndex = 0;
      return {
        decimalCharIndex: decimalCharIndex,
        minusCharIndex: minusCharIndex,
        suffixCharIndex: suffixCharIndex,
        currencyCharIndex: currencyCharIndex
      };
    }
  }, {
    key: "insert",
    value: function insert(event, text) {
      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        isDecimalSign: false,
        isMinusSign: false
      };
      var minusCharIndexOnText = text.search(this._minusSign);
      this._minusSign.lastIndex = 0;

      if (!this.allowMinusSign() && minusCharIndexOnText !== -1) {
        return;
      }

      var selectionStart = this.inputRef.current.selectionStart;
      var selectionEnd = this.inputRef.current.selectionEnd;
      var inputValue = this.inputRef.current.value.trim();

      var _this$getCharIndexes = this.getCharIndexes(inputValue),
          decimalCharIndex = _this$getCharIndexes.decimalCharIndex,
          minusCharIndex = _this$getCharIndexes.minusCharIndex,
          suffixCharIndex = _this$getCharIndexes.suffixCharIndex,
          currencyCharIndex = _this$getCharIndexes.currencyCharIndex;

      var newValueStr;

      if (sign.isMinusSign) {
        if (selectionStart === 0) {
          newValueStr = inputValue;

          if (minusCharIndex === -1 || selectionEnd !== 0) {
            newValueStr = this.insertText(inputValue, text, 0, selectionEnd);
          }

          this.updateValue(event, newValueStr, text, 'insert');
        }
      } else if (sign.isDecimalSign) {
        if (decimalCharIndex > 0 && selectionStart === decimalCharIndex) {
          this.updateValue(event, inputValue, text, 'insert');
        } else if (decimalCharIndex > selectionStart && decimalCharIndex < selectionEnd) {
          newValueStr = this.insertText(inputValue, text, selectionStart, selectionEnd);
          this.updateValue(event, newValueStr, text, 'insert');
        } else if (decimalCharIndex === -1 && this.props.maxFractionDigits) {
          newValueStr = this.insertText(inputValue, text, selectionStart, selectionEnd);
          this.updateValue(event, newValueStr, text, 'insert');
        }
      } else {
        var maxFractionDigits = this.numberFormat.resolvedOptions().maximumFractionDigits;
        var operation = selectionStart !== selectionEnd ? 'range-insert' : 'insert';

        if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
          if (selectionStart + text.length - (decimalCharIndex + 1) <= maxFractionDigits) {
            var charIndex = currencyCharIndex >= selectionStart ? currencyCharIndex - 1 : suffixCharIndex >= selectionStart ? suffixCharIndex : inputValue.length;
            newValueStr = inputValue.slice(0, selectionStart) + text + inputValue.slice(selectionStart + text.length, charIndex) + inputValue.slice(charIndex);
            this.updateValue(event, newValueStr, text, operation);
          }
        } else {
          newValueStr = this.insertText(inputValue, text, selectionStart, selectionEnd);
          this.updateValue(event, newValueStr, text, operation);
        }
      }
    }
  }, {
    key: "insertText",
    value: function insertText(value, text, start, end) {
      var textSplit = text === '.' ? text : text.split('.');

      if (textSplit.length === 2) {
        var decimalCharIndex = value.slice(start, end).search(this._decimal);
        this._decimal.lastIndex = 0;
        return decimalCharIndex > 0 ? value.slice(0, start) + this.formatValue(text) + value.slice(end) : value || this.formatValue(text);
      } else if (end - start === value.length) {
        return this.formatValue(text);
      } else if (start === 0) {
        return text + value.slice(end);
      } else if (end === value.length) {
        return value.slice(0, start) + text;
      } else {
        return value.slice(0, start) + text + value.slice(end);
      }
    }
  }, {
    key: "deleteRange",
    value: function deleteRange(value, start, end) {
      var newValueStr;
      if (end - start === value.length) newValueStr = '';else if (start === 0) newValueStr = value.slice(end);else if (end === value.length) newValueStr = value.slice(0, start);else newValueStr = value.slice(0, start) + value.slice(end);
      return newValueStr;
    }
  }, {
    key: "initCursor",
    value: function initCursor() {
      var selectionStart = this.inputRef.current.selectionStart;
      var inputValue = this.inputRef.current.value;
      var valueLength = inputValue.length;
      var index = null; // remove prefix

      var prefixLength = (this.prefixChar || '').length;
      inputValue = inputValue.replace(this._prefix, '');
      selectionStart = selectionStart - prefixLength;

      var _char4 = inputValue.charAt(selectionStart);

      if (this.isNumeralChar(_char4)) {
        return selectionStart + prefixLength;
      } //left


      var i = selectionStart - 1;

      while (i >= 0) {
        _char4 = inputValue.charAt(i);

        if (this.isNumeralChar(_char4)) {
          index = i + prefixLength;
          break;
        } else {
          i--;
        }
      }

      if (index !== null) {
        this.inputRef.current.setSelectionRange(index + 1, index + 1);
      } else {
        i = selectionStart;

        while (i < valueLength) {
          _char4 = inputValue.charAt(i);

          if (this.isNumeralChar(_char4)) {
            index = i + prefixLength;
            break;
          } else {
            i++;
          }
        }

        if (index !== null) {
          this.inputRef.current.setSelectionRange(index, index);
        }
      }

      return index || 0;
    }
  }, {
    key: "onInputClick",
    value: function onInputClick() {
      this.initCursor();
    }
  }, {
    key: "isNumeralChar",
    value: function isNumeralChar(_char5) {
      if (_char5.length === 1 && (this._numeral.test(_char5) || this._decimal.test(_char5) || this._group.test(_char5) || this._minusSign.test(_char5))) {
        this.resetRegex();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "resetRegex",
    value: function resetRegex() {
      this._numeral.lastIndex = 0;
      this._decimal.lastIndex = 0;
      this._group.lastIndex = 0;
      this._minusSign.lastIndex = 0;
    }
  }, {
    key: "updateValue",
    value: function updateValue(event, valueStr, insertedValueStr, operation) {
      var currentValue = this.inputRef.current.value;
      var newValue = null;

      if (valueStr != null) {
        newValue = this.parseValue(valueStr);
        newValue = this.evaluateEmpty(newValue);
        this.updateInput(newValue, insertedValueStr, operation, valueStr);
        this.handleOnChange(event, currentValue, newValue);
      }
    }
  }, {
    key: "evaluateEmpty",
    value: function evaluateEmpty(newValue) {
      return !newValue && !this.props.allowEmpty ? this.props.min || 0 : newValue;
    }
  }, {
    key: "handleOnChange",
    value: function handleOnChange(event, currentValue, newValue) {
      if (this.props.onChange && this.isValueChanged(currentValue, newValue)) {
        this.props.onChange({
          originalEvent: event,
          value: newValue
        });
      }
    }
  }, {
    key: "isValueChanged",
    value: function isValueChanged(currentValue, newValue) {
      if (newValue === null && currentValue !== null) {
        return true;
      }

      if (newValue != null) {
        var parsedCurrentValue = typeof currentValue === 'string' ? this.parseValue(currentValue) : currentValue;
        return newValue !== parsedCurrentValue;
      }

      return false;
    }
  }, {
    key: "validateValue",
    value: function validateValue(value) {
      if (value === '-' || value == null) {
        return null;
      }

      if (this.props.min !== null && value < this.props.min) {
        return this.props.min;
      }

      if (this.props.max !== null && value > this.props.max) {
        return this.props.max;
      }

      return value;
    }
  }, {
    key: "updateInput",
    value: function updateInput(value, insertedValueStr, operation, valueStr) {
      insertedValueStr = insertedValueStr || '';
      var inputEl = this.inputRef.current;
      var inputValue = inputEl.value;
      var newValue = this.formatValue(value);
      var currentLength = inputValue.length;

      if (newValue !== valueStr) {
        newValue = this.concatValues(newValue, valueStr);
      }

      if (currentLength === 0) {
        inputEl.value = newValue;
        inputEl.setSelectionRange(0, 0);
        var index = this.initCursor();
        var selectionEnd = index + insertedValueStr.length;
        inputEl.setSelectionRange(selectionEnd, selectionEnd);
      } else {
        var selectionStart = inputEl.selectionStart;
        var _selectionEnd = inputEl.selectionEnd;
        inputEl.value = newValue;
        var newLength = newValue.length;

        if (operation === 'range-insert') {
          var startValue = this.parseValue((inputValue || '').slice(0, selectionStart));
          var startValueStr = startValue !== null ? startValue.toString() : '';
          var startExpr = startValueStr.split('').join("(".concat(this.groupChar, ")?"));
          var sRegex = new RegExp(startExpr, 'g');
          sRegex.test(newValue);
          var tExpr = insertedValueStr.split('').join("(".concat(this.groupChar, ")?"));
          var tRegex = new RegExp(tExpr, 'g');
          tRegex.test(newValue.slice(sRegex.lastIndex));
          _selectionEnd = sRegex.lastIndex + tRegex.lastIndex;
          inputEl.setSelectionRange(_selectionEnd, _selectionEnd);
        } else if (newLength === currentLength) {
          if (operation === 'insert' || operation === 'delete-back-single') inputEl.setSelectionRange(_selectionEnd + 1, _selectionEnd + 1);else if (operation === 'delete-single') inputEl.setSelectionRange(_selectionEnd - 1, _selectionEnd - 1);else if (operation === 'delete-range' || operation === 'spin') inputEl.setSelectionRange(_selectionEnd, _selectionEnd);
        } else if (operation === 'delete-back-single') {
          var prevChar = inputValue.charAt(_selectionEnd - 1);
          var nextChar = inputValue.charAt(_selectionEnd);
          var diff = currentLength - newLength;

          var isGroupChar = this._group.test(nextChar);

          if (isGroupChar && diff === 1) {
            _selectionEnd += 1;
          } else if (!isGroupChar && this.isNumeralChar(prevChar)) {
            _selectionEnd += -1 * diff + 1;
          }

          this._group.lastIndex = 0;
          inputEl.setSelectionRange(_selectionEnd, _selectionEnd);
        } else if (inputValue === '-' && operation === 'insert') {
          inputEl.setSelectionRange(0, 0);

          var _index = this.initCursor();

          var _selectionEnd2 = _index + insertedValueStr.length + 1;

          inputEl.setSelectionRange(_selectionEnd2, _selectionEnd2);
        } else {
          _selectionEnd = _selectionEnd + (newLength - currentLength);
          inputEl.setSelectionRange(_selectionEnd, _selectionEnd);
        }
      }

      inputEl.setAttribute('aria-valuenow', value);
    }
  }, {
    key: "updateInputValue",
    value: function updateInputValue(newValue) {
      newValue = this.evaluateEmpty(newValue);
      var inputEl = this.inputRef.current;
      var value = inputEl.value;
      var formattedValue = this.formattedValue(newValue);

      if (value !== formattedValue) {
        inputEl.value = formattedValue;
        inputEl.setAttribute('aria-valuenow', newValue);
      }
    }
  }, {
    key: "formattedValue",
    value: function formattedValue(val) {
      var newValue = this.evaluateEmpty(val);
      return this.formatValue(newValue);
    }
  }, {
    key: "concatValues",
    value: function concatValues(val1, val2) {
      if (val1 && val2) {
        var decimalCharIndex = val2.search(this._decimal);
        this._decimal.lastIndex = 0;
        return decimalCharIndex !== -1 ? val1.split(this._decimal)[0] + val2.slice(decimalCharIndex) : val1;
      }

      return val1;
    }
  }, {
    key: "getDecimalLength",
    value: function getDecimalLength(value) {
      if (value) {
        var valueSplit = value.split(this._decimal);

        if (valueSplit.length === 2) {
          return valueSplit[1].replace(this._suffix, '').trim().replace(/\s/g, '').replace(this._currency, '').length;
        }
      }

      return 0;
    }
  }, {
    key: "updateModel",
    value: function updateModel(event, value) {
      if (this.props.onValueChange) {
        this.props.onValueChange({
          originalEvent: event,
          value: value,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: value
          }
        });
      }
    }
  }, {
    key: "onInputFocus",
    value: function onInputFocus(event) {
      var _this3 = this;

      event.persist();
      this.setState({
        focused: true
      }, function () {
        if (_this3.props.onFocus) {
          _this3.props.onFocus(event);
        }
      });
    }
  }, {
    key: "onInputBlur",
    value: function onInputBlur(event) {
      var _this4 = this;

      event.persist();
      this.setState({
        focused: false
      }, function () {
        var currentValue = _this4.inputRef.current.value;

        if (_this4.isValueChanged(currentValue, _this4.props.value)) {
          var newValue = _this4.validateValue(_this4.parseValue(currentValue));

          _this4.updateInputValue(newValue);

          _this4.updateModel(event, newValue);
        }

        if (_this4.props.onBlur) {
          _this4.props.onBlur(event);
        }
      });
    }
  }, {
    key: "clearTimer",
    value: function clearTimer() {
      if (this.timer) {
        clearInterval(this.timer);
      }
    }
  }, {
    key: "isStacked",
    value: function isStacked() {
      return this.props.showButtons && this.props.buttonLayout === 'stacked';
    }
  }, {
    key: "isHorizontal",
    value: function isHorizontal() {
      return this.props.showButtons && this.props.buttonLayout === 'horizontal';
    }
  }, {
    key: "isVertical",
    value: function isVertical() {
      return this.props.showButtons && this.props.buttonLayout === 'vertical';
    }
  }, {
    key: "getInputMode",
    value: function getInputMode() {
      return this.props.inputMode || (this.props.mode === 'decimal' && !this.props.minFractionDigits ? 'numeric' : 'decimal');
    }
  }, {
    key: "getFormatter",
    value: function getFormatter() {
      return this.numberFormat;
    }
  }, {
    key: "updateInputRef",
    value: function updateInputRef() {
      var ref = this.props.inputRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.inputRef.current);
        } else {
          ref.current = this.inputRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateInputRef();

      if (this.props.tooltip) {
        this.renderTooltip();
      }

      var newValue = this.validateValue(this.props.value);

      if (this.props.value !== null && this.props.value !== newValue) {
        this.updateModel(null, newValue);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$g({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }

      var isOptionChanged = this.isOptionChanged(prevProps);

      if (isOptionChanged) {
        this.constructParser();
      }

      if (prevProps.value !== this.props.value || isOptionChanged) {
        var newValue = this.validateValue(this.props.value);
        this.updateInputValue(newValue);

        if (this.props.value !== null && this.props.value !== newValue) {
          this.updateModel(null, newValue);
        }
      }
    }
  }, {
    key: "isOptionChanged",
    value: function isOptionChanged(prevProps) {
      var _this5 = this;

      var optionProps = ['locale', 'localeMatcher', 'mode', 'currency', 'currencyDisplay', 'useGrouping', 'minFractionDigits', 'maxFractionDigits', 'suffix', 'prefix'];
      return optionProps.some(function (option) {
        return prevProps[option] !== _this5.props[option];
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.element,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "renderInputElement",
    value: function renderInputElement() {
      var className = classNames('p-inputnumber-input', this.props.inputClassName);
      var valueToRender = this.formattedValue(this.props.value);
      return /*#__PURE__*/React.createElement(InputText$1, {
        ref: this.inputRef,
        id: this.props.inputId,
        style: this.props.inputStyle,
        role: "spinbutton",
        className: className,
        defaultValue: valueToRender,
        type: this.props.type,
        size: this.props.size,
        tabIndex: this.props.tabIndex,
        inputMode: this.getInputMode(),
        maxLength: this.props.maxLength,
        disabled: this.props.disabled,
        required: this.props.required,
        pattern: this.props.pattern,
        placeholder: this.props.placeholder,
        readOnly: this.props.readOnly,
        name: this.props.name,
        autoFocus: this.props.autoFocus,
        onKeyDown: this.onInputKeyDown,
        onKeyPress: this.onInputKeyPress,
        onInput: this.onInput,
        onClick: this.onInputClick,
        onBlur: this.onInputBlur,
        onFocus: this.onInputFocus,
        onPaste: this.onPaste,
        min: this.props.min,
        max: this.props.max,
        "aria-valuemin": this.props.min,
        "aria-valuemax": this.props.max,
        "aria-valuenow": this.props.value,
        "aria-labelledby": this.props.ariaLabelledBy
      });
    }
  }, {
    key: "renderUpButton",
    value: function renderUpButton() {
      var className = classNames('p-inputnumber-button p-inputnumber-button-up p-button p-button-icon-only p-component', {
        'p-disabled': this.props.disabled
      }, this.props.incrementButtonClassName);
      var icon = classNames('p-button-icon', this.props.incrementButtonIcon);
      return /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: className,
        onMouseLeave: this.onUpButtonMouseLeave,
        onMouseDown: this.onUpButtonMouseDown,
        onMouseUp: this.onUpButtonMouseUp,
        onKeyDown: this.onUpButtonKeyDown,
        onKeyUp: this.onUpButtonKeyUp,
        disabled: this.props.disabled,
        tabIndex: -1
      }, /*#__PURE__*/React.createElement("span", {
        className: icon
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }
  }, {
    key: "renderDownButton",
    value: function renderDownButton() {
      var className = classNames('p-inputnumber-button p-inputnumber-button-down p-button p-button-icon-only p-component', {
        'p-disabled': this.props.disabled
      }, this.props.decrementButtonClassName);
      var icon = classNames('p-button-icon', this.props.decrementButtonIcon);
      return /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: className,
        onMouseLeave: this.onDownButtonMouseLeave,
        onMouseDown: this.onDownButtonMouseDown,
        onMouseUp: this.onDownButtonMouseUp,
        onKeyDown: this.onDownButtonKeyDown,
        onKeyUp: this.onDownButtonKeyUp,
        disabled: this.props.disabled,
        tabIndex: -1
      }, /*#__PURE__*/React.createElement("span", {
        className: icon
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }
  }, {
    key: "renderButtonGroup",
    value: function renderButtonGroup() {
      var upButton = this.props.showButtons && this.renderUpButton();
      var downButton = this.props.showButtons && this.renderDownButton();

      if (this.isStacked()) {
        return /*#__PURE__*/React.createElement("span", {
          className: "p-inputnumber-button-group"
        }, upButton, downButton);
      }

      return /*#__PURE__*/React.createElement(React.Fragment, null, upButton, downButton);
    }
  }, {
    key: "render",
    value: function render() {
      var _this6 = this;

      var className = classNames('p-inputnumber p-component p-inputwrapper', this.props.className, {
        'p-inputwrapper-filled': this.props.value != null && this.props.value.toString().length > 0,
        'p-inputwrapper-focus': this.state.focused,
        'p-inputnumber-buttons-stacked': this.isStacked(),
        'p-inputnumber-buttons-horizontal': this.isHorizontal(),
        'p-inputnumber-buttons-vertical': this.isVertical()
      });
      var inputElement = this.renderInputElement();
      var buttonGroup = this.renderButtonGroup();
      return /*#__PURE__*/React.createElement("span", {
        ref: function ref(el) {
          return _this6.element = el;
        },
        id: this.props.id,
        className: className,
        style: this.props.style
      }, inputElement, buttonGroup);
    }
  }]);

  return InputNumber;
}(Component);

_defineProperty$s(InputNumber$1, "defaultProps", {
  value: null,
  inputRef: null,
  format: true,
  showButtons: false,
  buttonLayout: 'stacked',
  incrementButtonClassName: null,
  decrementButtonClassName: null,
  incrementButtonIcon: 'pi pi-angle-up',
  decrementButtonIcon: 'pi pi-angle-down',
  locale: undefined,
  localeMatcher: undefined,
  mode: 'decimal',
  suffix: null,
  prefix: null,
  currency: undefined,
  currencyDisplay: undefined,
  useGrouping: true,
  minFractionDigits: undefined,
  maxFractionDigits: undefined,
  id: null,
  name: null,
  type: 'text',
  allowEmpty: true,
  step: 1,
  min: null,
  max: null,
  disabled: false,
  required: false,
  tabIndex: null,
  pattern: null,
  inputMode: null,
  placeholder: null,
  readOnly: false,
  size: null,
  style: null,
  className: null,
  inputId: null,
  autoFocus: false,
  inputStyle: null,
  inputClassName: null,
  tooltip: null,
  tooltipOptions: null,
  ariaLabelledBy: null,
  onValueChange: null,
  onChange: null,
  onBlur: null,
  onFocus: null,
  onKeyDown: null
});

function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$1(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$g(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$g(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$g(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(o, minLen);
}

function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$g(arr, i) || _nonIterableRest$1();
}

function _typeof$r(obj) {
  "@babel/helpers - typeof";

  return _typeof$r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$r(obj);
}

function _classCallCheck$r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$r(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$r(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$r(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$r(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$q(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$q(o, p) {
  _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$q(o, p);
}

function _inherits$r(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$q(subClass, superClass);
}

function _possibleConstructorReturn$r(self, call) {
  if (call && (_typeof$r(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$q(self);
}

function _getPrototypeOf$r(o) {
  _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$r(o);
}

function _defineProperty$r(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$8$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8$2();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$r(this, result);
  };
}

function _isNativeReflectConstruct$8$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var FirstPageLink = /*#__PURE__*/function (_Component) {
  _inherits$r(FirstPageLink, _Component);

  var _super = _createSuper$8$2(FirstPageLink);

  function FirstPageLink() {
    _classCallCheck$r(this, FirstPageLink);

    return _super.apply(this, arguments);
  }

  _createClass$r(FirstPageLink, [{
    key: "render",
    value: function render() {
      var className = classNames('p-paginator-first p-paginator-element p-link', {
        'p-disabled': this.props.disabled
      });
      var iconClassName = 'p-paginator-icon pi pi-angle-double-left';
      var element = /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: className,
        onClick: this.props.onClick,
        disabled: this.props.disabled
      }, /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      }), /*#__PURE__*/React.createElement(Ripple, null));

      if (this.props.template) {
        var defaultOptions = {
          onClick: this.props.onClick,
          className: className,
          iconClassName: iconClassName,
          disabled: this.props.disabled,
          element: element,
          props: this.props
        };
        return ObjectUtils.getJSXElement(this.props.template, defaultOptions);
      }

      return element;
    }
  }]);

  return FirstPageLink;
}(Component);

_defineProperty$r(FirstPageLink, "defaultProps", {
  disabled: false,
  onClick: null,
  template: null
});

function _createSuper$7$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7$2();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$r(this, result);
  };
}

function _isNativeReflectConstruct$7$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var NextPageLink = /*#__PURE__*/function (_Component) {
  _inherits$r(NextPageLink, _Component);

  var _super = _createSuper$7$2(NextPageLink);

  function NextPageLink() {
    _classCallCheck$r(this, NextPageLink);

    return _super.apply(this, arguments);
  }

  _createClass$r(NextPageLink, [{
    key: "render",
    value: function render() {
      var className = classNames('p-paginator-next p-paginator-element p-link', {
        'p-disabled': this.props.disabled
      });
      var iconClassName = 'p-paginator-icon pi pi-angle-right';
      var element = /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: className,
        onClick: this.props.onClick,
        disabled: this.props.disabled
      }, /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      }), /*#__PURE__*/React.createElement(Ripple, null));

      if (this.props.template) {
        var defaultOptions = {
          onClick: this.props.onClick,
          className: className,
          iconClassName: iconClassName,
          disabled: this.props.disabled,
          element: element,
          props: this.props
        };
        return ObjectUtils.getJSXElement(this.props.template, defaultOptions);
      }

      return element;
    }
  }]);

  return NextPageLink;
}(Component);

_defineProperty$r(NextPageLink, "defaultProps", {
  disabled: false,
  onClick: null,
  template: null
});

function _createSuper$6$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6$2();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$r(this, result);
  };
}

function _isNativeReflectConstruct$6$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var PrevPageLink = /*#__PURE__*/function (_Component) {
  _inherits$r(PrevPageLink, _Component);

  var _super = _createSuper$6$2(PrevPageLink);

  function PrevPageLink() {
    _classCallCheck$r(this, PrevPageLink);

    return _super.apply(this, arguments);
  }

  _createClass$r(PrevPageLink, [{
    key: "render",
    value: function render() {
      var className = classNames('p-paginator-prev p-paginator-element p-link', {
        'p-disabled': this.props.disabled
      });
      var iconClassName = 'p-paginator-icon pi pi-angle-left';
      var element = /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: className,
        onClick: this.props.onClick,
        disabled: this.props.disabled
      }, /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      }), /*#__PURE__*/React.createElement(Ripple, null));

      if (this.props.template) {
        var defaultOptions = {
          onClick: this.props.onClick,
          className: className,
          iconClassName: iconClassName,
          disabled: this.props.disabled,
          element: element,
          props: this.props
        };
        return ObjectUtils.getJSXElement(this.props.template, defaultOptions);
      }

      return element;
    }
  }]);

  return PrevPageLink;
}(Component);

_defineProperty$r(PrevPageLink, "defaultProps", {
  disabled: false,
  onClick: null,
  template: null
});

function _createSuper$5$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5$2();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$r(this, result);
  };
}

function _isNativeReflectConstruct$5$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var LastPageLink = /*#__PURE__*/function (_Component) {
  _inherits$r(LastPageLink, _Component);

  var _super = _createSuper$5$2(LastPageLink);

  function LastPageLink() {
    _classCallCheck$r(this, LastPageLink);

    return _super.apply(this, arguments);
  }

  _createClass$r(LastPageLink, [{
    key: "render",
    value: function render() {
      var className = classNames('p-paginator-last p-paginator-element p-link', {
        'p-disabled': this.props.disabled
      });
      var iconClassName = 'p-paginator-icon pi pi-angle-double-right';
      var element = /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: className,
        onClick: this.props.onClick,
        disabled: this.props.disabled
      }, /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      }), /*#__PURE__*/React.createElement(Ripple, null));

      if (this.props.template) {
        var defaultOptions = {
          onClick: this.props.onClick,
          className: className,
          iconClassName: iconClassName,
          disabled: this.props.disabled,
          element: element,
          props: this.props
        };
        return ObjectUtils.getJSXElement(this.props.template, defaultOptions);
      }

      return element;
    }
  }]);

  return LastPageLink;
}(Component);

_defineProperty$r(LastPageLink, "defaultProps", {
  disabled: false,
  onClick: null,
  template: null
});

function _createSuper$4$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4$3();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$r(this, result);
  };
}

function _isNativeReflectConstruct$4$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var PageLinks = /*#__PURE__*/function (_Component) {
  _inherits$r(PageLinks, _Component);

  var _super = _createSuper$4$3(PageLinks);

  function PageLinks() {
    _classCallCheck$r(this, PageLinks);

    return _super.apply(this, arguments);
  }

  _createClass$r(PageLinks, [{
    key: "onPageLinkClick",
    value: function onPageLinkClick(event, pageLink) {
      if (this.props.onClick) {
        this.props.onClick({
          originalEvent: event,
          value: pageLink
        });
      }

      event.preventDefault();
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var elements;

      if (this.props.value) {
        var startPageInView = this.props.value[0];
        var endPageInView = this.props.value[this.props.value.length - 1];
        elements = this.props.value.map(function (pageLink, i) {
          var className = classNames('p-paginator-page p-paginator-element p-link', {
            'p-paginator-page-start': pageLink === startPageInView,
            'p-paginator-page-end': pageLink === endPageInView,
            'p-highlight': pageLink - 1 === _this.props.page
          });
          var element = /*#__PURE__*/React.createElement("button", {
            type: "button",
            className: className,
            onClick: function onClick(e) {
              return _this.onPageLinkClick(e, pageLink);
            }
          }, pageLink, /*#__PURE__*/React.createElement(Ripple, null));

          if (_this.props.template) {
            var defaultOptions = {
              onClick: function onClick(e) {
                return _this.onPageLinkClick(e, pageLink);
              },
              className: className,
              view: {
                startPage: startPageInView - 1,
                endPage: endPageInView - 1
              },
              page: pageLink - 1,
              currentPage: _this.props.page,
              totalPages: _this.props.pageCount,
              element: element,
              props: _this.props
            };
            element = ObjectUtils.getJSXElement(_this.props.template, defaultOptions);
          }

          return /*#__PURE__*/React.createElement(React.Fragment, {
            key: pageLink
          }, element);
        });
      }

      return /*#__PURE__*/React.createElement("span", {
        className: "p-paginator-pages"
      }, elements);
    }
  }]);

  return PageLinks;
}(Component);

_defineProperty$r(PageLinks, "defaultProps", {
  value: null,
  page: null,
  rows: null,
  pageCount: null,
  links: null,
  template: null
});

function _createSuper$3$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3$3();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$r(this, result);
  };
}

function _isNativeReflectConstruct$3$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var RowsPerPageDropdown = /*#__PURE__*/function (_Component) {
  _inherits$r(RowsPerPageDropdown, _Component);

  var _super = _createSuper$3$3(RowsPerPageDropdown);

  function RowsPerPageDropdown() {
    _classCallCheck$r(this, RowsPerPageDropdown);

    return _super.apply(this, arguments);
  }

  _createClass$r(RowsPerPageDropdown, [{
    key: "hasOptions",
    value: function hasOptions() {
      return this.props.options && this.props.options.length > 0;
    }
  }, {
    key: "render",
    value: function render() {
      var hasOptions = this.hasOptions();
      var options = hasOptions ? this.props.options.map(function (opt) {
        return {
          label: String(opt),
          value: opt
        };
      }) : [];
      var element = hasOptions ? /*#__PURE__*/React.createElement(Dropdown$1, {
        value: this.props.value,
        options: options,
        onChange: this.props.onChange,
        appendTo: this.props.appendTo,
        disabled: this.props.disabled
      }) : null;

      if (this.props.template) {
        var defaultOptions = {
          value: this.props.value,
          options: options,
          onChange: this.props.onChange,
          appendTo: this.props.appendTo,
          currentPage: this.props.page,
          totalPages: this.props.pageCount,
          totalRecords: this.props.totalRecords,
          disabled: this.props.disabled,
          element: element,
          props: this.props
        };
        return ObjectUtils.getJSXElement(this.props.template, defaultOptions);
      }

      return element;
    }
  }]);

  return RowsPerPageDropdown;
}(Component);

_defineProperty$r(RowsPerPageDropdown, "defaultProps", {
  options: null,
  value: null,
  page: null,
  pageCount: null,
  totalRecords: 0,
  appendTo: null,
  onChange: null,
  template: null,
  disabled: false
});

function ownKeys$f(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$f(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$f(Object(source), !0).forEach(function (key) {
      _defineProperty$r(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$2$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2$3();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$r(this, result);
  };
}

function _isNativeReflectConstruct$2$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var CurrentPageReport = /*#__PURE__*/function (_Component) {
  _inherits$r(CurrentPageReport, _Component);

  var _super = _createSuper$2$3(CurrentPageReport);

  function CurrentPageReport() {
    _classCallCheck$r(this, CurrentPageReport);

    return _super.apply(this, arguments);
  }

  _createClass$r(CurrentPageReport, [{
    key: "render",
    value: function render() {
      var report = {
        currentPage: this.props.page + 1,
        totalPages: this.props.pageCount,
        first: Math.min(this.props.first + 1, this.props.totalRecords),
        last: Math.min(this.props.first + this.props.rows, this.props.totalRecords),
        rows: this.props.rows,
        totalRecords: this.props.totalRecords
      };
      var text = this.props.reportTemplate.replace("{currentPage}", report.currentPage).replace("{totalPages}", report.totalPages).replace("{first}", report.first).replace("{last}", report.last).replace("{rows}", report.rows).replace("{totalRecords}", report.totalRecords);
      var element = /*#__PURE__*/React.createElement("span", {
        className: "p-paginator-current"
      }, text);

      if (this.props.template) {
        var defaultOptions = _objectSpread$f(_objectSpread$f({}, report), {
          className: 'p-paginator-current',
          element: element,
          props: this.props
        });

        return ObjectUtils.getJSXElement(this.props.template, defaultOptions);
      }

      return element;
    }
  }]);

  return CurrentPageReport;
}(Component);

_defineProperty$r(CurrentPageReport, "defaultProps", {
  pageCount: null,
  page: null,
  first: null,
  rows: null,
  totalRecords: null,
  reportTemplate: '({currentPage} of {totalPages})',
  template: null
});

function _createSuper$1$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$9();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$r(this, result);
  };
}

function _isNativeReflectConstruct$1$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var JumpToPageInput = /*#__PURE__*/function (_Component) {
  _inherits$r(JumpToPageInput, _Component);

  var _super = _createSuper$1$9(JumpToPageInput);

  function JumpToPageInput(props) {
    var _this;

    _classCallCheck$r(this, JumpToPageInput);

    _this = _super.call(this, props);
    _this.onChange = _this.onChange.bind(_assertThisInitialized$q(_this));
    return _this;
  }

  _createClass$r(JumpToPageInput, [{
    key: "onChange",
    value: function onChange(event) {
      if (this.props.onChange) {
        this.props.onChange(this.props.rows * (event.value - 1), this.props.rows);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var value = this.props.pageCount > 0 ? this.props.page + 1 : 0;
      var element = /*#__PURE__*/React.createElement(InputNumber$1, {
        value: value,
        onChange: this.onChange,
        className: "p-paginator-page-input",
        disabled: this.props.disabled
      });

      if (this.props.template) {
        var defaultOptions = {
          value: value,
          onChange: this.onChange,
          disabled: this.props.disabled,
          className: 'p-paginator-page-input',
          element: element,
          props: this.props
        };
        return ObjectUtils.getJSXElement(this.props.template, defaultOptions);
      }

      return element;
    }
  }]);

  return JumpToPageInput;
}(Component);

_defineProperty$r(JumpToPageInput, "defaultProps", {
  page: null,
  rows: null,
  pageCount: null,
  disabled: false,
  template: null,
  onChange: null
});

function _createSuper$x(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$x();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$r(this, result);
  };
}

function _isNativeReflectConstruct$x() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Paginator = /*#__PURE__*/function (_Component) {
  _inherits$r(Paginator, _Component);

  var _super = _createSuper$x(Paginator);

  function Paginator(props) {
    var _this;

    _classCallCheck$r(this, Paginator);

    _this = _super.call(this, props);
    _this.changePageToFirst = _this.changePageToFirst.bind(_assertThisInitialized$q(_this));
    _this.changePageToPrev = _this.changePageToPrev.bind(_assertThisInitialized$q(_this));
    _this.changePageToNext = _this.changePageToNext.bind(_assertThisInitialized$q(_this));
    _this.changePageToLast = _this.changePageToLast.bind(_assertThisInitialized$q(_this));
    _this.onRowsChange = _this.onRowsChange.bind(_assertThisInitialized$q(_this));
    _this.changePage = _this.changePage.bind(_assertThisInitialized$q(_this));
    _this.onPageLinkClick = _this.onPageLinkClick.bind(_assertThisInitialized$q(_this));
    return _this;
  }

  _createClass$r(Paginator, [{
    key: "isFirstPage",
    value: function isFirstPage() {
      return this.getPage() === 0;
    }
  }, {
    key: "isLastPage",
    value: function isLastPage() {
      return this.getPage() === this.getPageCount() - 1;
    }
  }, {
    key: "getPageCount",
    value: function getPageCount() {
      return Math.ceil(this.props.totalRecords / this.props.rows);
    }
  }, {
    key: "calculatePageLinkBoundaries",
    value: function calculatePageLinkBoundaries() {
      var numberOfPages = this.getPageCount();
      var visiblePages = Math.min(this.props.pageLinkSize, numberOfPages); //calculate range, keep current in middle if necessary

      var start = Math.max(0, Math.ceil(this.getPage() - visiblePages / 2));
      var end = Math.min(numberOfPages - 1, start + visiblePages - 1); //check when approaching to last page

      var delta = this.props.pageLinkSize - (end - start + 1);
      start = Math.max(0, start - delta);
      return [start, end];
    }
  }, {
    key: "updatePageLinks",
    value: function updatePageLinks() {
      var pageLinks = [];
      var boundaries = this.calculatePageLinkBoundaries();
      var start = boundaries[0];
      var end = boundaries[1];

      for (var i = start; i <= end; i++) {
        pageLinks.push(i + 1);
      }

      return pageLinks;
    }
  }, {
    key: "changePage",
    value: function changePage(first, rows) {
      var pc = this.getPageCount();
      var p = Math.floor(first / rows);

      if (p >= 0 && p < pc) {
        var newPageState = {
          first: first,
          rows: rows,
          page: p,
          pageCount: pc
        };

        if (this.props.onPageChange) {
          this.props.onPageChange(newPageState);
        }
      }
    }
  }, {
    key: "getPage",
    value: function getPage() {
      return Math.floor(this.props.first / this.props.rows);
    }
  }, {
    key: "empty",
    value: function empty() {
      var pageCount = this.getPageCount();
      return pageCount === 0;
    }
  }, {
    key: "changePageToFirst",
    value: function changePageToFirst(event) {
      this.changePage(0, this.props.rows);
      event.preventDefault();
    }
  }, {
    key: "changePageToPrev",
    value: function changePageToPrev(event) {
      this.changePage(this.props.first - this.props.rows, this.props.rows);
      event.preventDefault();
    }
  }, {
    key: "onPageLinkClick",
    value: function onPageLinkClick(event) {
      this.changePage((event.value - 1) * this.props.rows, this.props.rows);
    }
  }, {
    key: "changePageToNext",
    value: function changePageToNext(event) {
      this.changePage(this.props.first + this.props.rows, this.props.rows);
      event.preventDefault();
    }
  }, {
    key: "changePageToLast",
    value: function changePageToLast(event) {
      this.changePage((this.getPageCount() - 1) * this.props.rows, this.props.rows);
      event.preventDefault();
    }
  }, {
    key: "onRowsChange",
    value: function onRowsChange(event) {
      var rows = event.value;
      this.isRowChanged = rows !== this.props.rows;
      this.changePage(0, rows);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.rows !== prevProps.rows && !this.isRowChanged) {
        this.changePage(0, this.props.rows);
      } else if (this.getPage() > 0 && prevProps.totalRecords !== this.props.totalRecords && this.props.first >= this.props.totalRecords) {
        this.changePage((this.getPageCount() - 1) * this.props.rows, this.props.rows);
      }

      this.isRowChanged = false;
    }
  }, {
    key: "renderElement",
    value: function renderElement(key, template) {
      var element;

      switch (key) {
        case 'FirstPageLink':
          element = /*#__PURE__*/React.createElement(FirstPageLink, {
            key: key,
            onClick: this.changePageToFirst,
            disabled: this.isFirstPage() || this.empty(),
            template: template
          });
          break;

        case 'PrevPageLink':
          element = /*#__PURE__*/React.createElement(PrevPageLink, {
            key: key,
            onClick: this.changePageToPrev,
            disabled: this.isFirstPage() || this.empty(),
            template: template
          });
          break;

        case 'NextPageLink':
          element = /*#__PURE__*/React.createElement(NextPageLink, {
            key: key,
            onClick: this.changePageToNext,
            disabled: this.isLastPage() || this.empty(),
            template: template
          });
          break;

        case 'LastPageLink':
          element = /*#__PURE__*/React.createElement(LastPageLink, {
            key: key,
            onClick: this.changePageToLast,
            disabled: this.isLastPage() || this.empty(),
            template: template
          });
          break;

        case 'PageLinks':
          element = /*#__PURE__*/React.createElement(PageLinks, {
            key: key,
            value: this.updatePageLinks(),
            page: this.getPage(),
            rows: this.props.rows,
            pageCount: this.getPageCount(),
            onClick: this.onPageLinkClick,
            template: template
          });
          break;

        case 'RowsPerPageDropdown':
          element = /*#__PURE__*/React.createElement(RowsPerPageDropdown, {
            key: key,
            value: this.props.rows,
            page: this.getPage(),
            pageCount: this.getPageCount(),
            totalRecords: this.props.totalRecords,
            options: this.props.rowsPerPageOptions,
            onChange: this.onRowsChange,
            appendTo: this.props.dropdownAppendTo,
            template: template,
            disabled: this.empty()
          });
          break;

        case 'CurrentPageReport':
          element = /*#__PURE__*/React.createElement(CurrentPageReport, {
            reportTemplate: this.props.currentPageReportTemplate,
            key: key,
            page: this.getPage(),
            pageCount: this.getPageCount(),
            first: this.props.first,
            rows: this.props.rows,
            totalRecords: this.props.totalRecords,
            template: template
          });
          break;

        case 'JumpToPageInput':
          element = /*#__PURE__*/React.createElement(JumpToPageInput, {
            key: key,
            rows: this.props.rows,
            page: this.getPage(),
            pageCount: this.getPageCount(),
            onChange: this.changePage,
            disabled: this.empty(),
            template: template
          });
          break;

        default:
          element = null;
          break;
      }

      return element;
    }
  }, {
    key: "renderElements",
    value: function renderElements() {
      var _this2 = this;

      var template = this.props.template;

      if (template) {
        if (_typeof$r(template) === 'object') {
          return template.layout ? template.layout.split(' ').map(function (value) {
            var key = value.trim();
            return _this2.renderElement(key, template[key]);
          }) : Object.entries(template).map(function (_ref) {
            var _ref2 = _slicedToArray$1(_ref, 2),
                key = _ref2[0],
                _template = _ref2[1];

            return _this2.renderElement(key, _template);
          });
        }

        return template.split(' ').map(function (value) {
          return _this2.renderElement(value.trim());
        });
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.props.alwaysShow && this.getPageCount() === 1) {
        return null;
      } else {
        var className = classNames('p-paginator p-component', this.props.className);
        var leftContent = ObjectUtils.getJSXElement(this.props.leftContent, this.props);
        var rightContent = ObjectUtils.getJSXElement(this.props.rightContent, this.props);
        var elements = this.renderElements();
        var leftElement = leftContent && /*#__PURE__*/React.createElement("div", {
          className: "p-paginator-left-content"
        }, leftContent);
        var rightElement = rightContent && /*#__PURE__*/React.createElement("div", {
          className: "p-paginator-right-content"
        }, rightContent);
        return /*#__PURE__*/React.createElement("div", {
          className: className,
          style: this.props.style
        }, leftElement, elements, rightElement);
      }
    }
  }]);

  return Paginator;
}(Component);

_defineProperty$r(Paginator, "defaultProps", {
  totalRecords: 0,
  rows: 0,
  first: 0,
  pageLinkSize: 5,
  rowsPerPageOptions: null,
  alwaysShow: true,
  style: null,
  className: null,
  template: 'FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown',
  onPageChange: null,
  leftContent: null,
  rightContent: null,
  dropdownAppendTo: null,
  currentPageReportTemplate: '({currentPage} of {totalPages})'
});

function _extends$7() {
  _extends$7 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$7.apply(this, arguments);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$f(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$f(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$f(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$f(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$f(arr, i) || _nonIterableRest();
}

function _arrayWithoutHoles$a(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$f(arr);
}

function _iterableToArray$a(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _nonIterableSpread$a() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$a(arr) {
  return _arrayWithoutHoles$a(arr) || _iterableToArray$a(arr) || _unsupportedIterableToArray$f(arr) || _nonIterableSpread$a();
}

function _classCallCheck$q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$q(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$q(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$q(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$p(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$p(o, p) {
  _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$p(o, p);
}

function _inherits$q(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$p(subClass, superClass);
}

function _typeof$q(obj) {
  "@babel/helpers - typeof";

  return _typeof$q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$q(obj);
}

function _possibleConstructorReturn$q(self, call) {
  if (call && (_typeof$q(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$p(self);
}

function _getPrototypeOf$q(o) {
  _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$q(o);
}

function _defineProperty$q(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _createSuper$c$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$c$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var RowRadioButton = /*#__PURE__*/function (_Component) {
  _inherits$q(RowRadioButton, _Component);

  var _super = _createSuper$c$1(RowRadioButton);

  function RowRadioButton(props) {
    var _this;

    _classCallCheck$q(this, RowRadioButton);

    _this = _super.call(this, props);
    _this.state = {
      focused: false
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized$p(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$p(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$p(_this));
    _this.onChange = _this.onChange.bind(_assertThisInitialized$p(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$p(_this));
    return _this;
  }

  _createClass$q(RowRadioButton, [{
    key: "onClick",
    value: function onClick(event) {
      if (!this.props.disabled) {
        this.props.onChange(event);
        this.input.focus();
      }
    }
  }, {
    key: "onFocus",
    value: function onFocus() {
      this.setState({
        focused: true
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        focused: false
      });
    }
  }, {
    key: "onChange",
    value: function onChange(event) {
      this.onClick(event);
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (event.code === 'Space') {
        this.onClick(event);
        event.preventDefault();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var className = classNames('p-radiobutton p-component', {
        'p-radiobutton-focused': this.state.focused
      });
      var boxClassName = classNames('p-radiobutton-box p-component', {
        'p-highlight': this.props.checked,
        'p-focus': this.state.focused,
        'p-disabled': this.props.disabled
      });
      var name = "".concat(this.props.tableSelector, "_dt_radio");
      return /*#__PURE__*/React.createElement("div", {
        className: className
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-hidden-accessible"
      }, /*#__PURE__*/React.createElement("input", {
        name: name,
        ref: function ref(el) {
          return _this2.input = el;
        },
        type: "radio",
        checked: this.props.checked,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onChange: this.onChange,
        onKeyDown: this.onKeyDown
      })), /*#__PURE__*/React.createElement("div", {
        className: boxClassName,
        onClick: this.onClick,
        role: "radio",
        "aria-checked": this.props.checked
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-radiobutton-icon"
      })));
    }
  }]);

  return RowRadioButton;
}(Component);

function _createSuper$b$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$b$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var RowCheckbox = /*#__PURE__*/function (_Component) {
  _inherits$q(RowCheckbox, _Component);

  var _super = _createSuper$b$1(RowCheckbox);

  function RowCheckbox(props) {
    var _this;

    _classCallCheck$q(this, RowCheckbox);

    _this = _super.call(this, props);
    _this.state = {
      focused: false
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized$p(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$p(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$p(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$p(_this));
    return _this;
  }

  _createClass$q(RowCheckbox, [{
    key: "onClick",
    value: function onClick(event) {
      if (!this.props.disabled) {
        this.setState({
          focused: true
        });
        this.props.onChange(event);
      }
    }
  }, {
    key: "onFocus",
    value: function onFocus() {
      this.setState({
        focused: true
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        focused: false
      });
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (event.code === 'Space') {
        this.onClick(event);
        event.preventDefault();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-checkbox p-component', {
        'p-checkbox-focused': this.state.focused
      });
      var boxClassName = classNames('p-checkbox-box p-component', {
        'p-highlight': this.props.checked,
        'p-disabled': this.props.disabled,
        'p-focus': this.state.focused
      });
      var iconClassName = classNames('p-checkbox-icon', {
        'pi pi-check': this.props.checked
      });
      var tabIndex = this.props.disabled ? null : '0';
      return /*#__PURE__*/React.createElement("div", {
        className: className,
        onClick: this.onClick
      }, /*#__PURE__*/React.createElement("div", {
        className: boxClassName,
        role: "checkbox",
        "aria-checked": this.props.checked,
        tabIndex: tabIndex,
        onKeyDown: this.onKeyDown,
        onFocus: this.onFocus,
        onBlur: this.onBlur
      }, /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      })));
    }
  }]);

  return RowCheckbox;
}(Component);

function ownKeys$7$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$7$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$7$1(Object(source), !0).forEach(function (key) {
      _defineProperty$q(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$a$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$a$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var BodyCell = /*#__PURE__*/function (_Component) {
  _inherits$q(BodyCell, _Component);

  var _super = _createSuper$a$1(BodyCell);

  function BodyCell(props) {
    var _this;

    _classCallCheck$q(this, BodyCell);

    _this = _super.call(this, props);
    _this.state = {
      editing: props.editing,
      editingRowData: props.rowData,
      styleObject: {}
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized$p(_this));
    _this.onMouseDown = _this.onMouseDown.bind(_assertThisInitialized$p(_this));
    _this.onMouseUp = _this.onMouseUp.bind(_assertThisInitialized$p(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$p(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$p(_this));
    _this.onEditorFocus = _this.onEditorFocus.bind(_assertThisInitialized$p(_this));
    _this.onRowToggle = _this.onRowToggle.bind(_assertThisInitialized$p(_this));
    _this.onRadioChange = _this.onRadioChange.bind(_assertThisInitialized$p(_this));
    _this.onCheckboxChange = _this.onCheckboxChange.bind(_assertThisInitialized$p(_this));
    _this.onRowEditSave = _this.onRowEditSave.bind(_assertThisInitialized$p(_this));
    _this.onRowEditCancel = _this.onRowEditCancel.bind(_assertThisInitialized$p(_this));
    _this.onRowEditInit = _this.onRowEditInit.bind(_assertThisInitialized$p(_this));
    _this.editorCallback = _this.editorCallback.bind(_assertThisInitialized$p(_this));
    return _this;
  }

  _createClass$q(BodyCell, [{
    key: "field",
    get: function get() {
      return this.getColumnProp('field') || "field_".concat(this.props.index);
    }
  }, {
    key: "isEditable",
    value: function isEditable() {
      return this.getColumnProp('editor');
    }
  }, {
    key: "isSelected",
    value: function isSelected() {
      return this.props.selection ? this.props.selection instanceof Array ? this.findIndex(this.props.selection) > -1 : this.equals(this.props.selection) : false;
    }
  }, {
    key: "equalsData",
    value: function equalsData(data) {
      return this.props.compareSelectionBy === 'equals' ? data === this.props.rowData : ObjectUtils.equals(data, this.props.rowData, this.props.dataKey);
    }
  }, {
    key: "equals",
    value: function equals(selectedCell) {
      return (selectedCell.rowIndex === this.props.rowIndex || this.equalsData(selectedCell.rowData)) && (selectedCell.field === this.field || selectedCell.cellIndex === this.props.index);
    }
  }, {
    key: "isOutsideClicked",
    value: function isOutsideClicked(target) {
      return this.el && !(this.el.isSameNode(target) || this.el.contains(target));
    }
  }, {
    key: "getColumnProp",
    value: function getColumnProp(prop) {
      return this.props.column ? this.props.column.props[prop] : null;
    }
  }, {
    key: "getVirtualScrollerOption",
    value: function getVirtualScrollerOption(option) {
      return this.props.virtualScrollerOptions ? this.props.virtualScrollerOptions[option] : null;
    }
  }, {
    key: "getStyle",
    value: function getStyle() {
      var bodyStyle = this.getColumnProp('bodyStyle');
      var columnStyle = this.getColumnProp('style');
      return this.getColumnProp('frozen') ? Object.assign({}, columnStyle, bodyStyle, this.state.styleObject) : Object.assign({}, columnStyle, bodyStyle);
    }
  }, {
    key: "getCellParams",
    value: function getCellParams() {
      return {
        value: this.resolveFieldData(),
        field: this.field,
        rowData: this.props.rowData,
        rowIndex: this.props.rowIndex,
        cellIndex: this.props.index,
        selected: this.isSelected(),
        column: this.props.column,
        props: this.props
      };
    }
  }, {
    key: "getCellCallbackParams",
    value: function getCellCallbackParams(event) {
      var params = this.getCellParams();
      return _objectSpread$7$1({
        originalEvent: event
      }, params);
    }
  }, {
    key: "resolveFieldData",
    value: function resolveFieldData(data) {
      return ObjectUtils.resolveFieldData(data || this.props.rowData, this.field);
    }
  }, {
    key: "getEditingRowData",
    value: function getEditingRowData() {
      return this.props.editingMeta && this.props.editingMeta[this.props.rowIndex] ? this.props.editingMeta[this.props.rowIndex].data : this.props.rowData;
    }
  }, {
    key: "getTabIndex",
    value: function getTabIndex(cellSelected) {
      return this.props.allowCellSelection ? cellSelected ? 0 : this.props.rowIndex === 0 && this.props.index === 0 ? this.props.tabIndex : -1 : null;
    }
  }, {
    key: "findIndex",
    value: function findIndex(collection) {
      var _this2 = this;

      return (collection || []).findIndex(function (data) {
        return _this2.equals(data);
      });
    }
  }, {
    key: "closeCell",
    value: function closeCell(event) {
      var _this3 = this;

      var params = this.getCellCallbackParams(event);
      var onBeforeCellEditHide = this.getColumnProp('onBeforeCellEditHide');

      if (onBeforeCellEditHide) {
        onBeforeCellEditHide(params);
      }
      /* When using the 'tab' key, the focus event of the next cell is not called in IE. */


      setTimeout(function () {
        _this3.setState({
          editing: false
        }, function () {
          _this3.unbindDocumentEditListener();

          OverlayService.off('overlay-click', _this3.overlayEventListener);
          _this3.overlayEventListener = null;
        });
      }, 1);
    }
  }, {
    key: "switchCellToViewMode",
    value: function switchCellToViewMode(event, submit) {
      var callbackParams = this.getCellCallbackParams(event);
      var newRowData = this.state.editingRowData;
      var newValue = this.resolveFieldData(newRowData);

      var params = _objectSpread$7$1(_objectSpread$7$1({}, callbackParams), {}, {
        newRowData: newRowData,
        newValue: newValue
      });

      var onCellEditCancel = this.getColumnProp('onCellEditCancel');
      var cellEditValidator = this.getColumnProp('cellEditValidator');
      var onCellEditComplete = this.getColumnProp('onCellEditComplete');

      if (!submit && onCellEditCancel) {
        onCellEditCancel(params);
      }

      var valid = true;

      if (cellEditValidator) {
        valid = cellEditValidator(params);
      }

      if (valid) {
        if (submit && onCellEditComplete) {
          onCellEditComplete(params);
        }

        this.closeCell(event);
      } else {
        event.preventDefault();
      }
    }
  }, {
    key: "findNextSelectableCell",
    value: function findNextSelectableCell(cell) {
      var nextCell = cell.nextElementSibling;
      return nextCell ? DomHandler$1.hasClass(nextCell, 'p-selectable-cell') ? nextCell : this.findNextSelectableCell(nextCell) : null;
    }
  }, {
    key: "findPrevSelectableCell",
    value: function findPrevSelectableCell(cell) {
      var prevCell = cell.previousElementSibling;
      return prevCell ? DomHandler$1.hasClass(prevCell, 'p-selectable-cell') ? prevCell : this.findPrevSelectableCell(prevCell) : null;
    }
  }, {
    key: "findDownSelectableCell",
    value: function findDownSelectableCell(cell) {
      var downRow = cell.parentElement.nextElementSibling;
      var downCell = downRow ? downRow.children[this.props.index] : null;
      return downRow && downCell ? DomHandler$1.hasClass(downRow, 'p-selectable-row') && DomHandler$1.hasClass(downCell, 'p-selectable-cell') ? downCell : this.findDownSelectableCell(downCell) : null;
    }
  }, {
    key: "findUpSelectableCell",
    value: function findUpSelectableCell(cell) {
      var upRow = cell.parentElement.previousElementSibling;
      var upCell = upRow ? upRow.children[this.props.index] : null;
      return upRow && upCell ? DomHandler$1.hasClass(upRow, 'p-selectable-row') && DomHandler$1.hasClass(upCell, 'p-selectable-cell') ? upCell : this.findUpSelectableCell(upCell) : null;
    }
  }, {
    key: "changeTabIndex",
    value: function changeTabIndex(currentCell, nextCell) {
      if (currentCell && nextCell) {
        currentCell.tabIndex = -1;
        nextCell.tabIndex = this.props.tabIndex;
      }
    }
  }, {
    key: "focusOnElement",
    value: function focusOnElement() {
      var _this4 = this;

      clearTimeout(this.tabindexTimeout);
      this.tabindexTimeout = setTimeout(function () {
        if (_this4.state.editing) {
          var focusableEl = _this4.props.editMode === 'cell' ? DomHandler$1.getFirstFocusableElement(_this4.el, ':not(.p-cell-editor-key-helper)') : DomHandler$1.findSingle(_this4.el, '.p-row-editor-save');
          focusableEl && focusableEl.focus();
        }

        _this4.keyHelper && (_this4.keyHelper.tabIndex = _this4.state.editing ? -1 : 0);
      }, 1);
    }
  }, {
    key: "focusOnInit",
    value: function focusOnInit() {
      var _this5 = this;

      clearTimeout(this.initFocusTimeout);
      this.initFocusTimeout = setTimeout(function () {
        var focusableEl = _this5.props.editMode === 'row' ? DomHandler$1.findSingle(_this5.el, '.p-row-editor-init') : null;
        focusableEl && focusableEl.focus();
      }, 1);
    }
  }, {
    key: "updateStickyPosition",
    value: function updateStickyPosition() {
      if (this.getColumnProp('frozen')) {
        var styleObject = _objectSpread$7$1({}, this.state.styleObject);

        var align = this.getColumnProp('alignFrozen');

        if (align === 'right') {
          var right = 0;
          var next = this.el.nextElementSibling;

          if (next) {
            right = DomHandler$1.getOuterWidth(next) + parseFloat(next.style.right || 0);
          }

          styleObject['right'] = right + 'px';
        } else {
          var left = 0;
          var prev = this.el.previousElementSibling;

          if (prev) {
            left = DomHandler$1.getOuterWidth(prev) + parseFloat(prev.style.left || 0);
          }

          styleObject['left'] = left + 'px';
        }

        var isSameStyle = this.state.styleObject['left'] === styleObject['left'] && this.state.styleObject['right'] === styleObject['right'];
        !isSameStyle && this.setState({
          styleObject: styleObject
        });
      }
    }
  }, {
    key: "editorCallback",
    value: function editorCallback(val) {
      var editingRowData = _objectSpread$7$1({}, this.state.editingRowData);

      editingRowData[this.field] = val;
      this.setState({
        editingRowData: editingRowData
      }); // update editing meta for complete methods on row mode

      this.props.editingMeta[this.props.rowIndex].data[this.field] = val;
    }
  }, {
    key: "onClick",
    value: function onClick(event) {
      var _this6 = this;

      var params = this.getCellCallbackParams(event);

      if (this.props.editMode !== 'row' && this.isEditable() && !this.state.editing && (this.props.selectOnEdit || !this.props.selectOnEdit && this.props.selected)) {
        this.selfClick = true;
        var onBeforeCellEditShow = this.getColumnProp('onBeforeCellEditShow');
        var onCellEditInit = this.getColumnProp('onCellEditInit');
        var cellEditValidatorEvent = this.getColumnProp('cellEditValidatorEvent');

        if (onBeforeCellEditShow) {
          onBeforeCellEditShow(params);
        } // If the data is sorted using sort icon, it has been added to wait for the sort operation when any cell is wanted to be opened.


        setTimeout(function () {
          _this6.setState({
            editing: true
          }, function () {
            if (onCellEditInit) {
              onCellEditInit(params);
            }

            if (cellEditValidatorEvent === 'click') {
              _this6.bindDocumentEditListener();

              _this6.overlayEventListener = function (e) {
                if (!_this6.isOutsideClicked(e.target)) {
                  _this6.selfClick = true;
                }
              };

              OverlayService.on('overlay-click', _this6.overlayEventListener);
            }
          });
        }, 1);
      }

      if (this.props.allowCellSelection && this.props.onClick) {
        this.props.onClick(params);
      }
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event) {
      var params = this.getCellCallbackParams(event);

      if (this.props.onMouseDown) {
        this.props.onMouseDown(params);
      }
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(event) {
      var params = this.getCellCallbackParams(event);

      if (this.props.onMouseUp) {
        this.props.onMouseUp(params);
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (this.props.editMode !== 'row') {
        if (event.which === 13 || event.which === 9) {
          // tab || enter
          this.switchCellToViewMode(event, true);
        }

        if (event.which === 27) {
          // escape
          this.switchCellToViewMode(event, false);
        }
      }

      if (this.props.allowCellSelection) {
        var target = event.target,
            cell = event.currentTarget;

        switch (event.which) {
          //left arrow
          case 37:
            var prevCell = this.findPrevSelectableCell(cell);

            if (prevCell) {
              this.changeTabIndex(cell, prevCell);
              prevCell.focus();
            }

            event.preventDefault();
            break;
          //right arrow

          case 39:
            var nextCell = this.findNextSelectableCell(cell);

            if (nextCell) {
              this.changeTabIndex(cell, nextCell);
              nextCell.focus();
            }

            event.preventDefault();
            break;
          //up arrow

          case 38:
            var upCell = this.findUpSelectableCell(cell);

            if (upCell) {
              this.changeTabIndex(cell, upCell);
              upCell.focus();
            }

            event.preventDefault();
            break;
          //down arrow

          case 40:
            var downCell = this.findDownSelectableCell(cell);

            if (downCell) {
              this.changeTabIndex(cell, downCell);
              downCell.focus();
            }

            event.preventDefault();
            break;
          //enter

          case 13:
            // @deprecated
            if (!DomHandler$1.isClickable(target)) {
              this.onClick(event);
              event.preventDefault();
            }

            break;
          //space

          case 32:
            if (!DomHandler$1.isClickable(target) && !target.readOnly) {
              this.onClick(event);
              event.preventDefault();
            }

            break;
        }
      }
    }
  }, {
    key: "onBlur",
    value: function onBlur(event) {
      this.selfClick = false;

      if (this.props.editMode !== 'row' && this.state.editing && this.getColumnProp('cellEditValidatorEvent') === 'blur') {
        this.switchCellToViewMode(event, true);
      }
    }
  }, {
    key: "onEditorFocus",
    value: function onEditorFocus(event) {
      this.onClick(event);
    }
  }, {
    key: "onRadioChange",
    value: function onRadioChange(event) {
      this.props.onRadioChange({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.rowIndex
      });
    }
  }, {
    key: "onCheckboxChange",
    value: function onCheckboxChange(event) {
      this.props.onCheckboxChange({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.rowIndex
      });
    }
  }, {
    key: "onRowToggle",
    value: function onRowToggle(event) {
      this.props.onRowToggle({
        originalEvent: event,
        data: this.props.rowData
      });
      event.preventDefault();
    }
  }, {
    key: "onRowEditInit",
    value: function onRowEditInit(event) {
      this.props.onRowEditInit({
        originalEvent: event,
        data: this.props.rowData,
        newData: this.getEditingRowData(),
        field: this.field,
        index: this.props.rowIndex
      });
    }
  }, {
    key: "onRowEditSave",
    value: function onRowEditSave(event) {
      this.props.onRowEditSave({
        originalEvent: event,
        data: this.props.rowData,
        newData: this.getEditingRowData(),
        field: this.field,
        index: this.props.rowIndex
      });
      this.focusOnInit();
    }
  }, {
    key: "onRowEditCancel",
    value: function onRowEditCancel(event) {
      this.props.onRowEditCancel({
        originalEvent: event,
        data: this.props.rowData,
        newData: this.getEditingRowData(),
        field: this.field,
        index: this.props.rowIndex
      });
      this.focusOnInit();
    }
  }, {
    key: "bindDocumentEditListener",
    value: function bindDocumentEditListener() {
      var _this7 = this;

      if (!this.documentEditListener) {
        this.documentEditListener = function (e) {
          if (!_this7.selfClick && _this7.isOutsideClicked(e.target)) {
            _this7.switchCellToViewMode(e, true);
          }

          _this7.selfClick = false;
        };

        document.addEventListener('click', this.documentEditListener, true);
      }
    }
  }, {
    key: "unbindDocumentEditListener",
    value: function unbindDocumentEditListener() {
      if (this.documentEditListener) {
        document.removeEventListener('click', this.documentEditListener, true);
        this.documentEditListener = null;
        this.selfClick = false;
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.getColumnProp('frozen')) {
        this.updateStickyPosition();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.getColumnProp('frozen')) {
        this.updateStickyPosition();
      }

      if (this.props.editMode === 'cell' || this.props.editMode === 'row') {
        this.focusOnElement();

        if (prevProps.editingMeta !== this.props.editingMeta) {
          this.setState({
            editingRowData: this.getEditingRowData()
          });
        }

        if (prevState.editing !== this.state.editing) {
          var callbackParams = this.getCellCallbackParams();

          var params = _objectSpread$7$1(_objectSpread$7$1({}, callbackParams), {}, {
            editing: this.state.editing
          });

          this.props.onEditingMetaChange(params);
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindDocumentEditListener();

      if (this.overlayEventListener) {
        OverlayService.off('overlay-click', this.overlayEventListener);
        this.overlayEventListener = null;
      }
    }
  }, {
    key: "renderLoading",
    value: function renderLoading() {
      var options = this.getVirtualScrollerOption('getLoaderOptions')(this.props.rowIndex, {
        cellIndex: this.props.index,
        cellFirst: this.props.index === 0,
        cellLast: this.props.index === this.getVirtualScrollerOption('columns').length - 1,
        cellEven: this.props.index % 2 === 0,
        cellOdd: this.props.index % 2 !== 0,
        column: this.props.column,
        field: this.field
      });
      var content = ObjectUtils.getJSXElement(this.getVirtualScrollerOption('loadingTemplate'), options);
      return /*#__PURE__*/React.createElement("td", null, content);
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var _this8 = this;

      var content, editorKeyHelper;
      var cellSelected = this.props.allowCellSelection && this.isSelected();
      var isRowEditor = this.props.editMode === 'row';
      var tabIndex = this.getTabIndex(cellSelected);
      var selectionMode = this.getColumnProp('selectionMode');
      var rowReorder = this.getColumnProp('rowReorder');
      var expander = this.getColumnProp('expander');
      var rowEditor = this.getColumnProp('rowEditor');
      var header = this.getColumnProp('header');
      var body = this.getColumnProp('body');
      var editor = this.getColumnProp('editor');
      var frozen = this.getColumnProp('frozen');
      var align = this.getColumnProp('align');
      var value = this.resolveFieldData();
      var cellClassName = ObjectUtils.getPropValue(this.props.cellClassName, value, {
        props: this.props.tableProps,
        rowData: this.props.rowData,
        column: this.props.column
      });
      var className = classNames(this.getColumnProp('bodyClassName'), this.getColumnProp('className'), cellClassName, _defineProperty$q({
        'p-selection-column': selectionMode !== null,
        'p-editable-column': editor,
        'p-cell-editing': editor && this.state.editing,
        'p-frozen-column': frozen,
        'p-selectable-cell': this.props.allowCellSelection && this.props.isSelectable({
          data: this.getCellParams(),
          index: this.props.rowIndex
        }),
        'p-highlight': cellSelected
      }, "p-align-".concat(align), !!align));
      var style = this.getStyle();
      var title = this.props.responsiveLayout === 'stack' && /*#__PURE__*/React.createElement("span", {
        className: "p-column-title"
      }, ObjectUtils.getJSXElement(header, {
        props: this.props.tableProps
      }));

      if (selectionMode) {
        var showSelection = this.props.showSelectionElement ? this.props.showSelectionElement(this.props.rowData, {
          rowIndex: this.props.rowIndex,
          props: this.props.tableProps
        }) : true;
        content = showSelection && /*#__PURE__*/React.createElement(React.Fragment, null, selectionMode === 'single' && /*#__PURE__*/React.createElement(RowRadioButton, {
          checked: this.props.selected,
          onChange: this.onRadioChange,
          tabIndex: this.props.tabIndex,
          tableSelector: this.props.tableSelector
        }), selectionMode === 'multiple' && /*#__PURE__*/React.createElement(RowCheckbox, {
          checked: this.props.selected,
          onChange: this.onCheckboxChange,
          tabIndex: this.props.tabIndex
        }));
      } else if (rowReorder) {
        var showReorder = this.props.showRowReorderElement ? this.props.showRowReorderElement(this.props.rowData, {
          rowIndex: this.props.rowIndex,
          props: this.props.tableProps
        }) : true;
        content = showReorder && /*#__PURE__*/React.createElement("i", {
          className: classNames('p-datatable-reorderablerow-handle', this.getColumnProp('rowReorderIcon'))
        });
      } else if (expander) {
        var iconClassName = classNames('p-row-toggler-icon', this.props.expanded ? this.props.expandedRowIcon : this.props.collapsedRowIcon);
        var ariaControls = "".concat(this.props.tableSelector, "_content_").concat(this.props.rowIndex, "_expanded");
        var expanderProps = {
          onClick: this.onRowToggle,
          className: 'p-row-toggler p-link',
          iconClassName: iconClassName
        };
        content = /*#__PURE__*/React.createElement("button", {
          className: expanderProps.className,
          onClick: expanderProps.onClick,
          type: "button",
          "aria-expanded": this.props.expanded,
          "aria-controls": ariaControls,
          tabIndex: this.props.tabIndex
        }, /*#__PURE__*/React.createElement("span", {
          className: expanderProps.iconClassName
        }), /*#__PURE__*/React.createElement(Ripple, null));

        if (body) {
          expanderProps['element'] = content;
          content = ObjectUtils.getJSXElement(body, this.props.rowData, {
            column: this.props.column,
            field: this.field,
            rowIndex: this.props.rowIndex,
            frozenRow: this.props.frozenRow,
            props: this.props.tableProps,
            expander: expanderProps
          });
        }
      } else if (isRowEditor && rowEditor) {
        var rowEditorProps = {};

        if (this.state.editing) {
          rowEditorProps = {
            editing: true,
            onSaveClick: this.onRowEditSave,
            saveClassName: 'p-row-editor-save p-link',
            saveIconClassName: 'p-row-editor-save-icon pi pi-fw pi-check',
            onCancelClick: this.onRowEditCancel,
            cancelClassName: 'p-row-editor-cancel p-link',
            cancelIconClassName: 'p-row-editor-cancel-icon pi pi-fw pi-times'
          };
          content = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("button", {
            type: "button",
            onClick: rowEditorProps.onSaveClick,
            className: rowEditorProps.saveClassName,
            tabIndex: this.props.tabIndex
          }, /*#__PURE__*/React.createElement("span", {
            className: rowEditorProps.saveIconClassName
          }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("button", {
            type: "button",
            onClick: rowEditorProps.onCancelClick,
            className: rowEditorProps.cancelClassName,
            tabIndex: this.props.tabIndex
          }, /*#__PURE__*/React.createElement("span", {
            className: rowEditorProps.cancelIconClassName
          }), /*#__PURE__*/React.createElement(Ripple, null)));
        } else {
          rowEditorProps = {
            editing: false,
            onInitClick: this.onRowEditInit,
            initClassName: 'p-row-editor-init p-link',
            initIconClassName: 'p-row-editor-init-icon pi pi-fw pi-pencil'
          };
          content = /*#__PURE__*/React.createElement("button", {
            type: "button",
            onClick: rowEditorProps.onInitClick,
            className: rowEditorProps.initClassName,
            tabIndex: this.props.tabIndex
          }, /*#__PURE__*/React.createElement("span", {
            className: rowEditorProps.initIconClassName
          }), /*#__PURE__*/React.createElement(Ripple, null));
        }

        if (body) {
          rowEditorProps['element'] = content;
          content = ObjectUtils.getJSXElement(body, this.props.rowData, {
            column: this.props.column,
            field: this.field,
            rowIndex: this.props.rowIndex,
            frozenRow: this.props.frozenRow,
            props: this.props.tableProps,
            rowEditor: rowEditorProps
          });
        }
      } else if (body && !this.state.editing) {
        content = body ? ObjectUtils.getJSXElement(body, this.props.rowData, {
          column: this.props.column,
          field: this.field,
          rowIndex: this.props.rowIndex,
          frozenRow: this.props.frozenRow,
          props: this.props.tableProps
        }) : value;
      } else if (editor && this.state.editing) {
        content = ObjectUtils.getJSXElement(editor, {
          rowData: this.state.editingRowData,
          value: this.resolveFieldData(this.state.editingRowData),
          column: this.props.column,
          field: this.field,
          rowIndex: this.props.rowIndex,
          frozenRow: this.props.frozenRow,
          props: this.props.tableProps,
          editorCallback: this.editorCallback
        });
      } else {
        content = value;
      }

      if (!isRowEditor && editor) {
        /* eslint-disable */
        editorKeyHelper = /*#__PURE__*/React.createElement("a", {
          tabIndex: "0",
          ref: function ref(el) {
            return _this8.keyHelper = el;
          },
          className: "p-cell-editor-key-helper p-hidden-accessible",
          onFocus: this.onEditorFocus
        }, /*#__PURE__*/React.createElement("span", null));
        /* eslint-enable */
      }

      return /*#__PURE__*/React.createElement("td", {
        ref: function ref(el) {
          return _this8.el = el;
        },
        style: style,
        className: className,
        rowSpan: this.props.rowSpan,
        tabIndex: tabIndex,
        role: "cell",
        onClick: this.onClick,
        onKeyDown: this.onKeyDown,
        onBlur: this.onBlur,
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp
      }, editorKeyHelper, title, content);
    }
  }, {
    key: "render",
    value: function render() {
      return this.getVirtualScrollerOption('loading') ? this.renderLoading() : this.renderElement();
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.editMode === 'row' && nextProps.editing !== prevState.editing) {
        return {
          editing: nextProps.editing
        };
      }

      return null;
    }
  }]);

  return BodyCell;
}(Component);

function ownKeys$6$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$6$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6$1(Object(source), !0).forEach(function (key) {
      _defineProperty$q(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$9$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$9$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var BodyRow = /*#__PURE__*/function (_Component) {
  _inherits$q(BodyRow, _Component);

  var _super = _createSuper$9$1(BodyRow);

  function BodyRow(props) {
    var _this;

    _classCallCheck$q(this, BodyRow);

    _this = _super.call(this, props);

    if (!_this.props.onRowEditChange) {
      _this.state = {
        editing: false
      };
    }

    _this.onClick = _this.onClick.bind(_assertThisInitialized$p(_this));
    _this.onDoubleClick = _this.onDoubleClick.bind(_assertThisInitialized$p(_this));
    _this.onRightClick = _this.onRightClick.bind(_assertThisInitialized$p(_this));
    _this.onTouchEnd = _this.onTouchEnd.bind(_assertThisInitialized$p(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$p(_this));
    _this.onMouseDown = _this.onMouseDown.bind(_assertThisInitialized$p(_this));
    _this.onMouseUp = _this.onMouseUp.bind(_assertThisInitialized$p(_this));
    _this.onDragStart = _this.onDragStart.bind(_assertThisInitialized$p(_this));
    _this.onDragEnd = _this.onDragEnd.bind(_assertThisInitialized$p(_this));
    _this.onDragOver = _this.onDragOver.bind(_assertThisInitialized$p(_this));
    _this.onDragLeave = _this.onDragLeave.bind(_assertThisInitialized$p(_this));
    _this.onDrop = _this.onDrop.bind(_assertThisInitialized$p(_this));
    _this.onEditInit = _this.onEditInit.bind(_assertThisInitialized$p(_this));
    _this.onEditSave = _this.onEditSave.bind(_assertThisInitialized$p(_this));
    _this.onEditCancel = _this.onEditCancel.bind(_assertThisInitialized$p(_this));
    return _this;
  }

  _createClass$q(BodyRow, [{
    key: "isFocusable",
    value: function isFocusable() {
      return this.props.selectionMode && this.props.selectionModeInColumn !== 'single' && this.props.selectionModeInColumn !== 'multiple';
    }
  }, {
    key: "isGrouped",
    value: function isGrouped(column) {
      if (this.props.groupRowsBy && this.getColumnProp(column, 'field')) {
        if (Array.isArray(this.props.groupRowsBy)) return this.props.groupRowsBy.indexOf(column.props.field) > -1;else return this.props.groupRowsBy === column.props.field;
      }

      return false;
    }
  }, {
    key: "equals",
    value: function equals(data1, data2) {
      return this.props.compareSelectionBy === 'equals' ? data1 === data2 : ObjectUtils.equals(data1, data2, this.props.dataKey);
    }
  }, {
    key: "getColumnProp",
    value: function getColumnProp(col, prop) {
      return col ? col.props[prop] : null;
    }
  }, {
    key: "getEditing",
    value: function getEditing() {
      return this.props.onRowEditChange ? this.props.editing : this.state.editing;
    }
  }, {
    key: "getTabIndex",
    value: function getTabIndex() {
      return this.isFocusable() && !this.props.allowCellSelection ? this.props.index === 0 ? this.props.tabIndex : -1 : null;
    }
  }, {
    key: "findIndex",
    value: function findIndex(collection, rowData) {
      var _this2 = this;

      return (collection || []).findIndex(function (data) {
        return _this2.equals(rowData, data);
      });
    }
  }, {
    key: "changeTabIndex",
    value: function changeTabIndex(currentRow, nextRow) {
      if (currentRow && nextRow) {
        currentRow.tabIndex = -1;
        nextRow.tabIndex = this.props.tabIndex;
      }
    }
  }, {
    key: "findNextSelectableRow",
    value: function findNextSelectableRow(row) {
      var nextRow = row.nextElementSibling;
      return nextRow ? DomHandler$1.hasClass(nextRow, 'p-selectable-row') ? nextRow : this.findNextSelectableRow(nextRow) : null;
    }
  }, {
    key: "findPrevSelectableRow",
    value: function findPrevSelectableRow(row) {
      var prevRow = row.previousElementSibling;
      return prevRow ? DomHandler$1.hasClass(prevRow, 'p-selectable-row') ? prevRow : this.findPrevSelectableRow(prevRow) : null;
    }
  }, {
    key: "shouldRenderBodyCell",
    value: function shouldRenderBodyCell(value, column, i) {
      if (this.getColumnProp(column, 'hidden')) {
        return false;
      } else if (this.props.rowGroupMode && this.props.rowGroupMode === 'rowspan' && this.isGrouped(column)) {
        var prevRowData = value[i - 1];

        if (prevRowData) {
          var currentRowFieldData = ObjectUtils.resolveFieldData(value[i], this.getColumnProp(column, 'field'));
          var previousRowFieldData = ObjectUtils.resolveFieldData(prevRowData, this.getColumnProp(column, 'field'));
          return currentRowFieldData !== previousRowFieldData;
        }
      }

      return true;
    }
  }, {
    key: "calculateRowGroupSize",
    value: function calculateRowGroupSize(value, column, index) {
      if (this.isGrouped(column)) {
        var currentRowFieldData = ObjectUtils.resolveFieldData(value[index], this.getColumnProp(column, 'field'));
        var nextRowFieldData = currentRowFieldData;
        var groupRowSpan = 0;

        while (currentRowFieldData === nextRowFieldData) {
          groupRowSpan++;
          var nextRowData = value[++index];

          if (nextRowData) {
            nextRowFieldData = ObjectUtils.resolveFieldData(nextRowData, this.getColumnProp(column, 'field'));
          } else {
            break;
          }
        }

        return groupRowSpan === 1 ? null : groupRowSpan;
      } else {
        return null;
      }
    }
  }, {
    key: "onClick",
    value: function onClick(event) {
      this.props.onRowClick({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.index
      });
    }
  }, {
    key: "onDoubleClick",
    value: function onDoubleClick(event) {
      this.props.onRowDoubleClick({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.index
      });
    }
  }, {
    key: "onRightClick",
    value: function onRightClick(event) {
      this.props.onRowRightClick({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.index
      });
    }
  }, {
    key: "onTouchEnd",
    value: function onTouchEnd(event) {
      this.props.onRowTouchEnd(event);
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (this.isFocusable() && !this.props.allowCellSelection) {
        var target = event.target,
            row = event.currentTarget;

        switch (event.which) {
          //down arrow
          case 40:
            var nextRow = this.findNextSelectableRow(row);

            if (nextRow) {
              this.changeTabIndex(row, nextRow);
              nextRow.focus();
            }

            event.preventDefault();
            break;
          //up arrow

          case 38:
            var prevRow = this.findPrevSelectableRow(row);

            if (prevRow) {
              this.changeTabIndex(row, prevRow);
              prevRow.focus();
            }

            event.preventDefault();
            break;
          //enter

          case 13:
            // @deprecated
            if (!DomHandler$1.isClickable(target)) {
              this.onClick(event);
              event.preventDefault();
            }

            break;
          //space

          case 32:
            if (!DomHandler$1.isClickable(target) && !target.readOnly) {
              this.onClick(event);
              event.preventDefault();
            }

            break;
        }
      }
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event) {
      this.props.onRowMouseDown({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.index
      });
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(event) {
      this.props.onRowMouseUp({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.index
      });
    }
  }, {
    key: "onDragStart",
    value: function onDragStart(event) {
      this.props.onRowDragStart({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.index
      });
    }
  }, {
    key: "onDragOver",
    value: function onDragOver(event) {
      this.props.onRowDragOver({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.index
      });
    }
  }, {
    key: "onDragLeave",
    value: function onDragLeave(event) {
      this.props.onRowDragLeave({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.index
      });
    }
  }, {
    key: "onDragEnd",
    value: function onDragEnd(event) {
      this.props.onRowDragEnd({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.index
      });
    }
  }, {
    key: "onDrop",
    value: function onDrop(event) {
      this.props.onRowDrop({
        originalEvent: event,
        data: this.props.rowData,
        index: this.props.index
      });
    }
  }, {
    key: "onEditChange",
    value: function onEditChange(e, editing) {
      if (this.props.onRowEditChange) {
        var editingRows;
        var dataKey = this.props.dataKey;
        var originalEvent = e.originalEvent,
            data = e.data,
            index = e.index;

        if (dataKey) {
          var dataKeyValue = String(ObjectUtils.resolveFieldData(data, dataKey));
          editingRows = this.props.editingRows ? _objectSpread$6$1({}, this.props.editingRows) : {};
          if (editingRows[dataKeyValue] != null) delete editingRows[dataKeyValue];else editingRows[dataKeyValue] = true;
        } else {
          var editingRowIndex = this.findIndex(this.props.editingRows, data);
          editingRows = this.props.editingRows ? _toConsumableArray$a(this.props.editingRows) : [];
          if (editingRowIndex !== -1) editingRows = editingRows.filter(function (val, i) {
            return i !== editingRowIndex;
          });else editingRows.push(data);
        }

        this.props.onRowEditChange({
          originalEvent: originalEvent,
          data: editingRows,
          index: index
        });
      } else {
        this.setState({
          editing: editing
        });
      }
    }
  }, {
    key: "onEditInit",
    value: function onEditInit(e) {
      var event = e.originalEvent;

      if (this.props.onRowEditInit) {
        this.props.onRowEditInit({
          originalEvent: event,
          data: this.props.rowData,
          index: this.props.index
        });
      }

      this.onEditChange(e, true);
      event.preventDefault();
    }
  }, {
    key: "onEditSave",
    value: function onEditSave(e) {
      var event = e.originalEvent;
      var valid = this.props.rowEditValidator ? this.props.rowEditValidator(this.props.rowData, {
        props: this.props.tableProps
      }) : true;

      if (this.props.onRowEditSave) {
        this.props.onRowEditSave({
          originalEvent: event,
          data: this.props.rowData,
          index: this.props.index,
          valid: valid
        });
      }

      if (valid) {
        if (this.props.onRowEditComplete) {
          this.props.onRowEditComplete(e);
        }

        this.onEditChange(e, false);
      }

      event.preventDefault();
    }
  }, {
    key: "onEditCancel",
    value: function onEditCancel(e) {
      var event = e.originalEvent;

      if (this.props.onRowEditCancel) {
        this.props.onRowEditCancel({
          originalEvent: event,
          data: this.props.rowData,
          index: this.props.index
        });
      }

      this.onEditChange(e, false);
      event.preventDefault();
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this3 = this;

      return this.props.columns.map(function (col, i) {
        if (_this3.shouldRenderBodyCell(_this3.props.value, col, _this3.props.index)) {
          var key = "".concat(_this3.getColumnProp(col, 'columnKey') || _this3.getColumnProp(col, 'field'), "_").concat(i);
          var rowSpan = _this3.props.rowGroupMode === 'rowspan' ? _this3.calculateRowGroupSize(_this3.props.value, col, _this3.props.index) : null;

          var editing = _this3.getEditing();

          return /*#__PURE__*/React.createElement(BodyCell, {
            key: key,
            value: _this3.props.value,
            tableProps: _this3.props.tableProps,
            tableSelector: _this3.props.tableSelector,
            column: col,
            rowData: _this3.props.rowData,
            rowIndex: _this3.props.index,
            index: i,
            rowSpan: rowSpan,
            dataKey: _this3.props.dataKey,
            editing: editing,
            editingMeta: _this3.props.editingMeta,
            editMode: _this3.props.editMode,
            onRowEditInit: _this3.onEditInit,
            onRowEditSave: _this3.onEditSave,
            onRowEditCancel: _this3.onEditCancel,
            onEditingMetaChange: _this3.props.onEditingMetaChange,
            onRowToggle: _this3.props.onRowToggle,
            selection: _this3.props.selection,
            allowCellSelection: _this3.props.allowCellSelection,
            compareSelectionBy: _this3.props.compareSelectionBy,
            selectOnEdit: _this3.props.selectOnEdit,
            selected: _this3.props.selected,
            onClick: _this3.props.onCellClick,
            onMouseDown: _this3.props.onCellMouseDown,
            onMouseUp: _this3.props.onCellMouseUp,
            tabIndex: _this3.props.tabIndex,
            cellClassName: _this3.props.cellClassName,
            responsiveLayout: _this3.props.responsiveLayout,
            frozenRow: _this3.props.frozenRow,
            isSelectable: _this3.props.isSelectable,
            showSelectionElement: _this3.props.showSelectionElement,
            showRowReorderElement: _this3.props.showRowReorderElement,
            onRadioChange: _this3.props.onRadioChange,
            onCheckboxChange: _this3.props.onCheckboxChange,
            expanded: _this3.props.expanded,
            expandedRowIcon: _this3.props.expandedRowIcon,
            collapsedRowIcon: _this3.props.collapsedRowIcon,
            virtualScrollerOptions: _this3.props.virtualScrollerOptions
          });
        }

        return null;
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var rowClassName = ObjectUtils.getPropValue(this.props.rowClassName, this.props.rowData, {
        props: this.props.tableProps
      });
      var className = classNames(rowClassName, {
        'p-highlight': !this.props.allowCellSelection && this.props.selected,
        'p-highlight-contextmenu': this.props.contextMenuSelected,
        'p-selectable-row': this.props.allowRowSelection && this.props.isSelectable({
          data: this.props.rowData,
          index: this.props.index
        }),
        'p-row-odd': this.props.index % 2 !== 0
      });
      var content = this.renderContent();
      var tabIndex = this.getTabIndex();
      return /*#__PURE__*/React.createElement("tr", {
        ref: function ref(el) {
          return _this4.el = el;
        },
        role: "row",
        tabIndex: tabIndex,
        className: className,
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        onClick: this.onClick,
        onDoubleClick: this.onDoubleClick,
        onContextMenu: this.onRightClick,
        onTouchEnd: this.onTouchEnd,
        onKeyDown: this.onKeyDown,
        onDragStart: this.onDragStart,
        onDragOver: this.onDragOver,
        onDragLeave: this.onDragLeave,
        onDragEnd: this.onDragEnd,
        onDrop: this.onDrop
      }, content);
    }
  }]);

  return BodyRow;
}(Component);

function _createSuper$8$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$8$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var RowTogglerButton = /*#__PURE__*/function (_Component) {
  _inherits$q(RowTogglerButton, _Component);

  var _super = _createSuper$8$1(RowTogglerButton);

  function RowTogglerButton(props) {
    var _this;

    _classCallCheck$q(this, RowTogglerButton);

    _this = _super.call(this, props);
    _this.onClick = _this.onClick.bind(_assertThisInitialized$p(_this));
    return _this;
  }

  _createClass$q(RowTogglerButton, [{
    key: "onClick",
    value: function onClick(event) {
      this.props.onClick({
        originalEvent: event,
        data: this.props.rowData
      });
    }
  }, {
    key: "render",
    value: function render() {
      var iconClassName = classNames('p-row-toggler-icon', this.props.expanded ? this.props.expandedRowIcon : this.props.collapsedRowIcon);
      return /*#__PURE__*/React.createElement("button", {
        type: "button",
        onClick: this.onClick,
        className: "p-row-toggler p-link",
        tabIndex: this.props.tabIndex
      }, /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }
  }]);

  return RowTogglerButton;
}(Component);

var _excluded$4 = ["originalEvent"];

function ownKeys$5$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$5$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5$1(Object(source), !0).forEach(function (key) {
      _defineProperty$q(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$7$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$7$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TableBody = /*#__PURE__*/function (_Component) {
  _inherits$q(TableBody, _Component);

  var _super = _createSuper$7$1(TableBody);

  function TableBody(props) {
    var _this;

    _classCallCheck$q(this, TableBody);

    _this = _super.call(this, props);
    _this.state = {
      rowGroupHeaderStyleObject: {}
    }; // row

    _this.onRowClick = _this.onRowClick.bind(_assertThisInitialized$p(_this));
    _this.onRowDoubleClick = _this.onRowDoubleClick.bind(_assertThisInitialized$p(_this));
    _this.onRowRightClick = _this.onRowRightClick.bind(_assertThisInitialized$p(_this));
    _this.onRowTouchEnd = _this.onRowTouchEnd.bind(_assertThisInitialized$p(_this));
    _this.onRowMouseDown = _this.onRowMouseDown.bind(_assertThisInitialized$p(_this));
    _this.onRowMouseUp = _this.onRowMouseUp.bind(_assertThisInitialized$p(_this));
    _this.onRowToggle = _this.onRowToggle.bind(_assertThisInitialized$p(_this)); // drag

    _this.onRowDragStart = _this.onRowDragStart.bind(_assertThisInitialized$p(_this));
    _this.onRowDragOver = _this.onRowDragOver.bind(_assertThisInitialized$p(_this));
    _this.onRowDragLeave = _this.onRowDragLeave.bind(_assertThisInitialized$p(_this));
    _this.onRowDragEnd = _this.onRowDragEnd.bind(_assertThisInitialized$p(_this));
    _this.onRowDrop = _this.onRowDrop.bind(_assertThisInitialized$p(_this)); // selection

    _this.onRadioChange = _this.onRadioChange.bind(_assertThisInitialized$p(_this));
    _this.onCheckboxChange = _this.onCheckboxChange.bind(_assertThisInitialized$p(_this));
    _this.onDragSelectionMouseMove = _this.onDragSelectionMouseMove.bind(_assertThisInitialized$p(_this));
    _this.onDragSelectionMouseUp = _this.onDragSelectionMouseUp.bind(_assertThisInitialized$p(_this));
    _this.isSelectable = _this.isSelectable.bind(_assertThisInitialized$p(_this)); // cell

    _this.onCellClick = _this.onCellClick.bind(_assertThisInitialized$p(_this));
    _this.onCellMouseDown = _this.onCellMouseDown.bind(_assertThisInitialized$p(_this));
    _this.onCellMouseUp = _this.onCellMouseUp.bind(_assertThisInitialized$p(_this));
    _this.ref = _this.ref.bind(_assertThisInitialized$p(_this));
    return _this;
  }

  _createClass$q(TableBody, [{
    key: "ref",
    value: function ref(el) {
      this.el = el;
      this.props.virtualScrollerContentRef && this.props.virtualScrollerContentRef(el);
    }
  }, {
    key: "equals",
    value: function equals(data1, data2) {
      if (this.allowCellSelection()) return (data1.rowIndex === data2.rowIndex || data1.rowData === data2.rowData) && (data1.field === data2.field || data1.cellIndex === data2.cellIndex);else return this.props.compareSelectionBy === 'equals' ? data1 === data2 : ObjectUtils.equals(data1, data2, this.props.dataKey);
    }
  }, {
    key: "isSubheaderGrouping",
    value: function isSubheaderGrouping() {
      return this.props.rowGroupMode && this.props.rowGroupMode === 'subheader';
    }
  }, {
    key: "isSelectionEnabled",
    value: function isSelectionEnabled() {
      return this.props.selectionMode || this.props.selectionModeInColumn !== null || this.props.columns && this.props.columns.some(function (col) {
        return col && !!col.props.selectionMode;
      });
    }
  }, {
    key: "isRadioSelectionMode",
    value: function isRadioSelectionMode() {
      return this.props.selectionMode === 'radiobutton';
    }
  }, {
    key: "isCheckboxSelectionMode",
    value: function isCheckboxSelectionMode() {
      return this.props.selectionMode === 'checkbox';
    }
  }, {
    key: "isRadioSelectionModeInColumn",
    value: function isRadioSelectionModeInColumn() {
      return this.props.selectionModeInColumn === 'single';
    }
  }, {
    key: "isCheckboxSelectionModeInColumn",
    value: function isCheckboxSelectionModeInColumn() {
      return this.props.selectionModeInColumn === 'multiple';
    }
  }, {
    key: "isSingleSelection",
    value: function isSingleSelection() {
      return this.props.selectionMode === 'single' && !this.isCheckboxSelectionModeInColumn() || !this.isRadioSelectionMode() && this.isRadioSelectionModeInColumn();
    }
  }, {
    key: "isMultipleSelection",
    value: function isMultipleSelection() {
      return this.props.selectionMode === 'multiple' && !this.isRadioSelectionModeInColumn() || this.isCheckboxSelectionModeInColumn();
    }
  }, {
    key: "isRadioOnlySelection",
    value: function isRadioOnlySelection() {
      return this.isRadioSelectionMode() && this.isRadioSelectionModeInColumn();
    }
  }, {
    key: "isCheckboxOnlySelection",
    value: function isCheckboxOnlySelection() {
      return this.isCheckboxSelectionMode() && this.isCheckboxSelectionModeInColumn();
    }
  }, {
    key: "isSelected",
    value: function isSelected(rowData) {
      if (rowData && this.props.selection) {
        return this.props.selection instanceof Array ? this.findIndex(this.props.selection, rowData) > -1 : this.equals(rowData, this.props.selection);
      }

      return false;
    }
  }, {
    key: "isContextMenuSelected",
    value: function isContextMenuSelected(rowData) {
      if (rowData && this.props.contextMenuSelection) {
        return this.equals(rowData, this.props.contextMenuSelection);
      }

      return false;
    }
  }, {
    key: "isSelectable",
    value: function isSelectable(options) {
      return this.props.isDataSelectable ? this.props.isDataSelectable(options) : true;
    }
  }, {
    key: "isRowExpanded",
    value: function isRowExpanded(rowData) {
      if (rowData && this.props.expandedRows) {
        if (this.isSubheaderGrouping() && this.props.expandableRowGroups) {
          return this.isRowGroupExpanded(rowData);
        } else {
          if (this.props.dataKey) return this.props.expandedRows ? this.props.expandedRows[ObjectUtils.resolveFieldData(rowData, this.props.dataKey)] !== undefined : false;else return this.findIndex(this.props.expandedRows, rowData) !== -1;
        }
      }

      return false;
    }
  }, {
    key: "isRowGroupExpanded",
    value: function isRowGroupExpanded(rowData) {
      var _this2 = this;

      if (this.props.dataKey === this.props.groupRowsBy) return Object.keys(this.props.expandedRows).some(function (data) {
        return ObjectUtils.equals(data, ObjectUtils.resolveFieldData(rowData, _this2.props.dataKey));
      });else return this.props.expandedRows.some(function (data) {
        return ObjectUtils.equals(data, rowData, _this2.props.groupRowsBy);
      });
    }
  }, {
    key: "isRowEditing",
    value: function isRowEditing(rowData) {
      if (this.props.editMode === 'row' && rowData && this.props.editingRows) {
        if (this.props.dataKey) return this.props.editingRows ? this.props.editingRows[ObjectUtils.resolveFieldData(rowData, this.props.dataKey)] !== undefined : false;else return this.findIndex(this.props.editingRows, rowData) !== -1;
      }

      return false;
    }
  }, {
    key: "allowDrag",
    value: function allowDrag(event) {
      return this.props.dragSelection && this.isMultipleSelection() && !event.originalEvent.shiftKey;
    }
  }, {
    key: "allowRowDrag",
    value: function allowRowDrag(event) {
      return !this.allowCellSelection() && this.allowDrag(event);
    }
  }, {
    key: "allowCellDrag",
    value: function allowCellDrag(event) {
      return this.allowCellSelection() && this.allowDrag(event);
    }
  }, {
    key: "allowSelection",
    value: function allowSelection(event) {
      return !DomHandler$1.isClickable(event.originalEvent.target);
    }
  }, {
    key: "allowMetaKeySelection",
    value: function allowMetaKeySelection(event) {
      return !this.rowTouched && (!this.props.metaKeySelection || this.props.metaKeySelection && (event.originalEvent.metaKey || event.originalEvent.ctrlKey));
    }
  }, {
    key: "allowRangeSelection",
    value: function allowRangeSelection(event) {
      return this.isMultipleSelection() && event.originalEvent.shiftKey && this.anchorRowIndex !== null;
    }
  }, {
    key: "allowRowSelection",
    value: function allowRowSelection() {
      return (this.props.selectionMode || this.props.selectionModeInColumn) && !this.isRadioOnlySelection() && !this.isCheckboxOnlySelection();
    }
  }, {
    key: "allowCellSelection",
    value: function allowCellSelection() {
      return this.props.cellSelection && !this.isRadioSelectionModeInColumn() && !this.isCheckboxSelectionModeInColumn();
    }
  }, {
    key: "getColumnsLength",
    value: function getColumnsLength() {
      return this.props.columns ? this.props.columns.length : 0;
    }
  }, {
    key: "getVirtualScrollerOption",
    value: function getVirtualScrollerOption(option, options) {
      options = options || this.props.virtualScrollerOptions;
      return options ? options[option] : null;
    }
  }, {
    key: "findIndex",
    value: function findIndex(collection, rowData) {
      var _this3 = this;

      return (collection || []).findIndex(function (data) {
        return _this3.equals(rowData, data);
      });
    }
  }, {
    key: "rowGroupHeaderStyle",
    value: function rowGroupHeaderStyle() {
      if (this.props.scrollable) {
        return {
          top: this.state.rowGroupHeaderStyleObject['top']
        };
      }

      return null;
    }
  }, {
    key: "getRowKey",
    value: function getRowKey(rowData, index) {
      return this.props.dataKey ? ObjectUtils.resolveFieldData(rowData, this.props.dataKey) + '_' + index : index;
    }
  }, {
    key: "shouldRenderRowGroupHeader",
    value: function shouldRenderRowGroupHeader(value, rowData, i) {
      var currentRowFieldData = ObjectUtils.resolveFieldData(rowData, this.props.groupRowsBy);
      var prevRowData = value[i - 1];

      if (prevRowData) {
        var previousRowFieldData = ObjectUtils.resolveFieldData(prevRowData, this.props.groupRowsBy);
        return currentRowFieldData !== previousRowFieldData;
      } else {
        return true;
      }
    }
  }, {
    key: "shouldRenderRowGroupFooter",
    value: function shouldRenderRowGroupFooter(value, rowData, i, expanded) {
      if (this.props.expandableRowGroups && !expanded) {
        return false;
      } else {
        var currentRowFieldData = ObjectUtils.resolveFieldData(rowData, this.props.groupRowsBy);
        var nextRowData = value[i + 1];

        if (nextRowData) {
          var nextRowFieldData = ObjectUtils.resolveFieldData(nextRowData, this.props.groupRowsBy);
          return currentRowFieldData !== nextRowFieldData;
        } else {
          return true;
        }
      }
    }
  }, {
    key: "updateFrozenRowStickyPosition",
    value: function updateFrozenRowStickyPosition() {
      this.el.style.top = DomHandler$1.getOuterHeight(this.el.previousElementSibling) + 'px';
    }
  }, {
    key: "updateFrozenRowGroupHeaderStickyPosition",
    value: function updateFrozenRowGroupHeaderStickyPosition() {
      var tableHeaderHeight = DomHandler$1.getOuterHeight(this.el.previousElementSibling);
      var top = tableHeaderHeight + 'px';

      if (this.state.rowGroupHeaderStyleObject && this.state.rowGroupHeaderStyleObject.top !== top) {
        this.setState({
          rowGroupHeaderStyleObject: {
            top: top
          }
        });
      }
    }
  }, {
    key: "updateVirtualScrollerPosition",
    value: function updateVirtualScrollerPosition() {
      var tableHeaderHeight = DomHandler$1.getOuterHeight(this.el.previousElementSibling);
      this.el.style.top = (this.el.style.top || 0) + tableHeaderHeight + 'px';
    }
  }, {
    key: "onSingleSelection",
    value: function onSingleSelection(_ref) {
      var originalEvent = _ref.originalEvent,
          data = _ref.data,
          index = _ref.index,
          toggleable = _ref.toggleable,
          type = _ref.type;

      if (!this.isSelectable({
        data: data,
        index: index
      })) {
        return;
      }

      var selected = this.isSelected(data);
      var selection = this.props.selection;

      if (selected) {
        if (toggleable) {
          selection = null;
          this.onUnselect({
            originalEvent: originalEvent,
            data: data,
            type: type
          });
        }
      } else {
        selection = data;
        this.onSelect({
          originalEvent: originalEvent,
          data: data,
          type: type
        });
      }

      this.focusOnElement(originalEvent, true);

      if (this.props.onSelectionChange && selection !== this.props.selection) {
        this.props.onSelectionChange({
          originalEvent: originalEvent,
          value: selection,
          type: type
        });
      }
    }
  }, {
    key: "onMultipleSelection",
    value: function onMultipleSelection(_ref2) {
      var _this4 = this;

      var originalEvent = _ref2.originalEvent,
          data = _ref2.data,
          index = _ref2.index,
          toggleable = _ref2.toggleable,
          type = _ref2.type;

      if (!this.isSelectable({
        data: data,
        index: index
      })) {
        return;
      }

      var selected = this.isSelected(data);
      var selection = this.props.selection || [];

      if (selected) {
        if (toggleable) {
          var selectionIndex = this.findIndex(selection, data);
          selection = this.props.selection.filter(function (val, i) {
            return i !== selectionIndex;
          });
          this.onUnselect({
            originalEvent: originalEvent,
            data: data,
            type: type
          });
        } else if (selection.length) {
          this.props.selection.forEach(function (d) {
            return _this4.onUnselect({
              originalEvent: originalEvent,
              data: d,
              type: type
            });
          });
          selection = [data];
          this.onSelect({
            originalEvent: originalEvent,
            data: data,
            type: type
          });
        }
      } else {
        selection = toggleable && this.isMultipleSelection() ? [].concat(_toConsumableArray$a(selection), [data]) : [data];
        this.onSelect({
          originalEvent: originalEvent,
          data: data,
          type: type
        });
      }

      this.focusOnElement(originalEvent, true);

      if (this.props.onSelectionChange && selection !== this.props.selection) {
        this.props.onSelectionChange({
          originalEvent: originalEvent,
          value: selection,
          type: type
        });
      }
    }
  }, {
    key: "onRangeSelection",
    value: function onRangeSelection(event, type) {
      DomHandler$1.clearSelection();
      this.rangeRowIndex = this.allowCellSelection() ? event.rowIndex : event.index;
      var selectionInRange = this.selectRange(event);
      var selection = this.isMultipleSelection() ? _toConsumableArray$a(new Set([].concat(_toConsumableArray$a(this.props.selection || []), _toConsumableArray$a(selectionInRange)))) : selectionInRange;

      if (this.props.onSelectionChange && selection !== this.props.selection) {
        this.props.onSelectionChange({
          originalEvent: event.originalEvent,
          value: selection,
          type: type
        });
      }

      this.anchorRowIndex = this.rangeRowIndex;
      this.anchorCellIndex = event.cellIndex;
      this.focusOnElement(event.originalEvent, false);
    }
  }, {
    key: "selectRange",
    value: function selectRange(event) {
      var rangeStart, rangeEnd;

      if (this.rangeRowIndex > this.anchorRowIndex) {
        rangeStart = this.anchorRowIndex;
        rangeEnd = this.rangeRowIndex;
      } else if (this.rangeRowIndex < this.anchorRowIndex) {
        rangeStart = this.rangeRowIndex;
        rangeEnd = this.anchorRowIndex;
      } else {
        rangeStart = rangeEnd = this.rangeRowIndex;
      }

      if (this.props.paginator) {
        rangeStart = Math.max(rangeStart - this.props.first, 0);
        rangeEnd -= this.props.first;
      }

      return this.allowCellSelection() ? this.selectRangeOnCell(event, rangeStart, rangeEnd) : this.selectRangeOnRow(event, rangeStart, rangeEnd);
    }
  }, {
    key: "selectRangeOnRow",
    value: function selectRangeOnRow(event, rowRangeStart, rowRangeEnd) {
      var value = this.props.value;
      var selection = [];

      for (var i = rowRangeStart; i <= rowRangeEnd; i++) {
        var rangeRowData = value[i];

        if (!this.isSelectable({
          data: rangeRowData,
          index: i
        })) {
          continue;
        }

        selection.push(rangeRowData);
        this.onSelect({
          originalEvent: event.originalEvent,
          data: rangeRowData,
          type: 'row'
        });
      }

      return selection;
    }
  }, {
    key: "selectRangeOnCell",
    value: function selectRangeOnCell(event, rowRangeStart, rowRangeEnd) {
      var cellRangeStart,
          cellRangeEnd,
          cellIndex = event.cellIndex;

      if (cellIndex > this.anchorCellIndex) {
        cellRangeStart = this.anchorCellIndex;
        cellRangeEnd = cellIndex;
      } else if (cellIndex < this.anchorCellIndex) {
        cellRangeStart = cellIndex;
        cellRangeEnd = this.anchorCellIndex;
      } else {
        cellRangeStart = cellRangeEnd = cellIndex;
      }

      var value = this.props.value;
      var selection = [];

      for (var i = rowRangeStart; i <= rowRangeEnd; i++) {
        var rowData = value[i];
        var columns = this.props.columns;

        for (var j = cellRangeStart; j <= cellRangeEnd; j++) {
          var field = columns[j].props.field;

          var _value = ObjectUtils.resolveFieldData(rowData, field);

          var rangeRowData = {
            value: _value,
            field: field,
            rowData: rowData,
            rowIndex: i,
            cellIndex: j,
            selected: true
          };

          if (!this.isSelectable({
            data: rangeRowData,
            index: i
          })) {
            continue;
          }

          selection.push(rangeRowData);
          this.onSelect({
            originalEvent: event.originalEvent,
            data: rangeRowData,
            type: 'cell'
          });
        }
      }

      return selection;
    }
  }, {
    key: "onSelect",
    value: function onSelect(event) {
      if (this.allowCellSelection()) this.props.onCellSelect && this.props.onCellSelect(_objectSpread$5$1(_objectSpread$5$1({
        originalEvent: event.originalEvent
      }, event.data), {}, {
        type: event.type
      }));else this.props.onRowSelect && this.props.onRowSelect(event);
    }
  }, {
    key: "onUnselect",
    value: function onUnselect(event) {
      if (this.allowCellSelection()) this.props.onCellUnselect && this.props.onCellUnselect(_objectSpread$5$1(_objectSpread$5$1({
        originalEvent: event.originalEvent
      }, event.data), {}, {
        type: event.type
      }));else this.props.onRowUnselect && this.props.onRowUnselect(event);
    }
  }, {
    key: "enableDragSelection",
    value: function enableDragSelection(event) {
      if (this.props.dragSelection && !this.dragSelectionHelper) {
        this.dragSelectionHelper = document.createElement('div');
        DomHandler$1.addClass(this.dragSelectionHelper, 'p-datatable-drag-selection-helper');
        this.initialDragPosition = {
          x: event.clientX,
          y: event.clientY
        };
        this.dragSelectionHelper.style.top = "".concat(event.pageY, "px");
        this.dragSelectionHelper.style.left = "".concat(event.pageX, "px");
        this.bindDragSelectionEvents();
      }
    }
  }, {
    key: "focusOnElement",
    value: function focusOnElement(event, isFocused) {
      var target = event.currentTarget;

      if (!this.allowCellSelection() && this.props.selectionAutoFocus) {
        if (this.isCheckboxSelectionModeInColumn()) {
          var checkbox = DomHandler$1.findSingle(target, 'td.p-selection-column .p-checkbox-box');
          checkbox && checkbox.focus();
        } else if (this.isRadioSelectionModeInColumn()) {
          var radio = DomHandler$1.findSingle(target, 'td.p-selection-column input[type="radio"]');
          radio && radio.focus();
        }
      }

      !isFocused && target && target.focus();
    }
  }, {
    key: "changeTabIndex",
    value: function changeTabIndex(event, type) {
      var target = event.currentTarget;
      var isSelectable = DomHandler$1.hasClass(target, type === 'cell' ? 'p-selectable-cell' : 'p-selectable-row');

      if (isSelectable) {
        var selector = type === 'cell' ? 'tr > td' : 'tr';
        var tabbableEl = DomHandler$1.findSingle(this.el, "".concat(selector, "[tabindex=\"").concat(this.props.tabIndex, "\"]"));

        if (tabbableEl && target) {
          tabbableEl.tabIndex = -1;
          target.tabIndex = this.props.tabIndex;
        }
      }
    }
  }, {
    key: "onRowClick",
    value: function onRowClick(event) {
      if (this.allowCellSelection() || !this.allowSelection(event)) {
        return;
      }

      this.props.onRowClick && this.props.onRowClick(event);

      if (this.allowRowSelection()) {
        if (this.allowRangeSelection(event)) {
          this.onRangeSelection(event, 'row');
        } else {
          var toggleable = this.isRadioSelectionModeInColumn() || this.isCheckboxSelectionModeInColumn() || this.allowMetaKeySelection(event);
          this.anchorRowIndex = event.index;
          this.rangeRowIndex = event.index;
          this.anchorRowFirst = this.props.first;

          if (this.isSingleSelection()) {
            this.onSingleSelection(_objectSpread$5$1(_objectSpread$5$1({}, event), {}, {
              toggleable: toggleable,
              type: 'row'
            }));
          } else {
            this.onMultipleSelection(_objectSpread$5$1(_objectSpread$5$1({}, event), {}, {
              toggleable: toggleable,
              type: 'row'
            }));
          }
        }

        this.changeTabIndex(event.originalEvent, 'row');
      } else {
        this.focusOnElement(event.originalEvent);
      }

      this.rowTouched = false;
    }
  }, {
    key: "onRowDoubleClick",
    value: function onRowDoubleClick(e) {
      var event = e.originalEvent;

      if (DomHandler$1.isClickable(event.target)) {
        return;
      }

      if (this.props.onRowDoubleClick) {
        this.props.onRowDoubleClick(e);
      }
    }
  }, {
    key: "onRowRightClick",
    value: function onRowRightClick(event) {
      if (this.props.onContextMenu || this.props.onContextMenuSelectionChange) {
        DomHandler$1.clearSelection();

        if (this.props.onContextMenuSelectionChange) {
          this.props.onContextMenuSelectionChange({
            originalEvent: event.originalEvent,
            value: event.data
          });
        }

        if (this.props.onContextMenu) {
          this.props.onContextMenu({
            originalEvent: event.originalEvent,
            data: event.data
          });
        }

        event.originalEvent.preventDefault();
      }
    }
  }, {
    key: "onRowTouchEnd",
    value: function onRowTouchEnd() {
      this.rowTouched = true;
    }
  }, {
    key: "onRowMouseDown",
    value: function onRowMouseDown(e) {
      DomHandler$1.clearSelection();
      var event = e.originalEvent;
      if (DomHandler$1.hasClass(event.target, 'p-datatable-reorderablerow-handle')) event.currentTarget.draggable = true;else event.currentTarget.draggable = false;

      if (this.allowRowDrag(e)) {
        this.enableDragSelection(event, 'row');
        this.anchorRowIndex = e.index;
        this.rangeRowIndex = e.index;
        this.anchorRowFirst = this.props.first;
      }
    }
  }, {
    key: "onRowMouseUp",
    value: function onRowMouseUp(event) {
      var isSameRow = event.index === this.anchorRowIndex;

      if (this.allowRowDrag(event) && !isSameRow) {
        this.onRangeSelection(event, 'row');
      }
    }
  }, {
    key: "onRowToggle",
    value: function onRowToggle(event) {
      var expandedRows;
      var dataKey = this.props.dataKey;
      var hasDataKey = this.props.groupRowsBy ? dataKey === this.props.groupRowsBy : !!dataKey;

      if (hasDataKey) {
        var dataKeyValue = String(ObjectUtils.resolveFieldData(event.data, dataKey));
        expandedRows = this.props.expandedRows ? _objectSpread$5$1({}, this.props.expandedRows) : {};

        if (expandedRows[dataKeyValue] != null) {
          delete expandedRows[dataKeyValue];

          if (this.props.onRowCollapse) {
            this.props.onRowCollapse({
              originalEvent: event,
              data: event.data
            });
          }
        } else {
          expandedRows[dataKeyValue] = true;

          if (this.props.onRowExpand) {
            this.props.onRowExpand({
              originalEvent: event,
              data: event.data
            });
          }
        }
      } else {
        var expandedRowIndex = this.findIndex(this.props.expandedRows, event.data);
        expandedRows = this.props.expandedRows ? _toConsumableArray$a(this.props.expandedRows) : [];

        if (expandedRowIndex !== -1) {
          expandedRows = expandedRows.filter(function (val, i) {
            return i !== expandedRowIndex;
          });

          if (this.props.onRowCollapse) {
            this.props.onRowCollapse({
              originalEvent: event,
              data: event.data
            });
          }
        } else {
          expandedRows.push(event.data);

          if (this.props.onRowExpand) {
            this.props.onRowExpand({
              originalEvent: event,
              data: event.data
            });
          }
        }
      }

      if (this.props.onRowToggle) {
        this.props.onRowToggle({
          data: expandedRows
        });
      }
    }
  }, {
    key: "onRowDragStart",
    value: function onRowDragStart(e) {
      var event = e.originalEvent,
          index = e.index;
      this.rowDragging = true;
      this.draggedRowIndex = index;
      event.dataTransfer.setData('text', 'b'); // For firefox
    }
  }, {
    key: "onRowDragOver",
    value: function onRowDragOver(e) {
      var event = e.originalEvent,
          index = e.index;

      if (this.rowDragging && this.draggedRowIndex !== index) {
        var rowElement = event.currentTarget;
        var rowY = DomHandler$1.getOffset(rowElement).top + DomHandler$1.getWindowScrollTop();
        var pageY = event.pageY;
        var rowMidY = rowY + DomHandler$1.getOuterHeight(rowElement) / 2;
        var prevRowElement = rowElement.previousElementSibling;

        if (pageY < rowMidY) {
          DomHandler$1.removeClass(rowElement, 'p-datatable-dragpoint-bottom');
          this.droppedRowIndex = index;
          if (prevRowElement) DomHandler$1.addClass(prevRowElement, 'p-datatable-dragpoint-bottom');else DomHandler$1.addClass(rowElement, 'p-datatable-dragpoint-top');
        } else {
          if (prevRowElement) DomHandler$1.removeClass(prevRowElement, 'p-datatable-dragpoint-bottom');else DomHandler$1.addClass(rowElement, 'p-datatable-dragpoint-top');
          this.droppedRowIndex = index + 1;
          DomHandler$1.addClass(rowElement, 'p-datatable-dragpoint-bottom');
        }
      }

      event.preventDefault();
    }
  }, {
    key: "onRowDragLeave",
    value: function onRowDragLeave(e) {
      var event = e.originalEvent;
      var rowElement = event.currentTarget;
      var prevRowElement = rowElement.previousElementSibling;

      if (prevRowElement) {
        DomHandler$1.removeClass(prevRowElement, 'p-datatable-dragpoint-bottom');
      }

      DomHandler$1.removeClass(rowElement, 'p-datatable-dragpoint-bottom');
      DomHandler$1.removeClass(rowElement, 'p-datatable-dragpoint-top');
    }
  }, {
    key: "onRowDragEnd",
    value: function onRowDragEnd(e) {
      var event = e.originalEvent;
      this.rowDragging = false;
      this.draggedRowIndex = null;
      this.droppedRowIndex = null;
      event.currentTarget.draggable = false;
    }
  }, {
    key: "onRowDrop",
    value: function onRowDrop(e) {
      var event = e.originalEvent;

      if (this.droppedRowIndex != null) {
        var dropIndex = this.draggedRowIndex > this.droppedRowIndex ? this.droppedRowIndex : this.droppedRowIndex === 0 ? 0 : this.droppedRowIndex - 1;

        var val = _toConsumableArray$a(this.props.value);

        ObjectUtils.reorderArray(val, this.draggedRowIndex, dropIndex);

        if (this.props.onRowReorder) {
          this.props.onRowReorder({
            originalEvent: event,
            value: val,
            dragIndex: this.draggedRowIndex,
            dropIndex: this.droppedRowIndex
          });
        }
      } //cleanup


      this.onRowDragLeave(e);
      this.onRowDragEnd(e);
      event.preventDefault();
    }
  }, {
    key: "onRadioChange",
    value: function onRadioChange(event) {
      this.onSingleSelection(_objectSpread$5$1(_objectSpread$5$1({}, event), {}, {
        toggleable: true,
        type: 'radio'
      }));
    }
  }, {
    key: "onCheckboxChange",
    value: function onCheckboxChange(event) {
      this.onMultipleSelection(_objectSpread$5$1(_objectSpread$5$1({}, event), {}, {
        toggleable: true,
        type: 'checkbox'
      }));
    }
  }, {
    key: "onDragSelectionMouseMove",
    value: function onDragSelectionMouseMove(event) {
      var _this$initialDragPosi = this.initialDragPosition,
          x = _this$initialDragPosi.x,
          y = _this$initialDragPosi.y;
      var dx = event.clientX - x;
      var dy = event.clientY - y;
      if (dy < 0) this.dragSelectionHelper.style.top = "".concat(event.pageY + 5, "px");
      if (dx < 0) this.dragSelectionHelper.style.left = "".concat(event.pageX + 5, "px");
      this.dragSelectionHelper.style.height = "".concat(Math.abs(dy), "px");
      this.dragSelectionHelper.style.width = "".concat(Math.abs(dx), "px");
      event.preventDefault();
    }
  }, {
    key: "onDragSelectionMouseUp",
    value: function onDragSelectionMouseUp() {
      if (this.dragSelectionHelper) {
        this.dragSelectionHelper.remove();
        this.dragSelectionHelper = null;
      }

      document.removeEventListener('mousemove', this.onDragSelectionMouseMove);
      document.removeEventListener('mouseup', this.onDragSelectionMouseUp);
    }
  }, {
    key: "onCellClick",
    value: function onCellClick(event) {
      if (!this.allowSelection(event)) {
        return;
      }

      this.props.onCellClick && this.props.onCellClick(event);

      if (this.allowCellSelection()) {
        if (this.allowRangeSelection(event)) {
          this.onRangeSelection(event, 'cell');
        } else {
          var toggleable = this.allowMetaKeySelection(event);

          var originalEvent = event.originalEvent,
              data = _objectWithoutProperties(event, _excluded$4);

          this.anchorRowIndex = event.rowIndex;
          this.rangeRowIndex = event.rowIndex;
          this.anchorRowFirst = this.props.first;
          this.anchorCellIndex = event.cellIndex;

          if (this.isSingleSelection()) {
            this.onSingleSelection({
              originalEvent: originalEvent,
              data: data,
              index: event.rowIndex,
              toggleable: toggleable,
              type: 'cell'
            });
          } else {
            this.onMultipleSelection({
              originalEvent: originalEvent,
              data: data,
              index: event.rowIndex,
              toggleable: toggleable,
              type: 'cell'
            });
          }
        }

        this.changeTabIndex(event.originalEvent, 'cell');
      }

      this.rowTouched = false;
    }
  }, {
    key: "onCellMouseDown",
    value: function onCellMouseDown(event) {
      if (this.allowCellDrag(event)) {
        this.enableDragSelection(event.originalEvent);
        this.anchorRowIndex = event.rowIndex;
        this.rangeRowIndex = event.rowIndex;
        this.anchorRowFirst = this.props.first;
        this.anchorCellIndex = event.cellIndex;
      }
    }
  }, {
    key: "onCellMouseUp",
    value: function onCellMouseUp(event) {
      var isSameCell = event.rowIndex === this.anchorRowIndex && event.cellIndex === this.anchorCellIndex;

      if (this.allowCellDrag(event) && !isSameCell) {
        this.onRangeSelection(event, 'cell');
      }
    }
  }, {
    key: "bindDragSelectionEvents",
    value: function bindDragSelectionEvents() {
      document.addEventListener('mousemove', this.onDragSelectionMouseMove);
      document.addEventListener('mouseup', this.onDragSelectionMouseUp);
      document.body.appendChild(this.dragSelectionHelper);
    }
  }, {
    key: "unbindDragSelectionEvents",
    value: function unbindDragSelectionEvents() {
      this.onDragSelectionMouseUp();
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.frozenRow) {
        this.updateFrozenRowStickyPosition();
      }

      if (this.props.scrollable && this.props.rowGroupMode === 'subheader') {
        this.updateFrozenRowGroupHeaderStickyPosition();
      }

      if (!this.props.isVirtualScrollerDisabled && this.getVirtualScrollerOption('vertical')) {
        this.updateVirtualScrollerPosition();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.frozenRow) {
        this.updateFrozenRowStickyPosition();
      }

      if (this.props.scrollable && this.props.rowGroupMode === 'subheader') {
        this.updateFrozenRowGroupHeaderStickyPosition();
      }

      if (!this.props.isVirtualScrollerDisabled && this.getVirtualScrollerOption('vertical') && this.getVirtualScrollerOption('itemSize', prevProps.virtualScrollerOptions) !== this.getVirtualScrollerOption('itemSize')) {
        this.updateVirtualScrollerPosition();
      }

      if (this.props.paginator && this.isMultipleSelection() && this.props.first !== prevProps.first) {
        this.anchorRowIndex = null;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.props.dragSelection) {
        this.unbindDragSelectionEvents();
      }
    }
  }, {
    key: "renderEmptyContent",
    value: function renderEmptyContent() {
      if (!this.props.loading) {
        var colSpan = this.getColumnsLength();
        var content = ObjectUtils.getJSXElement(this.props.emptyMessage, {
          props: this.props,
          frozen: this.props.frozenRow
        }) || localeOption('emptyMessage');
        return /*#__PURE__*/React.createElement("tr", {
          className: "p-datatable-emptymessage",
          role: "row"
        }, /*#__PURE__*/React.createElement("td", {
          colSpan: colSpan,
          role: "cell"
        }, content));
      }

      return null;
    }
  }, {
    key: "renderGroupHeader",
    value: function renderGroupHeader(rowData, index, expanded, isSubheaderGrouping, colSpan) {
      if (isSubheaderGrouping && this.shouldRenderRowGroupHeader(this.props.value, rowData, index - this.props.first)) {
        var style = this.rowGroupHeaderStyle();
        var toggler = this.props.expandableRowGroups && /*#__PURE__*/React.createElement(RowTogglerButton, {
          onClick: this.onRowToggle,
          rowData: rowData,
          expanded: expanded,
          expandedRowIcon: this.props.expandedRowIcon,
          collapsedRowIcon: this.props.collapsedRowIcon
        });
        var content = ObjectUtils.getJSXElement(this.props.rowGroupHeaderTemplate, rowData, {
          index: index,
          props: this.props.tableProps
        });
        return /*#__PURE__*/React.createElement("tr", {
          className: "p-rowgroup-header",
          style: style,
          role: "row"
        }, /*#__PURE__*/React.createElement("td", {
          colSpan: colSpan
        }, toggler, /*#__PURE__*/React.createElement("span", {
          className: "p-rowgroup-header-name"
        }, content)));
      }

      return null;
    }
  }, {
    key: "renderRow",
    value: function renderRow(rowData, index, expanded) {
      if (!this.props.expandableRowGroups || expanded) {
        var selected = this.isSelectionEnabled() ? this.isSelected(rowData) : false;
        var contextMenuSelected = this.isContextMenuSelected(rowData);
        var allowRowSelection = this.allowRowSelection();
        var allowCellSelection = this.allowCellSelection();
        var editing = this.isRowEditing(rowData);
        return /*#__PURE__*/React.createElement(BodyRow, {
          tableProps: this.props.tableProps,
          tableSelector: this.props.tableSelector,
          value: this.props.value,
          columns: this.props.columns,
          rowData: rowData,
          index: index,
          selected: selected,
          contextMenuSelected: contextMenuSelected,
          onRowClick: this.onRowClick,
          onRowDoubleClick: this.onRowDoubleClick,
          onRowRightClick: this.onRowRightClick,
          tabIndex: this.props.tabIndex,
          isSelectable: this.isSelectable,
          onRowTouchEnd: this.onRowTouchEnd,
          onRowMouseDown: this.onRowMouseDown,
          onRowMouseUp: this.onRowMouseUp,
          onRowToggle: this.onRowToggle,
          onRowDragStart: this.onRowDragStart,
          onRowDragOver: this.onRowDragOver,
          onRowDragLeave: this.onRowDragLeave,
          onRowDragEnd: this.onRowDragEnd,
          onRowDrop: this.onRowDrop,
          onRadioChange: this.onRadioChange,
          onCheckboxChange: this.onCheckboxChange,
          onCellClick: this.onCellClick,
          onCellMouseDown: this.onCellMouseDown,
          onCellMouseUp: this.onCellMouseUp,
          editing: editing,
          editingRows: this.props.editingRows,
          editingMeta: this.props.editingMeta,
          editMode: this.props.editMode,
          onRowEditChange: this.props.onRowEditChange,
          onEditingMetaChange: this.props.onEditingMetaChange,
          groupRowsBy: this.props.groupRowsBy,
          compareSelectionBy: this.props.compareSelectionBy,
          dataKey: this.props.dataKey,
          rowGroupMode: this.props.rowGroupMode,
          onRowEditInit: this.props.onRowEditInit,
          rowEditValidator: this.props.rowEditValidator,
          onRowEditSave: this.props.onRowEditSave,
          onRowEditComplete: this.props.onRowEditComplete,
          onRowEditCancel: this.props.onRowEditCancel,
          selection: this.props.selection,
          allowRowSelection: allowRowSelection,
          allowCellSelection: allowCellSelection,
          selectOnEdit: this.props.selectOnEdit,
          selectionMode: this.props.selectionMode,
          selectionModeInColumn: this.props.selectionModeInColumn,
          cellClassName: this.props.cellClassName,
          responsiveLayout: this.props.responsiveLayout,
          frozenRow: this.props.frozenRow,
          showSelectionElement: this.props.showSelectionElement,
          showRowReorderElement: this.props.showRowReorderElement,
          expanded: expanded,
          expandedRowIcon: this.props.expandedRowIcon,
          collapsedRowIcon: this.props.collapsedRowIcon,
          rowClassName: this.props.rowClassName,
          virtualScrollerOptions: this.props.virtualScrollerOptions
        });
      }
    }
  }, {
    key: "renderExpansion",
    value: function renderExpansion(rowData, index, expanded, isSubheaderGrouping, colSpan) {
      if (expanded && !(isSubheaderGrouping && this.props.expandableRowGroups)) {
        var content = ObjectUtils.getJSXElement(this.props.rowExpansionTemplate, rowData, {
          index: index
        });
        var id = "".concat(this.props.tableSelector, "_content_").concat(index, "_expanded");
        return /*#__PURE__*/React.createElement("tr", {
          id: id,
          className: "p-datatable-row-expansion",
          role: "row"
        }, /*#__PURE__*/React.createElement("td", {
          role: "cell",
          colSpan: colSpan
        }, content));
      }

      return null;
    }
  }, {
    key: "renderGroupFooter",
    value: function renderGroupFooter(rowData, index, expanded, isSubheaderGrouping, colSpan) {
      if (isSubheaderGrouping && this.shouldRenderRowGroupFooter(this.props.value, rowData, index - this.props.first, expanded)) {
        var content = ObjectUtils.getJSXElement(this.props.rowGroupFooterTemplate, rowData, {
          index: index,
          colSpan: colSpan,
          props: this.props.tableProps
        });
        return /*#__PURE__*/React.createElement("tr", {
          className: "p-rowgroup-footer",
          role: "row"
        }, content);
      }

      return null;
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this5 = this;

      return this.props.value.map(function (rowData, i) {
        var index = _this5.getVirtualScrollerOption('getItemOptions') ? _this5.getVirtualScrollerOption('getItemOptions')(i).index : _this5.props.first + i;

        var key = _this5.getRowKey(rowData, index);

        var expanded = _this5.isRowExpanded(rowData);

        var isSubheaderGrouping = _this5.isSubheaderGrouping();

        var colSpan = _this5.getColumnsLength();

        var groupHeader = _this5.renderGroupHeader(rowData, index, expanded, isSubheaderGrouping, colSpan);

        var row = _this5.renderRow(rowData, index, expanded);

        var expansion = _this5.renderExpansion(rowData, index, expanded, isSubheaderGrouping, colSpan);

        var groupFooter = _this5.renderGroupFooter(rowData, index, expanded, isSubheaderGrouping, colSpan);

        return /*#__PURE__*/React.createElement(React.Fragment, {
          key: key
        }, groupHeader, row, expansion, groupFooter);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-datatable-tbody', this.props.className);
      var content = this.props.empty ? this.renderEmptyContent() : this.renderContent();
      return /*#__PURE__*/React.createElement("tbody", {
        ref: this.ref,
        className: className
      }, content);
    }
  }]);

  return TableBody;
}(Component);

function ownKeys$4$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$4$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4$1(Object(source), !0).forEach(function (key) {
      _defineProperty$q(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$6$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$6$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var FooterCell = /*#__PURE__*/function (_Component) {
  _inherits$q(FooterCell, _Component);

  var _super = _createSuper$6$1(FooterCell);

  function FooterCell(props) {
    var _this;

    _classCallCheck$q(this, FooterCell);

    _this = _super.call(this, props);
    _this.state = {
      styleObject: {}
    };
    return _this;
  }

  _createClass$q(FooterCell, [{
    key: "getColumnProp",
    value: function getColumnProp(prop) {
      return this.props.column.props[prop];
    }
  }, {
    key: "getStyle",
    value: function getStyle() {
      var footerStyle = this.getColumnProp('footerStyle');
      var columnStyle = this.getColumnProp('style');
      return this.getColumnProp('frozen') ? Object.assign({}, columnStyle, footerStyle, this.state.styleObject) : Object.assign({}, columnStyle, footerStyle);
    }
  }, {
    key: "updateStickyPosition",
    value: function updateStickyPosition() {
      if (this.getColumnProp('frozen')) {
        var styleObject = _objectSpread$4$1({}, this.state.styleObject);

        var align = this.getColumnProp('alignFrozen');

        if (align === 'right') {
          var right = 0;
          var next = this.el.nextElementSibling;

          if (next) {
            right = DomHandler$1.getOuterWidth(next) + parseFloat(next.style.right || 0);
          }

          styleObject['right'] = right + 'px';
        } else {
          var left = 0;
          var prev = this.el.previousElementSibling;

          if (prev) {
            left = DomHandler$1.getOuterWidth(prev) + parseFloat(prev.style.left || 0);
          }

          styleObject['left'] = left + 'px';
        }

        this.setState({
          styleObject: styleObject
        });
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.getColumnProp('frozen')) {
        this.updateStickyPosition();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.getColumnProp('frozen')) {
        this.updateStickyPosition();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var style = this.getStyle();
      var align = this.getColumnProp('align');
      var className = classNames(this.getColumnProp('footerClassName'), this.getColumnProp('className'), _defineProperty$q({
        'p-frozen-column': this.getColumnProp('frozen')
      }, "p-align-".concat(align), !!align));
      var colSpan = this.getColumnProp('colSpan');
      var rowSpan = this.getColumnProp('rowSpan');
      var content = ObjectUtils.getJSXElement(this.getColumnProp('footer'), {
        props: this.props.tableProps
      });
      return /*#__PURE__*/React.createElement("td", {
        ref: function ref(el) {
          return _this2.el = el;
        },
        style: style,
        className: className,
        role: "cell",
        colSpan: colSpan,
        rowSpan: rowSpan
      }, content);
    }
  }]);

  return FooterCell;
}(Component);

function _createSuper$5$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$5$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TableFooter = /*#__PURE__*/function (_Component) {
  _inherits$q(TableFooter, _Component);

  var _super = _createSuper$5$1(TableFooter);

  function TableFooter() {
    _classCallCheck$q(this, TableFooter);

    return _super.apply(this, arguments);
  }

  _createClass$q(TableFooter, [{
    key: "hasFooter",
    value: function hasFooter() {
      return this.props.footerColumnGroup ? true : this.props.columns ? this.props.columns.some(function (col) {
        return col && col.props.footer;
      }) : false;
    }
  }, {
    key: "renderGroupFooterCells",
    value: function renderGroupFooterCells(row) {
      var columns = React.Children.toArray(row.props.children);
      return this.renderFooterCells(columns);
    }
  }, {
    key: "renderFooterCells",
    value: function renderFooterCells(columns) {
      var _this = this;

      return React.Children.map(columns, function (col, i) {
        var isVisible = col ? !col.props.hidden : true;
        var key = col ? col.props.columnKey || col.props.field || i : i;
        return isVisible && /*#__PURE__*/React.createElement(FooterCell, {
          key: key,
          tableProps: _this.props.tableProps,
          column: col
        });
      });
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this2 = this;

      if (this.props.footerColumnGroup) {
        var rows = React.Children.toArray(this.props.footerColumnGroup.props.children);
        return rows.map(function (row, i) {
          return /*#__PURE__*/React.createElement("tr", {
            key: i,
            role: "row"
          }, _this2.renderGroupFooterCells(row));
        });
      }

      return /*#__PURE__*/React.createElement("tr", {
        role: "row"
      }, this.renderFooterCells(this.props.columns));
    }
  }, {
    key: "render",
    value: function render() {
      if (this.hasFooter()) {
        var content = this.renderContent();
        return /*#__PURE__*/React.createElement("tfoot", {
          className: "p-datatable-tfoot"
        }, content);
      }

      return null;
    }
  }]);

  return TableFooter;
}(Component);

function _createSuper$4$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4$2();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$4$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var HeaderCheckbox = /*#__PURE__*/function (_Component) {
  _inherits$q(HeaderCheckbox, _Component);

  var _super = _createSuper$4$2(HeaderCheckbox);

  function HeaderCheckbox(props) {
    var _this;

    _classCallCheck$q(this, HeaderCheckbox);

    _this = _super.call(this, props);
    _this.state = {
      focused: false
    };
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$p(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$p(_this));
    _this.onClick = _this.onClick.bind(_assertThisInitialized$p(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$p(_this));
    return _this;
  }

  _createClass$q(HeaderCheckbox, [{
    key: "onFocus",
    value: function onFocus() {
      this.setState({
        focused: true
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        focused: false
      });
    }
  }, {
    key: "onClick",
    value: function onClick(event) {
      if (!this.props.disabled) {
        this.setState({
          focused: true
        });
        this.props.onChange({
          originalEvent: event,
          checked: !this.props.checked
        });
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (event.code === 'Space') {
        this.onClick(event);
        event.preventDefault();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var boxClassName = classNames('p-checkbox-box p-component', {
        'p-highlight': this.props.checked,
        'p-disabled': this.props.disabled,
        'p-focus': this.state.focused
      });
      var iconClassName = classNames('p-checkbox-icon', {
        'pi pi-check': this.props.checked
      });
      var tabIndex = this.props.disabled ? null : 0;
      return /*#__PURE__*/React.createElement("div", {
        className: "p-checkbox p-component",
        onClick: this.onClick
      }, /*#__PURE__*/React.createElement("div", {
        className: boxClassName,
        role: "checkbox",
        "aria-checked": this.props.checked,
        tabIndex: tabIndex,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyDown: this.onKeyDown
      }, /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      })));
    }
  }]);

  return HeaderCheckbox;
}(Component);

function ownKeys$3$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$3$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3$1(Object(source), !0).forEach(function (key) {
      _defineProperty$q(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$3$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3$2();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$3$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var ColumnFilter = /*#__PURE__*/function (_Component) {
  _inherits$q(ColumnFilter, _Component);

  var _super = _createSuper$3$2(ColumnFilter);

  function ColumnFilter(props) {
    var _this;

    _classCallCheck$q(this, ColumnFilter);

    _this = _super.call(this, props);
    _this.state = {
      overlayVisible: false
    };
    _this.overlayRef = /*#__PURE__*/React.createRef();
    _this.filterCallback = _this.filterCallback.bind(_assertThisInitialized$p(_this));
    _this.filterApplyCallback = _this.filterApplyCallback.bind(_assertThisInitialized$p(_this));
    _this.onOperatorChange = _this.onOperatorChange.bind(_assertThisInitialized$p(_this));
    _this.addConstraint = _this.addConstraint.bind(_assertThisInitialized$p(_this));
    _this.clearFilter = _this.clearFilter.bind(_assertThisInitialized$p(_this));
    _this.applyFilter = _this.applyFilter.bind(_assertThisInitialized$p(_this));
    _this.onInputChange = _this.onInputChange.bind(_assertThisInitialized$p(_this));
    _this.toggleMenu = _this.toggleMenu.bind(_assertThisInitialized$p(_this));
    _this.onOverlayEnter = _this.onOverlayEnter.bind(_assertThisInitialized$p(_this));
    _this.onOverlayExit = _this.onOverlayExit.bind(_assertThisInitialized$p(_this));
    _this.onOverlayExited = _this.onOverlayExited.bind(_assertThisInitialized$p(_this));
    _this.onContentKeyDown = _this.onContentKeyDown.bind(_assertThisInitialized$p(_this));
    _this.onContentClick = _this.onContentClick.bind(_assertThisInitialized$p(_this));
    _this.onContentMouseDown = _this.onContentMouseDown.bind(_assertThisInitialized$p(_this));
    return _this;
  }

  _createClass$q(ColumnFilter, [{
    key: "field",
    get: function get() {
      return this.getColumnProp('filterField') || this.getColumnProp('field');
    }
  }, {
    key: "overlay",
    get: function get() {
      return this.overlayRef ? this.overlayRef.current : null;
    }
  }, {
    key: "filterModel",
    get: function get() {
      return this.props.filters[this.field];
    }
  }, {
    key: "filterStoreModel",
    get: function get() {
      return this.props.filtersStore[this.field];
    }
  }, {
    key: "hasFilter",
    value: function hasFilter() {
      if (this.props.filtersStore) {
        var fieldFilter = this.props.filtersStore[this.field];
        return fieldFilter && (fieldFilter.operator ? !this.isFilterBlank(fieldFilter.constraints[0].value) : !this.isFilterBlank(fieldFilter.value));
      }

      return false;
    }
  }, {
    key: "hasRowFilter",
    value: function hasRowFilter() {
      return this.filterModel && !this.isFilterBlank(this.filterModel.value);
    }
  }, {
    key: "isFilterBlank",
    value: function isFilterBlank(filter) {
      return ObjectUtils.isEmpty(filter);
    }
  }, {
    key: "isRowMatchModeSelected",
    value: function isRowMatchModeSelected(matchMode) {
      return this.filterModel && this.filterModel.matchMode === matchMode;
    }
  }, {
    key: "showMenuButton",
    value: function showMenuButton() {
      return this.getColumnProp('showFilterMenu') && (this.props.display === 'row' ? this.getColumnProp('dataType') !== 'boolean' : true);
    }
  }, {
    key: "matchModes",
    value: function matchModes() {
      return this.getColumnProp('filterMatchModeOptions') || PrimeReact.filterMatchModeOptions[this.findDataType()].map(function (key) {
        return {
          label: localeOption(key),
          value: key
        };
      });
    }
  }, {
    key: "isShowMatchModes",
    value: function isShowMatchModes() {
      return this.getColumnProp('dataType') !== 'boolean' && this.getColumnProp('showFilterMatchModes') && this.matchModes() && this.getColumnProp('showFilterMenuOptions');
    }
  }, {
    key: "isShowOperator",
    value: function isShowOperator() {
      return this.getColumnProp('showFilterOperator') && this.filterModel && this.filterModel.operator && this.getColumnProp('showFilterMenuOptions');
    }
  }, {
    key: "showRemoveIcon",
    value: function showRemoveIcon() {
      return this.fieldConstraints().length > 1;
    }
  }, {
    key: "isShowAddConstraint",
    value: function isShowAddConstraint() {
      return this.getColumnProp('showAddButton') && this.filterModel && this.filterModel.operator && this.fieldConstraints() && this.fieldConstraints().length < this.getColumnProp('maxConstraints') && this.getColumnProp('showFilterMenuOptions');
    }
  }, {
    key: "isOutsideClicked",
    value: function isOutsideClicked(target) {
      return !this.isTargetClicked(target) && this.overlayRef && this.overlayRef.current && !(this.overlayRef.current.isSameNode(target) || this.overlayRef.current.contains(target));
    }
  }, {
    key: "isTargetClicked",
    value: function isTargetClicked(target) {
      return this.icon && (this.icon.isSameNode(target) || this.icon.contains(target));
    }
  }, {
    key: "getColumnProp",
    value: function getColumnProp(prop) {
      return this.props.column.props[prop];
    }
  }, {
    key: "getDefaultConstraint",
    value: function getDefaultConstraint() {
      if (this.props.filtersStore && this.filterStoreModel) {
        if (this.filterStoreModel.operator) {
          return {
            matchMode: this.filterStoreModel.constraints[0].matchMode,
            operator: this.filterStoreModel.operator
          };
        } else {
          return {
            matchMode: this.filterStoreModel.matchMode
          };
        }
      }
    }
  }, {
    key: "findDataType",
    value: function findDataType() {
      var dataType = this.getColumnProp('dataType');
      var matchMode = this.getColumnProp('filterMatchMode');

      var hasMatchMode = function hasMatchMode(key) {
        return PrimeReact.filterMatchModeOptions[key].some(function (mode) {
          return mode === matchMode;
        });
      };

      if (matchMode === 'custom' && !hasMatchMode(dataType)) {
        PrimeReact.filterMatchModeOptions[dataType].push(FilterMatchMode.CUSTOM);
        return dataType;
      } else if (matchMode) {
        return Object.keys(PrimeReact.filterMatchModeOptions).find(function (key) {
          return hasMatchMode(key);
        }) || dataType;
      }

      return dataType;
    }
  }, {
    key: "clearFilter",
    value: function clearFilter() {
      var field = this.field;
      var filterClearCallback = this.getColumnProp('onFilterClear');
      var defaultConstraint = this.getDefaultConstraint();

      var filters = _objectSpread$3$1({}, this.props.filters);

      if (filters[field].operator) {
        filters[field].constraints.splice(1);
        filters[field].operator = defaultConstraint.operator;
        filters[field].constraints[0] = {
          value: null,
          matchMode: defaultConstraint.matchMode
        };
      } else {
        filters[field].value = null;
        filters[field].matchMode = defaultConstraint.matchMode;
      }

      filterClearCallback && filterClearCallback();
      this.props.onFilterChange(filters);
      this.props.onFilterApply();
      this.hide();
    }
  }, {
    key: "applyFilter",
    value: function applyFilter() {
      var filterApplyClickCallback = this.getColumnProp('onFilterApplyClick');
      filterApplyClickCallback && filterApplyClickCallback({
        field: this.field,
        constraints: this.filterModel
      });
      this.props.onFilterApply();
      this.hide();
    }
  }, {
    key: "toggleMenu",
    value: function toggleMenu() {
      this.setState(function (prevState) {
        return {
          overlayVisible: !prevState.overlayVisible
        };
      });
    }
  }, {
    key: "onToggleButtonKeyDown",
    value: function onToggleButtonKeyDown(event) {
      switch (event.key) {
        case 'Escape':
        case 'Tab':
          this.hide();
          break;

        case 'ArrowDown':
          if (this.state.overlayVisible) {
            var focusable = DomHandler$1.getFirstFocusableElement(this.overlay);
            focusable && focusable.focus();
            event.preventDefault();
          } else if (event.altKey) {
            this.setState({
              overlayVisible: true
            });
            event.preventDefault();
          }

          break;
      }
    }
  }, {
    key: "onContentKeyDown",
    value: function onContentKeyDown(event) {
      if (event.key === 'Escape') {
        this.hide();
        this.icon && this.icon.focus();
      }
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(event, index) {
      var filters = _objectSpread$3$1({}, this.props.filters);

      var value = event.target.value;

      if (this.props.display === 'menu') {
        filters[this.field].constraints[index].value = value;
      } else {
        filters[this.field].value = value;
      }

      this.props.onFilterChange(filters);

      if (!this.getColumnProp('showApplyButton') || this.props.display === 'row') {
        this.props.onFilterApply();
      }
    }
  }, {
    key: "onRowMatchModeChange",
    value: function onRowMatchModeChange(matchMode) {
      var filterMatchModeChangeCallback = this.getColumnProp('onFilterMatchModeChange');

      var filters = _objectSpread$3$1({}, this.props.filters);

      filters[this.field].matchMode = matchMode;
      filterMatchModeChangeCallback && filterMatchModeChangeCallback({
        field: this.field,
        matchMode: matchMode
      });
      this.props.onFilterChange(filters);
      this.props.onFilterApply();
      this.hide();
    }
  }, {
    key: "onRowMatchModeKeyDown",
    value: function onRowMatchModeKeyDown(event, matchMode, clear) {
      var item = event.target;

      switch (event.key) {
        case 'ArrowDown':
          var nextItem = this.findNextItem(item);

          if (nextItem) {
            item.removeAttribute('tabindex');
            nextItem.tabIndex = 0;
            nextItem.focus();
          }

          event.preventDefault();
          break;

        case 'ArrowUp':
          var prevItem = this.findPrevItem(item);

          if (prevItem) {
            item.removeAttribute('tabindex');
            prevItem.tabIndex = 0;
            prevItem.focus();
          }

          event.preventDefault();
          break;

        case 'Enter':
          clear ? this.clearFilter() : this.onRowMatchModeChange(matchMode.value);
          event.preventDefault();
          break;
      }
    }
  }, {
    key: "onOperatorChange",
    value: function onOperatorChange(e) {
      var filterOperationChangeCallback = this.getColumnProp('onFilterOperatorChange');
      var value = e.value;

      var filters = _objectSpread$3$1({}, this.props.filters);

      filters[this.field].operator = value;
      this.props.onFilterChange(filters);
      filterOperationChangeCallback && filterOperationChangeCallback({
        field: this.field,
        operator: value
      });

      if (!this.getColumnProp('showApplyButton')) {
        this.props.onFilterApply();
      }
    }
  }, {
    key: "onMenuMatchModeChange",
    value: function onMenuMatchModeChange(value, index) {
      var filterMatchModeChangeCallback = this.getColumnProp('onFilterMatchModeChange');

      var filters = _objectSpread$3$1({}, this.props.filters);

      filters[this.field].constraints[index].matchMode = value;
      this.props.onFilterChange(filters);
      filterMatchModeChangeCallback && filterMatchModeChangeCallback({
        field: this.field,
        matchMode: value,
        index: index
      });

      if (!this.getColumnProp('showApplyButton')) {
        this.props.onFilterApply();
      }
    }
  }, {
    key: "addConstraint",
    value: function addConstraint() {
      var filterConstraintAddCallback = this.getColumnProp('onFilterConstraintAdd');
      var defaultConstraint = this.getDefaultConstraint();

      var filters = _objectSpread$3$1({}, this.props.filters);

      var newConstraint = {
        value: null,
        matchMode: defaultConstraint.matchMode
      };
      filters[this.field].constraints.push(newConstraint);
      filterConstraintAddCallback && filterConstraintAddCallback({
        field: this.field,
        constraint: newConstraint
      });
      this.props.onFilterChange(filters);

      if (!this.getColumnProp('showApplyButton')) {
        this.props.onFilterApply();
      }
    }
  }, {
    key: "removeConstraint",
    value: function removeConstraint(index) {
      var filterConstraintRemoveCallback = this.getColumnProp('onFilterConstraintRemove');

      var filters = _objectSpread$3$1({}, this.props.filters);

      var removedConstraint = filters[this.field].constraints.splice(index, 1);
      filterConstraintRemoveCallback && filterConstraintRemoveCallback({
        field: this.field,
        constraint: removedConstraint
      });
      this.props.onFilterChange(filters);

      if (!this.getColumnProp('showApplyButton')) {
        this.props.onFilterApply();
      }
    }
  }, {
    key: "findNextItem",
    value: function findNextItem(item) {
      var nextItem = item.nextElementSibling;
      if (nextItem) return DomHandler$1.hasClass(nextItem, 'p-column-filter-separator') ? this.findNextItem(nextItem) : nextItem;else return item.parentElement.firstElementChild;
    }
  }, {
    key: "findPrevItem",
    value: function findPrevItem(item) {
      var prevItem = item.previousElementSibling;
      if (prevItem) return DomHandler$1.hasClass(prevItem, 'p-column-filter-separator') ? this.findPrevItem(prevItem) : prevItem;else return item.parentElement.lastElementChild;
    }
  }, {
    key: "hide",
    value: function hide() {
      this.setState({
        overlayVisible: false
      });
    }
  }, {
    key: "onContentClick",
    value: function onContentClick(event) {
      this.selfClick = true;
      OverlayService.emit('overlay-click', {
        originalEvent: event,
        target: this.overlay
      });
    }
  }, {
    key: "onContentMouseDown",
    value: function onContentMouseDown() {
      this.selfClick = true;
    }
  }, {
    key: "onOverlayEnter",
    value: function onOverlayEnter() {
      var _this2 = this;

      ZIndexUtils.set('overlay', this.overlay, PrimeReact.autoZIndex, PrimeReact.zIndex['overlay']);
      DomHandler$1.alignOverlay(this.overlay, this.icon, PrimeReact.appendTo, false);
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();

      this.overlayEventListener = function (e) {
        if (!_this2.isOutsideClicked(e.target)) {
          _this2.selfClick = true;
        }
      };

      OverlayService.on('overlay-click', this.overlayEventListener);
    }
  }, {
    key: "onOverlayExit",
    value: function onOverlayExit() {
      this.onOverlayHide();
    }
  }, {
    key: "onOverlayExited",
    value: function onOverlayExited() {
      ZIndexUtils.clear(this.overlay);
    }
  }, {
    key: "onOverlayHide",
    value: function onOverlayHide() {
      this.unbindOutsideClickListener();
      this.unbindResizeListener();
      this.unbindScrollListener();
      OverlayService.off('overlay-click', this.overlayEventListener);
      this.overlayEventListener = null;
    }
  }, {
    key: "bindOutsideClickListener",
    value: function bindOutsideClickListener() {
      var _this3 = this;

      if (!this.outsideClickListener) {
        this.outsideClickListener = function (event) {
          if (!_this3.selfClick && _this3.isOutsideClicked(event.target)) {
            _this3.hide();
          }

          _this3.selfClick = false;
        };

        document.addEventListener('click', this.outsideClickListener);
      }
    }
  }, {
    key: "unbindOutsideClickListener",
    value: function unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener('click', this.outsideClickListener);
        this.outsideClickListener = null;
        this.selfClick = false;
      }
    }
  }, {
    key: "bindScrollListener",
    value: function bindScrollListener() {
      var _this4 = this;

      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.icon, function () {
          if (_this4.state.overlayVisible) {
            _this4.hide();
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    }
  }, {
    key: "unbindScrollListener",
    value: function unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }
  }, {
    key: "bindResizeListener",
    value: function bindResizeListener() {
      var _this5 = this;

      if (!this.resizeListener) {
        this.resizeListener = function () {
          if (_this5.state.overlayVisible && !DomHandler$1.isTouchDevice()) {
            _this5.hide();
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    }
  }, {
    key: "unbindResizeListener",
    value: function unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    }
  }, {
    key: "fieldConstraints",
    value: function fieldConstraints() {
      return this.filterModel ? this.filterModel.constraints || [this.filterModel] : [];
    }
  }, {
    key: "operator",
    value: function operator() {
      return this.filterModel.operator;
    }
  }, {
    key: "operatorOptions",
    value: function operatorOptions() {
      return [{
        label: localeOption('matchAll'),
        value: FilterOperator.AND
      }, {
        label: localeOption('matchAny'),
        value: FilterOperator.OR
      }];
    }
  }, {
    key: "noFilterLabel",
    value: function noFilterLabel() {
      return localeOption('noFilter');
    }
  }, {
    key: "removeRuleButtonLabel",
    value: function removeRuleButtonLabel() {
      return localeOption('removeRule');
    }
  }, {
    key: "addRuleButtonLabel",
    value: function addRuleButtonLabel() {
      return localeOption('addRule');
    }
  }, {
    key: "clearButtonLabel",
    value: function clearButtonLabel() {
      return localeOption('clear');
    }
  }, {
    key: "applyButtonLabel",
    value: function applyButtonLabel() {
      return localeOption('apply');
    }
  }, {
    key: "filterCallback",
    value: function filterCallback(value) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var filters = _objectSpread$3$1({}, this.props.filters);

      var meta = filters[this.field];
      this.props.display === 'menu' && meta && meta.operator ? filters[this.field].constraints[index].value = value : filters[this.field].value = value;
      this.props.onFilterChange(filters);
    }
  }, {
    key: "filterApplyCallback",
    value: function filterApplyCallback() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      args && this.filterCallback(args[0], args[1]);
      this.props.onFilterApply();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.display === 'menu' && this.state.overlayVisible) {
        DomHandler$1.alignOverlay(this.overlay, this.icon, PrimeReact.appendTo, false);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.overlayEventListener) {
        OverlayService.off('overlay-click', this.overlayEventListener);
        this.overlayEventListener = null;
      }

      if (this.overlay) {
        ZIndexUtils.clear(this.overlay);
        this.onOverlayHide();
      }
    }
  }, {
    key: "renderFilterElement",
    value: function renderFilterElement(model, index) {
      var _this6 = this;

      var value = model ? model.value : null;
      return this.getColumnProp('filterElement') ? ObjectUtils.getJSXElement(this.getColumnProp('filterElement'), {
        field: this.field,
        index: index,
        filterModel: model,
        value: value,
        filterApplyCallback: this.filterApplyCallback,
        filterCallback: this.filterCallback
      }) : /*#__PURE__*/React.createElement(InputText$1, {
        type: this.getColumnProp('filterType'),
        value: value || '',
        onChange: function onChange(e) {
          return _this6.onInputChange(e, index);
        },
        className: "p-column-filter",
        placeholder: this.getColumnProp('filterPlaceholder'),
        maxLength: this.getColumnProp('filterMaxLength')
      });
    }
  }, {
    key: "renderRowFilterElement",
    value: function renderRowFilterElement() {
      if (this.props.display === 'row') {
        var content = this.renderFilterElement(this.filterModel, 0);
        return /*#__PURE__*/React.createElement("div", {
          className: "p-fluid p-column-filter-element"
        }, content);
      }

      return null;
    }
  }, {
    key: "renderMenuFilterElement",
    value: function renderMenuFilterElement(fieldConstraint, index) {
      if (this.props.display === 'menu') {
        return this.renderFilterElement(fieldConstraint, index);
      }

      return null;
    }
  }, {
    key: "renderMenuButton",
    value: function renderMenuButton() {
      var _this7 = this;

      if (this.showMenuButton()) {
        var className = classNames('p-column-filter-menu-button p-link', {
          'p-column-filter-menu-button-open': this.state.overlayVisible,
          'p-column-filter-menu-button-active': this.hasFilter()
        });
        return /*#__PURE__*/React.createElement("button", {
          ref: function ref(el) {
            return _this7.icon = el;
          },
          type: "button",
          className: className,
          "aria-haspopup": true,
          "aria-expanded": this.state.overlayVisible,
          onClick: this.toggleMenu,
          onKeyDown: this.onToggleButtonKeyDown
        }, /*#__PURE__*/React.createElement("span", {
          className: "pi pi-filter-icon pi-filter"
        }));
      }

      return null;
    }
  }, {
    key: "renderClearButton",
    value: function renderClearButton() {
      if (this.getColumnProp('showClearButton') && this.props.display === 'row') {
        var className = classNames('p-column-filter-clear-button p-link', {
          'p-hidden-space': !this.hasRowFilter()
        });
        return /*#__PURE__*/React.createElement("button", {
          className: className,
          type: "button",
          onClick: this.clearFilter
        }, /*#__PURE__*/React.createElement("span", {
          className: "pi pi-filter-slash"
        }));
      }

      return null;
    }
  }, {
    key: "renderRowItems",
    value: function renderRowItems() {
      var _this8 = this;

      if (this.isShowMatchModes()) {
        var matchModes = this.matchModes();
        var noFilterLabel = this.noFilterLabel();
        return /*#__PURE__*/React.createElement("ul", {
          className: "p-column-filter-row-items"
        }, matchModes.map(function (matchMode, i) {
          var value = matchMode.value,
              label = matchMode.label;
          var className = classNames('p-column-filter-row-item', {
            'p-highlight': _this8.isRowMatchModeSelected(value)
          });
          var tabIndex = i === 0 ? 0 : null;
          return /*#__PURE__*/React.createElement("li", {
            className: className,
            key: label,
            onClick: function onClick() {
              return _this8.onRowMatchModeChange(value);
            },
            onKeyDown: function onKeyDown(e) {
              return _this8.onRowMatchModeKeyDown(e, matchMode);
            },
            tabIndex: tabIndex
          }, label);
        }), /*#__PURE__*/React.createElement("li", {
          className: "p-column-filter-separator"
        }), /*#__PURE__*/React.createElement("li", {
          className: "p-column-filter-row-item",
          onClick: this.clearFilter,
          onKeyDown: function onKeyDown(e) {
            return _this8.onRowMatchModeKeyDown(e, null, true);
          }
        }, noFilterLabel));
      }

      return null;
    }
  }, {
    key: "renderOperator",
    value: function renderOperator() {
      if (this.isShowOperator()) {
        var options = this.operatorOptions();
        var value = this.operator();
        return /*#__PURE__*/React.createElement("div", {
          className: "p-column-filter-operator"
        }, /*#__PURE__*/React.createElement(Dropdown$1, {
          options: options,
          value: value,
          onChange: this.onOperatorChange,
          className: "p-column-filter-operator-dropdown"
        }));
      }

      return null;
    }
  }, {
    key: "renderMatchModeDropdown",
    value: function renderMatchModeDropdown(constraint, index) {
      var _this9 = this;

      if (this.isShowMatchModes()) {
        var options = this.matchModes();
        return /*#__PURE__*/React.createElement(Dropdown$1, {
          options: options,
          value: constraint.matchMode,
          onChange: function onChange(e) {
            return _this9.onMenuMatchModeChange(e.value, index);
          },
          className: "p-column-filter-matchmode-dropdown"
        });
      }

      return null;
    }
  }, {
    key: "renderRemoveButton",
    value: function renderRemoveButton(index) {
      var _this10 = this;

      if (this.showRemoveIcon()) {
        var removeRuleLabel = this.removeRuleButtonLabel();
        return /*#__PURE__*/React.createElement(Button$1, {
          type: "button",
          icon: "pi pi-trash",
          className: "p-column-filter-remove-button p-button-text p-button-danger p-button-sm",
          onClick: function onClick() {
            return _this10.removeConstraint(index);
          },
          label: removeRuleLabel
        });
      }

      return null;
    }
  }, {
    key: "renderConstraints",
    value: function renderConstraints() {
      var _this11 = this;

      var fieldConstraints = this.fieldConstraints();
      return /*#__PURE__*/React.createElement("div", {
        className: "p-column-filter-constraints"
      }, fieldConstraints.map(function (fieldConstraint, i) {
        var matchModeDropdown = _this11.renderMatchModeDropdown(fieldConstraint, i);

        var menuFilterElement = _this11.renderMenuFilterElement(fieldConstraint, i);

        var removeButton = _this11.renderRemoveButton(i);

        return /*#__PURE__*/React.createElement("div", {
          key: i,
          className: "p-column-filter-constraint"
        }, matchModeDropdown, menuFilterElement, /*#__PURE__*/React.createElement("div", null, removeButton));
      }));
    }
  }, {
    key: "renderAddRule",
    value: function renderAddRule() {
      if (this.isShowAddConstraint()) {
        var addRuleLabel = this.addRuleButtonLabel();
        return /*#__PURE__*/React.createElement("div", {
          className: "p-column-filter-add-rule"
        }, /*#__PURE__*/React.createElement(Button$1, {
          type: "button",
          label: addRuleLabel,
          icon: "pi pi-plus",
          className: "p-column-filter-add-button p-button-text p-button-sm",
          onClick: this.addConstraint
        }));
      }

      return null;
    }
  }, {
    key: "renderFilterClearButton",
    value: function renderFilterClearButton() {
      if (this.getColumnProp('showClearButton')) {
        if (!this.getColumnProp('filterClear')) {
          var clearLabel = this.clearButtonLabel();
          return /*#__PURE__*/React.createElement(Button$1, {
            type: "button",
            className: "p-button-outlined p-button-sm",
            onClick: this.clearFilter,
            label: clearLabel
          });
        }

        return ObjectUtils.getJSXElement(this.getColumnProp('filterClear'), {
          field: this.field,
          filterModel: this.filterModel,
          filterClearCallback: this.clearFilter
        });
      }

      return null;
    }
  }, {
    key: "renderFilterApplyButton",
    value: function renderFilterApplyButton() {
      if (this.getColumnProp('showApplyButton')) {
        if (!this.getColumnProp('filterApply')) {
          var applyLabel = this.applyButtonLabel();
          return /*#__PURE__*/React.createElement(Button$1, {
            type: "button",
            className: "p-button-sm",
            onClick: this.applyFilter,
            label: applyLabel
          });
        }

        return ObjectUtils.getJSXElement(this.getColumnProp('filterApply'), {
          field: this.field,
          filterModel: this.filterModel,
          filterApplyCallback: this.applyFilter
        });
      }

      return null;
    }
  }, {
    key: "renderButtonBar",
    value: function renderButtonBar() {
      var clearButton = this.renderFilterClearButton();
      var applyButton = this.renderFilterApplyButton();
      return /*#__PURE__*/React.createElement("div", {
        className: "p-column-filter-buttonbar"
      }, clearButton, applyButton);
    }
  }, {
    key: "renderItems",
    value: function renderItems() {
      var operator = this.renderOperator();
      var constraints = this.renderConstraints();
      var addRule = this.renderAddRule();
      var buttonBar = this.renderButtonBar();
      return /*#__PURE__*/React.createElement(React.Fragment, null, operator, constraints, addRule, buttonBar);
    }
  }, {
    key: "renderOverlay",
    value: function renderOverlay() {
      var style = this.getColumnProp('filterMenuStyle');
      var className = classNames('p-column-filter-overlay p-component p-fluid', this.getColumnProp('filterMenuClassName'), {
        'p-column-filter-overlay-menu': this.props.display === 'menu',
        'p-input-filled': PrimeReact.inputStyle === 'filled',
        'p-ripple-disabled': PrimeReact.ripple === false
      });
      var filterHeader = ObjectUtils.getJSXElement(this.getColumnProp('filterHeader'), {
        field: this.field,
        filterModel: this.filterModel,
        filterApplyCallback: this.filterApplyCallback
      });
      var filterFooter = ObjectUtils.getJSXElement(this.getColumnProp('filterFooter'), {
        field: this.field,
        filterModel: this.filterModel,
        filterApplyCallback: this.filterApplyCallback
      });
      var items = this.props.display === 'row' ? this.renderRowItems() : this.renderItems();
      return /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: this.overlayRef,
        classNames: "p-connected-overlay",
        "in": this.state.overlayVisible,
        timeout: {
          enter: 120,
          exit: 100
        },
        unmountOnExit: true,
        onEnter: this.onOverlayEnter,
        onExit: this.onOverlayExit,
        onExited: this.onOverlayExited
      }, /*#__PURE__*/React.createElement("div", {
        ref: this.overlayRef,
        style: style,
        className: className,
        onKeyDown: this.onContentKeyDown,
        onClick: this.onContentClick,
        onMouseDown: this.onContentMouseDown
      }, filterHeader, items, filterFooter)));
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-column-filter p-fluid', {
        'p-column-filter-row': this.props.display === 'row',
        'p-column-filter-menu': this.props.display === 'menu'
      });
      var rowFilterElement = this.renderRowFilterElement();
      var menuButton = this.renderMenuButton();
      var clearButton = this.renderClearButton();
      var overlay = this.renderOverlay();
      return /*#__PURE__*/React.createElement("div", {
        className: className
      }, rowFilterElement, menuButton, clearButton, overlay);
    }
  }]);

  return ColumnFilter;
}(Component);

function ownKeys$2$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$2$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2$2(Object(source), !0).forEach(function (key) {
      _defineProperty$q(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2$2(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$2$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2$2();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$2$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var HeaderCell = /*#__PURE__*/function (_Component) {
  _inherits$q(HeaderCell, _Component);

  var _super = _createSuper$2$2(HeaderCell);

  function HeaderCell(props) {
    var _this;

    _classCallCheck$q(this, HeaderCell);

    _this = _super.call(this, props);
    _this.state = {
      styleObject: {}
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized$p(_this));
    _this.onMouseDown = _this.onMouseDown.bind(_assertThisInitialized$p(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$p(_this)); // drag

    _this.onDragStart = _this.onDragStart.bind(_assertThisInitialized$p(_this));
    _this.onDragOver = _this.onDragOver.bind(_assertThisInitialized$p(_this));
    _this.onDragLeave = _this.onDragLeave.bind(_assertThisInitialized$p(_this));
    _this.onDrop = _this.onDrop.bind(_assertThisInitialized$p(_this)); // resize

    _this.onResizerMouseDown = _this.onResizerMouseDown.bind(_assertThisInitialized$p(_this));
    _this.onResizerClick = _this.onResizerClick.bind(_assertThisInitialized$p(_this));
    _this.onResizerDoubleClick = _this.onResizerDoubleClick.bind(_assertThisInitialized$p(_this));
    return _this;
  }

  _createClass$q(HeaderCell, [{
    key: "isBadgeVisible",
    value: function isBadgeVisible() {
      return this.props.multiSortMeta && this.props.multiSortMeta.length > 1;
    }
  }, {
    key: "isSortableDisabled",
    value: function isSortableDisabled() {
      return !this.getColumnProp('sortable') || this.getColumnProp('sortable') && (this.props.allSortableDisabled || this.getColumnProp('sortableDisabled'));
    }
  }, {
    key: "getColumnProp",
    value: function getColumnProp() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.props.column ? typeof args[0] === 'string' ? this.props.column.props[args[0]] : (args[0] || this.props.column).props[args[1]] : null;
    }
  }, {
    key: "getStyle",
    value: function getStyle() {
      var headerStyle = this.getColumnProp('headerStyle');
      var columnStyle = this.getColumnProp('style');
      return this.getColumnProp('frozen') ? Object.assign({}, columnStyle, headerStyle, this.state.styleObject) : Object.assign({}, columnStyle, headerStyle);
    }
  }, {
    key: "getMultiSortMetaIndex",
    value: function getMultiSortMetaIndex() {
      var _this2 = this;

      return this.props.multiSortMeta.findIndex(function (meta) {
        return meta.field === _this2.getColumnProp('field') || meta.field === _this2.getColumnProp('sortField');
      });
    }
  }, {
    key: "getSortMeta",
    value: function getSortMeta() {
      var sorted = false;
      var sortOrder = 0;
      var metaIndex = -1;

      if (this.props.sortMode === 'single') {
        sorted = this.props.sortField && (this.props.sortField === this.getColumnProp('field') || this.props.sortField === this.getColumnProp('sortField'));
        sortOrder = sorted ? this.props.sortOrder : 0;
      } else if (this.props.sortMode === 'multiple') {
        metaIndex = this.getMultiSortMetaIndex();

        if (metaIndex > -1) {
          sorted = true;
          sortOrder = this.props.multiSortMeta[metaIndex].order;
        }
      }

      return {
        sorted: sorted,
        sortOrder: sortOrder,
        metaIndex: metaIndex
      };
    }
  }, {
    key: "getAriaSort",
    value: function getAriaSort(_ref) {
      var sorted = _ref.sorted,
          sortOrder = _ref.sortOrder;

      if (this.getColumnProp('sortable')) {
        var sortIcon = sorted ? sortOrder < 0 ? 'pi-sort-amount-down' : 'pi-sort-amount-up-alt' : 'pi-sort-alt';
        if (sortIcon === 'pi-sort-amount-down') return 'descending';else if (sortIcon === 'pi-sort-amount-up-alt') return 'ascending';else return 'none';
      }

      return null;
    }
  }, {
    key: "updateStickyPosition",
    value: function updateStickyPosition() {
      if (this.getColumnProp('frozen')) {
        var styleObject = _objectSpread$2$2({}, this.state.styleObject);

        var align = this.getColumnProp('alignFrozen');

        if (align === 'right') {
          var right = 0;
          var next = this.el.nextElementSibling;

          if (next) {
            right = DomHandler$1.getOuterWidth(next) + parseFloat(next.style.right || 0);
          }

          styleObject['right'] = right + 'px';
        } else {
          var left = 0;
          var prev = this.el.previousElementSibling;

          if (prev) {
            left = DomHandler$1.getOuterWidth(prev) + parseFloat(prev.style.left || 0);
          }

          styleObject['left'] = left + 'px';
        }

        var filterRow = this.el.parentElement.nextElementSibling;

        if (filterRow) {
          var index = DomHandler$1.index(this.el);
          filterRow.children[index].style.left = styleObject['left'];
          filterRow.children[index].style.right = styleObject['right'];
        }

        var isSameStyle = this.state.styleObject['left'] === styleObject['left'] && this.state.styleObject['right'] === styleObject['right'];
        !isSameStyle && this.setState({
          styleObject: styleObject
        });
      }
    }
  }, {
    key: "updateSortableDisabled",
    value: function updateSortableDisabled(prevColumn) {
      if (this.getColumnProp(prevColumn, 'sortableDisabled') !== this.getColumnProp('sortableDisabled') || this.getColumnProp(prevColumn, 'sortable') !== this.getColumnProp('sortable')) {
        this.props.onSortableChange();
      }
    }
  }, {
    key: "onClick",
    value: function onClick(event) {
      if (!this.isSortableDisabled()) {
        var targetNode = event.target;

        if (DomHandler$1.hasClass(targetNode, 'p-sortable-column') || DomHandler$1.hasClass(targetNode, 'p-column-title') || DomHandler$1.hasClass(targetNode, 'p-column-header-content') || DomHandler$1.hasClass(targetNode, 'p-sortable-column-icon') || DomHandler$1.hasClass(targetNode.parentElement, 'p-sortable-column-icon')) {
          DomHandler$1.clearSelection();
          this.props.onSortChange({
            originalEvent: event,
            column: this.props.column,
            sortableDisabledFields: this.props.sortableDisabledFields
          });
        }
      }
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event) {
      this.props.onColumnMouseDown({
        originalEvent: event,
        column: this.props.column
      });
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (event.key === 'Enter' && event.currentTarget === this.el && DomHandler$1.hasClass(event.currentTarget, 'p-sortable-column')) {
        this.onClick(event);
        event.preventDefault();
      }
    }
  }, {
    key: "onDragStart",
    value: function onDragStart(event) {
      this.props.onColumnDragStart({
        originalEvent: event,
        column: this.props.column
      });
    }
  }, {
    key: "onDragOver",
    value: function onDragOver(event) {
      this.props.onColumnDragOver({
        originalEvent: event,
        column: this.props.column
      });
    }
  }, {
    key: "onDragLeave",
    value: function onDragLeave(event) {
      this.props.onColumnDragLeave({
        originalEvent: event,
        column: this.props.column
      });
    }
  }, {
    key: "onDrop",
    value: function onDrop(event) {
      this.props.onColumnDrop({
        originalEvent: event,
        column: this.props.column
      });
    }
  }, {
    key: "onResizerMouseDown",
    value: function onResizerMouseDown(event) {
      this.props.onColumnResizeStart({
        originalEvent: event,
        column: this.props.column
      });
    }
  }, {
    key: "onResizerClick",
    value: function onResizerClick(event) {
      if (this.props.onColumnResizerClick) {
        this.props.onColumnResizerClick({
          originalEvent: event,
          element: event.currentTarget.parentElement,
          column: this.props.column
        });
        event.preventDefault();
      }
    }
  }, {
    key: "onResizerDoubleClick",
    value: function onResizerDoubleClick(event) {
      if (this.props.onColumnResizerDoubleClick) {
        this.props.onColumnResizerDoubleClick({
          originalEvent: event,
          element: event.currentTarget.parentElement,
          column: this.props.column
        });
        event.preventDefault();
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.getColumnProp('frozen')) {
        this.updateStickyPosition();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.getColumnProp('frozen')) {
        this.updateStickyPosition();
      }

      this.updateSortableDisabled(prevProps.column);
    }
  }, {
    key: "renderResizer",
    value: function renderResizer() {
      if (this.props.resizableColumns && !this.getColumnProp('frozen')) {
        return /*#__PURE__*/React.createElement("span", {
          className: "p-column-resizer",
          onMouseDown: this.onResizerMouseDown,
          onClick: this.onResizerClick,
          onDoubleClick: this.onResizerDoubleClick
        });
      }

      return null;
    }
  }, {
    key: "renderTitle",
    value: function renderTitle() {
      var title = ObjectUtils.getJSXElement(this.getColumnProp('header'), {
        props: this.props.tableProps
      });
      return /*#__PURE__*/React.createElement("span", {
        className: "p-column-title"
      }, title);
    }
  }, {
    key: "renderSortIcon",
    value: function renderSortIcon(_ref2) {
      var sorted = _ref2.sorted,
          sortOrder = _ref2.sortOrder;

      if (this.getColumnProp('sortable')) {
        var sortIcon = sorted ? sortOrder < 0 ? 'pi-sort-amount-down' : 'pi-sort-amount-up-alt' : 'pi-sort-alt';
        var className = classNames('p-sortable-column-icon pi pi-fw', sortIcon);
        return /*#__PURE__*/React.createElement("span", {
          className: className
        });
      }

      return null;
    }
  }, {
    key: "renderBadge",
    value: function renderBadge(_ref3) {
      var metaIndex = _ref3.metaIndex;

      if (metaIndex !== -1 && this.isBadgeVisible()) {
        var value = this.props.groupRowsBy && this.props.groupRowsBy === this.props.groupRowSortField ? metaIndex : metaIndex + 1;
        return /*#__PURE__*/React.createElement("span", {
          className: "p-sortable-column-badge"
        }, value);
      }

      return null;
    }
  }, {
    key: "renderCheckbox",
    value: function renderCheckbox() {
      if (this.props.showSelectAll && this.getColumnProp('selectionMode') === 'multiple' && this.props.filterDisplay !== 'row') {
        var allRowsSelected = this.props.allRowsSelected(this.props.value);
        return /*#__PURE__*/React.createElement(HeaderCheckbox, {
          checked: allRowsSelected,
          onChange: this.props.onColumnCheckboxChange,
          disabled: this.props.empty
        });
      }

      return null;
    }
  }, {
    key: "renderFilter",
    value: function renderFilter() {
      if (this.props.filterDisplay === 'menu' && this.getColumnProp('filter')) {
        return /*#__PURE__*/React.createElement(ColumnFilter, {
          display: "menu",
          column: this.props.column,
          filters: this.props.filters,
          onFilterChange: this.props.onFilterChange,
          onFilterApply: this.props.onFilterApply,
          filtersStore: this.props.filtersStore
        });
      }

      return null;
    }
  }, {
    key: "renderHeader",
    value: function renderHeader(sortMeta) {
      var title = this.renderTitle();
      var sortIcon = this.renderSortIcon(sortMeta);
      var badge = this.renderBadge(sortMeta);
      var checkbox = this.renderCheckbox();
      var filter = this.renderFilter();
      return /*#__PURE__*/React.createElement("div", {
        className: "p-column-header-content"
      }, title, sortIcon, badge, checkbox, filter);
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var _this3 = this;

      var isSortableDisabled = this.isSortableDisabled();
      var sortMeta = this.getSortMeta();
      var style = this.getStyle();
      var align = this.getColumnProp('alignHeader') || this.getColumnProp('align');
      var className = classNames(this.getColumnProp('headerClassName'), this.getColumnProp('className'), _defineProperty$q({
        'p-sortable-column': this.getColumnProp('sortable'),
        'p-resizable-column': this.props.resizableColumns,
        'p-highlight': sortMeta.sorted,
        'p-frozen-column': this.getColumnProp('frozen'),
        'p-selection-column': this.getColumnProp('selectionMode'),
        'p-sortable-disabled': this.getColumnProp('sortable') && isSortableDisabled,
        'p-reorderable-column': this.props.reorderableColumns && this.getColumnProp('reorderable')
      }, "p-align-".concat(align), !!align));
      var tabIndex = this.getColumnProp('sortable') && !isSortableDisabled ? this.props.tabIndex : null;
      var colSpan = this.getColumnProp('colSpan');
      var rowSpan = this.getColumnProp('rowSpan');
      var ariaSort = this.getAriaSort(sortMeta);
      var resizer = this.renderResizer();
      var header = this.renderHeader(sortMeta);
      return /*#__PURE__*/React.createElement("th", {
        ref: function ref(el) {
          return _this3.el = el;
        },
        style: style,
        className: className,
        tabIndex: tabIndex,
        role: "columnheader",
        onClick: this.onClick,
        onKeyDown: this.onKeyDown,
        onMouseDown: this.onMouseDown,
        onDragStart: this.onDragStart,
        onDragOver: this.onDragOver,
        onDragLeave: this.onDragLeave,
        onDrop: this.onDrop,
        colSpan: colSpan,
        rowSpan: rowSpan,
        "aria-sort": ariaSort
      }, resizer, header);
    }
  }, {
    key: "render",
    value: function render() {
      return this.renderElement();
    }
  }]);

  return HeaderCell;
}(Component);

function ownKeys$1$3(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1$3(Object(source), !0).forEach(function (key) {
      _defineProperty$q(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$3(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$1$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$8();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$1$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TableHeader = /*#__PURE__*/function (_Component) {
  _inherits$q(TableHeader, _Component);

  var _super = _createSuper$1$8(TableHeader);

  function TableHeader(props) {
    var _this;

    _classCallCheck$q(this, TableHeader);

    _this = _super.call(this, props);
    _this.state = {
      sortableDisabledFields: [],
      allSortableDisabled: false,
      styleObject: {}
    };
    _this.onSortableChange = _this.onSortableChange.bind(_assertThisInitialized$p(_this));
    _this.onCheckboxChange = _this.onCheckboxChange.bind(_assertThisInitialized$p(_this));
    return _this;
  }

  _createClass$q(TableHeader, [{
    key: "isSingleSort",
    value: function isSingleSort() {
      return this.props.sortMode === 'single';
    }
  }, {
    key: "isMultipleSort",
    value: function isMultipleSort() {
      return this.props.sortMode === 'multiple';
    }
  }, {
    key: "isAllSortableDisabled",
    value: function isAllSortableDisabled() {
      return this.isSingleSort() && this.state.allSortableDisabled;
    }
  }, {
    key: "isColumnSorted",
    value: function isColumnSorted(column) {
      return this.props.sortField !== null ? column.props.field === this.props.sortField || column.props.sortField === this.props.sortField : false;
    }
  }, {
    key: "updateSortableDisabled",
    value: function updateSortableDisabled() {
      var _this2 = this;

      if (this.isSingleSort() || this.isMultipleSort() && this.props.onSortChange) {
        var sortableDisabledFields = [];
        var allSortableDisabled = false;
        this.props.columns.forEach(function (column) {
          if (column.props.sortableDisabled) {
            sortableDisabledFields.push(column.props.sortField || column.props.field);

            if (!allSortableDisabled && _this2.isColumnSorted(column)) {
              allSortableDisabled = true;
            }
          }
        });
        this.setState({
          sortableDisabledFields: sortableDisabledFields,
          allSortableDisabled: allSortableDisabled
        });
      }
    }
  }, {
    key: "onSortableChange",
    value: function onSortableChange() {
      this.updateSortableDisabled();
    }
  }, {
    key: "onCheckboxChange",
    value: function onCheckboxChange(e) {
      this.props.onColumnCheckboxChange(e, this.props.value);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateSortableDisabled();
    }
  }, {
    key: "renderGroupHeaderCells",
    value: function renderGroupHeaderCells(row) {
      var columns = React.Children.toArray(row.props.children);
      return this.renderHeaderCells(columns);
    }
  }, {
    key: "renderHeaderCells",
    value: function renderHeaderCells(columns) {
      var _this3 = this;

      return React.Children.map(columns, function (col, i) {
        var isVisible = col ? !col.props.hidden : true;
        var key = col ? col.props.columnKey || col.props.field || i : i;
        return isVisible && /*#__PURE__*/React.createElement(HeaderCell, {
          key: key,
          value: _this3.props.value,
          tableProps: _this3.props.tableProps,
          column: col,
          tabIndex: _this3.props.tabIndex,
          empty: _this3.props.empty,
          resizableColumns: _this3.props.resizableColumns,
          groupRowsBy: _this3.props.groupRowsBy,
          groupRowSortField: _this3.props.groupRowSortField,
          sortMode: _this3.props.sortMode,
          sortField: _this3.props.sortField,
          sortOrder: _this3.props.sortOrder,
          multiSortMeta: _this3.props.multiSortMeta,
          allSortableDisabled: _this3.isAllSortableDisabled(),
          onSortableChange: _this3.onSortableChange,
          sortableDisabledFields: _this3.state.sortableDisabledFields,
          filterDisplay: _this3.props.filterDisplay,
          filters: _this3.props.filters,
          filtersStore: _this3.props.filtersStore,
          onFilterChange: _this3.props.onFilterChange,
          onFilterApply: _this3.props.onFilterApply,
          onColumnMouseDown: _this3.props.onColumnMouseDown,
          onColumnDragStart: _this3.props.onColumnDragStart,
          onColumnDragOver: _this3.props.onColumnDragOver,
          onColumnDragLeave: _this3.props.onColumnDragLeave,
          onColumnDrop: _this3.props.onColumnDrop,
          onColumnResizeStart: _this3.props.onColumnResizeStart,
          onColumnResizerClick: _this3.props.onColumnResizerClick,
          onColumnResizerDoubleClick: _this3.props.onColumnResizerDoubleClick,
          showSelectAll: _this3.props.showSelectAll,
          allRowsSelected: _this3.props.allRowsSelected,
          onColumnCheckboxChange: _this3.onCheckboxChange,
          reorderableColumns: _this3.props.reorderableColumns,
          onSortChange: _this3.props.onSortChange
        });
      });
    }
  }, {
    key: "renderCheckbox",
    value: function renderCheckbox(selectionMode) {
      if (this.props.showSelectAll && selectionMode === 'multiple') {
        var allRowsSelected = this.props.allRowsSelected(this.props.value);
        return /*#__PURE__*/React.createElement(HeaderCheckbox, {
          checked: allRowsSelected,
          onChange: this.onCheckboxChange,
          disabled: this.props.empty
        });
      }

      return null;
    }
  }, {
    key: "renderFilter",
    value: function renderFilter(column, filter) {
      if (filter) {
        return /*#__PURE__*/React.createElement(ColumnFilter, {
          display: "row",
          column: column,
          filters: this.props.filters,
          filtersStore: this.props.filtersStore,
          onFilterChange: this.props.onFilterChange,
          onFilterApply: this.props.onFilterApply
        });
      }

      return null;
    }
  }, {
    key: "renderFilterCells",
    value: function renderFilterCells() {
      var _this4 = this;

      return React.Children.map(this.props.columns, function (col, i) {
        var isVisible = !col.props.hidden;

        if (isVisible) {
          var _col$props = col.props,
              filterHeaderStyle = _col$props.filterHeaderStyle,
              style = _col$props.style,
              filterHeaderClassName = _col$props.filterHeaderClassName,
              className = _col$props.className,
              frozen = _col$props.frozen,
              columnKey = _col$props.columnKey,
              field = _col$props.field,
              selectionMode = _col$props.selectionMode,
              filter = _col$props.filter;

          var colStyle = _objectSpread$1$3(_objectSpread$1$3({}, filterHeaderStyle || {}), style || {});

          var colClassName = classNames('p-filter-column', filterHeaderClassName, className, {
            'p-frozen-column': frozen
          });
          var colKey = columnKey || field || i;

          var checkbox = _this4.renderCheckbox(selectionMode);

          var filterRow = _this4.renderFilter(col, filter);

          return /*#__PURE__*/React.createElement("th", {
            key: colKey,
            style: colStyle,
            className: colClassName
          }, checkbox, filterRow);
        }

        return null;
      });
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this5 = this;

      if (this.props.headerColumnGroup) {
        var rows = React.Children.toArray(this.props.headerColumnGroup.props.children);
        return rows.map(function (row, i) {
          return /*#__PURE__*/React.createElement("tr", {
            key: i,
            role: "row"
          }, _this5.renderGroupHeaderCells(row));
        });
      } else {
        var headerRow = /*#__PURE__*/React.createElement("tr", {
          role: "row"
        }, this.renderHeaderCells(this.props.columns));
        var filterRow = this.props.filterDisplay === 'row' && /*#__PURE__*/React.createElement("tr", {
          role: "row"
        }, this.renderFilterCells());
        return /*#__PURE__*/React.createElement(React.Fragment, null, headerRow, filterRow);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var content = this.renderContent();
      return /*#__PURE__*/React.createElement("thead", {
        className: "p-datatable-thead"
      }, content);
    }
  }]);

  return TableHeader;
}(Component);

function ownKeys$e(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$e(Object(source), !0).forEach(function (key) {
      _defineProperty$q(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$w(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$w();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$q(this, result);
  };
}

function _isNativeReflectConstruct$w() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var DataTable$1 = /*#__PURE__*/function (_Component) {
  _inherits$q(DataTable, _Component);

  var _super = _createSuper$w(DataTable);

  function DataTable(props) {
    var _this;

    _classCallCheck$q(this, DataTable);

    _this = _super.call(this, props);
    _this.state = {
      d_rows: props.rows,
      columnOrder: [],
      groupRowsSortMeta: null,
      editingMeta: {},
      attributeSelector: null
    };

    if (!_this.props.onPage) {
      _this.state.first = props.first;
      _this.state.rows = props.rows;
    }

    if (!_this.props.onSort) {
      _this.state.sortField = props.sortField;
      _this.state.sortOrder = props.sortOrder;
      _this.state.multiSortMeta = props.multiSortMeta;
    }

    _this.state.d_filters = _this.cloneFilters(props.filters);

    if (!_this.props.onFilter) {
      _this.state.filters = props.filters;
    } // header


    _this.onSortChange = _this.onSortChange.bind(_assertThisInitialized$p(_this));
    _this.onFilterChange = _this.onFilterChange.bind(_assertThisInitialized$p(_this));
    _this.onFilterApply = _this.onFilterApply.bind(_assertThisInitialized$p(_this));
    _this.onColumnHeaderMouseDown = _this.onColumnHeaderMouseDown.bind(_assertThisInitialized$p(_this));
    _this.onColumnHeaderDragStart = _this.onColumnHeaderDragStart.bind(_assertThisInitialized$p(_this));
    _this.onColumnHeaderDragOver = _this.onColumnHeaderDragOver.bind(_assertThisInitialized$p(_this));
    _this.onColumnHeaderDragLeave = _this.onColumnHeaderDragLeave.bind(_assertThisInitialized$p(_this));
    _this.onColumnHeaderDrop = _this.onColumnHeaderDrop.bind(_assertThisInitialized$p(_this));
    _this.onColumnResizeStart = _this.onColumnResizeStart.bind(_assertThisInitialized$p(_this));
    _this.onColumnHeaderCheckboxChange = _this.onColumnHeaderCheckboxChange.bind(_assertThisInitialized$p(_this));
    _this.allRowsSelected = _this.allRowsSelected.bind(_assertThisInitialized$p(_this)); // body

    _this.onEditingMetaChange = _this.onEditingMetaChange.bind(_assertThisInitialized$p(_this)); //paginator

    _this.onPageChange = _this.onPageChange.bind(_assertThisInitialized$p(_this));
    return _this;
  }

  _createClass$q(DataTable, [{
    key: "isCustomStateStorage",
    value: function isCustomStateStorage() {
      return this.props.stateStorage === 'custom';
    }
  }, {
    key: "isStateful",
    value: function isStateful() {
      return this.props.stateKey != null || this.isCustomStateStorage();
    }
  }, {
    key: "isVirtualScrollerDisabled",
    value: function isVirtualScrollerDisabled() {
      return ObjectUtils.isEmpty(this.props.virtualScrollerOptions) || !this.props.scrollable;
    }
  }, {
    key: "isEquals",
    value: function isEquals(data1, data2) {
      return this.props.compareSelectionBy === 'equals' ? data1 === data2 : ObjectUtils.equals(data1, data2, this.props.dataKey);
    }
  }, {
    key: "hasFilter",
    value: function hasFilter() {
      return ObjectUtils.isNotEmpty(this.getFilters()) || this.props.globalFilter;
    }
  }, {
    key: "getFirst",
    value: function getFirst() {
      return this.props.onPage ? this.props.first : this.state.first;
    }
  }, {
    key: "getRows",
    value: function getRows() {
      return this.props.onPage ? this.props.rows : this.state.rows;
    }
  }, {
    key: "getSortField",
    value: function getSortField() {
      return this.props.onSort ? this.props.sortField : this.state.sortField;
    }
  }, {
    key: "getSortOrder",
    value: function getSortOrder() {
      return this.props.onSort ? this.props.sortOrder : this.state.sortOrder;
    }
  }, {
    key: "getMultiSortMeta",
    value: function getMultiSortMeta() {
      return (this.props.onSort ? this.props.multiSortMeta : this.state.multiSortMeta) || [];
    }
  }, {
    key: "getFilters",
    value: function getFilters() {
      return this.props.onFilter ? this.props.filters : this.state.filters;
    }
  }, {
    key: "getColumnProp",
    value: function getColumnProp(col, prop) {
      return col.props[prop];
    }
  }, {
    key: "getColumns",
    value: function getColumns(ignoreReorderable) {
      var _this2 = this;

      var columns = React.Children.toArray(this.props.children);

      if (!columns) {
        return null;
      }

      if (!ignoreReorderable && this.props.reorderableColumns && this.state.columnOrder) {
        var orderedColumns = this.state.columnOrder.reduce(function (arr, columnKey) {
          var column = _this2.findColumnByKey(columns, columnKey);

          column && arr.push(column);
          return arr;
        }, []);
        return [].concat(_toConsumableArray$a(orderedColumns), _toConsumableArray$a(columns.filter(function (col) {
          return orderedColumns.indexOf(col) < 0;
        })));
      }

      return columns;
    }
  }, {
    key: "getStorage",
    value: function getStorage() {
      switch (this.props.stateStorage) {
        case 'local':
          return window.localStorage;

        case 'session':
          return window.sessionStorage;

        case 'custom':
          return null;

        default:
          throw new Error(this.props.stateStorage + ' is not a valid value for the state storage, supported values are "local", "session" and "custom".');
      }
    }
  }, {
    key: "saveState",
    value: function saveState() {
      var state = {};

      if (this.props.paginator) {
        state.first = this.getFirst();
        state.rows = this.getRows();
      }

      var sortField = this.getSortField();

      if (sortField) {
        state.sortField = sortField;
        state.sortOrder = this.getSortOrder();
      }

      var multiSortMeta = this.getMultiSortMeta();

      if (multiSortMeta) {
        state.multiSortMeta = multiSortMeta;
      }

      if (this.hasFilter()) {
        state.filters = this.getFilters();
      }

      if (this.props.resizableColumns) {
        this.saveColumnWidths(state);
      }

      if (this.props.reorderableColumns) {
        state.columnOrder = this.state.columnOrder;
      }

      if (this.props.expandedRows) {
        state.expandedRows = this.props.expandedRows;
      }

      if (this.props.selection && this.props.onSelectionChange) {
        state.selection = this.props.selection;
      }

      if (this.isCustomStateStorage()) {
        if (this.props.customSaveState) {
          this.props.customSaveState(state);
        }
      } else {
        var storage = this.getStorage();

        if (ObjectUtils.isNotEmpty(state)) {
          storage.setItem(this.props.stateKey, JSON.stringify(state));
        }
      }

      if (this.props.onStateSave) {
        this.props.onStateSave(state);
      }
    }
  }, {
    key: "clearState",
    value: function clearState() {
      var storage = this.getStorage();

      if (storage && this.props.stateKey) {
        storage.removeItem(this.props.stateKey);
      }
    }
  }, {
    key: "restoreState",
    value: function restoreState(state) {
      var restoredState = {};

      if (this.isCustomStateStorage()) {
        if (this.props.customRestoreState) {
          restoredState = this.props.customRestoreState();
        }
      } else {
        var storage = this.getStorage();
        var stateString = storage.getItem(this.props.stateKey);
        var dateFormat = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/;

        var reviver = function reviver(key, value) {
          return typeof value === "string" && dateFormat.test(value) ? new Date(value) : value;
        };

        if (stateString) {
          restoredState = JSON.parse(stateString, reviver);
        }
      }

      this._restoreState(restoredState, state);
    }
  }, {
    key: "restoreTableState",
    value: function restoreTableState(restoredState) {
      var state = this._restoreState(restoredState);

      if (ObjectUtils.isNotEmpty(state)) {
        this.setState(state);
      }
    }
  }, {
    key: "_restoreState",
    value: function _restoreState(restoredState) {
      var _this3 = this;

      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (ObjectUtils.isNotEmpty(restoredState)) {
        if (this.props.paginator) {
          if (this.props.onPage) {
            var getOnPageParams = function getOnPageParams(first, rows) {
              var totalRecords = _this3.getTotalRecords(_this3.processedData());

              var pageCount = Math.ceil(totalRecords / rows) || 1;
              var page = Math.floor(first / rows);
              return {
                first: first,
                rows: rows,
                page: page,
                pageCount: pageCount
              };
            };

            this.props.onPage(this.createEvent(getOnPageParams(restoredState.first, restoredState.rows)));
          } else {
            state.first = restoredState.first;
            state.rows = restoredState.rows;
          }
        }

        if (restoredState.sortField) {
          if (this.props.onSort) {
            this.props.onSort(this.createEvent({
              sortField: restoredState.sortField,
              sortOrder: restoredState.sortOrder
            }));
          } else {
            state.sortField = restoredState.sortField;
            state.sortOrder = restoredState.sortOrder;
          }
        }

        if (restoredState.multiSortMeta) {
          if (this.props.onSort) {
            this.props.onSort(this.createEvent({
              multiSortMeta: restoredState.multiSortMeta
            }));
          } else {
            state.multiSortMeta = restoredState.multiSortMeta;
          }
        }

        if (restoredState.filters) {
          state.d_filters = this.cloneFilters(restoredState.filters);

          if (this.props.onFilter) {
            this.props.onFilter(this.createEvent({
              filters: restoredState.filters
            }));
          } else {
            state.filters = this.cloneFilters(restoredState.filters);
          }
        }

        if (this.props.resizableColumns) {
          this.columnWidthsState = restoredState.columnWidths;
          this.tableWidthState = restoredState.tableWidth;
        }

        if (this.props.reorderableColumns) {
          state.columnOrder = restoredState.columnOrder;
        }

        if (restoredState.expandedRows && this.props.onRowToggle) {
          this.props.onRowToggle({
            data: restoredState.expandedRows
          });
        }

        if (restoredState.selection && this.props.onSelectionChange) {
          this.props.onSelectionChange({
            value: restoredState.selection
          });
        }

        if (this.props.onStateRestore) {
          this.props.onStateRestore(restoredState);
        }
      }

      return state;
    }
  }, {
    key: "saveColumnWidths",
    value: function saveColumnWidths(state) {
      var widths = [];
      var headers = DomHandler$1.find(this.el, '.p-datatable-thead > tr > th');
      headers.forEach(function (header) {
        return widths.push(DomHandler$1.getOuterWidth(header));
      });
      state.columnWidths = widths.join(',');

      if (this.props.columnResizeMode === 'expand') {
        state.tableWidth = DomHandler$1.getOuterWidth(this.table) + 'px';
      }
    }
  }, {
    key: "restoreColumnWidths",
    value: function restoreColumnWidths() {
      var _this4 = this;

      if (this.columnWidthsState) {
        var widths = this.columnWidthsState.split(',');

        if (this.props.columnResizeMode === 'expand' && this.tableWidthState) {
          this.table.style.width = this.tableWidthState;
          this.table.style.minWidth = this.tableWidthState;
          this.el.style.width = this.tableWidthState;
        }

        if (ObjectUtils.isNotEmpty(widths)) {
          this.createStyleElement();
          var innerHTML = '';
          widths.forEach(function (width, index) {
            var style = _this4.props.scrollable ? "flex: 1 1 ".concat(width, "px !important") : "width: ".concat(width, "px !important");
            innerHTML += "\n                        .p-datatable[".concat(_this4.state.attributeSelector, "] .p-datatable-thead > tr > th:nth-child(").concat(index + 1, "),\n                        .p-datatable[").concat(_this4.state.attributeSelector, "] .p-datatable-tbody > tr > td:nth-child(").concat(index + 1, "),\n                        .p-datatable[").concat(_this4.state.attributeSelector, "] .p-datatable-tfoot > tr > td:nth-child(").concat(index + 1, ") {\n                            ").concat(style, "\n                        }\n                    ");
          });
          this.styleElement.innerHTML = innerHTML;
        }
      }
    }
  }, {
    key: "findParentHeader",
    value: function findParentHeader(element) {
      if (element.nodeName === 'TH') {
        return element;
      } else {
        var parent = element.parentElement;

        while (parent.nodeName !== 'TH') {
          parent = parent.parentElement;
          if (!parent) break;
        }

        return parent;
      }
    }
  }, {
    key: "getGroupRowSortField",
    value: function getGroupRowSortField() {
      return this.props.sortMode === 'single' ? this.props.sortField : this.state.groupRowsSortMeta ? this.state.groupRowsSortMeta.field : null;
    }
  }, {
    key: "getSelectableData",
    value: function getSelectableData(val) {
      var _this5 = this;

      if (this.props.showSelectionElement || this.props.isDataSelectable) {
        return val.filter(function (data, index) {
          var isSelectable = true;
          if (_this5.props.showSelectionElement) isSelectable = _this5.props.showSelectionElement({
            rowIndex: index,
            props: _this5.props
          });
          if (_this5.props.isDataSelectable && isSelectable) isSelectable = _this5.props.isDataSelectable({
            data: data,
            index: index
          });
          return isSelectable;
        });
      }

      return val;
    }
  }, {
    key: "allRowsSelected",
    value: function allRowsSelected(processedData) {
      var _this6 = this;

      if (this.props.onSelectAllChange) {
        return this.props.selectAll;
      } else {
        var data = this.props.selectionPageOnly ? this.dataToRender(processedData) : processedData;
        var val = this.props.frozenValue ? [].concat(_toConsumableArray$a(this.props.frozenValue), _toConsumableArray$a(data)) : data;
        var selectableVal = this.getSelectableData(val);
        return selectableVal && this.props.selection && selectableVal.every(function (sv) {
          return _this6.props.selection.some(function (s) {
            return _this6.isEquals(s, sv);
          });
        });
      }
    }
  }, {
    key: "getSelectionModeInColumn",
    value: function getSelectionModeInColumn(columns) {
      if (columns) {
        var col = columns.find(function (c) {
          return !!c.props.selectionMode;
        });
        return col ? col.props.selectionMode : null;
      }

      return null;
    }
  }, {
    key: "findColumnByKey",
    value: function findColumnByKey(columns, key) {
      return ObjectUtils.isNotEmpty(columns) ? columns.find(function (col) {
        return col.props.columnKey === key || col.props.field === key;
      }) : null;
    }
  }, {
    key: "getTotalRecords",
    value: function getTotalRecords(data) {
      return this.props.lazy ? this.props.totalRecords : data ? data.length : 0;
    }
  }, {
    key: "onEditingMetaChange",
    value: function onEditingMetaChange(e) {
      var rowData = e.rowData,
          field = e.field,
          rowIndex = e.rowIndex,
          editing = e.editing;

      var editingMeta = _objectSpread$e({}, this.state.editingMeta);

      var meta = editingMeta[rowIndex];

      if (editing) {
        !meta && (meta = editingMeta[rowIndex] = {
          data: _objectSpread$e({}, rowData),
          fields: []
        });
        meta['fields'].push(field);
      } else if (meta) {
        var fields = meta['fields'].filter(function (f) {
          return f !== field;
        });
        !fields.length ? delete editingMeta[rowIndex] : meta['fields'] = fields;
      }

      this.setState({
        editingMeta: editingMeta
      });
    }
  }, {
    key: "clearEditingMetaData",
    value: function clearEditingMetaData() {
      if (this.props.editMode && ObjectUtils.isNotEmpty(this.state.editingMeta)) {
        this.setState({
          editingMeta: {}
        });
      }
    }
  }, {
    key: "onColumnResizeStart",
    value: function onColumnResizeStart(e) {
      var event = e.originalEvent,
          column = e.column;
      var containerLeft = DomHandler$1.getOffset(this.el).left;
      this.resizeColumn = column;
      this.resizeColumnElement = event.currentTarget.parentElement;
      this.columnResizing = true;
      this.lastResizeHelperX = event.pageX - containerLeft + this.el.scrollLeft;
      this.bindColumnResizeEvents();
    }
  }, {
    key: "onColumnResize",
    value: function onColumnResize(event) {
      var containerLeft = DomHandler$1.getOffset(this.el).left;
      DomHandler$1.addClass(this.el, 'p-unselectable-text');
      this.resizeHelper.style.height = this.el.offsetHeight + 'px';
      this.resizeHelper.style.top = 0 + 'px';
      this.resizeHelper.style.left = event.pageX - containerLeft + this.el.scrollLeft + 'px';
      this.resizeHelper.style.display = 'block';
    }
  }, {
    key: "onColumnResizeEnd",
    value: function onColumnResizeEnd() {
      var delta = this.resizeHelper.offsetLeft - this.lastResizeHelperX;
      var columnWidth = this.resizeColumnElement.offsetWidth;
      var newColumnWidth = columnWidth + delta;
      var minWidth = this.resizeColumnElement.style.minWidth || 15;

      if (columnWidth + delta > parseInt(minWidth, 10)) {
        if (this.props.columnResizeMode === 'fit') {
          var nextColumn = this.resizeColumnElement.nextElementSibling;
          var nextColumnWidth = nextColumn.offsetWidth - delta;

          if (newColumnWidth > 15 && nextColumnWidth > 15) {
            this.resizeTableCells(newColumnWidth, nextColumnWidth);
          }
        } else if (this.props.columnResizeMode === 'expand') {
          var tableWidth = this.table.offsetWidth + delta + 'px';
          this.table.style.width = tableWidth;
          this.table.style.minWidth = tableWidth;
          this.resizeTableCells(newColumnWidth);
        }

        if (this.props.onColumnResizeEnd) {
          this.props.onColumnResizeEnd({
            element: this.resizeColumnElement,
            column: this.resizeColumn,
            delta: delta
          });
        }

        if (this.isStateful()) {
          this.saveState();
        }
      }

      this.resizeHelper.style.display = 'none';
      this.resizeColumn = null;
      this.resizeColumnElement = null;
      DomHandler$1.removeClass(this.el, 'p-unselectable-text');
      this.unbindColumnResizeEvents();
    }
  }, {
    key: "resizeTableCells",
    value: function resizeTableCells(newColumnWidth, nextColumnWidth) {
      var _this7 = this;

      var widths = [];
      var colIndex = DomHandler$1.index(this.resizeColumnElement);
      var headers = DomHandler$1.find(this.table, '.p-datatable-thead > tr > th');
      headers.forEach(function (header) {
        return widths.push(DomHandler$1.getOuterWidth(header));
      });
      this.destroyStyleElement();
      this.createStyleElement();
      var innerHTML = '';
      widths.forEach(function (width, index) {
        var colWidth = index === colIndex ? newColumnWidth : nextColumnWidth && index === colIndex + 1 ? nextColumnWidth : width;
        var style = _this7.props.scrollable ? "flex: 1 1 ".concat(colWidth, "px !important") : "width: ".concat(colWidth, "px !important");
        innerHTML += "\n                .p-datatable[".concat(_this7.state.attributeSelector, "] .p-datatable-thead > tr > th:nth-child(").concat(index + 1, "),\n                .p-datatable[").concat(_this7.state.attributeSelector, "] .p-datatable-tbody > tr > td:nth-child(").concat(index + 1, "),\n                .p-datatable[").concat(_this7.state.attributeSelector, "] .p-datatable-tfoot > tr > td:nth-child(").concat(index + 1, ") {\n                    ").concat(style, "\n                }\n            ");
      });
      this.styleElement.innerHTML = innerHTML;
    }
  }, {
    key: "bindColumnResizeEvents",
    value: function bindColumnResizeEvents() {
      var _this8 = this;

      if (!this.documentColumnResizeListener) {
        this.documentColumnResizeListener = document.addEventListener('mousemove', function (event) {
          if (_this8.columnResizing) {
            _this8.onColumnResize(event);
          }
        });
      }

      if (!this.documentColumnResizeEndListener) {
        this.documentColumnResizeEndListener = document.addEventListener('mouseup', function () {
          if (_this8.columnResizing) {
            _this8.columnResizing = false;

            _this8.onColumnResizeEnd();
          }
        });
      }
    }
  }, {
    key: "unbindColumnResizeEvents",
    value: function unbindColumnResizeEvents() {
      if (this.documentColumnResizeListener) {
        document.removeEventListener('document', this.documentColumnResizeListener);
        this.documentColumnResizeListener = null;
      }

      if (this.documentColumnResizeEndListener) {
        document.removeEventListener('document', this.documentColumnResizeEndListener);
        this.documentColumnResizeEndListener = null;
      }
    }
  }, {
    key: "onColumnHeaderMouseDown",
    value: function onColumnHeaderMouseDown(e) {
      DomHandler$1.clearSelection();
      var event = e.originalEvent,
          column = e.column;

      if (this.props.reorderableColumns && this.getColumnProp(column, 'reorderable') !== false) {
        if (event.target.nodeName === 'INPUT' || event.target.nodeName === 'TEXTAREA' || DomHandler$1.hasClass(event.target, 'p-column-resizer')) event.currentTarget.draggable = false;else event.currentTarget.draggable = true;
      }
    }
  }, {
    key: "onColumnHeaderCheckboxChange",
    value: function onColumnHeaderCheckboxChange(e, processedData) {
      var _this9 = this;

      if (this.props.onSelectAllChange) {
        this.props.onSelectAllChange(e);
      } else {
        var originalEvent = e.originalEvent,
            checked = e.checked;
        var data = this.props.selectionPageOnly ? this.dataToRender(processedData) : processedData;
        var selection = this.props.selectionPageOnly && this.props.selection ? this.props.selection.filter(function (s) {
          return !data.some(function (d) {
            return _this9.isEquals(s, d);
          });
        }) : [];

        if (checked) {
          selection = this.props.frozenValue ? [].concat(_toConsumableArray$a(selection), _toConsumableArray$a(this.props.frozenValue), _toConsumableArray$a(data)) : [].concat(_toConsumableArray$a(selection), _toConsumableArray$a(data));
          selection = this.getSelectableData(selection);
          this.props.onAllRowsSelect && this.props.onAllRowsSelect({
            originalEvent: originalEvent,
            data: selection,
            type: 'all'
          });
        } else {
          this.props.onAllRowsUnselect && this.props.onAllRowsUnselect({
            originalEvent: originalEvent,
            data: selection,
            type: 'all'
          });
        }

        if (this.props.onSelectionChange) {
          this.props.onSelectionChange({
            originalEvent: originalEvent,
            value: selection,
            type: 'all'
          });
        }
      }
    }
  }, {
    key: "onColumnHeaderDragStart",
    value: function onColumnHeaderDragStart(e) {
      var event = e.originalEvent,
          column = e.column;

      if (this.columnResizing) {
        event.preventDefault();
        return;
      }

      this.colReorderIconWidth = DomHandler$1.getHiddenElementOuterWidth(this.reorderIndicatorUp);
      this.colReorderIconHeight = DomHandler$1.getHiddenElementOuterHeight(this.reorderIndicatorUp);
      this.draggedColumn = column;
      this.draggedColumnElement = this.findParentHeader(event.currentTarget);
      event.dataTransfer.setData('text', 'b'); // Firefox requires this to make dragging possible
    }
  }, {
    key: "onColumnHeaderDragOver",
    value: function onColumnHeaderDragOver(e) {
      var event = e.originalEvent;
      var dropHeader = this.findParentHeader(event.currentTarget);

      if (this.props.reorderableColumns && this.draggedColumnElement && dropHeader) {
        event.preventDefault();

        if (this.draggedColumnElement !== dropHeader) {
          var containerOffset = DomHandler$1.getOffset(this.el);
          var dropHeaderOffset = DomHandler$1.getOffset(dropHeader);
          var targetLeft = dropHeaderOffset.left - containerOffset.left;
          var columnCenter = dropHeaderOffset.left + dropHeader.offsetWidth / 2;
          this.reorderIndicatorUp.style.top = dropHeaderOffset.top - containerOffset.top - (this.colReorderIconHeight - 1) + 'px';
          this.reorderIndicatorDown.style.top = dropHeaderOffset.top - containerOffset.top + dropHeader.offsetHeight + 'px';

          if (event.pageX > columnCenter) {
            this.reorderIndicatorUp.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(this.colReorderIconWidth / 2) + 'px';
            this.reorderIndicatorDown.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(this.colReorderIconWidth / 2) + 'px';
            this.dropPosition = 1;
          } else {
            this.reorderIndicatorUp.style.left = targetLeft - Math.ceil(this.colReorderIconWidth / 2) + 'px';
            this.reorderIndicatorDown.style.left = targetLeft - Math.ceil(this.colReorderIconWidth / 2) + 'px';
            this.dropPosition = -1;
          }

          this.reorderIndicatorUp.style.display = 'block';
          this.reorderIndicatorDown.style.display = 'block';
        }
      }
    }
  }, {
    key: "onColumnHeaderDragLeave",
    value: function onColumnHeaderDragLeave(e) {
      var event = e.originalEvent;

      if (this.props.reorderableColumns && this.draggedColumnElement) {
        event.preventDefault();
        this.reorderIndicatorUp.style.display = 'none';
        this.reorderIndicatorDown.style.display = 'none';
      }
    }
  }, {
    key: "onColumnHeaderDrop",
    value: function onColumnHeaderDrop(e) {
      var _this10 = this;

      var event = e.originalEvent,
          column = e.column;
      event.preventDefault();

      if (this.draggedColumnElement) {
        var dragIndex = DomHandler$1.index(this.draggedColumnElement);
        var dropIndex = DomHandler$1.index(this.findParentHeader(event.currentTarget));
        var allowDrop = dragIndex !== dropIndex;

        if (allowDrop && (dropIndex - dragIndex === 1 && this.dropPosition === -1 || dragIndex - dropIndex === 1 && this.dropPosition === 1)) {
          allowDrop = false;
        }

        if (allowDrop) {
          var columns = this.getColumns();

          var isSameColumn = function isSameColumn(col1, col2) {
            return col1.props.columnKey || col2.props.columnKey ? ObjectUtils.equals(col1.props, col2.props, 'columnKey') : ObjectUtils.equals(col1.props, col2.props, 'field');
          };

          var dragColIndex = columns.findIndex(function (child) {
            return isSameColumn(child, _this10.draggedColumn);
          });
          var dropColIndex = columns.findIndex(function (child) {
            return isSameColumn(child, column);
          });

          if (dropColIndex < dragColIndex && this.dropPosition === 1) {
            dropColIndex++;
          }

          if (dropColIndex > dragColIndex && this.dropPosition === -1) {
            dropColIndex--;
          }

          ObjectUtils.reorderArray(columns, dragColIndex, dropColIndex);
          var columnOrder = columns.reduce(function (orders, col) {
            orders.push(col.props.columnKey || col.props.field);
            return orders;
          }, []);
          this.setState({
            columnOrder: columnOrder
          });

          if (this.props.onColReorder) {
            this.props.onColReorder({
              originalEvent: event,
              dragIndex: dragColIndex,
              dropIndex: dropColIndex,
              columns: columns
            });
          }
        }

        this.reorderIndicatorUp.style.display = 'none';
        this.reorderIndicatorDown.style.display = 'none';
        this.draggedColumnElement.draggable = false;
        this.draggedColumnElement = null;
        this.draggedColumn = null;
        this.dropPosition = null;
      }
    }
  }, {
    key: "createStyleElement",
    value: function createStyleElement() {
      this.styleElement = DomHandler$1.createInlineStyle(PrimeReact.nonce);
    }
  }, {
    key: "createResponsiveStyle",
    value: function createResponsiveStyle() {
      if (!this.responsiveStyleElement) {
        this.responsiveStyleElement = DomHandler$1.createInlineStyle(PrimeReact.nonce);
        var innerHTML = "\n@media screen and (max-width: ".concat(this.props.breakpoint, ") {\n    .p-datatable[").concat(this.state.attributeSelector, "] .p-datatable-thead > tr > th,\n    .p-datatable[").concat(this.state.attributeSelector, "] .p-datatable-tfoot > tr > td {\n        display: none !important;\n    }\n\n    .p-datatable[").concat(this.state.attributeSelector, "] .p-datatable-tbody > tr > td {\n        display: flex;\n        width: 100% !important;\n        align-items: center;\n        justify-content: space-between;\n    }\n\n    .p-datatable[").concat(this.state.attributeSelector, "] .p-datatable-tbody > tr > td:not(:last-child) {\n        border: 0 none;\n    }\n\n    .p-datatable[").concat(this.state.attributeSelector, "].p-datatable-gridlines .p-datatable-tbody > tr > td:last-child {\n        border-top: 0;\n        border-right: 0;\n        border-left: 0;\n    }\n\n    .p-datatable[").concat(this.state.attributeSelector, "] .p-datatable-tbody > tr > td > .p-column-title {\n        display: block;\n    }\n}\n");
        this.responsiveStyleElement.innerHTML = innerHTML;
      }
    }
  }, {
    key: "destroyResponsiveStyle",
    value: function destroyResponsiveStyle() {
      this.responsiveStyleElement = DomHandler$1.removeInlineStyle(this.responsiveStyleElement);
    }
  }, {
    key: "destroyStyleElement",
    value: function destroyStyleElement() {
      this.styleElement = DomHandler$1.removeInlineStyle(this.styleElement);
    }
  }, {
    key: "onPageChange",
    value: function onPageChange(e) {
      this.clearEditingMetaData();
      if (this.props.onPage) this.props.onPage(this.createEvent(e));else this.setState({
        first: e.first,
        rows: e.rows
      });

      if (this.props.onValueChange) {
        this.props.onValueChange(this.processedData());
      }
    }
  }, {
    key: "onSortChange",
    value: function onSortChange(e) {
      this.clearEditingMetaData();
      var event = e.originalEvent,
          column = e.column,
          sortableDisabledFields = e.sortableDisabledFields;
      var sortField = column.props.sortField || column.props.field;
      var sortOrder = this.props.defaultSortOrder;
      var multiSortMeta;
      var eventMeta;
      this.columnSortable = column.props.sortable;
      this.columnSortFunction = column.props.sortFunction;
      this.columnField = column.props.sortField;

      if (this.props.sortMode === 'multiple') {
        var metaKey = event.metaKey || event.ctrlKey;
        multiSortMeta = _toConsumableArray$a(this.getMultiSortMeta());
        var sortMeta = multiSortMeta.find(function (sortMeta) {
          return sortMeta.field === sortField;
        });
        sortOrder = sortMeta ? this.getCalculatedSortOrder(sortMeta.order) : sortOrder;
        var newMetaData = {
          field: sortField,
          order: sortOrder
        };

        if (sortOrder) {
          multiSortMeta = metaKey ? multiSortMeta : multiSortMeta.filter(function (meta) {
            return sortableDisabledFields.some(function (field) {
              return field === meta.field;
            });
          });
          this.addSortMeta(newMetaData, multiSortMeta);
        } else if (this.props.removableSort) {
          this.removeSortMeta(newMetaData, multiSortMeta);
        }

        eventMeta = {
          multiSortMeta: multiSortMeta
        };
      } else {
        sortOrder = this.getSortField() === sortField ? this.getCalculatedSortOrder(this.getSortOrder()) : sortOrder;

        if (this.props.removableSort) {
          sortField = sortOrder ? sortField : null;
        }

        eventMeta = {
          sortField: sortField,
          sortOrder: sortOrder
        };
      }

      if (this.props.onSort) {
        this.props.onSort(this.createEvent(eventMeta));
      } else {
        eventMeta.first = 0;
        this.setState(eventMeta);
      }

      if (this.props.onValueChange) {
        this.props.onValueChange(this.processedData({
          sortField: sortField,
          sortOrder: sortOrder,
          multiSortMeta: multiSortMeta
        }));
      }
    }
  }, {
    key: "getCalculatedSortOrder",
    value: function getCalculatedSortOrder(currentOrder) {
      return this.props.removableSort ? this.props.defaultSortOrder === currentOrder ? currentOrder * -1 : 0 : currentOrder * -1;
    }
  }, {
    key: "compareValuesOnSort",
    value: function compareValuesOnSort(value1, value2) {
      return ObjectUtils.sort(value1, value2, 1, PrimeReact.locale);
    }
  }, {
    key: "addSortMeta",
    value: function addSortMeta(meta, multiSortMeta) {
      var index = multiSortMeta.findIndex(function (sortMeta) {
        return sortMeta.field === meta.field;
      });
      if (index >= 0) multiSortMeta[index] = meta;else multiSortMeta.push(meta);
    }
  }, {
    key: "removeSortMeta",
    value: function removeSortMeta(meta, multiSortMeta) {
      var index = multiSortMeta.findIndex(function (sortMeta) {
        return sortMeta.field === meta.field;
      });

      if (index >= 0) {
        multiSortMeta.splice(index, 1);
      }

      multiSortMeta = multiSortMeta.length > 0 ? multiSortMeta : null;
    }
  }, {
    key: "sortSingle",
    value: function sortSingle(data, field, order) {
      var _this11 = this;

      if (this.props.groupRowsBy && this.props.groupRowsBy === this.props.sortField) {
        var multiSortMeta = [{
          field: this.props.sortField,
          order: this.props.sortOrder || this.props.defaultSortOrder
        }];
        this.props.sortField !== field && multiSortMeta.push({
          field: field,
          order: order
        });
        return this.sortMultiple(data, multiSortMeta);
      }

      var value = _toConsumableArray$a(data);

      if (this.columnSortable && this.columnSortFunction) {
        value = this.columnSortFunction({
          field: field,
          order: order
        });
      } else {
        value.sort(function (data1, data2) {
          var value1 = ObjectUtils.resolveFieldData(data1, field);
          var value2 = ObjectUtils.resolveFieldData(data2, field);

          var result = _this11.compareValuesOnSort(value1, value2);

          return order * result;
        });
      }

      return value;
    }
  }, {
    key: "sortMultiple",
    value: function sortMultiple(data) {
      var _this12 = this;

      var multiSortMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (this.props.groupRowsBy && (this.groupRowsSortMeta || multiSortMeta.length && this.props.groupRowsBy === multiSortMeta[0].field)) {
        var firstSortMeta = multiSortMeta[0];
        !this.groupRowsSortMeta && (this.groupRowsSortMeta = firstSortMeta);

        if (firstSortMeta.field !== this.groupRowsSortMeta.field) {
          multiSortMeta = [this.groupRowsSortMeta].concat(_toConsumableArray$a(multiSortMeta));
        }
      }

      var value = _toConsumableArray$a(data);

      if (this.columnSortable && this.columnSortFunction) {
        var meta = multiSortMeta.find(function (meta) {
          return meta.field === _this12.columnField;
        });
        var field = this.columnField;
        var order = meta ? meta.order : this.defaultSortOrder;
        value = this.columnSortFunction({
          field: field,
          order: order
        });
      } else {
        value.sort(function (data1, data2) {
          return _this12.multisortField(data1, data2, multiSortMeta, 0);
        });
      }

      return value;
    }
  }, {
    key: "multisortField",
    value: function multisortField(data1, data2, multiSortMeta, index) {
      var value1 = ObjectUtils.resolveFieldData(data1, multiSortMeta[index].field);
      var value2 = ObjectUtils.resolveFieldData(data2, multiSortMeta[index].field);

      if (value1 === value2) {
        return multiSortMeta.length - 1 > index ? this.multisortField(data1, data2, multiSortMeta, index + 1) : 0;
      }

      var result = this.compareValuesOnSort(value1, value2);
      return multiSortMeta[index].order * result;
    }
  }, {
    key: "onFilterChange",
    value: function onFilterChange(filters) {
      this.clearEditingMetaData();
      this.setState({
        d_filters: filters
      });
    }
  }, {
    key: "onFilterApply",
    value: function onFilterApply() {
      var _this13 = this;

      clearTimeout(this.filterTimeout);
      this.filterTimeout = setTimeout(function () {
        var filters = _this13.cloneFilters(_this13.state.d_filters);

        if (_this13.props.onFilter) {
          _this13.props.onFilter(_this13.createEvent({
            filters: filters
          }));
        } else {
          _this13.setState({
            first: 0,
            filters: filters
          });
        }

        if (_this13.props.onValueChange) {
          _this13.props.onValueChange(_this13.processedData({
            filters: filters
          }));
        }
      }, this.props.filterDelay);
    }
  }, {
    key: "filterLocal",
    value: function filterLocal(data, filters) {
      if (!data) return;
      filters = filters || {};
      var columns = this.getColumns();
      var filteredValue = [];
      var isGlobalFilter = filters['global'] || this.props.globalFilter;
      var globalFilterFieldsArray;

      if (isGlobalFilter) {
        globalFilterFieldsArray = this.props.globalFilterFields || columns.filter(function (col) {
          return !col.props.excludeGlobalFilter;
        }).map(function (col) {
          return col.props.filterField || col.props.field;
        });
      }

      for (var i = 0; i < data.length; i++) {
        var localMatch = true;
        var globalMatch = false;
        var localFiltered = false;

        for (var prop in filters) {
          if (Object.prototype.hasOwnProperty.call(filters, prop) && prop !== 'global') {
            localFiltered = true;
            var filterField = prop;
            var filterMeta = filters[filterField];

            if (filterMeta.operator) {
              for (var j = 0; j < filterMeta.constraints.length; j++) {
                var filterConstraint = filterMeta.constraints[j];
                localMatch = this.executeLocalFilter(filterField, data[i], filterConstraint, j);

                if (filterMeta.operator === FilterOperator.OR && localMatch || filterMeta.operator === FilterOperator.AND && !localMatch) {
                  break;
                }
              }
            } else {
              localMatch = this.executeLocalFilter(filterField, data[i], filterMeta, 0);
            }

            if (!localMatch) {
              break;
            }
          }
        }

        if (isGlobalFilter && !globalMatch && globalFilterFieldsArray) {
          for (var _j = 0; _j < globalFilterFieldsArray.length; _j++) {
            var globalFilterField = globalFilterFieldsArray[_j];
            var matchMode = filters['global'] ? filters['global'].matchMode : FilterMatchMode.CONTAINS;
            var value = filters['global'] ? filters['global'].value : this.props.globalFilter;
            globalMatch = FilterService.filters[matchMode](ObjectUtils.resolveFieldData(data[i], globalFilterField), value, this.props.filterLocale);

            if (globalMatch) {
              break;
            }
          }
        }

        var matches = void 0;

        if (isGlobalFilter) {
          matches = localFiltered ? localFiltered && localMatch && globalMatch : globalMatch;
        } else {
          matches = localFiltered && localMatch;
        }

        if (matches) {
          filteredValue.push(data[i]);
        }
      }

      if (filteredValue.length === this.props.value.length) {
        filteredValue = data;
      }

      return filteredValue;
    }
  }, {
    key: "executeLocalFilter",
    value: function executeLocalFilter(field, rowData, filterMeta, index) {
      var filterValue = filterMeta.value;
      var filterMatchMode = filterMeta.matchMode === 'custom' ? "custom_".concat(field) : filterMeta.matchMode || FilterMatchMode.STARTS_WITH;
      var dataFieldValue = ObjectUtils.resolveFieldData(rowData, field);
      var filterConstraint = FilterService.filters[filterMatchMode];
      return filterConstraint(dataFieldValue, filterValue, this.props.filterLocale, index);
    }
  }, {
    key: "cloneFilters",
    value: function cloneFilters(filters) {
      var _this14 = this;

      filters = filters || this.props.filters;
      var cloned = {};

      if (filters) {
        Object.entries(filters).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              prop = _ref2[0],
              value = _ref2[1];

          cloned[prop] = value.operator ? {
            operator: value.operator,
            constraints: value.constraints.map(function (constraint) {
              return _objectSpread$e({}, constraint);
            })
          } : _objectSpread$e({}, value);
        });
      } else {
        var columns = this.getColumns();
        cloned = columns.reduce(function (_filters, col) {
          var field = col.props.filterField || col.props.field;
          var filterFunction = col.props.filterFunction;
          var dataType = col.props.dataType;
          var matchMode = col.props.filterMatchMode || (PrimeReact.filterMatchModeOptions[dataType] ? PrimeReact.filterMatchModeOptions[dataType][0] : FilterMatchMode.STARTS_WITH);
          var constraint = {
            value: null,
            matchMode: matchMode
          };

          if (filterFunction) {
            FilterService.register("custom_".concat(field), function () {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              return filterFunction.apply(void 0, args.concat([{
                column: col
              }]));
            });
          }

          _filters[field] = _this14.props.filterDisplay === 'menu' ? {
            operator: FilterOperator.AND,
            constraints: [constraint]
          } : constraint;
          return _filters;
        }, {});
      }

      return cloned;
    }
  }, {
    key: "filter",
    value: function filter(value, field, matchMode) {
      var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var filters = _objectSpread$e({}, this.state.d_filters);

      var meta = filters[field];
      var constraint = meta && meta.operator ? meta.constraints[index] : meta;
      constraint = meta ? {
        value: value,
        matchMode: matchMode || constraint.matchMode
      } : {
        value: value,
        matchMode: matchMode
      };
      this.props.filterDisplay === 'menu' && meta && meta.operator ? filters[field].constraints[index] = constraint : filters[field] = constraint;
      this.setState({
        d_filters: filters
      }, this.onFilterApply);
    }
  }, {
    key: "reset",
    value: function reset() {
      var state = {
        d_rows: this.props.rows,
        d_filters: this.cloneFilters(this.props.filters),
        groupRowsSortMeta: null,
        editingMeta: {}
      };

      if (!this.props.onPage) {
        state.first = this.props.first;
        state.rows = this.props.rows;
      }

      if (!this.props.onSort) {
        state.sortField = this.props.sortField;
        state.sortOrder = this.props.sortOrder;
        state.multiSortMeta = this.props.multiSortMeta;
      }

      if (!this.props.onFilter) {
        state.filters = this.props.filters;
      }

      this.resetColumnOrder();
      this.setState(state);
    }
  }, {
    key: "resetScroll",
    value: function resetScroll() {
      if (this.wrapper) {
        var scrollableContainer = !this.isVirtualScrollerDisabled() ? DomHandler$1.findSingle(this.wrapper, '.p-virtualscroller') : this.wrapper;
        scrollableContainer.scrollTo(0, 0);
      }
    }
  }, {
    key: "resetColumnOrder",
    value: function resetColumnOrder() {
      var columns = this.getColumns(true);
      var columnOrder = [];

      if (columns) {
        columnOrder = columns.reduce(function (orders, col) {
          orders.push(col.props.columnKey || col.props.field);
          return orders;
        }, []);
      }

      this.setState({
        columnOrder: columnOrder
      });
    }
  }, {
    key: "exportCSV",
    value: function exportCSV(options) {
      var _this15 = this;

      var data;
      var csv = "\uFEFF";
      var columns = this.getColumns();

      if (options && options.selectionOnly) {
        data = this.props.selection || [];
      } else {
        data = [].concat(_toConsumableArray$a(this.props.frozenValue || []), _toConsumableArray$a(this.processedData() || []));
      } //headers


      columns.forEach(function (column, i) {
        var _column$props = column.props,
            field = _column$props.field,
            header = _column$props.header,
            exportable = _column$props.exportable;

        if (exportable && field) {
          csv += '"' + (header || field) + '"';

          if (i < columns.length - 1) {
            csv += _this15.props.csvSeparator;
          }
        }
      }); //body

      data.forEach(function (record) {
        csv += '\n';
        columns.forEach(function (column, i) {
          var _column$props2 = column.props,
              columnField = _column$props2.field,
              exportField = _column$props2.exportField,
              exportable = _column$props2.exportable;
          var field = exportField || columnField;

          if (exportable && field) {
            var cellData = ObjectUtils.resolveFieldData(record, field);

            if (cellData != null) {
              cellData = _this15.props.exportFunction ? _this15.props.exportFunction({
                data: cellData,
                field: field,
                rowData: record,
                column: column
              }) : String(cellData).replace(/"/g, '""');
            } else cellData = '';

            csv += '"' + cellData + '"';

            if (i < columns.length - 1) {
              csv += _this15.props.csvSeparator;
            }
          }
        });
      });
      DomHandler$1.exportCSV(csv, this.props.exportFilename);
    }
  }, {
    key: "closeEditingCell",
    value: function closeEditingCell() {
      if (this.props.editMode !== "row") {
        document.body.click();
      }
    }
  }, {
    key: "createEvent",
    value: function createEvent(event) {
      return _objectSpread$e({
        first: this.getFirst(),
        rows: this.getRows(),
        sortField: this.getSortField(),
        sortOrder: this.getSortOrder(),
        multiSortMeta: this.getMultiSortMeta(),
        filters: this.getFilters()
      }, event);
    }
  }, {
    key: "processedData",
    value: function processedData(localState) {
      var data = this.props.value || [];

      if (!this.props.lazy) {
        if (data && data.length) {
          var filters = localState && localState.filters || this.getFilters();
          var sortField = localState && localState.sortField || this.getSortField();
          var sortOrder = localState && localState.sortOrder || this.getSortOrder();
          var multiSortMeta = localState && localState.multiSortMeta || this.getMultiSortMeta();

          if (ObjectUtils.isNotEmpty(filters) || this.props.globalFilter) {
            data = this.filterLocal(data, filters);
          }

          if (sortField || ObjectUtils.isNotEmpty(multiSortMeta)) {
            if (this.props.sortMode === 'single') data = this.sortSingle(data, sortField, sortOrder);else if (this.props.sortMode === 'multiple') data = this.sortMultiple(data, multiSortMeta);
          }
        }
      }

      return data;
    }
  }, {
    key: "dataToRender",
    value: function dataToRender(data) {
      if (data && this.props.paginator) {
        var first = this.props.lazy ? 0 : this.getFirst();
        return data.slice(first, first + this.getRows());
      }

      return data;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this16 = this;

      this.setState({
        attributeSelector: UniqueComponentId()
      }, function () {
        _this16.el.setAttribute(_this16.state.attributeSelector, '');

        if (_this16.props.responsiveLayout === 'stack' && !_this16.props.scrollable) {
          _this16.createResponsiveStyle();
        }
      });

      if (this.isStateful()) {
        this.setState(this.restoreState(this.state));

        if (this.props.resizableColumns) {
          this.restoreColumnWidths();
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.isStateful()) {
        this.saveState();
      }

      if (prevProps.responsiveLayout !== this.props.responsiveLayout) {
        this.destroyResponsiveStyle();

        if (this.props.responsiveLayout === 'stack' && !this.props.scrollable) {
          this.createResponsiveStyle();
        }
      }

      if (prevProps.filters !== this.props.filters) {
        this.setState({
          filters: this.cloneFilters(this.props.filters),
          d_filters: this.cloneFilters(this.props.filters)
        });
      }

      if (prevProps.globalFilter !== this.props.globalFilter) {
        this.filter(this.props.globalFilter, 'global', 'contains');
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindColumnResizeEvents();
      this.destroyStyleElement();
      this.destroyResponsiveStyle();
    }
  }, {
    key: "renderLoader",
    value: function renderLoader() {
      if (this.props.loading) {
        var iconClassName = classNames('p-datatable-loading-icon pi-spin', this.props.loadingIcon);
        return /*#__PURE__*/React.createElement("div", {
          className: "p-datatable-loading-overlay p-component-overlay"
        }, /*#__PURE__*/React.createElement("i", {
          className: iconClassName
        }));
      }

      return null;
    }
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      if (this.props.header) {
        var content = ObjectUtils.getJSXElement(this.props.header, {
          props: this.props
        });
        return /*#__PURE__*/React.createElement("div", {
          className: "p-datatable-header"
        }, content);
      }

      return null;
    }
  }, {
    key: "renderTableHeader",
    value: function renderTableHeader(options, empty) {
      var sortField = this.getSortField();
      var sortOrder = this.getSortOrder();

      var multiSortMeta = _toConsumableArray$a(this.getMultiSortMeta());

      var groupRowSortField = this.getGroupRowSortField();
      var filters = this.state.d_filters;
      var filtersStore = this.getFilters();
      var processedData = options.items,
          columns = options.columns;
      return /*#__PURE__*/React.createElement(TableHeader, {
        value: processedData,
        tableProps: this.props,
        columns: columns,
        tabIndex: this.props.tabIndex,
        empty: empty,
        headerColumnGroup: this.props.headerColumnGroup,
        resizableColumns: this.props.resizableColumns,
        onColumnResizeStart: this.onColumnResizeStart,
        onColumnResizerClick: this.props.onColumnResizerClick,
        onColumnResizerDoubleClick: this.props.onColumnResizerDoubleClick,
        sortMode: this.props.sortMode,
        sortField: sortField,
        sortOrder: sortOrder,
        multiSortMeta: multiSortMeta,
        groupRowsBy: this.props.groupRowsBy,
        groupRowSortField: groupRowSortField,
        onSortChange: this.onSortChange,
        filterDisplay: this.props.filterDisplay,
        filters: filters,
        filtersStore: filtersStore,
        onFilterChange: this.onFilterChange,
        onFilterApply: this.onFilterApply,
        showSelectAll: this.props.showSelectAll,
        allRowsSelected: this.allRowsSelected,
        onColumnCheckboxChange: this.onColumnHeaderCheckboxChange,
        onColumnMouseDown: this.onColumnHeaderMouseDown,
        onColumnDragStart: this.onColumnHeaderDragStart,
        onColumnDragOver: this.onColumnHeaderDragOver,
        onColumnDragLeave: this.onColumnHeaderDragLeave,
        onColumnDrop: this.onColumnHeaderDrop,
        rowGroupMode: this.props.rowGroupMode,
        reorderableColumns: this.props.reorderableColumns
      });
    }
  }, {
    key: "renderTableBody",
    value: function renderTableBody(options, selectionModeInColumn, empty, isVirtualScrollerDisabled) {
      var tableSelector = this.state.attributeSelector;
      var first = this.getFirst();
      var editingMeta = this.state.editingMeta;
      var rows = options.rows,
          columns = options.columns,
          contentRef = options.contentRef,
          className = options.className;
      var frozenBody = this.props.frozenValue && /*#__PURE__*/React.createElement(TableBody, {
        value: this.props.frozenValue,
        className: "p-datatable-frozen-tbody",
        frozenRow: true,
        tableProps: this.props,
        tableSelector: tableSelector,
        columns: columns,
        selectionModeInColumn: selectionModeInColumn,
        first: first,
        editingMeta: editingMeta,
        onEditingMetaChange: this.onEditingMetaChange,
        tabIndex: this.props.tabIndex,
        onRowClick: this.props.onRowClick,
        onRowDoubleClick: this.props.onRowDoubleClick,
        onCellClick: this.props.onCellClick,
        selection: this.props.selection,
        onSelectionChange: this.props.onSelectionChange,
        lazy: this.props.lazy,
        paginator: this.props.paginator,
        onCellSelect: this.props.onCellSelect,
        onCellUnselect: this.props.onCellUnselect,
        onRowSelect: this.props.onRowSelect,
        onRowUnselect: this.props.onRowUnselect,
        dragSelection: this.props.dragSelection,
        onContextMenu: this.props.onContextMenu,
        onContextMenuSelectionChange: this.props.onContextMenuSelectionChange,
        metaKeySelection: this.props.metaKeySelection,
        selectionMode: this.props.selectionMode,
        cellSelection: this.props.cellSelection,
        contextMenuSelection: this.props.contextMenuSelection,
        dataKey: this.props.dataKey,
        expandedRows: this.props.expandedRows,
        onRowCollapse: this.props.onRowCollapse,
        onRowExpand: this.props.onRowExpand,
        onRowToggle: this.props.onRowToggle,
        editMode: this.props.editMode,
        editingRows: this.props.editingRows,
        onRowReorder: this.props.onRowReorder,
        scrollable: this.props.scrollable,
        rowGroupMode: this.props.rowGroupMode,
        groupRowsBy: this.props.groupRowsBy,
        expandableRowGroups: this.props.expandableRowGroups,
        loading: this.props.loading,
        emptyMessage: this.props.emptyMessage,
        rowGroupHeaderTemplate: this.props.rowGroupHeaderTemplate,
        rowExpansionTemplate: this.props.rowExpansionTemplate,
        rowGroupFooterTemplate: this.props.rowGroupFooterTemplate,
        onRowEditChange: this.props.onRowEditChange,
        compareSelectionBy: this.props.compareSelectionBy,
        selectOnEdit: this.props.selectOnEdit,
        onRowEditInit: this.props.onRowEditInit,
        rowEditValidator: this.props.rowEditValidator,
        onRowEditSave: this.props.onRowEditSave,
        onRowEditComplete: this.props.onRowEditComplete,
        onRowEditCancel: this.props.onRowEditCancel,
        cellClassName: this.props.cellClassName,
        responsiveLayout: this.props.responsiveLayout,
        selectionAutoFocus: this.props.selectionAutoFocus,
        isDataSelectable: this.props.isDataSelectable,
        showSelectionElement: this.props.showSelectionElement,
        showRowReorderElement: this.props.showRowReorderElement,
        expandedRowIcon: this.props.expandedRowIcon,
        collapsedRowIcon: this.props.collapsedRowIcon,
        rowClassName: this.props.rowClassName,
        isVirtualScrollerDisabled: true
      });
      var body = /*#__PURE__*/React.createElement(TableBody, {
        value: this.dataToRender(rows),
        className: className,
        empty: empty,
        frozenRow: false,
        tableProps: this.props,
        tableSelector: tableSelector,
        columns: columns,
        selectionModeInColumn: selectionModeInColumn,
        first: first,
        editingMeta: editingMeta,
        onEditingMetaChange: this.onEditingMetaChange,
        tabIndex: this.props.tabIndex,
        onRowClick: this.props.onRowClick,
        onRowDoubleClick: this.props.onRowDoubleClick,
        onCellClick: this.props.onCellClick,
        selection: this.props.selection,
        onSelectionChange: this.props.onSelectionChange,
        lazy: this.props.lazy,
        paginator: this.props.paginator,
        onCellSelect: this.props.onCellSelect,
        onCellUnselect: this.props.onCellUnselect,
        onRowSelect: this.props.onRowSelect,
        onRowUnselect: this.props.onRowUnselect,
        dragSelection: this.props.dragSelection,
        onContextMenu: this.props.onContextMenu,
        onContextMenuSelectionChange: this.props.onContextMenuSelectionChange,
        metaKeySelection: this.props.metaKeySelection,
        selectionMode: this.props.selectionMode,
        cellSelection: this.props.cellSelection,
        contextMenuSelection: this.props.contextMenuSelection,
        dataKey: this.props.dataKey,
        expandedRows: this.props.expandedRows,
        onRowCollapse: this.props.onRowCollapse,
        onRowExpand: this.props.onRowExpand,
        onRowToggle: this.props.onRowToggle,
        editMode: this.props.editMode,
        editingRows: this.props.editingRows,
        onRowReorder: this.props.onRowReorder,
        scrollable: this.props.scrollable,
        rowGroupMode: this.props.rowGroupMode,
        groupRowsBy: this.props.groupRowsBy,
        expandableRowGroups: this.props.expandableRowGroups,
        loading: this.props.loading,
        emptyMessage: this.props.emptyMessage,
        rowGroupHeaderTemplate: this.props.rowGroupHeaderTemplate,
        rowExpansionTemplate: this.props.rowExpansionTemplate,
        rowGroupFooterTemplate: this.props.rowGroupFooterTemplate,
        onRowEditChange: this.props.onRowEditChange,
        compareSelectionBy: this.props.compareSelectionBy,
        selectOnEdit: this.props.selectOnEdit,
        onRowEditInit: this.props.onRowEditInit,
        rowEditValidator: this.props.rowEditValidator,
        onRowEditSave: this.props.onRowEditSave,
        onRowEditComplete: this.props.onRowEditComplete,
        onRowEditCancel: this.props.onRowEditCancel,
        cellClassName: this.props.cellClassName,
        responsiveLayout: this.props.responsiveLayout,
        selectionAutoFocus: this.props.selectionAutoFocus,
        isDataSelectable: this.props.isDataSelectable,
        showSelectionElement: this.props.showSelectionElement,
        showRowReorderElement: this.props.showRowReorderElement,
        expandedRowIcon: this.props.expandedRowIcon,
        collapsedRowIcon: this.props.collapsedRowIcon,
        rowClassName: this.props.rowClassName,
        virtualScrollerContentRef: contentRef,
        virtualScrollerOptions: options,
        isVirtualScrollerDisabled: isVirtualScrollerDisabled
      });
      return /*#__PURE__*/React.createElement(React.Fragment, null, frozenBody, body);
    }
  }, {
    key: "renderTableFooter",
    value: function renderTableFooter(options) {
      var columns = options.columns;
      return /*#__PURE__*/React.createElement(TableFooter, {
        tableProps: this.props,
        columns: columns,
        footerColumnGroup: this.props.footerColumnGroup
      });
    }
  }, {
    key: "renderContent",
    value: function renderContent(processedData, columns, selectionModeInColumn, empty) {
      var _this17 = this;

      if (!columns) return;
      var isVirtualScrollerDisabled = this.isVirtualScrollerDisabled();
      var virtualScrollerOptions = this.props.virtualScrollerOptions || {};
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this17.wrapper = el;
        },
        className: "p-datatable-wrapper",
        style: {
          maxHeight: isVirtualScrollerDisabled ? this.props.scrollHeight : null
        }
      }, /*#__PURE__*/React.createElement(VirtualScroller, _extends$7({}, virtualScrollerOptions, {
        items: processedData,
        columns: columns,
        scrollHeight: this.props.scrollHeight,
        disabled: isVirtualScrollerDisabled,
        loaderDisabled: true,
        showSpacer: false,
        contentTemplate: function contentTemplate(options) {
          var ref = function ref(el) {
            _this17.table = el;
            options.spacerRef && options.spacerRef(el);
          };

          var tableClassName = classNames('p-datatable-table', _this17.props.tableClassName);

          var tableHeader = _this17.renderTableHeader(options, empty);

          var tableBody = _this17.renderTableBody(options, selectionModeInColumn, empty, isVirtualScrollerDisabled);

          var tableFooter = _this17.renderTableFooter(options);

          return /*#__PURE__*/React.createElement("table", {
            ref: ref,
            style: _this17.props.tableStyle,
            className: tableClassName,
            role: "table"
          }, tableHeader, tableBody, tableFooter);
        }
      })));
    }
  }, {
    key: "renderFooter",
    value: function renderFooter() {
      if (this.props.footer) {
        var content = ObjectUtils.getJSXElement(this.props.footer, {
          props: this.props
        });
        return /*#__PURE__*/React.createElement("div", {
          className: "p-datatable-footer"
        }, content);
      }

      return null;
    }
  }, {
    key: "renderPaginator",
    value: function renderPaginator(position, totalRecords) {
      var className = classNames('p-paginator-' + position, this.props.paginatorClassName);
      return /*#__PURE__*/React.createElement(Paginator, {
        first: this.getFirst(),
        rows: this.getRows(),
        pageLinkSize: this.props.pageLinkSize,
        className: className,
        onPageChange: this.onPageChange,
        template: this.props.paginatorTemplate,
        totalRecords: totalRecords,
        rowsPerPageOptions: this.props.rowsPerPageOptions,
        currentPageReportTemplate: this.props.currentPageReportTemplate,
        leftContent: this.props.paginatorLeft,
        rightContent: this.props.paginatorRight,
        alwaysShow: this.props.alwaysShowPaginator,
        dropdownAppendTo: this.props.paginatorDropdownAppendTo
      });
    }
  }, {
    key: "renderPaginatorTop",
    value: function renderPaginatorTop(totalRecords) {
      if (this.props.paginator && this.props.paginatorPosition !== 'bottom') {
        return this.renderPaginator('top', totalRecords);
      }

      return null;
    }
  }, {
    key: "renderPaginatorBottom",
    value: function renderPaginatorBottom(totalRecords) {
      if (this.props.paginator && this.props.paginatorPosition !== 'top') {
        return this.renderPaginator('bottom', totalRecords);
      }

      return null;
    }
  }, {
    key: "renderResizeHelper",
    value: function renderResizeHelper() {
      var _this18 = this;

      if (this.props.resizableColumns) {
        return /*#__PURE__*/React.createElement("div", {
          ref: function ref(el) {
            return _this18.resizeHelper = el;
          },
          className: "p-column-resizer-helper",
          style: {
            display: 'none'
          }
        });
      }

      return null;
    }
  }, {
    key: "renderReorderIndicators",
    value: function renderReorderIndicators() {
      var _this19 = this;

      if (this.props.reorderableColumns) {
        var style = {
          position: 'absolute',
          display: 'none'
        };
        return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
          ref: function ref(el) {
            return _this19.reorderIndicatorUp = el;
          },
          className: "pi pi-arrow-down p-datatable-reorder-indicator-up",
          style: style
        }), /*#__PURE__*/React.createElement("span", {
          ref: function ref(el) {
            return _this19.reorderIndicatorDown = el;
          },
          className: "pi pi-arrow-up p-datatable-reorder-indicator-down",
          style: style
        }));
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var _this20 = this;

      var processedData = this.processedData();
      var columns = this.getColumns();
      var totalRecords = this.getTotalRecords(processedData);
      var empty = ObjectUtils.isEmpty(processedData);
      var selectionModeInColumn = this.getSelectionModeInColumn(columns);
      var selectable = this.props.selectionMode || selectionModeInColumn;
      var className = classNames('p-datatable p-component', {
        'p-datatable-hoverable-rows': this.props.rowHover,
        'p-datatable-selectable': selectable && !this.props.cellSelection,
        'p-datatable-selectable-cell': selectable && this.props.cellSelection,
        'p-datatable-auto-layout': this.props.autoLayout,
        'p-datatable-resizable': this.props.resizableColumns,
        'p-datatable-resizable-fit': this.props.resizableColumns && this.props.columnResizeMode === 'fit',
        'p-datatable-scrollable': this.props.scrollable,
        'p-datatable-scrollable-vertical': this.props.scrollable && this.props.scrollDirection === 'vertical',
        'p-datatable-scrollable-horizontal': this.props.scrollable && this.props.scrollDirection === 'horizontal',
        'p-datatable-scrollable-both': this.props.scrollable && this.props.scrollDirection === 'both',
        'p-datatable-flex-scrollable': this.props.scrollable && this.props.scrollHeight === 'flex',
        'p-datatable-responsive-stack': this.props.responsiveLayout === 'stack',
        'p-datatable-responsive-scroll': this.props.responsiveLayout === 'scroll',
        'p-datatable-striped': this.props.stripedRows,
        'p-datatable-gridlines': this.props.showGridlines,
        'p-datatable-grouped-header': this.props.headerColumnGroup != null,
        'p-datatable-grouped-footer': this.props.footerColumnGroup != null,
        'p-datatable-sm': this.props.size === 'small',
        'p-datatable-lg': this.props.size === 'large'
      }, this.props.className);
      var loader = this.renderLoader();
      var header = this.renderHeader();
      var paginatorTop = this.renderPaginatorTop(totalRecords);
      var content = this.renderContent(processedData, columns, selectionModeInColumn, empty);
      var paginatorBottom = this.renderPaginatorBottom(totalRecords);
      var footer = this.renderFooter();
      var resizeHelper = this.renderResizeHelper();
      var reorderIndicators = this.renderReorderIndicators();
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this20.el = el;
        },
        id: this.props.id,
        className: className,
        style: this.props.style,
        "data-scrollselectors": ".p-datatable-wrapper"
      }, loader, header, paginatorTop, content, paginatorBottom, footer, resizeHelper, reorderIndicators);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.rows !== prevState.d_rows && !nextProps.onPage) {
        return {
          rows: nextProps.rows,
          d_rows: nextProps.rows
        };
      }

      return null;
    }
  }]);

  return DataTable;
}(Component);

_defineProperty$q(DataTable$1, "defaultProps", {
  id: null,
  value: null,
  header: null,
  footer: null,
  style: null,
  className: null,
  tableStyle: null,
  tableClassName: null,
  paginator: false,
  paginatorPosition: 'bottom',
  alwaysShowPaginator: true,
  paginatorClassName: null,
  paginatorTemplate: 'FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown',
  paginatorLeft: null,
  paginatorRight: null,
  paginatorDropdownAppendTo: null,
  pageLinkSize: 5,
  rowsPerPageOptions: null,
  currentPageReportTemplate: '({currentPage} of {totalPages})',
  first: 0,
  rows: null,
  totalRecords: null,
  lazy: false,
  sortField: null,
  sortOrder: null,
  multiSortMeta: null,
  sortMode: 'single',
  defaultSortOrder: 1,
  removableSort: false,
  emptyMessage: null,
  selectionMode: null,
  dragSelection: false,
  cellSelection: false,
  selection: null,
  onSelectionChange: null,
  contextMenuSelection: null,
  onContextMenuSelectionChange: null,
  compareSelectionBy: 'deepEquals',
  dataKey: null,
  metaKeySelection: true,
  selectOnEdit: true,
  selectionPageOnly: false,
  selectionAutoFocus: true,
  showSelectAll: true,
  selectAll: false,
  onSelectAllChange: null,
  headerColumnGroup: null,
  footerColumnGroup: null,
  rowExpansionTemplate: null,
  expandedRows: null,
  onRowToggle: null,
  resizableColumns: false,
  columnResizeMode: 'fit',
  reorderableColumns: false,
  filters: null,
  globalFilter: null,
  filterDelay: 300,
  filterLocale: undefined,
  scrollable: false,
  scrollHeight: null,
  scrollDirection: 'vertical',
  virtualScrollerOptions: null,
  frozenWidth: null,
  frozenValue: null,
  csvSeparator: ',',
  exportFilename: 'download',
  rowGroupMode: null,
  autoLayout: false,
  rowClassName: null,
  cellClassName: null,
  rowGroupHeaderTemplate: null,
  rowGroupFooterTemplate: null,
  loading: false,
  loadingIcon: 'pi pi-spinner',
  tabIndex: 0,
  stateKey: null,
  stateStorage: 'session',
  groupRowsBy: null,
  editMode: 'cell',
  editingRows: null,
  expandableRowGroups: false,
  rowHover: false,
  showGridlines: false,
  stripedRows: false,
  size: 'normal',
  responsiveLayout: 'stack',
  breakpoint: '960px',
  filterDisplay: 'menu',
  expandedRowIcon: 'pi pi-chevron-down',
  collapsedRowIcon: 'pi pi-chevron-right',
  onRowEditComplete: null,
  globalFilterFields: null,
  showSelectionElement: null,
  showRowReorderElement: null,
  isDataSelectable: null,
  onColumnResizeEnd: null,
  onColumnResizerClick: null,
  onColumnResizerDoubleClick: null,
  onSort: null,
  onPage: null,
  onFilter: null,
  onAllRowsSelect: null,
  onAllRowsUnselect: null,
  onRowClick: null,
  onRowDoubleClick: null,
  onRowSelect: null,
  onRowUnselect: null,
  onRowExpand: null,
  onRowCollapse: null,
  onContextMenu: null,
  onColReorder: null,
  onCellClick: null,
  onCellSelect: null,
  onCellUnselect: null,
  onRowReorder: null,
  onValueChange: null,
  rowEditValidator: null,
  onRowEditInit: null,
  onRowEditSave: null,
  onRowEditCancel: null,
  onRowEditChange: null,
  exportFunction: null,
  customSaveState: null,
  customRestoreState: null,
  onStateSave: null,
  onStateRestore: null
});

var EMPTY_MESSAGE$1 = {
  ru: "  ",
  en: "Nothing found"
};
var DataTable = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      header = _ref.header,
      footer = _ref.footer,
      style = _ref.style,
      className = _ref.className,
      tableStyle = _ref.tableStyle,
      tableClassName = _ref.tableClassName,
      _ref$paginator = _ref.paginator,
      paginator = _ref$paginator === void 0 ? false : _ref$paginator,
      paginatorClassName = _ref.paginatorClassName,
      rowsPerPageOptions = _ref.rowsPerPageOptions,
      _ref$first = _ref.first,
      first = _ref$first === void 0 ? 0 : _ref$first,
      rows = _ref.rows,
      totalRecords = _ref.totalRecords,
      _ref$lazy = _ref.lazy,
      lazy = _ref$lazy === void 0 ? false : _ref$lazy,
      sortField = _ref.sortField,
      sortOrder = _ref.sortOrder,
      multiSortMeta = _ref.multiSortMeta,
      _ref$sortMode = _ref.sortMode,
      sortMode = _ref$sortMode === void 0 ? "single" : _ref$sortMode,
      _ref$defaultSortOrder = _ref.defaultSortOrder,
      defaultSortOrder = _ref$defaultSortOrder === void 0 ? 1 : _ref$defaultSortOrder,
      _ref$removableSort = _ref.removableSort,
      removableSort = _ref$removableSort === void 0 ? false : _ref$removableSort,
      customEmptyMessage = _ref.emptyMessage,
      selection = _ref.selection,
      onSelectionChange = _ref.onSelectionChange,
      dataKey = _ref.dataKey,
      _ref$selectionPageOnl = _ref.selectionPageOnly,
      selectionPageOnly = _ref$selectionPageOnl === void 0 ? false : _ref$selectionPageOnl,
      _ref$showSelectAll = _ref.showSelectAll,
      showSelectAll = _ref$showSelectAll === void 0 ? true : _ref$showSelectAll,
      _ref$selectAll = _ref.selectAll,
      selectAll = _ref$selectAll === void 0 ? false : _ref$selectAll,
      onSelectAllChange = _ref.onSelectAllChange,
      headerColumnGroup = _ref.headerColumnGroup,
      footerColumnGroup = _ref.footerColumnGroup,
      filters = _ref.filters,
      globalFilter = _ref.globalFilter,
      filterLocale = _ref.filterLocale,
      _ref$scrollable = _ref.scrollable,
      scrollable = _ref$scrollable === void 0 ? false : _ref$scrollable,
      scrollHeight = _ref.scrollHeight,
      _ref$scrollDirection = _ref.scrollDirection,
      scrollDirection = _ref$scrollDirection === void 0 ? "vertical" : _ref$scrollDirection,
      frozenWidth = _ref.frozenWidth,
      frozenValue = _ref.frozenValue,
      _ref$csvSeparator = _ref.csvSeparator,
      csvSeparator = _ref$csvSeparator === void 0 ? "," : _ref$csvSeparator,
      _ref$exportFilename = _ref.exportFilename,
      exportFilename = _ref$exportFilename === void 0 ? "download" : _ref$exportFilename,
      _ref$autoLayout = _ref.autoLayout,
      autoLayout = _ref$autoLayout === void 0 ? false : _ref$autoLayout,
      rowClassName = _ref.rowClassName,
      cellClassName = _ref.cellClassName,
      _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? false : _ref$loading,
      _ref$tabIndex = _ref.tabIndex,
      tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
      _ref$editMode = _ref.editMode,
      editMode = _ref$editMode === void 0 ? false : _ref$editMode,
      editingRows = _ref.editingRows,
      _ref$showGridlines = _ref.showGridlines,
      showGridlines = _ref$showGridlines === void 0 ? false : _ref$showGridlines,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? "normal" : _ref$size,
      _ref$responsiveLayout = _ref.responsiveLayout,
      responsiveLayout = _ref$responsiveLayout === void 0 ? "stack" : _ref$responsiveLayout,
      _ref$breakpoint = _ref.breakpoint,
      breakpoint = _ref$breakpoint === void 0 ? "960px" : _ref$breakpoint,
      _ref$filterDisplay = _ref.filterDisplay,
      filterDisplay = _ref$filterDisplay === void 0 ? "menu" : _ref$filterDisplay,
      onRowEditComplete = _ref.onRowEditComplete,
      globalFilterFields = _ref.globalFilterFields,
      showSelectionElement = _ref.showSelectionElement,
      isDataSelectable = _ref.isDataSelectable,
      columnKey = _ref.columnKey,
      rowHover = _ref.rowHover,
      expandedRows = _ref.expandedRows,
      rowExpansionTemplate = _ref.rowExpansionTemplate,
      onRowToggle = _ref.onRowToggle,
      onRowExpand = _ref.onRowExpand,
      onRowCollapse = _ref.onRowCollapse,
      onRowClick = _ref.onRowClick,
      onSort = _ref.onSort,
      onPage = _ref.onPage,
      onFilter = _ref.onFilter,
      onAllRowsSelect = _ref.onAllRowsSelect,
      onAllRowsUnselect = _ref.onAllRowsUnselect,
      onRowSelect = _ref.onRowSelect,
      onRowUnselect = _ref.onRowUnselect,
      onValueChange = _ref.onValueChange,
      rowEditValidator = _ref.rowEditValidator,
      onRowEditInit = _ref.onRowEditInit,
      onRowEditSave = _ref.onRowEditSave,
      onRowEditCancel = _ref.onRowEditCancel,
      onRowEditChange = _ref.onRowEditChange,
      exportFunction = _ref.exportFunction,
      children = _ref.children;
  var emptyMessage = customEmptyMessage || EMPTY_MESSAGE$1[locale().locale];
  return /*#__PURE__*/React.createElement(DataTable$1, {
    ref: ref,
    id: id,
    value: value,
    header: header,
    footer: footer,
    style: style,
    className: className,
    tableStyle: tableStyle,
    tableClassName: tableClassName,
    paginator: paginator,
    paginatorClassName: paginatorClassName,
    rowsPerPageOptions: rowsPerPageOptions,
    alwaysShowPaginator: false,
    first: first,
    rows: rows,
    totalRecords: totalRecords,
    lazy: lazy,
    sortField: sortField,
    sortOrder: sortOrder,
    multiSortMeta: multiSortMeta,
    sortMode: sortMode,
    defaultSortOrder: defaultSortOrder,
    removableSort: removableSort,
    emptyMessage: emptyMessage,
    selection: selection,
    onSelectionChange: onSelectionChange,
    dataKey: dataKey,
    selectionPageOnly: selectionPageOnly,
    showSelectAll: showSelectAll,
    selectAll: selectAll,
    onSelectAllChange: onSelectAllChange,
    headerColumnGroup: headerColumnGroup,
    footerColumnGroup: footerColumnGroup,
    filters: filters,
    globalFilter: globalFilter,
    filterLocale: filterLocale,
    scrollable: scrollable,
    scrollHeight: scrollHeight,
    scrollDirection: scrollDirection,
    frozenWidth: frozenWidth,
    frozenValue: frozenValue,
    csvSeparator: csvSeparator,
    exportFilename: exportFilename,
    autoLayout: autoLayout,
    rowClassName: rowClassName,
    cellClassName: cellClassName,
    loading: loading,
    tabIndex: tabIndex,
    editMode: editMode ? "row" : null,
    editingRows: editingRows,
    showGridlines: showGridlines,
    size: size,
    responsiveLayout: responsiveLayout,
    breakpoint: breakpoint,
    filterDisplay: filterDisplay,
    onRowEditComplete: onRowEditComplete,
    globalFilterFields: globalFilterFields,
    showSelectionElement: showSelectionElement,
    isDataSelectable: isDataSelectable,
    columnKey: columnKey,
    rowHover: rowHover,
    expandedRows: expandedRows,
    rowExpansionTemplate: rowExpansionTemplate,
    onRowToggle: onRowToggle,
    onRowExpand: onRowExpand,
    onRowCollapse: onRowCollapse,
    onRowClick: onRowClick,
    onSort: onSort,
    onPage: onPage,
    onFilter: onFilter,
    onAllRowsSelect: onAllRowsSelect,
    onAllRowsUnselect: onAllRowsUnselect,
    onRowSelect: onRowSelect,
    onRowUnselect: onRowUnselect,
    onValueChange: onValueChange,
    rowEditValidator: rowEditValidator,
    onRowEditInit: onRowEditInit,
    onRowEditSave: onRowEditSave,
    onRowEditCancel: onRowEditCancel,
    onRowEditChange: onRowEditChange,
    exportFunction: exportFunction
  }, children);
});

function _extends$6() {
  _extends$6 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$6.apply(this, arguments);
}

function _typeof$p(obj) {
  "@babel/helpers - typeof";

  return _typeof$p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$p(obj);
}

function _arrayLikeToArray$1$5(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$9(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1$5(arr);
}

function _iterableToArray$9(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$1$5(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$5(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$5(o, minLen);
}

function _nonIterableSpread$9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$9(arr) {
  return _arrayWithoutHoles$9(arr) || _iterableToArray$9(arr) || _unsupportedIterableToArray$1$5(arr) || _nonIterableSpread$9();
}

function _classCallCheck$p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$p(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$p(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$p(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$p(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$o(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$o(o, p) {
  _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$o(o, p);
}

function _inherits$p(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$o(subClass, superClass);
}

function _possibleConstructorReturn$p(self, call) {
  if (call && (_typeof$p(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$o(self);
}

function _getPrototypeOf$p(o) {
  _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$p(o);
}

function _defineProperty$p(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$1$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$7();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$p(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$p(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$p(this, result);
  };
}

function _isNativeReflectConstruct$1$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var CalendarPanelComponent = /*#__PURE__*/function (_Component) {
  _inherits$p(CalendarPanelComponent, _Component);

  var _super = _createSuper$1$7(CalendarPanelComponent);

  function CalendarPanelComponent() {
    _classCallCheck$p(this, CalendarPanelComponent);

    return _super.apply(this, arguments);
  }

  _createClass$p(CalendarPanelComponent, [{
    key: "renderElement",
    value: function renderElement() {
      return /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: this.props.forwardRef,
        classNames: "p-connected-overlay",
        "in": this.props["in"],
        timeout: {
          enter: 120,
          exit: 100
        },
        options: this.props.transitionOptions,
        unmountOnExit: true,
        onEnter: this.props.onEnter,
        onEntered: this.props.onEntered,
        onExit: this.props.onExit,
        onExited: this.props.onExited
      }, /*#__PURE__*/React.createElement("div", {
        ref: this.props.forwardRef,
        className: this.props.className,
        style: this.props.style,
        onClick: this.props.onClick,
        onMouseUp: this.props.onMouseUp
      }, this.props.children));
    }
  }, {
    key: "render",
    value: function render() {
      var element = this.renderElement();
      return this.props.inline ? element : /*#__PURE__*/React.createElement(Portal, {
        element: element,
        appendTo: this.props.appendTo
      });
    }
  }]);

  return CalendarPanelComponent;
}(Component);

_defineProperty$p(CalendarPanelComponent, "defaultProps", {
  appendTo: null,
  style: null,
  className: null
});

var CalendarPanel = /*#__PURE__*/React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(CalendarPanelComponent, _extends$6({
    forwardRef: ref
  }, props));
});

function _createForOfIteratorHelper$9(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$e(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$e(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$e(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(o, minLen);
}

function _arrayLikeToArray$e(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function ownKeys$d(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$d(Object(source), !0).forEach(function (key) {
      _defineProperty$p(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$v();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$p(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$p(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$p(this, result);
  };
}

function _isNativeReflectConstruct$v() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Calendar = /*#__PURE__*/function (_Component) {
  _inherits$p(Calendar, _Component);

  var _super = _createSuper$v(Calendar);

  function Calendar(props) {
    var _this;

    _classCallCheck$p(this, Calendar);

    _this = _super.call(this, props);
    _this.state = {
      focused: false,
      overlayVisible: false
    };

    if (!_this.props.onViewDateChange) {
      var viewDate = _this.getViewDate(_this.props.viewDate);

      _this.validateDate(viewDate);

      _this.state = _objectSpread$d(_objectSpread$d({}, _this.state), {}, {
        viewDate: viewDate
      });
    }

    _this.navigation = null;
    _this.onUserInput = _this.onUserInput.bind(_assertThisInitialized$o(_this));
    _this.onInputFocus = _this.onInputFocus.bind(_assertThisInitialized$o(_this));
    _this.onInputBlur = _this.onInputBlur.bind(_assertThisInitialized$o(_this));
    _this.onInputKeyDown = _this.onInputKeyDown.bind(_assertThisInitialized$o(_this));
    _this.onButtonClick = _this.onButtonClick.bind(_assertThisInitialized$o(_this));
    _this.onPrevButtonClick = _this.onPrevButtonClick.bind(_assertThisInitialized$o(_this));
    _this.onNextButtonClick = _this.onNextButtonClick.bind(_assertThisInitialized$o(_this));
    _this.onMonthDropdownChange = _this.onMonthDropdownChange.bind(_assertThisInitialized$o(_this));
    _this.onYearDropdownChange = _this.onYearDropdownChange.bind(_assertThisInitialized$o(_this));
    _this.onTodayButtonClick = _this.onTodayButtonClick.bind(_assertThisInitialized$o(_this));
    _this.onClearButtonClick = _this.onClearButtonClick.bind(_assertThisInitialized$o(_this));
    _this.onPanelClick = _this.onPanelClick.bind(_assertThisInitialized$o(_this));
    _this.onPanelMouseUp = _this.onPanelMouseUp.bind(_assertThisInitialized$o(_this));
    _this.incrementHour = _this.incrementHour.bind(_assertThisInitialized$o(_this));
    _this.decrementHour = _this.decrementHour.bind(_assertThisInitialized$o(_this));
    _this.incrementMinute = _this.incrementMinute.bind(_assertThisInitialized$o(_this));
    _this.decrementMinute = _this.decrementMinute.bind(_assertThisInitialized$o(_this));
    _this.incrementSecond = _this.incrementSecond.bind(_assertThisInitialized$o(_this));
    _this.decrementSecond = _this.decrementSecond.bind(_assertThisInitialized$o(_this));
    _this.toggleAmPm = _this.toggleAmPm.bind(_assertThisInitialized$o(_this));
    _this.onTimePickerElementMouseDown = _this.onTimePickerElementMouseDown.bind(_assertThisInitialized$o(_this));
    _this.onTimePickerElementMouseUp = _this.onTimePickerElementMouseUp.bind(_assertThisInitialized$o(_this));
    _this.onTimePickerElementMouseLeave = _this.onTimePickerElementMouseLeave.bind(_assertThisInitialized$o(_this));
    _this.onOverlayEnter = _this.onOverlayEnter.bind(_assertThisInitialized$o(_this));
    _this.onOverlayEntered = _this.onOverlayEntered.bind(_assertThisInitialized$o(_this));
    _this.onOverlayExit = _this.onOverlayExit.bind(_assertThisInitialized$o(_this));
    _this.onOverlayExited = _this.onOverlayExited.bind(_assertThisInitialized$o(_this));
    _this.reFocusInputField = _this.reFocusInputField.bind(_assertThisInitialized$o(_this));
    _this.overlayRef = /*#__PURE__*/createRef();
    _this.inputRef = /*#__PURE__*/createRef(_this.props.inputRef);
    return _this;
  }

  _createClass$p(Calendar, [{
    key: "updateInputRef",
    value: function updateInputRef() {
      var ref = this.props.inputRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.inputRef.current);
        } else {
          ref.current = this.inputRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.updateInputRef();

      if (this.props.tooltip) {
        this.renderTooltip();
      }

      if (this.props.inline) {
        this.initFocusableCell();
      } else if (this.props.mask) {
        mask(this.inputRef.current, {
          mask: this.props.mask,
          readOnly: this.props.readOnlyInput || this.props.disabled,
          onChange: function onChange(e) {
            return _this2.updateValueOnInput(e.originalEvent, e.value);
          }
        });
      }

      if (this.props.value) {
        this.updateInputfield(this.props.value);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this3 = this;

      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$d({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }

      if (!this.props.onViewDateChange && !this.viewStateChanged) {
        var propValue = this.props.value;

        if (Array.isArray(propValue)) {
          propValue = propValue[0];
        }

        var prevPropValue = prevProps.value;

        if (Array.isArray(prevPropValue)) {
          prevPropValue = prevPropValue[0];
        }

        if (!prevPropValue && propValue || propValue && propValue instanceof Date && propValue.getTime() !== prevPropValue.getTime()) {
          var viewDate = this.props.viewDate && this.isValidDate(this.props.viewDate) ? this.props.viewDate : propValue && this.isValidDate(propValue) ? propValue : new Date();
          this.validateDate(viewDate);
          this.setState({
            viewDate: viewDate
          }, function () {
            _this3.viewStateChanged = true;
          });
        }
      }

      if (this.overlayRef && this.overlayRef.current) {
        this.updateFocus();
      }

      if (prevProps.value !== this.props.value && (!this.viewStateChanged || !this.isVisible()) || this.isOptionChanged(prevProps)) {
        this.updateInputfield(this.props.value);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.hideTimeout) {
        clearTimeout(this.hideTimeout);
      }

      if (this.touchUIMask) {
        this.disableModality();
        this.touchUIMask = null;
      }

      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }

      this.unbindDocumentClickListener();
      this.unbindDocumentResizeListener();

      if (this.scrollHandler) {
        this.scrollHandler.destroy();
        this.scrollHandler = null;
      }

      ZIndexUtils.clear(this.overlayRef.current);
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.inputRef.current,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "isVisible",
    value: function isVisible() {
      return this.props.onVisibleChange ? this.props.visible : this.state.overlayVisible;
    }
  }, {
    key: "isOptionChanged",
    value: function isOptionChanged(prevProps) {
      var _this4 = this;

      var optionProps = ['dateFormat', 'hourFormat', 'timeOnly', 'showSeconds', 'showMillisec'];
      return optionProps.some(function (option) {
        return prevProps[option] !== _this4.props[option];
      });
    }
  }, {
    key: "getDateFormat",
    value: function getDateFormat() {
      return this.props.dateFormat || localeOption('dateFormat', this.props.locale);
    }
  }, {
    key: "onInputFocus",
    value: function onInputFocus(event) {
      var _this5 = this;

      if (this.ignoreFocusFunctionality) {
        this.setState({
          focused: true
        }, function () {
          _this5.ignoreFocusFunctionality = false;
        });
      } else {
        event.persist();

        if (this.props.showOnFocus && !this.isVisible()) {
          this.showOverlay();
        }

        this.setState({
          focused: true
        }, function () {
          if (_this5.props.onFocus) {
            _this5.props.onFocus(event);
          }
        });
      }
    }
  }, {
    key: "onInputBlur",
    value: function onInputBlur(event) {
      var _this6 = this;

      event.persist();
      this.setState({
        focused: false
      }, function () {
        if (_this6.props.onBlur) {
          _this6.props.onBlur(event);
        }

        if (!_this6.props.keepInvalid) {
          _this6.updateInputfield(_this6.props.value);
        }
      });
    }
  }, {
    key: "onInputKeyDown",
    value: function onInputKeyDown(event) {
      this.isKeydown = true;

      switch (event.which) {
        //escape
        case 27:
          {
            this.hideOverlay();
            break;
          }
        //tab

        case 9:
          {
            if (this.isVisible()) {
              this.trapFocus(event);
            }

            if (this.props.touchUI) {
              this.disableModality();
            }

            break;
          }
      }
    }
  }, {
    key: "onUserInput",
    value: function onUserInput(event) {
      // IE 11 Workaround for input placeholder
      if (!this.isKeydown) {
        return;
      }

      this.isKeydown = false;
      this.updateValueOnInput(event, event.target.value);

      if (this.props.onInput) {
        this.props.onInput(event);
      }
    }
  }, {
    key: "updateValueOnInput",
    value: function updateValueOnInput(event, rawValue) {
      try {
        var value = this.parseValueFromString(rawValue);

        if (this.isValidSelection(value)) {
          this.updateModel(event, value);
          this.updateViewDate(event, value.length ? value[0] : value);
        }
      } catch (err) {
        //invalid date
        var _value = this.props.keepInvalid ? rawValue : null;

        this.updateModel(event, _value);
      }
    }
  }, {
    key: "reFocusInputField",
    value: function reFocusInputField() {
      if (!this.props.inline && this.inputRef.current) {
        this.ignoreFocusFunctionality = true;
        this.inputRef.current.focus();
      }
    }
  }, {
    key: "isValidSelection",
    value: function isValidSelection(value) {
      var _this7 = this;

      var isValid = true;

      if (this.isSingleSelection()) {
        if (!(this.isSelectable(value.getDate(), value.getMonth(), value.getFullYear(), false) && this.isSelectableTime(value))) {
          isValid = false;
        }
      } else if (value.every(function (v) {
        return _this7.isSelectable(v.getDate(), v.getMonth(), v.getFullYear(), false) && _this7.isSelectableTime(v);
      })) {
        if (this.isRangeSelection()) {
          isValid = value.length > 1 && value[1] > value[0] ? true : false;
        }
      }

      return isValid;
    }
  }, {
    key: "onButtonClick",
    value: function onButtonClick() {
      if (this.isVisible()) {
        this.hideOverlay();
      } else {
        this.showOverlay();
      }
    }
  }, {
    key: "onPrevButtonClick",
    value: function onPrevButtonClick(event) {
      this.navigation = {
        backward: true,
        button: true
      };
      this.navBackward(event);
    }
  }, {
    key: "onNextButtonClick",
    value: function onNextButtonClick(event) {
      this.navigation = {
        backward: false,
        button: true
      };
      this.navForward(event);
    }
  }, {
    key: "onContainerButtonKeydown",
    value: function onContainerButtonKeydown(event) {
      switch (event.which) {
        //tab
        case 9:
          this.trapFocus(event);
          break;
        //escape

        case 27:
          this.hideOverlay(null, this.reFocusInputField);
          event.preventDefault();
          break;
      }
    }
  }, {
    key: "trapFocus",
    value: function trapFocus(event) {
      event.preventDefault();
      var focusableElements = DomHandler$1.getFocusableElements(this.overlayRef.current);

      if (focusableElements && focusableElements.length > 0) {
        if (!document.activeElement) {
          focusableElements[0].focus();
        } else {
          var focusedIndex = focusableElements.indexOf(document.activeElement);

          if (event.shiftKey) {
            if (focusedIndex === -1 || focusedIndex === 0) focusableElements[focusableElements.length - 1].focus();else focusableElements[focusedIndex - 1].focus();
          } else {
            if (focusedIndex === -1 || focusedIndex === focusableElements.length - 1) focusableElements[0].focus();else focusableElements[focusedIndex + 1].focus();
          }
        }
      }
    }
  }, {
    key: "updateFocus",
    value: function updateFocus() {
      var cell;

      if (this.navigation) {
        if (this.navigation.button) {
          this.initFocusableCell();
          if (this.navigation.backward) DomHandler$1.findSingle(this.overlayRef.current, '.p-datepicker-prev').focus();else DomHandler$1.findSingle(this.overlayRef.current, '.p-datepicker-next').focus();
        } else {
          if (this.navigation.backward) {
            var cells = DomHandler$1.find(this.overlayRef.current, '.p-datepicker-calendar td span:not(.p-disabled)');
            cell = cells[cells.length - 1];
          } else {
            cell = DomHandler$1.findSingle(this.overlayRef.current, '.p-datepicker-calendar td span:not(.p-disabled)');
          }

          if (cell) {
            cell.tabIndex = '0';
            cell.focus();
          }
        }

        this.navigation = null;
      } else {
        this.initFocusableCell();
      }
    }
  }, {
    key: "initFocusableCell",
    value: function initFocusableCell() {
      var cell;

      if (this.view === 'month') {
        var cells = DomHandler$1.find(this.overlayRef.current, '.p-monthpicker .p-monthpicker-month');
        var selectedCell = DomHandler$1.findSingle(this.overlayRef.current, '.p-monthpicker .p-monthpicker-month.p-highlight');
        cells.forEach(function (cell) {
          return cell.tabIndex = -1;
        });
        cell = selectedCell || cells[0];
      } else {
        cell = DomHandler$1.findSingle(this.overlayRef.current, 'span.p-highlight');

        if (!cell) {
          var todayCell = DomHandler$1.findSingle(this.overlayRef.current, 'td.p-datepicker-today span:not(.p-disabled)');
          if (todayCell) cell = todayCell;else cell = DomHandler$1.findSingle(this.overlayRef.current, '.p-datepicker-calendar td span:not(.p-disabled)');
        }
      }

      if (cell) {
        cell.tabIndex = '0';
      }
    }
  }, {
    key: "navBackward",
    value: function navBackward(event) {
      if (this.props.disabled) {
        event.preventDefault();
        return;
      }

      var newViewDate = new Date(this.getViewDate().getTime());
      newViewDate.setDate(1);

      if (this.props.view === 'date') {
        if (newViewDate.getMonth() === 0) {
          newViewDate.setMonth(11);
          newViewDate.setFullYear(newViewDate.getFullYear() - 1);
        } else {
          newViewDate.setMonth(newViewDate.getMonth() - 1);
        }
      } else if (this.props.view === 'month') {
        var currentYear = newViewDate.getFullYear();
        var newYear = currentYear - 1;

        if (this.props.yearNavigator) {
          var minYear = parseInt(this.props.yearRange.split(':')[0], 10);

          if (newYear < minYear) {
            newYear = minYear;
          }
        }

        newViewDate.setFullYear(newYear);
      }

      this.updateViewDate(event, newViewDate);
      event.preventDefault();
    }
  }, {
    key: "navForward",
    value: function navForward(event) {
      if (this.props.disabled) {
        event.preventDefault();
        return;
      }

      var newViewDate = new Date(this.getViewDate().getTime());
      newViewDate.setDate(1);

      if (this.props.view === 'date') {
        if (newViewDate.getMonth() === 11) {
          newViewDate.setMonth(0);
          newViewDate.setFullYear(newViewDate.getFullYear() + 1);
        } else {
          newViewDate.setMonth(newViewDate.getMonth() + 1);
        }
      } else if (this.props.view === 'month') {
        var currentYear = newViewDate.getFullYear();
        var newYear = currentYear + 1;

        if (this.props.yearNavigator) {
          var maxYear = parseInt(this.props.yearRange.split(':')[1], 10);

          if (newYear > maxYear) {
            newYear = maxYear;
          }
        }

        newViewDate.setFullYear(newYear);
      }

      this.updateViewDate(event, newViewDate);
      event.preventDefault();
    }
  }, {
    key: "onMonthDropdownChange",
    value: function onMonthDropdownChange(event, value) {
      var currentViewDate = this.getViewDate();
      var newViewDate = new Date(currentViewDate.getTime());
      newViewDate.setMonth(parseInt(value, 10));
      this.updateViewDate(event, newViewDate);
    }
  }, {
    key: "onYearDropdownChange",
    value: function onYearDropdownChange(event, value) {
      var currentViewDate = this.getViewDate();
      var newViewDate = new Date(currentViewDate.getTime());
      newViewDate.setFullYear(parseInt(value, 10));
      this.updateViewDate(event, newViewDate);
    }
  }, {
    key: "onTodayButtonClick",
    value: function onTodayButtonClick(event) {
      var today = new Date();
      var dateMeta = {
        day: today.getDate(),
        month: today.getMonth(),
        year: today.getFullYear(),
        today: true,
        selectable: true
      };
      var timeMeta = {
        hours: today.getHours(),
        minutes: today.getMinutes(),
        seconds: today.getSeconds(),
        milliseconds: today.getMilliseconds()
      };
      this.updateViewDate(event, today);
      this.onDateSelect(event, dateMeta, timeMeta);

      if (this.props.onTodayButtonClick) {
        this.props.onTodayButtonClick(event);
      }
    }
  }, {
    key: "onClearButtonClick",
    value: function onClearButtonClick(event) {
      this.updateModel(event, null);
      this.updateInputfield(null);
      this.hideOverlay();

      if (this.props.onClearButtonClick) {
        this.props.onClearButtonClick(event);
      }
    }
  }, {
    key: "onPanelClick",
    value: function onPanelClick(event) {
      if (!this.props.inline) {
        OverlayService.emit('overlay-click', {
          originalEvent: event,
          target: this.container
        });
      }
    }
  }, {
    key: "onPanelMouseUp",
    value: function onPanelMouseUp(event) {
      this.onPanelClick(event);
    }
  }, {
    key: "onTimePickerElementMouseDown",
    value: function onTimePickerElementMouseDown(event, type, direction) {
      if (!this.props.disabled) {
        this.repeat(event, null, type, direction);
        event.preventDefault();
      }
    }
  }, {
    key: "onTimePickerElementMouseUp",
    value: function onTimePickerElementMouseUp() {
      if (!this.props.disabled) {
        this.clearTimePickerTimer();
      }
    }
  }, {
    key: "onTimePickerElementMouseLeave",
    value: function onTimePickerElementMouseLeave() {
      if (!this.props.disabled) {
        this.clearTimePickerTimer();
      }
    }
  }, {
    key: "repeat",
    value: function repeat(event, interval, type, direction) {
      var _this8 = this;

      event.persist();
      var i = interval || 500;
      this.clearTimePickerTimer();
      this.timePickerTimer = setTimeout(function () {
        _this8.repeat(event, 100, type, direction);
      }, i);

      switch (type) {
        case 0:
          if (direction === 1) this.incrementHour(event);else this.decrementHour(event);
          break;

        case 1:
          if (direction === 1) this.incrementMinute(event);else this.decrementMinute(event);
          break;

        case 2:
          if (direction === 1) this.incrementSecond(event);else this.decrementSecond(event);
          break;

        case 3:
          if (direction === 1) this.incrementMilliSecond(event);else this.decrementMilliSecond(event);
          break;
      }
    }
  }, {
    key: "clearTimePickerTimer",
    value: function clearTimePickerTimer() {
      if (this.timePickerTimer) {
        clearTimeout(this.timePickerTimer);
      }
    }
  }, {
    key: "incrementHour",
    value: function incrementHour(event) {
      var currentTime = this.getCurrentDateTime();
      var currentHour = currentTime.getHours();
      var newHour = currentHour + this.props.stepHour;
      newHour = newHour >= 24 ? newHour - 24 : newHour;

      if (this.validateHour(newHour, currentTime)) {
        if (this.props.maxDate && this.props.maxDate.toDateString() === currentTime.toDateString() && this.props.maxDate.getHours() === newHour) {
          if (this.props.maxDate.getMinutes() < currentTime.getMinutes()) {
            if (this.props.maxDate.getSeconds() < currentTime.getSeconds()) {
              if (this.props.maxDate.getMilliseconds() < currentTime.getMilliseconds()) {
                this.updateTime(event, newHour, this.props.maxDate.getMinutes(), this.props.maxDate.getSeconds(), this.props.maxDate.getMilliseconds());
              } else {
                this.updateTime(event, newHour, this.props.maxDate.getMinutes(), this.props.maxDate.getSeconds(), currentTime.getMilliseconds());
              }
            } else {
              this.updateTime(event, newHour, this.props.maxDate.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
            }
          } else if (this.props.maxDate.getMinutes() === currentTime.getMinutes()) {
            if (this.props.maxDate.getSeconds() < currentTime.getSeconds()) {
              if (this.props.maxDate.getMilliseconds() < currentTime.getMilliseconds()) {
                this.updateTime(event, newHour, this.props.maxDate.getMinutes(), this.props.maxDate.getSeconds(), this.props.maxDate.getMilliseconds());
              } else {
                this.updateTime(event, newHour, this.props.maxDate.getMinutes(), this.props.maxDate.getSeconds(), currentTime.getMilliseconds());
              }
            } else {
              this.updateTime(event, newHour, this.props.maxDate.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
            }
          } else {
            this.updateTime(event, newHour, currentTime.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
          }
        } else {
          this.updateTime(event, newHour, currentTime.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
        }
      }

      event.preventDefault();
    }
  }, {
    key: "decrementHour",
    value: function decrementHour(event) {
      var currentTime = this.getCurrentDateTime();
      var currentHour = currentTime.getHours();
      var newHour = currentHour - this.props.stepHour;
      newHour = newHour < 0 ? newHour + 24 : newHour;

      if (this.validateHour(newHour, currentTime)) {
        if (this.props.minDate && this.props.minDate.toDateString() === currentTime.toDateString() && this.props.minDate.getHours() === newHour) {
          if (this.props.minDate.getMinutes() > currentTime.getMinutes()) {
            if (this.props.minDate.getSeconds() > currentTime.getSeconds()) {
              if (this.props.minDate.getMilliseconds() > currentTime.getMilliseconds()) {
                this.updateTime(event, newHour, this.props.minDate.getMinutes(), this.props.minDate.getSeconds(), this.props.minDate.getMilliseconds());
              } else {
                this.updateTime(event, newHour, this.props.minDate.getMinutes(), this.props.minDate.getSeconds(), currentTime.getMilliseconds());
              }
            } else {
              this.updateTime(event, newHour, this.props.minDate.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
            }
          } else if (this.props.minDate.getMinutes() === currentTime.getMinutes()) {
            if (this.props.minDate.getSeconds() > currentTime.getSeconds()) {
              if (this.props.minDate.getMilliseconds() > currentTime.getMilliseconds()) {
                this.updateTime(event, newHour, this.props.minDate.getMinutes(), this.props.minDate.getSeconds(), this.props.minDate.getMilliseconds());
              } else {
                this.updateTime(event, newHour, this.props.minDate.getMinutes(), this.props.minDate.getSeconds(), currentTime.getMilliseconds());
              }
            } else {
              this.updateTime(event, newHour, this.props.minDate.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
            }
          } else {
            this.updateTime(event, newHour, currentTime.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
          }
        } else {
          this.updateTime(event, newHour, currentTime.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
        }
      }

      event.preventDefault();
    }
  }, {
    key: "doStepMinute",
    value: function doStepMinute(currentMinute, step) {
      if (this.props.stepMinute <= 1) {
        return step ? currentMinute + step : currentMinute;
      }

      if (!step) {
        step = this.props.stepMinute;

        if (currentMinute % step === 0) {
          return currentMinute;
        }
      }

      var newMinute = currentMinute + step;
      newMinute = Math.floor(newMinute / step) * step;
      return newMinute;
    }
  }, {
    key: "incrementMinute",
    value: function incrementMinute(event) {
      var currentTime = this.getCurrentDateTime();
      var currentMinute = currentTime.getMinutes();
      var newMinute = this.doStepMinute(currentMinute, this.props.stepMinute);
      newMinute = newMinute > 59 ? newMinute - 60 : newMinute;

      if (this.validateMinute(newMinute, currentTime)) {
        if (this.props.maxDate && this.props.maxDate.toDateString() === currentTime.toDateString() && this.props.maxDate.getMinutes() === newMinute) {
          if (this.props.maxDate.getSeconds() < currentTime.getSeconds()) {
            if (this.props.maxDate.getMilliseconds() < currentTime.getMilliseconds()) {
              this.updateTime(event, currentTime.getHours(), newMinute, this.props.maxDate.getSeconds(), this.props.maxDate.getMilliseconds());
            } else {
              this.updateTime(event, currentTime.getHours(), newMinute, this.props.maxDate.getSeconds(), currentTime.getMilliseconds());
            }
          } else {
            this.updateTime(event, currentTime.getHours(), newMinute, currentTime.getSeconds(), currentTime.getMilliseconds());
          }
        } else {
          this.updateTime(event, currentTime.getHours(), newMinute, currentTime.getSeconds(), currentTime.getMilliseconds());
        }
      }

      event.preventDefault();
    }
  }, {
    key: "decrementMinute",
    value: function decrementMinute(event) {
      var currentTime = this.getCurrentDateTime();
      var currentMinute = currentTime.getMinutes();
      var newMinute = this.doStepMinute(currentMinute, -this.props.stepMinute);
      newMinute = newMinute < 0 ? newMinute + 60 : newMinute;

      if (this.validateMinute(newMinute, currentTime)) {
        if (this.props.minDate && this.props.minDate.toDateString() === currentTime.toDateString() && this.props.minDate.getMinutes() === newMinute) {
          if (this.props.minDate.getSeconds() > currentTime.getSeconds()) {
            if (this.props.minDate.getMilliseconds() > currentTime.getMilliseconds()) {
              this.updateTime(event, currentTime.getHours(), newMinute, this.props.minDate.getSeconds(), this.props.minDate.getMilliseconds());
            } else {
              this.updateTime(event, currentTime.getHours(), newMinute, this.props.minDate.getSeconds(), currentTime.getMilliseconds());
            }
          } else {
            this.updateTime(event, currentTime.getHours(), newMinute, currentTime.getSeconds(), currentTime.getMilliseconds());
          }
        } else {
          this.updateTime(event, currentTime.getHours(), newMinute, currentTime.getSeconds(), currentTime.getMilliseconds());
        }
      }

      event.preventDefault();
    }
  }, {
    key: "incrementSecond",
    value: function incrementSecond(event) {
      var currentTime = this.getCurrentDateTime();
      var currentSecond = currentTime.getSeconds();
      var newSecond = currentSecond + this.props.stepSecond;
      newSecond = newSecond > 59 ? newSecond - 60 : newSecond;

      if (this.validateSecond(newSecond, currentTime)) {
        if (this.props.maxDate && this.props.maxDate.toDateString() === currentTime.toDateString() && this.props.maxDate.getSeconds() === newSecond) {
          if (this.props.maxDate.getMilliseconds() < currentTime.getMilliseconds()) {
            this.updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, this.props.maxDate.getMilliseconds());
          } else {
            this.updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, currentTime.getMilliseconds());
          }
        } else {
          this.updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, currentTime.getMilliseconds());
        }
      }

      event.preventDefault();
    }
  }, {
    key: "decrementSecond",
    value: function decrementSecond(event) {
      var currentTime = this.getCurrentDateTime();
      var currentSecond = currentTime.getSeconds();
      var newSecond = currentSecond - this.props.stepSecond;
      newSecond = newSecond < 0 ? newSecond + 60 : newSecond;

      if (this.validateSecond(newSecond, currentTime)) {
        if (this.props.minDate && this.props.minDate.toDateString() === currentTime.toDateString() && this.props.minDate.getSeconds() === newSecond) {
          if (this.props.minDate.getMilliseconds() > currentTime.getMilliseconds()) {
            this.updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, this.props.minDate.getMilliseconds());
          } else {
            this.updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, currentTime.getMilliseconds());
          }
        } else {
          this.updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, currentTime.getMilliseconds());
        }
      }

      event.preventDefault();
    }
  }, {
    key: "incrementMilliSecond",
    value: function incrementMilliSecond(event) {
      var currentTime = this.getCurrentDateTime();
      var currentMillisecond = currentTime.getMilliseconds();
      var newMillisecond = currentMillisecond + this.props.stepMillisec;
      newMillisecond = newMillisecond > 999 ? newMillisecond - 1000 : newMillisecond;

      if (this.validateMillisecond(newMillisecond, currentTime)) {
        this.updateTime(event, currentTime.getHours(), currentTime.getMinutes(), currentTime.getSeconds(), newMillisecond);
      }

      event.preventDefault();
    }
  }, {
    key: "decrementMilliSecond",
    value: function decrementMilliSecond(event) {
      var currentTime = this.getCurrentDateTime();
      var currentMillisecond = currentTime.getMilliseconds();
      var newMillisecond = currentMillisecond - this.props.stepMillisec;
      newMillisecond = newMillisecond < 0 ? newMillisecond + 999 : newMillisecond;

      if (this.validateMillisecond(newMillisecond, currentTime)) {
        this.updateTime(event, currentTime.getHours(), currentTime.getMinutes(), currentTime.getSeconds(), newMillisecond);
      }

      event.preventDefault();
    }
  }, {
    key: "toggleAmPm",
    value: function toggleAmPm(event) {
      var currentTime = this.getCurrentDateTime();
      var currentHour = currentTime.getHours();
      var newHour = currentHour >= 12 ? currentHour - 12 : currentHour + 12;
      this.updateTime(event, newHour, currentTime.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
      event.preventDefault();
    }
  }, {
    key: "getViewDate",
    value: function getViewDate(date) {
      var propValue = this.props.value;
      var viewDate = date || (this.props.onViewDateChange ? this.props.viewDate : this.state.viewDate);

      if (Array.isArray(propValue)) {
        propValue = propValue[0];
      }

      return viewDate && this.isValidDate(viewDate) ? viewDate : propValue && this.isValidDate(propValue) ? propValue : new Date();
    }
  }, {
    key: "getCurrentDateTime",
    value: function getCurrentDateTime() {
      if (this.isSingleSelection()) {
        return this.props.value && this.props.value instanceof Date ? this.props.value : this.getViewDate();
      } else if (this.isMultipleSelection()) {
        if (this.props.value && this.props.value.length) {
          return this.props.value[this.props.value.length - 1];
        }
      } else if (this.isRangeSelection()) {
        if (this.props.value && this.props.value.length) {
          var startDate = this.props.value[0];
          var endDate = this.props.value[1];
          return endDate || startDate;
        }
      }

      return new Date();
    }
  }, {
    key: "isValidDate",
    value: function isValidDate(date) {
      return date instanceof Date && !isNaN(date);
    }
  }, {
    key: "validateHour",
    value: function validateHour(hour, value) {
      var valid = true;
      var valueDateString = value ? value.toDateString() : null;

      if (this.props.minDate && valueDateString && this.props.minDate.toDateString() === valueDateString) {
        if (this.props.minDate.getHours() > hour) {
          valid = false;
        }
      }

      if (this.props.maxDate && valueDateString && this.props.maxDate.toDateString() === valueDateString) {
        if (this.props.maxDate.getHours() < hour) {
          valid = false;
        }
      }

      return valid;
    }
  }, {
    key: "validateMinute",
    value: function validateMinute(minute, value) {
      var valid = true;
      var valueDateString = value ? value.toDateString() : null;

      if (this.props.minDate && valueDateString && this.props.minDate.toDateString() === valueDateString) {
        if (value.getHours() === this.props.minDate.getHours()) {
          if (this.props.minDate.getMinutes() > minute) {
            valid = false;
          }
        }
      }

      if (this.props.maxDate && valueDateString && this.props.maxDate.toDateString() === valueDateString) {
        if (value.getHours() === this.props.maxDate.getHours()) {
          if (this.props.maxDate.getMinutes() < minute) {
            valid = false;
          }
        }
      }

      return valid;
    }
  }, {
    key: "validateSecond",
    value: function validateSecond(second, value) {
      var valid = true;
      var valueDateString = value ? value.toDateString() : null;

      if (this.props.minDate && valueDateString && this.props.minDate.toDateString() === valueDateString) {
        if (value.getHours() === this.props.minDate.getHours() && value.getMinutes() === this.props.minDate.getMinutes()) {
          if (this.props.minDate.getSeconds() > second) {
            valid = false;
          }
        }
      }

      if (this.props.maxDate && valueDateString && this.props.maxDate.toDateString() === valueDateString) {
        if (value.getHours() === this.props.maxDate.getHours() && value.getMinutes() === this.props.maxDate.getMinutes()) {
          if (this.props.maxDate.getSeconds() < second) {
            valid = false;
          }
        }
      }

      return valid;
    }
  }, {
    key: "validateMillisecond",
    value: function validateMillisecond(millisecond, value) {
      var valid = true;
      var valueDateString = value ? value.toDateString() : null;

      if (this.props.minDate && valueDateString && this.props.minDate.toDateString() === valueDateString) {
        if (value.getHours() === this.props.minDate.getHours() && value.getSeconds() === this.props.minDate.getSeconds() && value.getMinutes() === this.props.minDate.getMinutes()) {
          if (this.props.minDate.getMilliseconds() > millisecond) {
            valid = false;
          }
        }
      }

      if (this.props.maxDate && valueDateString && this.props.maxDate.toDateString() === valueDateString) {
        if (value.getHours() === this.props.maxDate.getHours() && value.getSeconds() === this.props.maxDate.getSeconds() && value.getMinutes() === this.props.maxDate.getMinutes()) {
          if (this.props.maxDate.getMilliseconds() < millisecond) {
            valid = false;
          }
        }
      }

      return valid;
    }
  }, {
    key: "validateDate",
    value: function validateDate(value) {
      if (this.props.yearNavigator) {
        var viewYear = value.getFullYear();
        var minRangeYear = this.props.yearRange ? parseInt(this.props.yearRange.split(':')[0], 10) : null;
        var maxRangeYear = this.props.yearRange ? parseInt(this.props.yearRange.split(':')[1], 10) : null;
        var minYear = this.props.minDate && minRangeYear != null ? Math.max(this.props.minDate.getFullYear(), minRangeYear) : this.props.minDate || minRangeYear;
        var maxYear = this.props.maxDate && maxRangeYear != null ? Math.min(this.props.maxDate.getFullYear(), maxRangeYear) : this.props.maxDate || maxRangeYear;

        if (minYear && minYear > viewYear) {
          viewYear = minYear;
        }

        if (maxYear && maxYear < viewYear) {
          viewYear = maxYear;
        }

        value.setFullYear(viewYear);
      }

      if (this.props.monthNavigator && this.props.view !== 'month') {
        var viewMonth = value.getMonth();
        var viewMonthWithMinMax = parseInt(this.isInMinYear(value) && Math.max(this.props.minDate.getMonth(), viewMonth).toString() || this.isInMaxYear(value) && Math.min(this.props.maxDate.getMonth(), viewMonth).toString() || viewMonth);
        value.setMonth(viewMonthWithMinMax);
      }
    }
  }, {
    key: "updateTime",
    value: function updateTime(event, hour, minute, second, millisecond) {
      var newDateTime = this.getCurrentDateTime();
      newDateTime.setHours(hour);
      newDateTime.setMinutes(minute);
      newDateTime.setSeconds(second);
      newDateTime.setMilliseconds(millisecond);

      if (this.isMultipleSelection()) {
        if (this.props.value && this.props.value.length) {
          var value = _toConsumableArray$9(this.props.value);

          value[value.length - 1] = newDateTime;
          newDateTime = value;
        } else {
          newDateTime = [newDateTime];
        }
      } else if (this.isRangeSelection()) {
        if (this.props.value && this.props.value.length) {
          var startDate = this.props.value[0];
          var endDate = this.props.value[1];
          newDateTime = endDate ? [startDate, newDateTime] : [newDateTime, null];
        } else {
          newDateTime = [newDateTime, null];
        }
      }

      this.updateModel(event, newDateTime);

      if (this.props.onSelect) {
        this.props.onSelect({
          originalEvent: event,
          value: newDateTime
        });
      }

      this.updateInputfield(newDateTime);
    }
  }, {
    key: "updateViewDate",
    value: function updateViewDate(event, value) {
      this.validateDate(value);

      if (this.props.onViewDateChange) {
        this.props.onViewDateChange({
          originalEvent: event,
          value: value
        });
      } else {
        this.viewStateChanged = true;
        this.setState({
          viewDate: value
        });
      }
    }
  }, {
    key: "onDateCellKeydown",
    value: function onDateCellKeydown(event, date, groupIndex) {
      var cellContent = event.currentTarget;
      var cell = cellContent.parentElement;

      switch (event.which) {
        //down arrow
        case 40:
          {
            cellContent.tabIndex = '-1';
            var cellIndex = DomHandler$1.index(cell);
            var nextRow = cell.parentElement.nextElementSibling;

            if (nextRow) {
              var focusCell = nextRow.children[cellIndex].children[0];

              if (DomHandler$1.hasClass(focusCell, 'p-disabled')) {
                this.navigation = {
                  backward: false
                };
                this.navForward(event);
              } else {
                nextRow.children[cellIndex].children[0].tabIndex = '0';
                nextRow.children[cellIndex].children[0].focus();
              }
            } else {
              this.navigation = {
                backward: false
              };
              this.navForward(event);
            }

            event.preventDefault();
            break;
          }
        //up arrow

        case 38:
          {
            cellContent.tabIndex = '-1';

            var _cellIndex = DomHandler$1.index(cell);

            var prevRow = cell.parentElement.previousElementSibling;

            if (prevRow) {
              var _focusCell = prevRow.children[_cellIndex].children[0];

              if (DomHandler$1.hasClass(_focusCell, 'p-disabled')) {
                this.navigation = {
                  backward: true
                };
                this.navBackward(event);
              } else {
                _focusCell.tabIndex = '0';

                _focusCell.focus();
              }
            } else {
              this.navigation = {
                backward: true
              };
              this.navBackward(event);
            }

            event.preventDefault();
            break;
          }
        //left arrow

        case 37:
          {
            cellContent.tabIndex = '-1';
            var prevCell = cell.previousElementSibling;

            if (prevCell) {
              var _focusCell2 = prevCell.children[0];

              if (DomHandler$1.hasClass(_focusCell2, 'p-disabled')) {
                this.navigateToMonth(true, groupIndex, event);
              } else {
                _focusCell2.tabIndex = '0';

                _focusCell2.focus();
              }
            } else {
              this.navigateToMonth(true, groupIndex, event);
            }

            event.preventDefault();
            break;
          }
        //right arrow

        case 39:
          {
            cellContent.tabIndex = '-1';
            var nextCell = cell.nextElementSibling;

            if (nextCell) {
              var _focusCell3 = nextCell.children[0];

              if (DomHandler$1.hasClass(_focusCell3, 'p-disabled')) {
                this.navigateToMonth(false, groupIndex, event);
              } else {
                _focusCell3.tabIndex = '0';

                _focusCell3.focus();
              }
            } else {
              this.navigateToMonth(false, groupIndex, event);
            }

            event.preventDefault();
            break;
          }
        //enter

        case 13:
          {
            this.onDateSelect(event, date);
            event.preventDefault();
            break;
          }
        //escape

        case 27:
          {
            this.hideOverlay(null, this.reFocusInputField);
            event.preventDefault();
            break;
          }
        //tab

        case 9:
          {
            this.trapFocus(event);
            break;
          }
      }
    }
  }, {
    key: "navigateToMonth",
    value: function navigateToMonth(prev, groupIndex, event) {
      if (prev) {
        if (this.props.numberOfMonths === 1 || groupIndex === 0) {
          this.navigation = {
            backward: true
          };
          this.navBackward(event);
        } else {
          var prevMonthContainer = this.overlayRef.current.children[groupIndex - 1];
          var cells = DomHandler$1.find(prevMonthContainer, '.p-datepicker-calendar td span:not(.p-disabled)');
          var focusCell = cells[cells.length - 1];
          focusCell.tabIndex = '0';
          focusCell.focus();
        }
      } else {
        if (this.props.numberOfMonths === 1 || groupIndex === this.props.numberOfMonths - 1) {
          this.navigation = {
            backward: false
          };
          this.navForward(event);
        } else {
          var nextMonthContainer = this.overlayRef.current.children[groupIndex + 1];

          var _focusCell4 = DomHandler$1.findSingle(nextMonthContainer, '.p-datepicker-calendar td span:not(.p-disabled)');

          _focusCell4.tabIndex = '0';

          _focusCell4.focus();
        }
      }
    }
  }, {
    key: "onMonthCellKeydown",
    value: function onMonthCellKeydown(event, index) {
      var cell = event.currentTarget;

      switch (event.which) {
        //arrows
        case 38:
        case 40:
          {
            cell.tabIndex = '-1';
            var cells = cell.parentElement.children;
            var cellIndex = DomHandler$1.index(cell);
            var nextCell = cells[event.which === 40 ? cellIndex + 3 : cellIndex - 3];

            if (nextCell) {
              nextCell.tabIndex = '0';
              nextCell.focus();
            }

            event.preventDefault();
            break;
          }
        //left arrow

        case 37:
          {
            cell.tabIndex = '-1';
            var prevCell = cell.previousElementSibling;

            if (prevCell) {
              prevCell.tabIndex = '0';
              prevCell.focus();
            }

            event.preventDefault();
            break;
          }
        //right arrow

        case 39:
          {
            cell.tabIndex = '-1';
            var _nextCell = cell.nextElementSibling;

            if (_nextCell) {
              _nextCell.tabIndex = '0';

              _nextCell.focus();
            }

            event.preventDefault();
            break;
          }
        //enter

        case 13:
          {
            this.onMonthSelect(event, index);
            event.preventDefault();
            break;
          }
        //escape

        case 27:
          {
            this.hideOverlay(null, this.reFocusInputField);
            event.preventDefault();
            break;
          }
        //tab

        case 9:
          {
            this.trapFocus(event);
            break;
          }
      }
    }
  }, {
    key: "onDateSelect",
    value: function onDateSelect(event, dateMeta, timeMeta) {
      var _this9 = this;

      if (this.props.disabled || !dateMeta.selectable) {
        event.preventDefault();
        return;
      }

      DomHandler$1.find(this.overlayRef.current, '.p-datepicker-calendar td span:not(.p-disabled)').forEach(function (cell) {
        return cell.tabIndex = -1;
      });
      event.currentTarget.focus();

      if (this.isMultipleSelection()) {
        if (this.isSelected(dateMeta)) {
          var value = this.props.value.filter(function (date, i) {
            return !_this9.isDateEquals(date, dateMeta);
          });
          this.updateModel(event, value);
          this.updateInputfield(value);
        } else if (!this.props.maxDateCount || !this.props.value || this.props.maxDateCount > this.props.value.length) {
          this.selectDate(event, dateMeta, timeMeta);
        }
      } else {
        this.selectDate(event, dateMeta, timeMeta);
      }

      if (!this.props.inline && this.isSingleSelection() && (!this.props.showTime || this.props.hideOnDateTimeSelect)) {
        setTimeout(function () {
          _this9.hideOverlay('dateselect');
        }, 100);

        if (this.touchUIMask) {
          this.disableModality();
        }
      }

      event.preventDefault();
    }
  }, {
    key: "selectTime",
    value: function selectTime(date, timeMeta) {
      if (this.props.showTime) {
        var hours, minutes, seconds, milliseconds;

        if (timeMeta) {
          hours = timeMeta.hours;
          minutes = timeMeta.minutes;
          seconds = timeMeta.seconds;
          milliseconds = timeMeta.milliseconds;
        } else {
          var time = this.getCurrentDateTime();
          var _ref = [time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()];
          hours = _ref[0];
          minutes = _ref[1];
          seconds = _ref[2];
          milliseconds = _ref[3];
        }

        date.setHours(hours);
        date.setMinutes(minutes);
        date.setSeconds(seconds);
        date.setMilliseconds(milliseconds);
      }
    }
  }, {
    key: "selectDate",
    value: function selectDate(event, dateMeta, timeMeta) {
      var date = new Date(dateMeta.year, dateMeta.month, dateMeta.day);
      this.selectTime(date, timeMeta);

      if (this.props.minDate && this.props.minDate > date) {
        date = this.props.minDate;
      }

      if (this.props.maxDate && this.props.maxDate < date) {
        date = this.props.maxDate;
      }

      var selectedValues = date;

      if (this.isSingleSelection()) {
        this.updateModel(event, date);
      } else if (this.isMultipleSelection()) {
        selectedValues = this.props.value ? [].concat(_toConsumableArray$9(this.props.value), [date]) : [date];
        this.updateModel(event, selectedValues);
      } else if (this.isRangeSelection()) {
        if (this.props.value && this.props.value.length) {
          var startDate = this.props.value[0];
          var endDate = this.props.value[1];

          if (!endDate) {
            if (date.getTime() >= startDate.getTime()) {
              endDate = date;
            } else {
              endDate = startDate;
              startDate = date;
            }
          } else {
            startDate = date;
            endDate = null;
          }

          selectedValues = [startDate, endDate];
          this.updateModel(event, selectedValues);
        } else {
          selectedValues = [date, null];
          this.updateModel(event, selectedValues);
        }
      }

      if (this.props.onSelect) {
        this.props.onSelect({
          originalEvent: event,
          value: date
        });
      }

      this.updateInputfield(selectedValues);
    }
  }, {
    key: "onMonthSelect",
    value: function onMonthSelect(event, month) {
      this.onDateSelect(event, {
        year: this.getViewDate().getFullYear(),
        month: month,
        day: 1,
        selectable: true
      });
      event.preventDefault();
    }
  }, {
    key: "updateModel",
    value: function updateModel(event, value) {
      if (this.props.onChange) {
        var newValue = value && value instanceof Date ? new Date(value.getTime()) : value;
        this.viewStateChanged = true;
        this.props.onChange({
          originalEvent: event,
          value: newValue,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: newValue
          }
        });
      }
    }
  }, {
    key: "showOverlay",
    value: function showOverlay(type) {
      var _this10 = this;

      if (this.props.onVisibleChange) {
        this.props.onVisibleChange({
          visible: true,
          type: type
        });
      } else {
        this.setState({
          overlayVisible: true
        }, function () {
          _this10.overlayEventListener = function (e) {
            if (!_this10.isOutsideClicked(e.target)) {
              _this10.isOverlayClicked = true;
            }
          };

          OverlayService.on('overlay-click', _this10.overlayEventListener);
        });
      }
    }
  }, {
    key: "hideOverlay",
    value: function hideOverlay(type, callback) {
      var _this11 = this;

      var _hideCallback = function _hideCallback() {
        _this11.viewStateChanged = false;
        _this11.ignoreFocusFunctionality = false;
        _this11.isOverlayClicked = false;

        if (callback) {
          callback();
        }

        OverlayService.off('overlay-click', _this11.overlayEventListener);
        _this11.overlayEventListener = null;
      };

      if (this.props.onVisibleChange) this.props.onVisibleChange({
        visible: false,
        type: type,
        callback: _hideCallback
      });else this.setState({
        overlayVisible: false
      }, _hideCallback);
    }
  }, {
    key: "onOverlayEnter",
    value: function onOverlayEnter() {
      if (this.props.autoZIndex) {
        var key = this.props.touchUI ? 'modal' : 'overlay';
        ZIndexUtils.set(key, this.overlayRef.current, PrimeReact.autoZIndex, this.props.baseZIndex || PrimeReact.zIndex[key]);
      }

      this.alignOverlay();
    }
  }, {
    key: "onOverlayEntered",
    value: function onOverlayEntered() {
      this.bindDocumentClickListener();
      this.bindDocumentResizeListener();
      this.bindScrollListener();
      this.props.onShow && this.props.onShow();
    }
  }, {
    key: "onOverlayExit",
    value: function onOverlayExit() {
      this.unbindDocumentClickListener();
      this.unbindDocumentResizeListener();
      this.unbindScrollListener();
    }
  }, {
    key: "onOverlayExited",
    value: function onOverlayExited() {
      ZIndexUtils.clear(this.overlayRef.current);
      this.props.onHide && this.props.onHide();
    }
  }, {
    key: "bindDocumentClickListener",
    value: function bindDocumentClickListener() {
      var _this12 = this;

      if (!this.documentClickListener) {
        this.documentClickListener = function (event) {
          if (!_this12.isOverlayClicked && _this12.isVisible() && _this12.isOutsideClicked(event.target)) {
            _this12.hideOverlay('outside');
          }

          _this12.isOverlayClicked = false;
        };

        document.addEventListener('click', this.documentClickListener);
      }
    }
  }, {
    key: "unbindDocumentClickListener",
    value: function unbindDocumentClickListener() {
      if (this.documentClickListener) {
        document.removeEventListener('click', this.documentClickListener);
        this.documentClickListener = null;
      }
    }
  }, {
    key: "bindDocumentResizeListener",
    value: function bindDocumentResizeListener() {
      if (!this.documentResizeListener && !this.props.touchUI) {
        this.documentResizeListener = this.onWindowResize.bind(this);
        window.addEventListener('resize', this.documentResizeListener);
      }
    }
  }, {
    key: "unbindDocumentResizeListener",
    value: function unbindDocumentResizeListener() {
      if (this.documentResizeListener) {
        window.removeEventListener('resize', this.documentResizeListener);
        this.documentResizeListener = null;
      }
    }
  }, {
    key: "bindScrollListener",
    value: function bindScrollListener() {
      var _this13 = this;

      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.container, function () {
          if (_this13.isVisible()) {
            _this13.hideOverlay();
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    }
  }, {
    key: "unbindScrollListener",
    value: function unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }
  }, {
    key: "isOutsideClicked",
    value: function isOutsideClicked(target) {
      return this.container && !(this.container.isSameNode(target) || this.isNavIconClicked(target) || this.container.contains(target) || this.overlayRef && this.overlayRef.current.contains(target));
    }
  }, {
    key: "isNavIconClicked",
    value: function isNavIconClicked(target) {
      return DomHandler$1.hasClass(target, 'p-datepicker-prev') || DomHandler$1.hasClass(target, 'p-datepicker-prev-icon') || DomHandler$1.hasClass(target, 'p-datepicker-next') || DomHandler$1.hasClass(target, 'p-datepicker-next-icon');
    }
  }, {
    key: "onWindowResize",
    value: function onWindowResize() {
      if (this.isVisible() && !DomHandler$1.isTouchDevice()) {
        this.hideOverlay();
      }
    }
  }, {
    key: "alignOverlay",
    value: function alignOverlay() {
      if (this.props.touchUI) {
        this.enableModality();
      } else {
        DomHandler$1.alignOverlay(this.overlayRef.current, this.inputRef.current.parentElement, this.props.appendTo || PrimeReact.appendTo);
      }
    }
  }, {
    key: "enableModality",
    value: function enableModality() {
      var _this14 = this;

      if (!this.touchUIMask) {
        this.touchUIMask = document.createElement('div');
        this.touchUIMask.style.zIndex = String(ZIndexUtils.get(this.overlayRef.current) - 1);
        DomHandler$1.addMultipleClasses(this.touchUIMask, 'p-component-overlay p-datepicker-mask p-datepicker-mask-scrollblocker p-component-overlay-enter');

        this.touchUIMaskClickListener = function () {
          _this14.disableModality();
        };

        this.touchUIMask.addEventListener('click', this.touchUIMaskClickListener);
        document.body.appendChild(this.touchUIMask);
        DomHandler$1.addClass(document.body, 'p-overflow-hidden');
      }
    }
  }, {
    key: "disableModality",
    value: function disableModality() {
      var _this15 = this;

      if (this.touchUIMask) {
        DomHandler$1.addClass(this.touchUIMask, 'p-component-overlay-leave');
        this.touchUIMask.addEventListener('animationend', function () {
          _this15.destroyMask();
        });
      }
    }
  }, {
    key: "destroyMask",
    value: function destroyMask() {
      this.touchUIMask.removeEventListener('click', this.touchUIMaskClickListener);
      this.touchUIMaskClickListener = null;
      document.body.removeChild(this.touchUIMask);
      this.touchUIMask = null;
      var bodyChildren = document.body.children;
      var hasBlockerMasks;

      for (var i = 0; i < bodyChildren.length; i++) {
        var bodyChild = bodyChildren[i];

        if (DomHandler$1.hasClass(bodyChild, 'p-datepicker-mask-scrollblocker')) {
          hasBlockerMasks = true;
          break;
        }
      }

      if (!hasBlockerMasks) {
        DomHandler$1.removeClass(document.body, 'p-overflow-hidden');
      }
    }
  }, {
    key: "getFirstDayOfMonthIndex",
    value: function getFirstDayOfMonthIndex(month, year) {
      var day = new Date();
      day.setDate(1);
      day.setMonth(month);
      day.setFullYear(year);
      var dayIndex = day.getDay() + this.getSundayIndex();
      return dayIndex >= 7 ? dayIndex - 7 : dayIndex;
    }
  }, {
    key: "getDaysCountInMonth",
    value: function getDaysCountInMonth(month, year) {
      return 32 - this.daylightSavingAdjust(new Date(year, month, 32)).getDate();
    }
  }, {
    key: "getDaysCountInPrevMonth",
    value: function getDaysCountInPrevMonth(month, year) {
      var prev = this.getPreviousMonthAndYear(month, year);
      return this.getDaysCountInMonth(prev.month, prev.year);
    }
  }, {
    key: "daylightSavingAdjust",
    value: function daylightSavingAdjust(date) {
      if (!date) {
        return null;
      }

      date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
      return date;
    }
  }, {
    key: "getPreviousMonthAndYear",
    value: function getPreviousMonthAndYear(month, year) {
      var m, y;

      if (month === 0) {
        m = 11;
        y = year - 1;
      } else {
        m = month - 1;
        y = year;
      }

      return {
        'month': m,
        'year': y
      };
    }
  }, {
    key: "getNextMonthAndYear",
    value: function getNextMonthAndYear(month, year) {
      var m, y;

      if (month === 11) {
        m = 0;
        y = year + 1;
      } else {
        m = month + 1;
        y = year;
      }

      return {
        'month': m,
        'year': y
      };
    }
  }, {
    key: "getSundayIndex",
    value: function getSundayIndex() {
      var firstDayOfWeek = localeOption('firstDayOfWeek', this.props.locale);
      return firstDayOfWeek > 0 ? 7 - firstDayOfWeek : 0;
    }
  }, {
    key: "createWeekDays",
    value: function createWeekDays() {
      var weekDays = [];

      var _localeOptions = localeOptions(this.props.locale),
          dayIndex = _localeOptions.firstDayOfWeek,
          dayNamesMin = _localeOptions.dayNamesMin;

      for (var i = 0; i < 7; i++) {
        weekDays.push(dayNamesMin[dayIndex]);
        dayIndex = dayIndex === 6 ? 0 : ++dayIndex;
      }

      return weekDays;
    }
  }, {
    key: "createMonths",
    value: function createMonths(month, year) {
      var months = [];

      for (var i = 0; i < this.props.numberOfMonths; i++) {
        var m = month + i;
        var y = year;

        if (m > 11) {
          m = m % 11 - 1;
          y = year + 1;
        }

        months.push(this.createMonth(m, y));
      }

      return months;
    }
  }, {
    key: "createMonth",
    value: function createMonth(month, year) {
      var dates = [];
      var firstDay = this.getFirstDayOfMonthIndex(month, year);
      var daysLength = this.getDaysCountInMonth(month, year);
      var prevMonthDaysLength = this.getDaysCountInPrevMonth(month, year);
      var dayNo = 1;
      var today = new Date();
      var weekNumbers = [];
      var monthRows = Math.ceil((daysLength + firstDay) / 7);

      for (var i = 0; i < monthRows; i++) {
        var week = [];

        if (i === 0) {
          for (var j = prevMonthDaysLength - firstDay + 1; j <= prevMonthDaysLength; j++) {
            var prev = this.getPreviousMonthAndYear(month, year);
            week.push({
              day: j,
              month: prev.month,
              year: prev.year,
              otherMonth: true,
              today: this.isToday(today, j, prev.month, prev.year),
              selectable: this.isSelectable(j, prev.month, prev.year, true)
            });
          }

          var remainingDaysLength = 7 - week.length;

          for (var _j = 0; _j < remainingDaysLength; _j++) {
            week.push({
              day: dayNo,
              month: month,
              year: year,
              today: this.isToday(today, dayNo, month, year),
              selectable: this.isSelectable(dayNo, month, year, false)
            });
            dayNo++;
          }
        } else {
          for (var _j2 = 0; _j2 < 7; _j2++) {
            if (dayNo > daysLength) {
              var next = this.getNextMonthAndYear(month, year);
              week.push({
                day: dayNo - daysLength,
                month: next.month,
                year: next.year,
                otherMonth: true,
                today: this.isToday(today, dayNo - daysLength, next.month, next.year),
                selectable: this.isSelectable(dayNo - daysLength, next.month, next.year, true)
              });
            } else {
              week.push({
                day: dayNo,
                month: month,
                year: year,
                today: this.isToday(today, dayNo, month, year),
                selectable: this.isSelectable(dayNo, month, year, false)
              });
            }

            dayNo++;
          }
        }

        if (this.props.showWeek) {
          weekNumbers.push(this.getWeekNumber(new Date(week[0].year, week[0].month, week[0].day)));
        }

        dates.push(week);
      }

      return {
        month: month,
        year: year,
        dates: dates,
        weekNumbers: weekNumbers
      };
    }
  }, {
    key: "getWeekNumber",
    value: function getWeekNumber(date) {
      var checkDate = new Date(date.getTime());
      checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
      var time = checkDate.getTime();
      checkDate.setMonth(0);
      checkDate.setDate(1);
      return Math.floor(Math.round((time - checkDate.getTime()) / 86400000) / 7) + 1;
    }
  }, {
    key: "isSelectable",
    value: function isSelectable(day, month, year, otherMonth) {
      var validMin = true;
      var validMax = true;
      var validDate = true;
      var validDay = true;
      var validMonth = true;

      if (this.props.minDate) {
        if (this.props.minDate.getFullYear() > year) {
          validMin = false;
        } else if (this.props.minDate.getFullYear() === year) {
          if (this.props.minDate.getMonth() > month) {
            validMin = false;
          } else if (this.props.minDate.getMonth() === month) {
            if (this.props.minDate.getDate() > day) {
              validMin = false;
            }
          }
        }
      }

      if (this.props.maxDate) {
        if (this.props.maxDate.getFullYear() < year) {
          validMax = false;
        } else if (this.props.maxDate.getFullYear() === year) {
          if (this.props.maxDate.getMonth() < month) {
            validMax = false;
          } else if (this.props.maxDate.getMonth() === month) {
            if (this.props.maxDate.getDate() < day) {
              validMax = false;
            }
          }
        }
      }

      if (this.props.disabledDates) {
        validDate = !this.isDateDisabled(day, month, year);
      }

      if (this.props.disabledDays) {
        validDay = !this.isDayDisabled(day, month, year);
      }

      if (this.props.selectOtherMonths === false && otherMonth) {
        validMonth = false;
      }

      return validMin && validMax && validDate && validDay && validMonth;
    }
  }, {
    key: "isSelectableTime",
    value: function isSelectableTime(value) {
      var validMin = true;
      var validMax = true;

      if (this.props.minDate && this.props.minDate.toDateString() === value.toDateString()) {
        if (this.props.minDate.getHours() > value.getHours()) {
          validMin = false;
        } else if (this.props.minDate.getHours() === value.getHours()) {
          if (this.props.minDate.getMinutes() > value.getMinutes()) {
            validMin = false;
          } else if (this.props.minDate.getMinutes() === value.getMinutes()) {
            if (this.props.minDate.getSeconds() > value.getSeconds()) {
              validMin = false;
            } else if (this.props.minDate.getSeconds() === value.getSeconds()) {
              if (this.props.minDate.getMilliseconds() > value.getMilliseconds()) {
                validMin = false;
              }
            }
          }
        }
      }

      if (this.props.maxDate && this.props.maxDate.toDateString() === value.toDateString()) {
        if (this.props.maxDate.getHours() < value.getHours()) {
          validMax = false;
        } else if (this.props.maxDate.getHours() === value.getHours()) {
          if (this.props.maxDate.getMinutes() < value.getMinutes()) {
            validMax = false;
          } else if (this.props.maxDate.getMinutes() === value.getMinutes()) {
            if (this.props.maxDate.getSeconds() < value.getSeconds()) {
              validMax = false;
            } else if (this.props.maxDate.getSeconds() === value.getSeconds()) {
              if (this.props.maxDate.getMilliseconds() < value.getMilliseconds()) {
                validMax = false;
              }
            }
          }
        }
      }

      return validMin && validMax;
    }
  }, {
    key: "isSelected",
    value: function isSelected(dateMeta) {
      if (this.props.value) {
        if (this.isSingleSelection()) {
          return this.isDateEquals(this.props.value, dateMeta);
        } else if (this.isMultipleSelection()) {
          var selected = false;

          var _iterator = _createForOfIteratorHelper$9(this.props.value),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var date = _step.value;
              selected = this.isDateEquals(date, dateMeta);

              if (selected) {
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return selected;
        } else if (this.isRangeSelection()) {
          if (this.props.value[1]) return this.isDateEquals(this.props.value[0], dateMeta) || this.isDateEquals(this.props.value[1], dateMeta) || this.isDateBetween(this.props.value[0], this.props.value[1], dateMeta);else {
            return this.isDateEquals(this.props.value[0], dateMeta);
          }
        }
      } else {
        return false;
      }
    }
  }, {
    key: "isMonthSelected",
    value: function isMonthSelected(month) {
      var viewDate = this.getViewDate();
      if (this.props.value && this.props.value instanceof Date) return this.props.value.getDate() === 1 && this.props.value.getMonth() === month && this.props.value.getFullYear() === viewDate.getFullYear();else return false;
    }
  }, {
    key: "isDateEquals",
    value: function isDateEquals(value, dateMeta) {
      if (value && value instanceof Date) return value.getDate() === dateMeta.day && value.getMonth() === dateMeta.month && value.getFullYear() === dateMeta.year;else return false;
    }
  }, {
    key: "isDateBetween",
    value: function isDateBetween(start, end, dateMeta) {
      var between = false;

      if (start && end) {
        var date = new Date(dateMeta.year, dateMeta.month, dateMeta.day);
        return start.getTime() <= date.getTime() && end.getTime() >= date.getTime();
      }

      return between;
    }
  }, {
    key: "isSingleSelection",
    value: function isSingleSelection() {
      return this.props.selectionMode === 'single';
    }
  }, {
    key: "isRangeSelection",
    value: function isRangeSelection() {
      return this.props.selectionMode === 'range';
    }
  }, {
    key: "isMultipleSelection",
    value: function isMultipleSelection() {
      return this.props.selectionMode === 'multiple';
    }
  }, {
    key: "isToday",
    value: function isToday(today, day, month, year) {
      return today.getDate() === day && today.getMonth() === month && today.getFullYear() === year;
    }
  }, {
    key: "isDateDisabled",
    value: function isDateDisabled(day, month, year) {
      if (this.props.disabledDates) {
        for (var i = 0; i < this.props.disabledDates.length; i++) {
          var disabledDate = this.props.disabledDates[i];

          if (disabledDate.getFullYear() === year && disabledDate.getMonth() === month && disabledDate.getDate() === day) {
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "isDayDisabled",
    value: function isDayDisabled(day, month, year) {
      if (this.props.disabledDays) {
        var weekday = new Date(year, month, day);
        var weekdayNumber = weekday.getDay();
        return this.props.disabledDays.indexOf(weekdayNumber) !== -1;
      }

      return false;
    }
  }, {
    key: "updateInputfield",
    value: function updateInputfield(value) {
      if (!(this.inputRef && this.inputRef.current)) {
        return;
      }

      var formattedValue = '';

      if (value) {
        try {
          if (this.isSingleSelection()) {
            formattedValue = this.isValidDate(value) ? this.formatDateTime(value) : '';
          } else if (this.isMultipleSelection()) {
            for (var i = 0; i < value.length; i++) {
              var selectedValue = value[i];
              var dateAsString = this.isValidDate(selectedValue) ? this.formatDateTime(selectedValue) : '';
              formattedValue += dateAsString;

              if (i !== value.length - 1) {
                formattedValue += ', ';
              }
            }
          } else if (this.isRangeSelection()) {
            if (value && value.length) {
              var startDate = value[0];
              var endDate = value[1];
              formattedValue = this.isValidDate(startDate) ? this.formatDateTime(startDate) : '';

              if (endDate) {
                formattedValue += this.isValidDate(endDate) ? ' - ' + this.formatDateTime(endDate) : '';
              }
            }
          }
        } catch (err) {
          formattedValue = value;
        }
      }

      this.inputRef.current.value = formattedValue;
    }
  }, {
    key: "formatDateTime",
    value: function formatDateTime(date) {
      var formattedValue = null;

      if (date) {
        if (this.props.timeOnly) {
          formattedValue = this.formatTime(date);
        } else {
          formattedValue = this.formatDate(date, this.getDateFormat());

          if (this.props.showTime) {
            formattedValue += ' ' + this.formatTime(date);
          }
        }
      }

      return formattedValue;
    }
  }, {
    key: "formatDate",
    value: function formatDate(date, format) {
      if (!date) {
        return '';
      }

      var iFormat;

      var lookAhead = function lookAhead(match) {
        var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;

        if (matches) {
          iFormat++;
        }

        return matches;
      },
          formatNumber = function formatNumber(match, value, len) {
        var num = '' + value;

        if (lookAhead(match)) {
          while (num.length < len) {
            num = '0' + num;
          }
        }

        return num;
      },
          formatName = function formatName(match, value, shortNames, longNames) {
        return lookAhead(match) ? longNames[value] : shortNames[value];
      };

      var output = '';
      var literal = false;

      var _localeOptions2 = localeOptions(this.props.locale),
          dayNamesShort = _localeOptions2.dayNamesShort,
          dayNames = _localeOptions2.dayNames,
          monthNamesShort = _localeOptions2.monthNamesShort,
          monthNames = _localeOptions2.monthNames;

      if (date) {
        for (iFormat = 0; iFormat < format.length; iFormat++) {
          if (literal) {
            if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
              literal = false;
            } else {
              output += format.charAt(iFormat);
            }
          } else {
            switch (format.charAt(iFormat)) {
              case 'd':
                output += formatNumber('d', date.getDate(), 2);
                break;

              case 'D':
                output += formatName('D', date.getDay(), dayNamesShort, dayNames);
                break;

              case 'o':
                output += formatNumber('o', Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                break;

              case 'm':
                output += formatNumber('m', date.getMonth() + 1, 2);
                break;

              case 'M':
                output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
                break;

              case 'y':
                output += lookAhead('y') ? date.getFullYear() : (date.getFullYear() % 100 < 10 ? '0' : '') + date.getFullYear() % 100;
                break;

              case '@':
                output += date.getTime();
                break;

              case '!':
                output += date.getTime() * 10000 + this.ticksTo1970;
                break;

              case '\'':
                if (lookAhead('\'')) {
                  output += '\'';
                } else {
                  literal = true;
                }

                break;

              default:
                output += format.charAt(iFormat);
            }
          }
        }
      }

      return output;
    }
  }, {
    key: "formatTime",
    value: function formatTime(date) {
      if (!date) {
        return '';
      }

      var output = '';
      var hours = date.getHours();
      var minutes = date.getMinutes();
      var seconds = date.getSeconds();
      var milliseconds = date.getMilliseconds();

      if (this.props.hourFormat === '12' && hours > 11 && hours !== 12) {
        hours -= 12;
      }

      if (this.props.hourFormat === '12') {
        output += hours === 0 ? 12 : hours < 10 ? '0' + hours : hours;
      } else {
        output += hours < 10 ? '0' + hours : hours;
      }

      output += ':';
      output += minutes < 10 ? '0' + minutes : minutes;

      if (this.props.showSeconds) {
        output += ':';
        output += seconds < 10 ? '0' + seconds : seconds;
      }

      if (this.props.showMillisec) {
        output += '.';
        output += milliseconds < 100 ? (milliseconds < 10 ? '00' : '0') + milliseconds : milliseconds;
      }

      if (this.props.hourFormat === '12') {
        output += date.getHours() > 11 ? ' PM' : ' AM';
      }

      return output;
    }
  }, {
    key: "parseValueFromString",
    value: function parseValueFromString(text) {
      if (!text || text.trim().length === 0) {
        return null;
      }

      var value;

      if (this.isSingleSelection()) {
        value = this.parseDateTime(text);
      } else if (this.isMultipleSelection()) {
        var tokens = text.split(',');
        value = [];

        var _iterator2 = _createForOfIteratorHelper$9(tokens),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var token = _step2.value;
            value.push(this.parseDateTime(token.trim()));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else if (this.isRangeSelection()) {
        var _tokens = text.split(' - ');

        value = [];

        for (var i = 0; i < _tokens.length; i++) {
          value[i] = this.parseDateTime(_tokens[i].trim());
        }
      }

      return value;
    }
  }, {
    key: "parseDateTime",
    value: function parseDateTime(text) {
      var date;
      var parts = text.split(' ');

      if (this.props.timeOnly) {
        date = new Date();
        this.populateTime(date, parts[0], parts[1]);
      } else {
        if (this.props.showTime) {
          date = this.parseDate(parts[0], this.getDateFormat());
          this.populateTime(date, parts[1], parts[2]);
        } else {
          date = this.parseDate(text, this.getDateFormat());
        }
      }

      return date;
    }
  }, {
    key: "populateTime",
    value: function populateTime(value, timeString, ampm) {
      if (this.props.hourFormat === '12' && ampm !== 'PM' && ampm !== 'AM') {
        throw new Error('Invalid Time');
      }

      var time = this.parseTime(timeString, ampm);
      value.setHours(time.hour);
      value.setMinutes(time.minute);
      value.setSeconds(time.second);
      value.setMilliseconds(time.millisecond);
    }
  }, {
    key: "parseTime",
    value: function parseTime(value, ampm) {
      value = this.props.showMillisec ? value.replace('.', ':') : value;
      var tokens = value.split(':');
      var validTokenLength = this.props.showSeconds ? 3 : 2;
      validTokenLength = this.props.showMillisec ? validTokenLength + 1 : validTokenLength;

      if (tokens.length !== validTokenLength || tokens[0].length !== 2 || tokens[1].length !== 2 || this.props.showSeconds && tokens[2].length !== 2 || this.props.showMillisec && tokens[3].length !== 3) {
        throw new Error('Invalid time');
      }

      var h = parseInt(tokens[0], 10);
      var m = parseInt(tokens[1], 10);
      var s = this.props.showSeconds ? parseInt(tokens[2], 10) : null;
      var ms = this.props.showMillisec ? parseInt(tokens[3], 10) : null;

      if (isNaN(h) || isNaN(m) || h > 23 || m > 59 || this.props.hourFormat === '12' && h > 12 || this.props.showSeconds && (isNaN(s) || s > 59) || this.props.showMillisec && (isNaN(s) || s > 1000)) {
        throw new Error('Invalid time');
      } else {
        if (this.props.hourFormat === '12' && h !== 12 && ampm === 'PM') {
          h += 12;
        }

        return {
          hour: h,
          minute: m,
          second: s,
          millisecond: ms
        };
      }
    } // Ported from jquery-ui datepicker parseDate

  }, {
    key: "parseDate",
    value: function parseDate(value, format) {
      if (format == null || value == null) {
        throw new Error('Invalid arguments');
      }

      value = _typeof$p(value) === "object" ? value.toString() : value + "";

      if (value === "") {
        return null;
      }

      var iFormat,
          dim,
          extra,
          iValue = 0,
          shortYearCutoff = typeof this.props.shortYearCutoff !== "string" ? this.props.shortYearCutoff : new Date().getFullYear() % 100 + parseInt(this.props.shortYearCutoff, 10),
          year = -1,
          month = -1,
          day = -1,
          doy = -1,
          literal = false,
          date,
          lookAhead = function lookAhead(match) {
        var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;

        if (matches) {
          iFormat++;
        }

        return matches;
      },
          getNumber = function getNumber(match) {
        var isDoubled = lookAhead(match),
            size = match === "@" ? 14 : match === "!" ? 20 : match === "y" && isDoubled ? 4 : match === "o" ? 3 : 2,
            minSize = match === "y" ? size : 1,
            digits = new RegExp("^\\d{" + minSize + "," + size + "}"),
            num = value.substring(iValue).match(digits);

        if (!num) {
          throw new Error('Missing number at position ' + iValue);
        }

        iValue += num[0].length;
        return parseInt(num[0], 10);
      },
          getName = function getName(match, shortNames, longNames) {
        var index = -1;
        var arr = lookAhead(match) ? longNames : shortNames;
        var names = [];

        for (var i = 0; i < arr.length; i++) {
          names.push([i, arr[i]]);
        }

        names.sort(function (a, b) {
          return -(a[1].length - b[1].length);
        });

        for (var _i = 0; _i < names.length; _i++) {
          var name = names[_i][1];

          if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
            index = names[_i][0];
            iValue += name.length;
            break;
          }
        }

        if (index !== -1) {
          return index + 1;
        } else {
          throw new Error('Unknown name at position ' + iValue);
        }
      },
          checkLiteral = function checkLiteral() {
        if (value.charAt(iValue) !== format.charAt(iFormat)) {
          throw new Error('Unexpected literal at position ' + iValue);
        }

        iValue++;
      };

      if (this.props.view === 'month') {
        day = 1;
      }

      var _localeOptions3 = localeOptions(this.props.locale),
          dayNamesShort = _localeOptions3.dayNamesShort,
          dayNames = _localeOptions3.dayNames,
          monthNamesShort = _localeOptions3.monthNamesShort,
          monthNames = _localeOptions3.monthNames;

      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
            literal = false;
          } else {
            checkLiteral();
          }
        } else {
          switch (format.charAt(iFormat)) {
            case "d":
              day = getNumber("d");
              break;

            case "D":
              getName("D", dayNamesShort, dayNames);
              break;

            case "o":
              doy = getNumber("o");
              break;

            case "m":
              month = getNumber("m");
              break;

            case "M":
              month = getName("M", monthNamesShort, monthNames);
              break;

            case "y":
              year = getNumber("y");
              break;

            case "@":
              date = new Date(getNumber("@"));
              year = date.getFullYear();
              month = date.getMonth() + 1;
              day = date.getDate();
              break;

            case "!":
              date = new Date((getNumber("!") - this.ticksTo1970) / 10000);
              year = date.getFullYear();
              month = date.getMonth() + 1;
              day = date.getDate();
              break;

            case "'":
              if (lookAhead("'")) {
                checkLiteral();
              } else {
                literal = true;
              }

              break;

            default:
              checkLiteral();
          }
        }
      }

      if (iValue < value.length) {
        extra = value.substr(iValue);

        if (!/^\s+/.test(extra)) {
          throw new Error('Extra/unparsed characters found in date: ' + extra);
        }
      }

      if (year === -1) {
        year = new Date().getFullYear();
      } else if (year < 100) {
        year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
      }

      if (doy > -1) {
        month = 1;
        day = doy;

        do {
          dim = this.getDaysCountInMonth(year, month - 1);

          if (day <= dim) {
            break;
          }

          month++;
          day -= dim;
        } while (true);
      }

      date = this.daylightSavingAdjust(new Date(year, month - 1, day));

      if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
        throw new Error('Invalid date'); // E.g. 31/02/00
      }

      return date;
    }
  }, {
    key: "renderBackwardNavigator",
    value: function renderBackwardNavigator(isVisible) {
      var _this16 = this;

      var navigatorProps = isVisible ? {
        'onClick': this.onPrevButtonClick,
        'onKeyDown': function onKeyDown(e) {
          return _this16.onContainerButtonKeydown(e);
        }
      } : {
        'style': {
          visibility: 'hidden'
        }
      };
      return /*#__PURE__*/React.createElement("button", _extends$6({
        type: "button",
        className: "p-datepicker-prev p-link"
      }, navigatorProps), /*#__PURE__*/React.createElement("span", {
        className: "p-datepicker-prev-icon pi pi-chevron-left"
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }
  }, {
    key: "renderForwardNavigator",
    value: function renderForwardNavigator(isVisible) {
      var _this17 = this;

      var navigatorProps = isVisible ? {
        'onClick': this.onNextButtonClick,
        'onKeyDown': function onKeyDown(e) {
          return _this17.onContainerButtonKeydown(e);
        }
      } : {
        'style': {
          visibility: 'hidden'
        }
      };
      return /*#__PURE__*/React.createElement("button", _extends$6({
        type: "button",
        className: "p-datepicker-next p-link"
      }, navigatorProps), /*#__PURE__*/React.createElement("span", {
        className: "p-datepicker-next-icon pi pi-chevron-right"
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }
  }, {
    key: "isInMinYear",
    value: function isInMinYear(viewDate) {
      return this.props.minDate && this.props.minDate.getFullYear() === viewDate.getFullYear();
    }
  }, {
    key: "isInMaxYear",
    value: function isInMaxYear(viewDate) {
      return this.props.maxDate && this.props.maxDate.getFullYear() === viewDate.getFullYear();
    }
  }, {
    key: "renderTitleMonthElement",
    value: function renderTitleMonthElement(month) {
      var _this18 = this;

      var monthNames = localeOption('monthNames', this.props.locale);

      if (this.props.monthNavigator && this.props.view !== 'month') {
        var viewDate = this.getViewDate();
        var viewMonth = viewDate.getMonth();
        var displayedMonthOptions = monthNames.map(function (month, index) {
          return (!_this18.isInMinYear(viewDate) || index >= _this18.props.minDate.getMonth()) && (!_this18.isInMaxYear(viewDate) || index <= _this18.props.maxDate.getMonth()) ? {
            label: month,
            value: index,
            index: index
          } : null;
        }).filter(function (option) {
          return !!option;
        });
        var displayedMonthNames = displayedMonthOptions.map(function (option) {
          return option.label;
        });
        var content = /*#__PURE__*/React.createElement("select", {
          className: "p-datepicker-month",
          onChange: function onChange(e) {
            return _this18.onMonthDropdownChange(e, e.target.value);
          },
          value: viewMonth
        }, displayedMonthOptions.map(function (option) {
          return /*#__PURE__*/React.createElement("option", {
            key: option.label,
            value: option.value
          }, option.label);
        }));

        if (this.props.monthNavigatorTemplate) {
          var defaultContentOptions = {
            onChange: this.onMonthDropdownChange,
            className: 'p-datepicker-month',
            value: viewMonth,
            names: displayedMonthNames,
            options: displayedMonthOptions,
            element: content,
            props: this.props
          };
          return ObjectUtils.getJSXElement(this.props.monthNavigatorTemplate, defaultContentOptions);
        }

        return content;
      } else {
        return /*#__PURE__*/React.createElement("span", {
          className: "p-datepicker-month"
        }, monthNames[month]);
      }
    }
  }, {
    key: "renderTitleYearElement",
    value: function renderTitleYearElement(year) {
      var _this19 = this;

      if (this.props.yearNavigator) {
        var yearOptions = [];
        var years = this.props.yearRange.split(':');
        var yearStart = parseInt(years[0], 10);
        var yearEnd = parseInt(years[1], 10);

        for (var i = yearStart; i <= yearEnd; i++) {
          yearOptions.push(i);
        }

        var viewDate = this.getViewDate();
        var viewYear = viewDate.getFullYear();
        var displayedYearNames = yearOptions.filter(function (year) {
          return !(_this19.props.minDate && _this19.props.minDate.getFullYear() > year) && !(_this19.props.maxDate && _this19.props.maxDate.getFullYear() < year);
        });
        var content = /*#__PURE__*/React.createElement("select", {
          className: "p-datepicker-year",
          onChange: function onChange(e) {
            return _this19.onYearDropdownChange(e, e.target.value);
          },
          value: viewYear
        }, displayedYearNames.map(function (year) {
          return /*#__PURE__*/React.createElement("option", {
            key: year,
            value: year
          }, year);
        }));

        if (this.props.yearNavigatorTemplate) {
          var options = displayedYearNames.map(function (name, i) {
            return {
              label: name,
              value: name,
              index: i
            };
          });
          var defaultContentOptions = {
            onChange: this.onYearDropdownChange,
            className: 'p-datepicker-year',
            value: viewYear,
            names: displayedYearNames,
            options: options,
            element: content,
            props: this.props
          };
          return ObjectUtils.getJSXElement(this.props.yearNavigatorTemplate, defaultContentOptions);
        }

        return content;
      } else {
        return /*#__PURE__*/React.createElement("span", {
          className: "p-datepicker-year"
        }, year);
      }
    }
  }, {
    key: "renderTitle",
    value: function renderTitle(monthMetaData) {
      var month = this.renderTitleMonthElement(monthMetaData.month);
      var year = this.renderTitleYearElement(monthMetaData.year);
      return /*#__PURE__*/React.createElement("div", {
        className: "p-datepicker-title"
      }, month, year);
    }
  }, {
    key: "renderDayNames",
    value: function renderDayNames(weekDays) {
      var dayNames = weekDays.map(function (weekDay, index) {
        return /*#__PURE__*/React.createElement("th", {
          key: "".concat(weekDay, "-").concat(index),
          scope: "col"
        }, /*#__PURE__*/React.createElement("span", null, weekDay));
      });

      if (this.props.showWeek) {
        var weekHeader = /*#__PURE__*/React.createElement("th", {
          scope: "col",
          key: 'wn',
          className: "p-datepicker-weekheader p-disabled"
        }, /*#__PURE__*/React.createElement("span", null, localeOption('weekHeader', this.props.locale)));
        return [weekHeader].concat(_toConsumableArray$9(dayNames));
      } else {
        return dayNames;
      }
    }
  }, {
    key: "renderDateCellContent",
    value: function renderDateCellContent(date, className, groupIndex) {
      var _this20 = this;

      var content = this.props.dateTemplate ? this.props.dateTemplate(date) : date.day;
      return /*#__PURE__*/React.createElement("span", {
        className: className,
        onClick: function onClick(e) {
          return _this20.onDateSelect(e, date);
        },
        onKeyDown: function onKeyDown(e) {
          return _this20.onDateCellKeydown(e, date, groupIndex);
        }
      }, content, /*#__PURE__*/React.createElement(Ripple, null));
    }
  }, {
    key: "renderWeek",
    value: function renderWeek(weekDates, weekNumber, groupIndex) {
      var _this21 = this;

      var week = weekDates.map(function (date) {
        var selected = _this21.isSelected(date);

        var cellClassName = classNames({
          'p-datepicker-other-month': date.otherMonth,
          'p-datepicker-today': date.today
        });
        var dateClassName = classNames({
          'p-highlight': selected,
          'p-disabled': !date.selectable
        });
        var content = date.otherMonth && !_this21.props.showOtherMonths ? null : _this21.renderDateCellContent(date, dateClassName, groupIndex);
        return /*#__PURE__*/React.createElement("td", {
          key: date.day,
          className: cellClassName
        }, content);
      });

      if (this.props.showWeek) {
        var weekNumberCell = /*#__PURE__*/React.createElement("td", {
          key: 'wn' + weekNumber,
          className: "p-datepicker-weeknumber"
        }, /*#__PURE__*/React.createElement("span", {
          className: "p-disabled"
        }, weekNumber));
        return [weekNumberCell].concat(_toConsumableArray$9(week));
      } else {
        return week;
      }
    }
  }, {
    key: "renderDates",
    value: function renderDates(monthMetaData, groupIndex) {
      var _this22 = this;

      return monthMetaData.dates.map(function (weekDates, index) {
        return /*#__PURE__*/React.createElement("tr", {
          key: index
        }, _this22.renderWeek(weekDates, monthMetaData.weekNumbers[index], groupIndex));
      });
    }
  }, {
    key: "renderDateViewGrid",
    value: function renderDateViewGrid(monthMetaData, weekDays, groupIndex) {
      var dayNames = this.renderDayNames(weekDays);
      var dates = this.renderDates(monthMetaData, groupIndex);
      return /*#__PURE__*/React.createElement("div", {
        className: "p-datepicker-calendar-container"
      }, /*#__PURE__*/React.createElement("table", {
        className: "p-datepicker-calendar"
      }, /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement("tr", null, dayNames)), /*#__PURE__*/React.createElement("tbody", null, dates)));
    }
  }, {
    key: "renderMonth",
    value: function renderMonth(monthMetaData, index) {
      var weekDays = this.createWeekDays();
      var backwardNavigator = this.renderBackwardNavigator(index === 0);
      var forwardNavigator = this.renderForwardNavigator(this.props.numberOfMonths === 1 || index === this.props.numberOfMonths - 1);
      var title = this.renderTitle(monthMetaData);
      var dateViewGrid = this.renderDateViewGrid(monthMetaData, weekDays, index);
      var header = this.props.headerTemplate ? this.props.headerTemplate() : null;
      return /*#__PURE__*/React.createElement("div", {
        key: monthMetaData.month,
        className: "p-datepicker-group"
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-datepicker-header"
      }, header, backwardNavigator, title, forwardNavigator), dateViewGrid);
    }
  }, {
    key: "renderMonths",
    value: function renderMonths(monthsMetaData) {
      var _this23 = this;

      var groups = monthsMetaData.map(function (monthMetaData, index) {
        return _this23.renderMonth(monthMetaData, index);
      });
      return /*#__PURE__*/React.createElement("div", {
        className: "p-datepicker-group-container"
      }, groups);
    }
  }, {
    key: "renderDateView",
    value: function renderDateView() {
      var viewDate = this.getViewDate();
      var monthsMetaData = this.createMonths(viewDate.getMonth(), viewDate.getFullYear());
      var months = this.renderMonths(monthsMetaData);
      return /*#__PURE__*/React.createElement(React.Fragment, null, months);
    }
  }, {
    key: "renderMonthViewMonth",
    value: function renderMonthViewMonth(index) {
      var _this24 = this;

      var className = classNames('p-monthpicker-month', {
        'p-highlight': this.isMonthSelected(index)
      });
      var monthNamesShort = localeOption('monthNamesShort', this.props.locale);
      var monthName = monthNamesShort[index];
      return /*#__PURE__*/React.createElement("span", {
        key: monthName,
        className: className,
        onClick: function onClick(event) {
          return _this24.onMonthSelect(event, index);
        },
        onKeyDown: function onKeyDown(event) {
          return _this24.onMonthCellKeydown(event, index);
        }
      }, monthName, /*#__PURE__*/React.createElement(Ripple, null));
    }
  }, {
    key: "renderMonthViewMonths",
    value: function renderMonthViewMonths() {
      var months = [];

      for (var i = 0; i <= 11; i++) {
        months.push(this.renderMonthViewMonth(i));
      }

      return months;
    }
  }, {
    key: "renderMonthView",
    value: function renderMonthView() {
      var backwardNavigator = this.renderBackwardNavigator(true);
      var forwardNavigator = this.renderForwardNavigator(true);
      var yearElement = this.renderTitleYearElement(this.getViewDate().getFullYear());
      var months = this.renderMonthViewMonths();
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
        className: "p-datepicker-group-container"
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-datepicker-group"
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-datepicker-header"
      }, backwardNavigator, /*#__PURE__*/React.createElement("div", {
        className: "p-datepicker-title"
      }, yearElement), forwardNavigator))), /*#__PURE__*/React.createElement("div", {
        className: "p-monthpicker"
      }, months));
    }
  }, {
    key: "renderDatePicker",
    value: function renderDatePicker() {
      if (!this.props.timeOnly) {
        if (this.props.view === 'date') {
          return this.renderDateView();
        } else if (this.props.view === 'month') {
          return this.renderMonthView();
        } else {
          return null;
        }
      }
    }
  }, {
    key: "renderHourPicker",
    value: function renderHourPicker() {
      var _this25 = this;

      var currentTime = this.getCurrentDateTime();
      var hour = currentTime.getHours();

      if (this.props.hourFormat === '12') {
        if (hour === 0) hour = 12;else if (hour > 11 && hour !== 12) hour = hour - 12;
      }

      var hourDisplay = hour < 10 ? '0' + hour : hour;
      return /*#__PURE__*/React.createElement("div", {
        className: "p-hour-picker"
      }, /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-link",
        onMouseDown: function onMouseDown(e) {
          return _this25.onTimePickerElementMouseDown(e, 0, 1);
        },
        onMouseUp: this.onTimePickerElementMouseUp,
        onMouseLeave: this.onTimePickerElementMouseLeave,
        onKeyDown: function onKeyDown(e) {
          return _this25.onContainerButtonKeydown(e);
        }
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-up"
      }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("span", null, hourDisplay), /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-link",
        onMouseDown: function onMouseDown(e) {
          return _this25.onTimePickerElementMouseDown(e, 0, -1);
        },
        onMouseUp: this.onTimePickerElementMouseUp,
        onMouseLeave: this.onTimePickerElementMouseLeave,
        onKeyDown: function onKeyDown(e) {
          return _this25.onContainerButtonKeydown(e);
        }
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-down"
      }), /*#__PURE__*/React.createElement(Ripple, null)));
    }
  }, {
    key: "renderMinutePicker",
    value: function renderMinutePicker() {
      var _this26 = this;

      var currentTime = this.getCurrentDateTime();
      var minute = currentTime.getMinutes();
      var minuteDisplay = minute < 10 ? '0' + minute : minute;
      return /*#__PURE__*/React.createElement("div", {
        className: "p-minute-picker"
      }, /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-link",
        onMouseDown: function onMouseDown(e) {
          return _this26.onTimePickerElementMouseDown(e, 1, 1);
        },
        onMouseUp: this.onTimePickerElementMouseUp,
        onMouseLeave: this.onTimePickerElementMouseLeave,
        onKeyDown: function onKeyDown(e) {
          return _this26.onContainerButtonKeydown(e);
        }
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-up"
      }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("span", null, minuteDisplay), /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-link",
        onMouseDown: function onMouseDown(e) {
          return _this26.onTimePickerElementMouseDown(e, 1, -1);
        },
        onMouseUp: this.onTimePickerElementMouseUp,
        onMouseLeave: this.onTimePickerElementMouseLeave,
        onKeyDown: function onKeyDown(e) {
          return _this26.onContainerButtonKeydown(e);
        }
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-down"
      }), /*#__PURE__*/React.createElement(Ripple, null)));
    }
  }, {
    key: "renderSecondPicker",
    value: function renderSecondPicker() {
      var _this27 = this;

      if (this.props.showSeconds) {
        var currentTime = this.getCurrentDateTime();
        var second = currentTime.getSeconds();
        var secondDisplay = second < 10 ? '0' + second : second;
        return /*#__PURE__*/React.createElement("div", {
          className: "p-second-picker"
        }, /*#__PURE__*/React.createElement("button", {
          type: "button",
          className: "p-link",
          onMouseDown: function onMouseDown(e) {
            return _this27.onTimePickerElementMouseDown(e, 2, 1);
          },
          onMouseUp: this.onTimePickerElementMouseUp,
          onMouseLeave: this.onTimePickerElementMouseLeave,
          onKeyDown: function onKeyDown(e) {
            return _this27.onContainerButtonKeydown(e);
          }
        }, /*#__PURE__*/React.createElement("span", {
          className: "pi pi-chevron-up"
        }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("span", null, secondDisplay), /*#__PURE__*/React.createElement("button", {
          type: "button",
          className: "p-link",
          onMouseDown: function onMouseDown(e) {
            return _this27.onTimePickerElementMouseDown(e, 2, -1);
          },
          onMouseUp: this.onTimePickerElementMouseUp,
          onMouseLeave: this.onTimePickerElementMouseLeave,
          onKeyDown: function onKeyDown(e) {
            return _this27.onContainerButtonKeydown(e);
          }
        }, /*#__PURE__*/React.createElement("span", {
          className: "pi pi-chevron-down"
        }), /*#__PURE__*/React.createElement(Ripple, null)));
      }

      return null;
    }
  }, {
    key: "renderMiliSecondPicker",
    value: function renderMiliSecondPicker() {
      var _this28 = this;

      if (this.props.showMillisec) {
        var currentTime = this.getCurrentDateTime();
        var millisecond = currentTime.getMilliseconds();
        var millisecondDisplay = millisecond < 100 ? (millisecond < 10 ? '00' : '0') + millisecond : millisecond;
        return /*#__PURE__*/React.createElement("div", {
          className: "p-millisecond-picker"
        }, /*#__PURE__*/React.createElement("button", {
          type: "button",
          className: "p-link",
          onMouseDown: function onMouseDown(e) {
            return _this28.onTimePickerElementMouseDown(e, 3, 1);
          },
          onMouseUp: this.onTimePickerElementMouseUp,
          onMouseLeave: this.onTimePickerElementMouseLeave,
          onKeyDown: function onKeyDown(e) {
            return _this28.onContainerButtonKeydown(e);
          }
        }, /*#__PURE__*/React.createElement("span", {
          className: "pi pi-chevron-up"
        }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("span", null, millisecondDisplay), /*#__PURE__*/React.createElement("button", {
          type: "button",
          className: "p-link",
          onMouseDown: function onMouseDown(e) {
            return _this28.onTimePickerElementMouseDown(e, 3, -1);
          },
          onMouseUp: this.onTimePickerElementMouseUp,
          onMouseLeave: this.onTimePickerElementMouseLeave,
          onKeyDown: function onKeyDown(e) {
            return _this28.onContainerButtonKeydown(e);
          }
        }, /*#__PURE__*/React.createElement("span", {
          className: "pi pi-chevron-down"
        }), /*#__PURE__*/React.createElement(Ripple, null)));
      }

      return null;
    }
  }, {
    key: "renderAmPmPicker",
    value: function renderAmPmPicker() {
      if (this.props.hourFormat === '12') {
        var currentTime = this.getCurrentDateTime();
        var hour = currentTime.getHours();
        var display = hour > 11 ? 'PM' : 'AM';
        return /*#__PURE__*/React.createElement("div", {
          className: "p-ampm-picker"
        }, /*#__PURE__*/React.createElement("button", {
          type: "button",
          className: "p-link",
          onClick: this.toggleAmPm
        }, /*#__PURE__*/React.createElement("span", {
          className: "pi pi-chevron-up"
        }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("span", null, display), /*#__PURE__*/React.createElement("button", {
          type: "button",
          className: "p-link",
          onClick: this.toggleAmPm
        }, /*#__PURE__*/React.createElement("span", {
          className: "pi pi-chevron-down"
        }), /*#__PURE__*/React.createElement(Ripple, null)));
      }

      return null;
    }
  }, {
    key: "renderSeparator",
    value: function renderSeparator(separator) {
      return /*#__PURE__*/React.createElement("div", {
        className: "p-separator"
      }, /*#__PURE__*/React.createElement("span", null, separator));
    }
  }, {
    key: "renderTimePicker",
    value: function renderTimePicker() {
      if (this.props.showTime || this.props.timeOnly) {
        return /*#__PURE__*/React.createElement("div", {
          className: "p-timepicker"
        }, this.renderHourPicker(), this.renderSeparator(':'), this.renderMinutePicker(), this.props.showSeconds && this.renderSeparator(':'), this.renderSecondPicker(), this.props.showMillisec && this.renderSeparator('.'), this.renderMiliSecondPicker(), this.props.hourFormat === '12' && this.renderSeparator(':'), this.renderAmPmPicker());
      }

      return null;
    }
  }, {
    key: "renderInputElement",
    value: function renderInputElement() {
      if (!this.props.inline) {
        return /*#__PURE__*/React.createElement(InputText$1, {
          ref: this.inputRef,
          id: this.props.inputId,
          name: this.props.name,
          type: "text",
          className: this.props.inputClassName,
          style: this.props.inputStyle,
          readOnly: this.props.readOnlyInput,
          disabled: this.props.disabled,
          required: this.props.required,
          autoComplete: "off",
          placeholder: this.props.placeholder,
          tabIndex: this.props.tabIndex,
          onInput: this.onUserInput,
          onFocus: this.onInputFocus,
          onBlur: this.onInputBlur,
          onKeyDown: this.onInputKeyDown,
          "aria-labelledby": this.props.ariaLabelledBy,
          inputMode: this.props.inputMode
        });
      }

      return null;
    }
  }, {
    key: "renderButton",
    value: function renderButton() {
      if (this.props.showIcon) {
        return /*#__PURE__*/React.createElement(Button$1, {
          type: "button",
          icon: this.props.icon,
          onClick: this.onButtonClick,
          tabIndex: "-1",
          disabled: this.props.disabled,
          className: "p-datepicker-trigger"
        });
      }

      return null;
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var input = this.renderInputElement();
      var button = this.renderButton();

      if (this.props.iconPos === 'left') {
        return /*#__PURE__*/React.createElement(React.Fragment, null, button, input);
      }

      return /*#__PURE__*/React.createElement(React.Fragment, null, input, button);
    }
  }, {
    key: "renderButtonBar",
    value: function renderButtonBar() {
      var _this29 = this;

      if (this.props.showButtonBar) {
        var todayClassName = classNames('p-button-text', this.props.todayButtonClassName);
        var clearClassName = classNames('p-button-text', this.props.clearButtonClassName);

        var _localeOptions4 = localeOptions(this.props.locale),
            today = _localeOptions4.today,
            clear = _localeOptions4.clear;

        return /*#__PURE__*/React.createElement("div", {
          className: "p-datepicker-buttonbar"
        }, /*#__PURE__*/React.createElement(Button$1, {
          type: "button",
          label: today,
          onClick: this.onTodayButtonClick,
          onKeyDown: function onKeyDown(e) {
            return _this29.onContainerButtonKeydown(e);
          },
          className: todayClassName
        }), /*#__PURE__*/React.createElement(Button$1, {
          type: "button",
          label: clear,
          onClick: this.onClearButtonClick,
          onKeyDown: function onKeyDown(e) {
            return _this29.onContainerButtonKeydown(e);
          },
          className: clearClassName
        }));
      }

      return null;
    }
  }, {
    key: "renderFooter",
    value: function renderFooter() {
      if (this.props.footerTemplate) {
        var content = this.props.footerTemplate();
        return /*#__PURE__*/React.createElement("div", {
          className: "p-datepicker-footer"
        }, content);
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames,
          _this30 = this;

      var className = classNames('p-calendar p-component p-inputwrapper', this.props.className, (_classNames = {}, _defineProperty$p(_classNames, "p-calendar-w-btn p-calendar-w-btn-".concat(this.props.iconPos), this.props.showIcon), _defineProperty$p(_classNames, 'p-calendar-disabled', this.props.disabled), _defineProperty$p(_classNames, 'p-calendar-timeonly', this.props.timeOnly), _defineProperty$p(_classNames, 'p-inputwrapper-filled', this.props.value || DomHandler$1.hasClass(this.inputRef.current, 'p-filled') && this.inputRef.current.value !== ''), _defineProperty$p(_classNames, 'p-inputwrapper-focus', this.state.focused), _classNames));
      var panelClassName = classNames('p-datepicker p-component', this.props.panelClassName, {
        'p-datepicker-inline': this.props.inline,
        'p-disabled': this.props.disabled,
        'p-datepicker-timeonly': this.props.timeOnly,
        'p-datepicker-multiple-month': this.props.numberOfMonths > 1,
        'p-datepicker-monthpicker': this.props.view === 'month',
        'p-datepicker-touch-ui': this.props.touchUI
      });
      var content = this.renderContent();
      var datePicker = this.renderDatePicker();
      var timePicker = this.renderTimePicker();
      var buttonBar = this.renderButtonBar();
      var footer = this.renderFooter();
      var isVisible = this.props.inline || this.isVisible();
      return /*#__PURE__*/React.createElement("span", {
        ref: function ref(el) {
          return _this30.container = el;
        },
        id: this.props.id,
        className: className,
        style: this.props.style
      }, content, /*#__PURE__*/React.createElement(CalendarPanel, {
        ref: this.overlayRef,
        className: panelClassName,
        style: this.props.panelStyle,
        appendTo: this.props.appendTo,
        inline: this.props.inline,
        onClick: this.onPanelClick,
        onMouseUp: this.onPanelMouseUp,
        "in": isVisible,
        onEnter: this.onOverlayEnter,
        onEntered: this.onOverlayEntered,
        onExit: this.onOverlayExit,
        onExited: this.onOverlayExited,
        transitionOptions: this.props.transitionOptions
      }, datePicker, timePicker, buttonBar, footer));
    }
  }]);

  return Calendar;
}(Component);

_defineProperty$p(Calendar, "defaultProps", {
  id: null,
  inputRef: null,
  name: null,
  value: null,
  visible: false,
  viewDate: null,
  style: null,
  className: null,
  inline: false,
  selectionMode: 'single',
  inputId: null,
  inputStyle: null,
  inputClassName: null,
  inputMode: 'none',
  required: false,
  readOnlyInput: false,
  keepInvalid: false,
  mask: null,
  disabled: false,
  tabIndex: null,
  placeholder: null,
  showIcon: false,
  icon: 'pi pi-calendar',
  iconPos: 'right',
  showOnFocus: true,
  numberOfMonths: 1,
  view: 'date',
  touchUI: false,
  showTime: false,
  timeOnly: false,
  showSeconds: false,
  showMillisec: false,
  hourFormat: '24',
  stepHour: 1,
  stepMinute: 1,
  stepSecond: 1,
  stepMillisec: 1,
  shortYearCutoff: '+10',
  hideOnDateTimeSelect: false,
  showWeek: false,
  locale: null,
  dateFormat: null,
  panelStyle: null,
  panelClassName: null,
  monthNavigator: false,
  yearNavigator: false,
  yearRange: null,
  disabledDates: null,
  disabledDays: null,
  minDate: null,
  maxDate: null,
  maxDateCount: null,
  showOtherMonths: true,
  selectOtherMonths: false,
  showButtonBar: false,
  todayButtonClassName: 'p-button-secondary',
  clearButtonClassName: 'p-button-secondary',
  autoZIndex: true,
  baseZIndex: 0,
  appendTo: null,
  tooltip: null,
  tooltipOptions: null,
  ariaLabelledBy: null,
  dateTemplate: null,
  headerTemplate: null,
  footerTemplate: null,
  monthNavigatorTemplate: null,
  yearNavigatorTemplate: null,
  transitionOptions: null,
  onVisibleChange: null,
  onFocus: null,
  onBlur: null,
  onInput: null,
  onSelect: null,
  onChange: null,
  onViewDateChange: null,
  onTodayButtonClick: null,
  onClearButtonClick: null,
  onShow: null,
  onHide: null
});

function _classCallCheck$o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$o(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$o(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$o(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$o(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _inherits$o(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$O(subClass, superClass);
}

function _typeof$o(obj) {
  "@babel/helpers - typeof";

  return _typeof$o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$o(obj);
}

function _possibleConstructorReturn$o(self, call) {
  if (call && (_typeof$o(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$O(self);
}

function _getPrototypeOf$o(o) {
  _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$o(o);
}

function _defineProperty$o(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var LOCALES_RANGE_BLOCKS = {
  ru: {
    today: "",
    yesterday: "",
    week: "",
    last30days: "30 ",
    thisMonth: " ",
    lastMonth: " ",
    last180days: "180 ",
    allTime: " ",
    clear: ""
  },
  en: {
    today: "Today",
    yesterday: "Yesterday",
    week: "Week",
    last30days: "30 days",
    thisMonth: "This month",
    lastMonth: "Last month",
    last180days: "180 days",
    allTime: "All period",
    clear: "Clear"
  }
};
var MONTHS = {
  ru: {
    0: "",
    1: "",
    2: "",
    3: "",
    4: "",
    5: "",
    6: "",
    7: "",
    8: "",
    9: "",
    10: "",
    11: ""
  },
  en: {
    0: "January",
    1: "February",
    2: "March",
    3: "April",
    4: "May",
    5: "June",
    6: "July",
    7: "August",
    8: "September",
    9: "October",
    10: "November",
    11: "December"
  }
};
var START_DATE = new Date("2010-01-01T00:00");

function _createSuper$u(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$u(); return function _createSuperInternal() { var Super = _getPrototypeOf$o(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$o(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$o(this, result); }; }

function _isNativeReflectConstruct$u() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var withRange = function withRange(Component) {
  return /*#__PURE__*/function (_React$Component) {
    _inherits$o(_class2, _React$Component);

    var _super = _createSuper$u(_class2);

    function _class2(props) {
      var _this;

      _classCallCheck$o(this, _class2);

      _this = _super.call(this, props);

      _defineProperty$o(_assertThisInitialized$O(_this), "clear", function () {
        _this.onChange(null);
      });

      _defineProperty$o(_assertThisInitialized$O(_this), "setToday", function () {
        var newDate = [new Date(), new Date()];

        _this.onChange(newDate);
      });

      _defineProperty$o(_assertThisInitialized$O(_this), "setYesterday", function () {
        var _getPartsOfTime = getPartsOfTime(),
            day = _getPartsOfTime.day,
            month = _getPartsOfTime.month,
            year = _getPartsOfTime.year;

        var yesterday = new Date(year, month, day - 1);
        var newDate = [yesterday, yesterday];

        _this.onChange(newDate);
      });

      _defineProperty$o(_assertThisInitialized$O(_this), "setCurrentMonth", function () {
        var _getPartsOfTime2 = getPartsOfTime(),
            month = _getPartsOfTime2.month,
            year = _getPartsOfTime2.year;

        var lastDayInMonth = new Date(year, month + 1, 0).getDate();
        var newDate = [new Date(year, month, 1), new Date(year, month, lastDayInMonth)];

        _this.onChange(newDate);
      });

      _defineProperty$o(_assertThisInitialized$O(_this), "setLastMonth", function () {
        var _getPartsOfTime3 = getPartsOfTime(),
            month = _getPartsOfTime3.month,
            year = _getPartsOfTime3.year;

        var prevMonth = month - 1;
        var lastDayInPrevMonth = new Date(year, month, 0).getDate();
        var newDate = [new Date(year, prevMonth, 1), new Date(year, prevMonth, lastDayInPrevMonth)];

        _this.onChange(newDate);
      });

      _defineProperty$o(_assertThisInitialized$O(_this), "setAllTime", function () {
        var _getPartsOfTime4 = getPartsOfTime(),
            month = _getPartsOfTime4.month,
            day = _getPartsOfTime4.day,
            year = _getPartsOfTime4.year;

        var newDate = [_this.props.startDate, new Date(year, month, day)];

        _this.onChange(newDate);
      });

      _defineProperty$o(_assertThisInitialized$O(_this), "setWeek", function () {
        _this.setLastDays(7);
      });

      _defineProperty$o(_assertThisInitialized$O(_this), "setLast30Days", function () {
        _this.setLastDays(30);
      });

      _defineProperty$o(_assertThisInitialized$O(_this), "setLast180Days", function () {
        _this.setLastDays(180);
      });

      _defineProperty$o(_assertThisInitialized$O(_this), "setLastDays", function (days) {
        var _getPartsOfTime5 = getPartsOfTime(),
            month = _getPartsOfTime5.month,
            day = _getPartsOfTime5.day,
            year = _getPartsOfTime5.year;

        var daysDiff = day - (days - 1);
        var startDate = new Date(year, month, daysDiff);
        var date = [startDate, new Date(year, month, day)];

        _this.onChange(date);
      });

      _defineProperty$o(_assertThisInitialized$O(_this), "onChange", function (value) {
        _this.refCalendar.current.onButtonClick();

        _this.props.onChange({
          target: {
            name: _this.props.name || null,
            id: _this.props.id || null,
            value: value
          }
        });
      });

      _defineProperty$o(_assertThisInitialized$O(_this), "renderFooter", function () {
        if (!_this.props.rangeButtonsBar) return null;
        var translations = LOCALES_RANGE_BLOCKS[_this.props.locale];
        var blocks = [{
          title: translations.today,
          method: _this.setToday
        }, {
          title: translations.yesterday,
          method: _this.setYesterday
        }, {
          title: translations.week,
          method: _this.setWeek
        }, {
          title: translations.last30days,
          method: _this.setLast30Days
        }, {
          title: translations.thisMonth,
          method: _this.setCurrentMonth
        }, {
          title: translations.lastMonth,
          method: _this.setLastMonth
        }, {
          title: translations.last180days,
          method: _this.setLast180Days
        }, {
          title: translations.allTime,
          method: _this.setAllTime
        }];
        return /*#__PURE__*/React.createElement("div", {
          className: "flex flex-column p-datepicker-range-buttons"
        }, blocks.map(function (block, index) {
          return /*#__PURE__*/React.createElement(Button, {
            key: index,
            className: "p-button-text p-button-plain",
            label: block.title,
            size: "small",
            onClick: block.method
          });
        }), /*#__PURE__*/React.createElement(Button, {
          label: translations.clear,
          size: "small",
          onClick: _this.clear
        }));
      });

      _this.refCalendar = /*#__PURE__*/React.createRef();
      return _this;
    }

    _createClass$o(_class2, [{
      key: "render",
      value: function render() {
        var panelClassName = classNames(this.props.panelClassName, {
          "p-datepicker_buttons-bar": this.props.rangeButtonsBar
        });
        return /*#__PURE__*/React.createElement(Component, _extends$c({}, this.props, {
          panelClassName: panelClassName,
          selectionMode: "range",
          ref: this.refCalendar,
          footerTemplate: this.renderFooter
        }));
      }
    }]);

    return _class2;
  }(React.Component);
};

var DatePicker = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      onChange = _ref.onChange,
      yearRange = _ref.yearRange,
      _ref$name = _ref.name,
      name = _ref$name === void 0 ? "" : _ref$name,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder,
      _ref$mode = _ref.mode,
      mode = _ref$mode === void 0 ? "default" : _ref$mode,
      _ref$dateFormat = _ref.dateFormat,
      dateFormat = _ref$dateFormat === void 0 ? "dd.mm.yy" : _ref$dateFormat,
      _ref$showIcon = _ref.showIcon,
      showIcon = _ref$showIcon === void 0 ? true : _ref$showIcon,
      _ref$rangeButtonsBar = _ref.rangeButtonsBar,
      rangeButtonsBar = _ref$rangeButtonsBar === void 0 ? false : _ref$rangeButtonsBar,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$monthNavigator = _ref.monthNavigator,
      monthNavigator = _ref$monthNavigator === void 0 ? true : _ref$monthNavigator,
      _ref$yearNavigator = _ref.yearNavigator,
      yearNavigator = _ref$yearNavigator === void 0 ? true : _ref$yearNavigator,
      _ref$startRangeOfYear = _ref.startRangeOfYears,
      startRangeOfYears = _ref$startRangeOfYear === void 0 ? "2010" : _ref$startRangeOfYear,
      _ref$minDate = _ref.minDate,
      minDate = _ref$minDate === void 0 ? null : _ref$minDate,
      _ref$maxDate = _ref.maxDate,
      maxDate = _ref$maxDate === void 0 ? null : _ref$maxDate,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      style = _ref.style,
      inputClassName = _ref.inputClassName,
      inputStyle = _ref.inputStyle,
      panelClassName = _ref.panelClassName,
      panelStyle = _ref.panelStyle,
      _ref$mask = _ref.mask,
      mask = _ref$mask === void 0 ? null : _ref$mask,
      _ref$showOtherMonths = _ref.showOtherMonths,
      showOtherMonths = _ref$showOtherMonths === void 0 ? true : _ref$showOtherMonths,
      _ref$selectOtherMonth = _ref.selectOtherMonths,
      selectOtherMonths = _ref$selectOtherMonth === void 0 ? true : _ref$selectOtherMonth,
      _ref$startDate = _ref.startDate,
      startDate = _ref$startDate === void 0 ? START_DATE : _ref$startDate,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      _ref$required = _ref.required,
      required = _ref$required === void 0 ? false : _ref$required,
      inputId = _ref.inputId,
      _ref$readOnlyInput = _ref.readOnlyInput,
      readOnlyInput = _ref$readOnlyInput === void 0 ? false : _ref$readOnlyInput,
      tabIndex = _ref.tabIndex,
      _ref$autoZIndex = _ref.autoZIndex,
      autoZIndex = _ref$autoZIndex === void 0 ? true : _ref$autoZIndex,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 50 : _ref$baseZIndex,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur,
      onInput = _ref.onInput,
      onSelect = _ref.onSelect,
      onShow = _ref.onShow,
      onHide = _ref.onHide,
      onVisibleChange = _ref.onVisibleChange;
  var defaultViewDate = (value === null || value === void 0 ? void 0 : value[0]) || new Date();

  var _useState = useState(defaultViewDate),
      _useState2 = _slicedToArray$2(_useState, 2),
      viewDate = _useState2[0],
      setViewDate = _useState2[1];

  var getDefaultProps = function getDefaultProps() {
    return {
      id: id,
      ref: ref,
      name: name,
      value: value,
      showIcon: showIcon,
      onChange: onChange,
      dateFormat: dateFormat,
      placeholder: placeholder,
      yearRange: getYearRange(),
      locale: locale().locale,
      disabled: disabled,
      monthNavigator: monthNavigator,
      yearNavigator: yearNavigator,
      startRangeOfYears: startRangeOfYears,
      minDate: minDate,
      maxDate: maxDate,
      className: className,
      style: style,
      inputClassName: inputClassName,
      inputStyle: inputStyle,
      panelClassName: panelClassName,
      panelStyle: panelStyle,
      mask: mask,
      showOtherMonths: showOtherMonths,
      selectOtherMonths: selectOtherMonths,
      tooltip: tooltip,
      tooltipOptions: filterTooltipOptions(tooltipOptions),
      required: required,
      inputId: inputId,
      readOnlyInput: readOnlyInput,
      tabIndex: tabIndex,
      autoZIndex: autoZIndex,
      baseZIndex: baseZIndex,
      onFocus: onFocus,
      onBlur: onBlur,
      onInput: onInput,
      onSelect: onSelect,
      onShow: onShow,
      viewDate: viewDate,
      onHide: onHide,
      onVisibleChange: onVisibleChange,
      onViewDateChange: onViewDateChangeCustom
    };
  };

  var factory = function factory() {
    switch (mode) {
      case "range":
        return renderDateRangePicker();

      case "default":
        return renderDatePicker();

      default:
        throw new Error("Invalid mode");
    }
  };

  var onViewDateChangeCustom = function onViewDateChangeCustom(e) {
    setViewDate(e.value);
  };

  var getYearRange = function getYearRange() {
    var _getPartsOfTime = getPartsOfTime(),
        year = _getPartsOfTime.year;

    var startYear = startDate ? startDate.getFullYear() : startRangeOfYears;
    return yearRange || "".concat(startYear, ":").concat(year);
  };

  var renderDateRangePicker = function renderDateRangePicker() {
    var RangePicker = useMemo(function () {
      return withRange(Calendar);
    }, []);
    return /*#__PURE__*/React.createElement(RangePicker, _extends$c({}, getDefaultProps(), {
      rangeButtonsBar: rangeButtonsBar,
      headerTemplate: headerTemplate,
      viewDate: viewDate,
      onViewDateChange: onViewDateChangeCustom,
      numberOfMonths: 2,
      startDate: startDate
    }));
  };

  var headerTemplate = function headerTemplate() {
    var month = viewDate.getMonth();
    var nextMonth = month === 11 ? 0 : month + 1;
    var monthName = MONTHS[locale().locale][nextMonth];
    var year = viewDate.getFullYear();
    var displayedYear = month === 11 ? year + 1 : year;
    return /*#__PURE__*/React.createElement("div", {
      className: "p-datepicker-header-custom"
    }, /*#__PURE__*/React.createElement("span", {
      className: "p-datepicker-month-name"
    }, monthName), /*#__PURE__*/React.createElement("span", {
      className: "p-datepicker-year-name"
    }, displayedYear));
  };

  var renderDatePicker = function renderDatePicker() {
    return /*#__PURE__*/React.createElement(Calendar, _extends$c({}, getDefaultProps(), {
      numberOfMonths: 1
    }));
  };

  return factory();
});

var DateTimePicker = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      name = _ref.name,
      value = _ref.value,
      onChange = _ref.onChange,
      yearRange = _ref.yearRange,
      _ref$showSeconds = _ref.showSeconds,
      showSeconds = _ref$showSeconds === void 0 ? true : _ref$showSeconds,
      _ref$showMillisec = _ref.showMillisec,
      showMillisec = _ref$showMillisec === void 0 ? false : _ref$showMillisec,
      _ref$showUTC = _ref.showUTC,
      showUTC = _ref$showUTC === void 0 ? false : _ref$showUTC,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$stepHour = _ref.stepHour,
      stepHour = _ref$stepHour === void 0 ? 1 : _ref$stepHour,
      _ref$stepSecond = _ref.stepSecond,
      stepSecond = _ref$stepSecond === void 0 ? 1 : _ref$stepSecond,
      _ref$stepMinute = _ref.stepMinute,
      stepMinute = _ref$stepMinute === void 0 ? 1 : _ref$stepMinute,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder,
      _ref$showIcon = _ref.showIcon,
      showIcon = _ref$showIcon === void 0 ? false : _ref$showIcon,
      _ref$viewDate = _ref.viewDate,
      viewDate = _ref$viewDate === void 0 ? null : _ref$viewDate,
      _ref$mask = _ref.mask,
      mask = _ref$mask === void 0 ? null : _ref$mask,
      _ref$minDate = _ref.minDate,
      minDate = _ref$minDate === void 0 ? null : _ref$minDate,
      _ref$maxDate = _ref.maxDate,
      maxDate = _ref$maxDate === void 0 ? null : _ref$maxDate,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      style = _ref.style,
      inputClassName = _ref.inputClassName,
      inputStyle = _ref.inputStyle,
      panelClassName = _ref.panelClassName,
      panelStyle = _ref.panelStyle,
      _ref$dateFormat = _ref.dateFormat,
      dateFormat = _ref$dateFormat === void 0 ? "dd.mm.yy" : _ref$dateFormat,
      _ref$monthNavigator = _ref.monthNavigator,
      monthNavigator = _ref$monthNavigator === void 0 ? true : _ref$monthNavigator,
      _ref$yearNavigator = _ref.yearNavigator,
      yearNavigator = _ref$yearNavigator === void 0 ? true : _ref$yearNavigator,
      _ref$startRangeOfYear = _ref.startRangeOfYears,
      startRangeOfYears = _ref$startRangeOfYear === void 0 ? "2010" : _ref$startRangeOfYear,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      _ref$required = _ref.required,
      required = _ref$required === void 0 ? false : _ref$required,
      inputId = _ref.inputId,
      _ref$readOnlyInput = _ref.readOnlyInput,
      readOnlyInput = _ref$readOnlyInput === void 0 ? false : _ref$readOnlyInput,
      tabIndex = _ref.tabIndex,
      _ref$autoZIndex = _ref.autoZIndex,
      autoZIndex = _ref$autoZIndex === void 0 ? true : _ref$autoZIndex,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 50 : _ref$baseZIndex,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur,
      onInput = _ref.onInput,
      onSelect = _ref.onSelect,
      onShow = _ref.onShow,
      onHide = _ref.onHide,
      onVisibleChange = _ref.onVisibleChange;

  var getYearRange = function getYearRange() {
    var _getPartsOfTime = getPartsOfTime(),
        year = _getPartsOfTime.year;

    return yearRange || "".concat(startRangeOfYears, ":").concat(year);
  };

  var renderFooter = function renderFooter() {
    if (!showUTC || !value) return null;
    var day = value.getUTCDate();
    var month = value.getUTCMonth() + 1;
    var year = value.getUTCFullYear();
    var formattedDay = String(day).padStart(2, "0");
    var formattedMonth = String(month).padStart(2, "0");
    var hours = value.getUTCHours();
    var minutes = value.getUTCMinutes();
    var formattedHours = String(hours).padStart(2, "0");
    var formattedMinutes = String(minutes).padStart(2, "0");
    var date = "".concat(formattedDay, ".").concat(formattedMonth, ".").concat(year);
    var baseTime = "".concat(formattedHours, ":").concat(formattedMinutes);
    var formattedUTCDate = "".concat(date, " ").concat(baseTime);

    if (showSeconds) {
      var seconds = value.getUTCSeconds();
      var formattedSeconds = String(seconds).padStart(2, "0");
      formattedUTCDate += ":".concat(formattedSeconds);

      if (showMillisec) {
        var milliseconds = value.getUTCMilliseconds();
        var formattedMilliseconds = String(milliseconds).padStart(3, "0");
        formattedUTCDate += ".".concat(formattedMilliseconds);
      }
    }

    return /*#__PURE__*/React.createElement("div", {
      className: "text-center"
    }, /*#__PURE__*/React.createElement("span", {
      className: "font-bold"
    }, "UTC: "), /*#__PURE__*/React.createElement("span", null, formattedUTCDate));
  };

  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(Calendar, {
    id: id,
    name: name,
    ref: ref,
    value: value,
    onChange: onChange,
    showSeconds: showSeconds,
    showMillisec: showMillisec,
    stepHour: stepHour,
    stepSecond: stepSecond,
    stepMinute: stepMinute,
    placeholder: placeholder,
    disabled: disabled,
    showIcon: showIcon,
    viewDate: viewDate,
    mask: mask,
    minDate: minDate,
    maxDate: maxDate,
    className: className,
    style: style,
    inputClassName: inputClassName,
    inputStyle: inputStyle,
    panelClassName: panelClassName,
    panelStyle: panelStyle,
    dateFormat: dateFormat,
    hourFormat: "24",
    showTime: true,
    monthNavigator: monthNavigator,
    yearNavigator: yearNavigator,
    startRangeOfYears: startRangeOfYears,
    yearRange: getYearRange(),
    footerTemplate: renderFooter,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    required: required,
    inputId: inputId,
    readOnlyInput: readOnlyInput,
    tabIndex: tabIndex,
    autoZIndex: autoZIndex,
    baseZIndex: baseZIndex,
    onFocus: onFocus,
    onBlur: onBlur,
    onInput: onInput,
    onSelect: onSelect,
    onShow: onShow,
    onHide: onHide,
    onVisibleChange: onVisibleChange
  });
});

var Dialog = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      header = _ref.header,
      footer = _ref.footer,
      visible = _ref.visible,
      onHide = _ref.onHide,
      onShow = _ref.onShow,
      contentStyle = _ref.contentStyle,
      contentClassName = _ref.contentClassName,
      style = _ref.style,
      className = _ref.className,
      showHeader = _ref.showHeader,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 100 : _ref$baseZIndex,
      breakpoints = _ref.breakpoints,
      onClick = _ref.onClick,
      onMaskClick = _ref.onMaskClick,
      children = _ref.children;
  return /*#__PURE__*/React.createElement(Dialog$1, {
    ref: ref,
    id: id,
    header: header,
    footer: footer,
    visible: visible,
    onHide: onHide,
    onShow: onShow,
    contentStyle: contentStyle,
    contentClassName: contentClassName,
    style: style,
    className: className,
    showHeader: showHeader,
    baseZIndex: baseZIndex,
    breakpoints: breakpoints,
    onClick: onClick,
    onMaskClick: onMaskClick // props below are unavailable for users
    ,
    draggable: false,
    resizable: false,
    modal: true,
    closeOnEscape: true,
    dismissableMask: true,
    rtl: false,
    closable: true,
    maximizable: false,
    blockScroll: true,
    keepInViewport: true,
    maximized: false
  }, children);
});

function _classCallCheck$n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$n(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$n(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$n(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$n(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$n(o, p) {
  _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$n(o, p);
}

function _inherits$n(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$n(subClass, superClass);
}

function _typeof$n(obj) {
  "@babel/helpers - typeof";

  return _typeof$n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$n(obj);
}

function _assertThisInitialized$n(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$n(self, call) {
  if (call && (_typeof$n(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$n(self);
}

function _getPrototypeOf$n(o) {
  _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$n(o);
}

function _defineProperty$n(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$n(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$n(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$n(this, result);
  };
}

function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Divider$1 = /*#__PURE__*/function (_Component) {
  _inherits$n(Divider, _Component);

  var _super = _createSuper$t(Divider);

  function Divider() {
    _classCallCheck$n(this, Divider);

    return _super.apply(this, arguments);
  }

  _createClass$n(Divider, [{
    key: "isHorizontal",
    get: function get() {
      return this.props.layout === 'horizontal';
    }
  }, {
    key: "isVertical",
    get: function get() {
      return this.props.layout === 'vertical';
    }
  }, {
    key: "render",
    value: function render() {
      var dividerClassName = classNames("p-divider p-component p-divider-".concat(this.props.layout, " p-divider-").concat(this.props.type), {
        'p-divider-left': this.isHorizontal && (!this.props.align || this.props.align === 'left'),
        'p-divider-right': this.isHorizontal && this.props.align === 'right',
        'p-divider-center': this.isHorizontal && this.props.align === 'center' || this.isVertical && (!this.props.align || this.props.align === 'center'),
        'p-divider-top': this.isVertical && this.props.align === 'top',
        'p-divider-bottom': this.isVertical && this.props.align === 'bottom'
      }, this.props.className);
      return /*#__PURE__*/React.createElement("div", {
        className: dividerClassName,
        style: this.props.style,
        role: "separator"
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-divider-content"
      }, this.props.children));
    }
  }]);

  return Divider;
}(Component);

_defineProperty$n(Divider$1, "defaultProps", {
  align: null,
  layout: 'horizontal',
  type: 'solid',
  style: null,
  className: null
});

var Divider = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var align = _ref.align,
      layout = _ref.layout,
      type = _ref.type,
      style = _ref.style,
      className = _ref.className,
      children = _ref.children;
  return /*#__PURE__*/React.createElement(Divider$1, {
    ref: ref,
    align: align,
    layout: layout,
    type: type,
    style: style,
    className: className
  }, children);
});

var EMPTY_MESSAGE = {
  ru: "  ",
  en: "Nothing found"
};
var Dropdown = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      name = _ref.name,
      value = _ref.value,
      options = _ref.options,
      optionLabel = _ref.optionLabel,
      optionValue = _ref.optionValue,
      optionDisabled = _ref.optionDisabled,
      optionGroupLabel = _ref.optionGroupLabel,
      optionGroupChildren = _ref.optionGroupChildren,
      style = _ref.style,
      className = _ref.className,
      filter = _ref.filter,
      filterBy = _ref.filterBy,
      placeholder = _ref.placeholder,
      required = _ref.required,
      disabled = _ref.disabled,
      panelClassName = _ref.panelClassName,
      panelStyle = _ref.panelStyle,
      inputId = _ref.inputId,
      showClear = _ref.showClear,
      ariaLabel = _ref.ariaLabel,
      ariaLabelledBy = _ref.ariaLabelledBy,
      autoFocus = _ref.autoFocus,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      onChange = _ref.onChange,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur,
      onShow = _ref.onShow,
      onHide = _ref.onHide;
  var emptyMessage = EMPTY_MESSAGE[locale().locale];
  var dropdownClassName = classNames(className, "w-full");
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(Dropdown$1, {
    ref: ref,
    id: id,
    name: name,
    value: value,
    options: options,
    optionLabel: optionLabel,
    optionValue: optionValue,
    optionDisabled: optionDisabled,
    optionGroupLabel: optionGroupLabel,
    optionGroupChildren: optionGroupChildren,
    style: style,
    className: dropdownClassName,
    filter: filter,
    filterBy: filterBy,
    placeholder: placeholder,
    required: required,
    disabled: disabled,
    panelClassName: panelClassName,
    panelStyle: panelStyle,
    inputId: inputId,
    showClear: showClear,
    ariaLabelledBy: ariaLabelledBy,
    ariaLabel: ariaLabel,
    emptyMessage: emptyMessage,
    emptyFilterMessage: emptyMessage,
    autoFocus: autoFocus,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    showFilterClear: true,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur,
    onShow: onShow,
    onHide: onHide
  });
});

function _arrayLikeToArray$d(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$8(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$d(arr);
}

function _iterableToArray$8(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$d(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$d(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(o, minLen);
}

function _nonIterableSpread$8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$8(arr) {
  return _arrayWithoutHoles$8(arr) || _iterableToArray$8(arr) || _unsupportedIterableToArray$d(arr) || _nonIterableSpread$8();
}

function _classCallCheck$m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$m(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$m(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$m(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$m(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$m(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$m(o, p) {
  _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$m(o, p);
}

function _inherits$m(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$m(subClass, superClass);
}

function _typeof$m(obj) {
  "@babel/helpers - typeof";

  return _typeof$m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$m(obj);
}

function _possibleConstructorReturn$m(self, call) {
  if (call && (_typeof$m(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$m(self);
}

function _getPrototypeOf$m(o) {
  _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$m(o);
}

function _defineProperty$m(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends$5() {
  _extends$5 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$5.apply(this, arguments);
}

function _createSuper$1$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$6();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$m(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$m(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$m(this, result);
  };
}

function _isNativeReflectConstruct$1$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var UIMessageComponent = /*#__PURE__*/function (_Component) {
  _inherits$m(UIMessageComponent, _Component);

  var _super = _createSuper$1$6(UIMessageComponent);

  function UIMessageComponent(props) {
    var _this;

    _classCallCheck$m(this, UIMessageComponent);

    _this = _super.call(this, props);
    _this.onClick = _this.onClick.bind(_assertThisInitialized$m(_this));
    _this.onClose = _this.onClose.bind(_assertThisInitialized$m(_this));
    return _this;
  }

  _createClass$m(UIMessageComponent, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      if (!this.props.message.sticky) {
        this.timeout = setTimeout(function () {
          _this2.onClose(null);
        }, this.props.message.life || 3000);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
    }
  }, {
    key: "onClose",
    value: function onClose(event) {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }

      if (this.props.onClose) {
        this.props.onClose(this.props.message);
      }

      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }, {
    key: "onClick",
    value: function onClick() {
      if (this.props.onClick) {
        this.props.onClick(this.props.message);
      }
    }
  }, {
    key: "renderCloseIcon",
    value: function renderCloseIcon() {
      if (this.props.message.closable !== false) {
        return /*#__PURE__*/React.createElement("button", {
          type: "button",
          className: "p-message-close p-link",
          onClick: this.onClose
        }, /*#__PURE__*/React.createElement("i", {
          className: "p-message-close-icon pi pi-times"
        }), /*#__PURE__*/React.createElement(Ripple, null));
      }

      return null;
    }
  }, {
    key: "renderMessage",
    value: function renderMessage() {
      if (this.props.message) {
        var _this$props$message = this.props.message,
            severity = _this$props$message.severity,
            content = _this$props$message.content,
            summary = _this$props$message.summary,
            detail = _this$props$message.detail;
        var icon = classNames('p-message-icon pi ', {
          'pi-info-circle': severity === 'info',
          'pi-check': severity === 'success',
          'pi-exclamation-triangle': severity === 'warn',
          'pi-times-circle': severity === 'error'
        });
        return content || /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
          className: icon
        }), /*#__PURE__*/React.createElement("span", {
          className: "p-message-summary"
        }, summary), /*#__PURE__*/React.createElement("span", {
          className: "p-message-detail"
        }, detail));
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var severity = this.props.message.severity;
      var className = 'p-message p-component p-message-' + severity;
      var closeIcon = this.renderCloseIcon();
      var message = this.renderMessage();
      return /*#__PURE__*/React.createElement("div", {
        ref: this.props.forwardRef,
        className: className,
        onClick: this.onClick
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-message-wrapper"
      }, message, closeIcon));
    }
  }]);

  return UIMessageComponent;
}(Component);

_defineProperty$m(UIMessageComponent, "defaultProps", {
  message: null,
  onClose: null,
  onClick: null
});

var UIMessage = /*#__PURE__*/React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(UIMessageComponent, _extends$5({
    forwardRef: ref
  }, props));
});

function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$m(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$m(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$m(this, result);
  };
}

function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var messageIdx$1 = 0;

var Messages = /*#__PURE__*/function (_Component) {
  _inherits$m(Messages, _Component);

  var _super = _createSuper$s(Messages);

  function Messages(props) {
    var _this;

    _classCallCheck$m(this, Messages);

    _this = _super.call(this, props);
    _this.state = {
      messages: []
    };
    _this.onClose = _this.onClose.bind(_assertThisInitialized$m(_this));
    return _this;
  }

  _createClass$m(Messages, [{
    key: "show",
    value: function show(value) {
      if (value) {
        var newMessages = [];

        if (Array.isArray(value)) {
          for (var i = 0; i < value.length; i++) {
            value[i].id = messageIdx$1++;
            newMessages = [].concat(_toConsumableArray$8(this.state.messages), _toConsumableArray$8(value));
          }
        } else {
          value.id = messageIdx$1++;
          newMessages = this.state.messages ? [].concat(_toConsumableArray$8(this.state.messages), [value]) : [value];
        }

        this.setState({
          messages: newMessages
        });
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this.setState({
        messages: []
      });
    }
  }, {
    key: "replace",
    value: function replace(value) {
      var _this2 = this;

      this.setState({
        messages: []
      }, function () {
        return _this2.show(value);
      });
    }
  }, {
    key: "onClose",
    value: function onClose(message) {
      var newMessages = this.state.messages.filter(function (msg) {
        return msg.id !== message.id;
      });
      this.setState({
        messages: newMessages
      });

      if (this.props.onRemove) {
        this.props.onRemove(message);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      return /*#__PURE__*/React.createElement("div", {
        id: this.props.id,
        className: this.props.className,
        style: this.props.style
      }, /*#__PURE__*/React.createElement(TransitionGroup$1, null, this.state.messages.map(function (message) {
        var messageRef = /*#__PURE__*/React.createRef();
        return /*#__PURE__*/React.createElement(CSSTransition, {
          nodeRef: messageRef,
          key: message.id,
          classNames: "p-message",
          unmountOnExit: true,
          timeout: {
            enter: 300,
            exit: 300
          },
          options: _this3.props.transitionOptions
        }, /*#__PURE__*/React.createElement(UIMessage, {
          ref: messageRef,
          message: message,
          onClick: _this3.props.onClick,
          onClose: _this3.onClose
        }));
      })));
    }
  }]);

  return Messages;
}(Component);

_defineProperty$m(Messages, "defaultProps", {
  id: null,
  className: null,
  style: null,
  transitionOptions: null,
  onRemove: null,
  onClick: null
});

function _classCallCheck$l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$l(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$l(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$l(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$l(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$l(o, p) {
  _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$l(o, p);
}

function _inherits$l(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$l(subClass, superClass);
}

function _typeof$l(obj) {
  "@babel/helpers - typeof";

  return _typeof$l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$l(obj);
}

function _assertThisInitialized$l(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$l(self, call) {
  if (call && (_typeof$l(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$l(self);
}

function _getPrototypeOf$l(o) {
  _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$l(o);
}

function _defineProperty$l(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$l(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$l(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$l(this, result);
  };
}

function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var ProgressBar$1 = /*#__PURE__*/function (_Component) {
  _inherits$l(ProgressBar, _Component);

  var _super = _createSuper$r(ProgressBar);

  function ProgressBar() {
    _classCallCheck$l(this, ProgressBar);

    return _super.apply(this, arguments);
  }

  _createClass$l(ProgressBar, [{
    key: "renderLabel",
    value: function renderLabel() {
      if (this.props.showValue && this.props.value != null) {
        var label = this.props.displayValueTemplate ? this.props.displayValueTemplate(this.props.value) : this.props.value + this.props.unit;
        return /*#__PURE__*/React.createElement("div", {
          className: "p-progressbar-label"
        }, label);
      }

      return null;
    }
  }, {
    key: "renderDeterminate",
    value: function renderDeterminate() {
      var className = classNames('p-progressbar p-component p-progressbar-determinate', this.props.className);
      var label = this.renderLabel();
      return /*#__PURE__*/React.createElement("div", {
        role: "progressbar",
        id: this.props.id,
        className: className,
        style: this.props.style,
        "aria-valuemin": "0",
        "aria-valuenow": this.props.value,
        "aria-valuemax": "100",
        "aria-label": this.props.value
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-progressbar-value p-progressbar-value-animate",
        style: {
          width: this.props.value + '%',
          display: 'block',
          backgroundColor: this.props.color
        }
      }), label);
    }
  }, {
    key: "renderIndeterminate",
    value: function renderIndeterminate() {
      var className = classNames('p-progressbar p-component p-progressbar-indeterminate', this.props.className);
      return /*#__PURE__*/React.createElement("div", {
        role: "progressbar",
        id: this.props.id,
        className: className,
        style: this.props.style
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-progressbar-indeterminate-container"
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-progressbar-value p-progressbar-value-animate",
        style: {
          backgroundColor: this.props.color
        }
      })));
    }
  }, {
    key: "render",
    value: function render() {
      if (this.props.mode === 'determinate') return this.renderDeterminate();else if (this.props.mode === 'indeterminate') return this.renderIndeterminate();else throw new Error(this.props.mode + " is not a valid mode for the ProgressBar. Valid values are 'determinate' and 'indeterminate'");
    }
  }]);

  return ProgressBar;
}(Component);

_defineProperty$l(ProgressBar$1, "defaultProps", {
  id: null,
  value: null,
  showValue: true,
  unit: '%',
  style: null,
  className: null,
  mode: 'determinate',
  displayValueTemplate: null,
  color: null
});

function _arrayLikeToArray$1$4(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$7(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1$4(arr);
}

function _iterableToArray$7(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$1$4(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$4(o, minLen);
}

function _nonIterableSpread$7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$7(arr) {
  return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$1$4(arr) || _nonIterableSpread$7();
}

function _classCallCheck$k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$k(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$k(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$k(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$k(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$k(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$k(o, p) {
  _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$k(o, p);
}

function _inherits$k(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$k(subClass, superClass);
}

function _typeof$k(obj) {
  "@babel/helpers - typeof";

  return _typeof$k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$k(obj);
}

function _possibleConstructorReturn$k(self, call) {
  if (call && (_typeof$k(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$k(self);
}

function _getPrototypeOf$k(o) {
  _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$k(o);
}

function _defineProperty$k(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createForOfIteratorHelper$8(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$c(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$c(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$c(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(o, minLen);
}

function _arrayLikeToArray$c(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$k(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$k(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$k(this, result);
  };
}

function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var FileUpload$1 = /*#__PURE__*/function (_Component) {
  _inherits$k(FileUpload, _Component);

  var _super = _createSuper$q(FileUpload);

  function FileUpload(props) {
    var _this;

    _classCallCheck$k(this, FileUpload);

    _this = _super.call(this, props);
    _this.state = {
      files: [],
      msgs: [],
      focused: false,
      progress: 0
    };
    _this.choose = _this.choose.bind(_assertThisInitialized$k(_this));
    _this.upload = _this.upload.bind(_assertThisInitialized$k(_this));
    _this.clear = _this.clear.bind(_assertThisInitialized$k(_this));
    _this.onFileSelect = _this.onFileSelect.bind(_assertThisInitialized$k(_this));
    _this.onDragEnter = _this.onDragEnter.bind(_assertThisInitialized$k(_this));
    _this.onDragOver = _this.onDragOver.bind(_assertThisInitialized$k(_this));
    _this.onDragLeave = _this.onDragLeave.bind(_assertThisInitialized$k(_this));
    _this.onDrop = _this.onDrop.bind(_assertThisInitialized$k(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$k(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$k(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$k(_this));
    _this.onSimpleUploaderClick = _this.onSimpleUploaderClick.bind(_assertThisInitialized$k(_this));
    _this.duplicateIEEvent = false;
    return _this;
  }

  _createClass$k(FileUpload, [{
    key: "hasFiles",
    value: function hasFiles() {
      return this.state.files && this.state.files.length > 0;
    }
  }, {
    key: "isImage",
    value: function isImage(file) {
      return /^image\//.test(file.type);
    }
  }, {
    key: "chooseDisabled",
    value: function chooseDisabled() {
      return this.props.disabled || this.props.fileLimit && this.props.fileLimit <= this.state.files.length + this.uploadedFileCount;
    }
  }, {
    key: "uploadDisabled",
    value: function uploadDisabled() {
      return this.props.disabled || !this.hasFiles();
    }
  }, {
    key: "cancelDisabled",
    value: function cancelDisabled() {
      return this.props.disabled || !this.hasFiles();
    }
  }, {
    key: "chooseButtonLabel",
    value: function chooseButtonLabel() {
      return this.props.chooseLabel || this.props.chooseOptions.label || localeOption('choose');
    }
  }, {
    key: "uploadButtonLabel",
    value: function uploadButtonLabel() {
      return this.props.uploadLabel || this.props.uploadOptions.label || localeOption('upload');
    }
  }, {
    key: "cancelButtonLabel",
    value: function cancelButtonLabel() {
      return this.props.cancelLabel || this.props.cancelOptions.label || localeOption('cancel');
    }
  }, {
    key: "remove",
    value: function remove(event, index) {
      this.clearInputElement();

      var currentFiles = _toConsumableArray$7(this.state.files);

      var removedFile = this.state.files[index];
      currentFiles.splice(index, 1);
      this.setState({
        files: currentFiles
      });

      if (this.props.onRemove) {
        this.props.onRemove({
          originalEvent: event,
          file: removedFile
        });
      }
    }
  }, {
    key: "clearInputElement",
    value: function clearInputElement() {
      if (this.fileInput) {
        this.fileInput.value = '';
      }
    }
  }, {
    key: "clearIEInput",
    value: function clearIEInput() {
      if (this.fileInput) {
        this.duplicateIEEvent = true; //IE11 fix to prevent onFileChange trigger again

        this.fileInput.value = '';
      }
    }
  }, {
    key: "formatSize",
    value: function formatSize(bytes) {
      if (bytes === 0) {
        return '0 B';
      }

      var k = 1000,
          dm = 3,
          sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
          i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
  }, {
    key: "onFileSelect",
    value: function onFileSelect(event) {
      var _this2 = this;

      if (event.type !== 'drop' && this.isIE11() && this.duplicateIEEvent) {
        this.duplicateIEEvent = false;
        return;
      }

      this.setState({
        msgs: []
      });
      this.files = this.state.files ? _toConsumableArray$7(this.state.files) : [];
      var files = event.dataTransfer ? event.dataTransfer.files : event.target.files;

      for (var i = 0; i < files.length; i++) {
        var file = files[i];

        if (!this.isFileSelected(file)) {
          if (this.validate(file)) {
            if (this.isImage(file)) {
              file.objectURL = window.URL.createObjectURL(file);
            }

            this.files.push(file);
          }
        }
      }

      this.setState({
        files: this.files
      }, function () {
        if (_this2.hasFiles() && _this2.props.auto) {
          _this2.upload();
        }
      });

      if (this.props.onSelect) {
        this.props.onSelect({
          originalEvent: event,
          files: files
        });
      }

      if (event.type !== 'drop' && this.isIE11()) {
        this.clearIEInput();
      } else {
        this.clearInputElement();
      }

      if (this.props.mode === 'basic' && this.files.length > 0) {
        this.fileInput.style.display = 'none';
      }
    }
  }, {
    key: "isFileSelected",
    value: function isFileSelected(file) {
      var _iterator = _createForOfIteratorHelper$8(this.state.files),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var sFile = _step.value;
          if (sFile.name + sFile.type + sFile.size === file.name + file.type + file.size) return true;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return false;
    }
  }, {
    key: "isIE11",
    value: function isIE11() {
      return !!window['MSInputMethodContext'] && !!document['documentMode'];
    }
  }, {
    key: "validate",
    value: function validate(file) {
      if (this.props.maxFileSize && file.size > this.props.maxFileSize) {
        var message = {
          severity: 'error',
          summary: this.props.invalidFileSizeMessageSummary.replace('{0}', file.name),
          detail: this.props.invalidFileSizeMessageDetail.replace('{0}', this.formatSize(this.props.maxFileSize))
        };

        if (this.props.mode === 'advanced') {
          this.messagesUI.show(message);
        }

        if (this.props.onValidationFail) {
          this.props.onValidationFail(file);
        }

        return false;
      }

      return true;
    }
  }, {
    key: "upload",
    value: function upload() {
      var _this3 = this;

      if (this.props.customUpload) {
        if (this.props.fileLimit) {
          this.uploadedFileCount += this.state.files.length;
        }

        if (this.props.uploadHandler) {
          this.props.uploadHandler({
            files: this.state.files,
            options: {
              clear: this.clear,
              props: this.props
            }
          });
        }
      } else {
        this.setState({
          msgs: []
        });
        var xhr = new XMLHttpRequest();
        var formData = new FormData();

        if (this.props.onBeforeUpload) {
          this.props.onBeforeUpload({
            'xhr': xhr,
            'formData': formData
          });
        }

        var _iterator2 = _createForOfIteratorHelper$8(this.state.files),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var file = _step2.value;
            formData.append(this.props.name, file, file.name);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        xhr.upload.addEventListener('progress', function (event) {
          if (event.lengthComputable) {
            _this3.setState({
              progress: Math.round(event.loaded * 100 / event.total)
            }, function () {
              if (_this3.props.onProgress) {
                _this3.props.onProgress({
                  originalEvent: event,
                  progress: _this3.state.progress
                });
              }
            });
          }
        });

        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4) {
            _this3.setState({
              progress: 0
            });

            if (xhr.status >= 200 && xhr.status < 300) {
              if (_this3.props.fileLimit) {
                _this3.uploadedFileCount += _this3.state.files.length;
              }

              if (_this3.props.onUpload) {
                _this3.props.onUpload({
                  xhr: xhr,
                  files: _this3.state.files
                });
              }
            } else {
              if (_this3.props.onError) {
                _this3.props.onError({
                  xhr: xhr,
                  files: _this3.state.files
                });
              }
            }

            _this3.clear();
          }
        };

        xhr.open('POST', this.props.url, true);

        if (this.props.onBeforeSend) {
          this.props.onBeforeSend({
            'xhr': xhr,
            'formData': formData
          });
        }

        xhr.withCredentials = this.props.withCredentials;
        xhr.send(formData);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this.setState({
        files: []
      });

      if (this.props.onClear) {
        this.props.onClear();
      }

      this.clearInputElement();
    }
  }, {
    key: "choose",
    value: function choose() {
      this.fileInput.click();
    }
  }, {
    key: "onFocus",
    value: function onFocus() {
      this.setState({
        focused: true
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        focused: false
      });
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (event.which === 13) {
        // enter
        this.choose();
      }
    }
  }, {
    key: "onDragEnter",
    value: function onDragEnter(event) {
      if (!this.props.disabled) {
        event.dataTransfer.dropEffect = "copy";
        event.stopPropagation();
        event.preventDefault();
      }
    }
  }, {
    key: "onDragOver",
    value: function onDragOver(event) {
      if (!this.props.disabled) {
        event.dataTransfer.dropEffect = "copy";
        DomHandler$1.addClass(this.content, 'p-fileupload-highlight');
        event.stopPropagation();
        event.preventDefault();
      }
    }
  }, {
    key: "onDragLeave",
    value: function onDragLeave(event) {
      if (!this.props.disabled) {
        event.dataTransfer.dropEffect = "copy";
        DomHandler$1.removeClass(this.content, 'p-fileupload-highlight');
      }
    }
  }, {
    key: "onDrop",
    value: function onDrop(event) {
      if (!this.props.disabled) {
        DomHandler$1.removeClass(this.content, 'p-fileupload-highlight');
        event.stopPropagation();
        event.preventDefault();
        var files = event.dataTransfer ? event.dataTransfer.files : event.target.files;
        var allowDrop = this.props.multiple || files && files.length === 0;

        if (allowDrop) {
          this.onFileSelect(event);
        }
      }
    }
  }, {
    key: "onSimpleUploaderClick",
    value: function onSimpleUploaderClick() {
      if (this.hasFiles()) {
        this.upload();
      } else {
        this.fileInput.click();
      }
    }
  }, {
    key: "renderChooseButton",
    value: function renderChooseButton() {
      var _this4 = this;

      var _this$props$chooseOpt = this.props.chooseOptions,
          className = _this$props$chooseOpt.className,
          style = _this$props$chooseOpt.style,
          icon = _this$props$chooseOpt.icon,
          iconOnly = _this$props$chooseOpt.iconOnly;
      var chooseClassName = classNames('p-button p-fileupload-choose p-component', {
        'p-disabled': this.props.disabled,
        'p-focus': this.state.focused,
        'p-button-icon-only': iconOnly
      }, className);
      var labelClassName = 'p-button-label p-clickable';
      var label = iconOnly ? /*#__PURE__*/React.createElement("span", {
        className: labelClassName,
        dangerouslySetInnerHTML: {
          __html: "&nbsp;"
        }
      }) : /*#__PURE__*/React.createElement("span", {
        className: labelClassName
      }, this.chooseButtonLabel());
      return /*#__PURE__*/React.createElement("span", {
        className: chooseClassName,
        style: style,
        onClick: this.choose,
        onKeyDown: this.onKeyDown,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        tabIndex: 0
      }, /*#__PURE__*/React.createElement("input", {
        ref: function ref(el) {
          return _this4.fileInput = el;
        },
        type: "file",
        onChange: this.onFileSelect,
        multiple: this.props.multiple,
        accept: this.props.accept,
        disabled: this.chooseDisabled()
      }), IconUtils.getJSXIcon(icon || 'pi pi-fw pi-plus', {
        className: 'p-button-icon p-button-icon-left p-clickable'
      }, {
        props: this.props
      }), label, /*#__PURE__*/React.createElement(Ripple, null));
    }
  }, {
    key: "renderFile",
    value: function renderFile(file, index) {
      var _this5 = this;

      var preview = this.isImage(file) ? /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("img", {
        alt: file.name,
        role: "presentation",
        src: file.objectURL,
        width: this.props.previewWidth
      })) : null;
      var fileName = /*#__PURE__*/React.createElement("div", {
        className: "p-fileupload-filename"
      }, file.name);
      var size = /*#__PURE__*/React.createElement("div", null, this.formatSize(file.size));
      var removeButton = /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Button$1, {
        type: "button",
        icon: "pi pi-times",
        onClick: function onClick(e) {
          return _this5.remove(e, index);
        }
      }));
      var content = /*#__PURE__*/React.createElement(React.Fragment, null, preview, fileName, size, removeButton);

      if (this.props.itemTemplate) {
        var defaultContentOptions = {
          onRemove: function onRemove(event) {
            return _this5.remove(event, index);
          },
          previewElement: preview,
          fileNameElement: fileName,
          sizeElement: size,
          removeElement: removeButton,
          formatSize: this.formatSize(file.size),
          files: this.state.files,
          index: index,
          element: content,
          props: this.props
        };
        content = ObjectUtils.getJSXElement(this.props.itemTemplate, file, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement("div", {
        className: "p-fileupload-row",
        key: file.name + file.type + file.size
      }, content);
    }
  }, {
    key: "renderFiles",
    value: function renderFiles() {
      var _this6 = this;

      return /*#__PURE__*/React.createElement("div", {
        className: "p-fileupload-files"
      }, this.state.files.map(function (file, index) {
        return _this6.renderFile(file, index);
      }));
    }
  }, {
    key: "renderEmptyContent",
    value: function renderEmptyContent() {
      if (this.props.emptyTemplate && !this.hasFiles()) {
        return ObjectUtils.getJSXElement(this.props.emptyTemplate, this.props);
      }

      return null;
    }
  }, {
    key: "renderProgressBarContent",
    value: function renderProgressBarContent() {
      if (this.props.progressBarTemplate) {
        return ObjectUtils.getJSXElement(this.props.progressBarTemplate, this.props);
      }

      return /*#__PURE__*/React.createElement(ProgressBar$1, {
        value: this.state.progress,
        showValue: false
      });
    }
  }, {
    key: "renderAdvanced",
    value: function renderAdvanced() {
      var _this7 = this;

      var className = classNames('p-fileupload p-fileupload-advanced p-component', this.props.className);
      var headerClassName = classNames('p-fileupload-buttonbar', this.props.headerClassName);
      var contentClassName = classNames('p-fileupload-content', this.props.contentClassName);
      var uploadButton, cancelButton, filesList, progressBar;
      var chooseButton = this.renderChooseButton();
      var emptyContent = this.renderEmptyContent();

      if (!this.props.auto) {
        var uploadOptions = this.props.uploadOptions;
        var cancelOptions = this.props.cancelOptions;
        var uploadLabel = !uploadOptions.iconOnly ? this.uploadButtonLabel() : '';
        var cancelLabel = !cancelOptions.iconOnly ? this.cancelButtonLabel() : '';
        uploadButton = /*#__PURE__*/React.createElement(Button$1, {
          type: "button",
          label: uploadLabel,
          icon: uploadOptions.icon || 'pi pi-upload',
          onClick: this.upload,
          disabled: this.uploadDisabled(),
          style: uploadOptions.style,
          className: uploadOptions.className
        });
        cancelButton = /*#__PURE__*/React.createElement(Button$1, {
          type: "button",
          label: cancelLabel,
          icon: cancelOptions.icon || 'pi pi-times',
          onClick: this.clear,
          disabled: this.cancelDisabled(),
          style: cancelOptions.style,
          className: cancelOptions.className
        });
      }

      if (this.hasFiles()) {
        filesList = this.renderFiles();
        progressBar = this.renderProgressBarContent();
      }

      var header = /*#__PURE__*/React.createElement("div", {
        className: headerClassName,
        style: this.props.headerStyle
      }, chooseButton, uploadButton, cancelButton);

      if (this.props.headerTemplate) {
        var defaultContentOptions = {
          className: headerClassName,
          chooseButton: chooseButton,
          uploadButton: uploadButton,
          cancelButton: cancelButton,
          element: header,
          props: this.props
        };
        header = ObjectUtils.getJSXElement(this.props.headerTemplate, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement("div", {
        id: this.props.id,
        className: className,
        style: this.props.style
      }, header, /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          _this7.content = el;
        },
        className: contentClassName,
        style: this.props.contentStyle,
        onDragEnter: this.onDragEnter,
        onDragOver: this.onDragOver,
        onDragLeave: this.onDragLeave,
        onDrop: this.onDrop
      }, progressBar, /*#__PURE__*/React.createElement(Messages, {
        ref: function ref(el) {
          return _this7.messagesUI = el;
        }
      }), filesList, emptyContent));
    }
  }, {
    key: "renderBasic",
    value: function renderBasic() {
      var _this8 = this;

      var hasFiles = this.hasFiles();
      var chooseOptions = this.props.chooseOptions;
      var className = classNames('p-fileupload p-fileupload-basic p-component', this.props.className);
      var buttonClassName = classNames('p-button p-component p-fileupload-choose', {
        'p-fileupload-choose-selected': hasFiles,
        'p-disabled': this.props.disabled,
        'p-focus': this.state.focused
      }, chooseOptions.className);
      var chooseIcon = chooseOptions.icon || classNames({
        'pi pi-plus': !chooseOptions.icon && (!hasFiles || this.props.auto),
        'pi pi-upload': !chooseOptions.icon && hasFiles && !this.props.auto
      });
      var labelClassName = 'p-button-label p-clickable';
      var chooseLabel = chooseOptions.iconOnly ? /*#__PURE__*/React.createElement("span", {
        className: labelClassName,
        dangerouslySetInnerHTML: {
          __html: "&nbsp;"
        }
      }) : /*#__PURE__*/React.createElement("span", {
        className: labelClassName
      }, this.chooseButtonLabel());
      var label = this.props.auto ? chooseLabel : /*#__PURE__*/React.createElement("span", {
        className: labelClassName
      }, hasFiles ? this.state.files[0].name : chooseLabel);
      var icon = IconUtils.getJSXIcon(chooseIcon, {
        className: 'p-button-icon p-button-icon-left'
      }, {
        props: this.props,
        hasFiles: hasFiles
      });
      return /*#__PURE__*/React.createElement("div", {
        className: className,
        style: this.props.style
      }, /*#__PURE__*/React.createElement(Messages, {
        ref: function ref(el) {
          return _this8.messagesUI = el;
        }
      }), /*#__PURE__*/React.createElement("span", {
        className: buttonClassName,
        style: chooseOptions.style,
        onMouseUp: this.onSimpleUploaderClick,
        onKeyDown: this.onKeyDown,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        tabIndex: 0
      }, icon, label, !hasFiles && /*#__PURE__*/React.createElement("input", {
        ref: function ref(el) {
          return _this8.fileInput = el;
        },
        type: "file",
        accept: this.props.accept,
        multiple: this.props.multiple,
        disabled: this.props.disabled,
        onChange: this.onFileSelect
      }), /*#__PURE__*/React.createElement(Ripple, null)));
    }
  }, {
    key: "render",
    value: function render() {
      if (this.props.mode === 'advanced') return this.renderAdvanced();else if (this.props.mode === 'basic') return this.renderBasic();
    }
  }]);

  return FileUpload;
}(Component);

_defineProperty$k(FileUpload$1, "defaultProps", {
  id: null,
  name: null,
  url: null,
  mode: 'advanced',
  multiple: false,
  accept: null,
  disabled: false,
  auto: false,
  maxFileSize: null,
  invalidFileSizeMessageSummary: '{0}: Invalid file size, ',
  invalidFileSizeMessageDetail: 'maximum upload size is {0}.',
  style: null,
  className: null,
  widthCredentials: false,
  previewWidth: 50,
  chooseLabel: null,
  uploadLabel: null,
  cancelLabel: null,
  chooseOptions: {
    label: null,
    icon: null,
    iconOnly: false,
    className: null,
    style: null
  },
  uploadOptions: {
    label: null,
    icon: null,
    iconOnly: false,
    className: null,
    style: null
  },
  cancelOptions: {
    label: null,
    icon: null,
    iconOnly: false,
    className: null,
    style: null
  },
  customUpload: false,
  headerClassName: null,
  headerStyle: null,
  contentClassName: null,
  contentStyle: null,
  headerTemplate: null,
  itemTemplate: null,
  emptyTemplate: null,
  progressBarTemplate: null,
  onBeforeUpload: null,
  onBeforeSend: null,
  onUpload: null,
  onError: null,
  onClear: null,
  onSelect: null,
  onProgress: null,
  onValidationFail: null,
  uploadHandler: null,
  onRemove: null
});

var getValidationMessage = function getValidationMessage(file, maxFileSize) {
  return {
    /* eslint-disable max-len */
    en: "".concat(file.name, ": Invalid file size (").concat(file.size, " bytes), maximum upload size is ").concat(maxFileSize, " bytes."),
    ru: "".concat(file.name, ": \u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u044B\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u0444\u0430\u0439\u043B\u0430 (").concat(file.size, " \u0431\u0430\u0439\u0442), \u043C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u044B\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u2014 ").concat(maxFileSize, " \u0431\u0430\u0439\u0442.")
    /* eslint-enable max-len */

  };
};

var FileUpload = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      name = _ref.name,
      url = _ref.url,
      _ref$multiple = _ref.multiple,
      multiple = _ref$multiple === void 0 ? false : _ref$multiple,
      accept = _ref.accept,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$auto = _ref.auto,
      auto = _ref$auto === void 0 ? false : _ref$auto,
      maxFileSize = _ref.maxFileSize,
      style = _ref.style,
      className = _ref.className,
      _ref$withCredentials = _ref.withCredentials,
      withCredentials = _ref$withCredentials === void 0 ? false : _ref$withCredentials,
      chooseLabel = _ref.chooseLabel,
      chooseOptions = _ref.chooseOptions,
      _ref$customUpload = _ref.customUpload,
      customUpload = _ref$customUpload === void 0 ? false : _ref$customUpload,
      onBeforeUpload = _ref.onBeforeUpload,
      onBeforeSend = _ref.onBeforeSend,
      onUpload = _ref.onUpload,
      onError = _ref.onError,
      onClear = _ref.onClear,
      onSelect = _ref.onSelect,
      onProgress = _ref.onProgress,
      handleFailedValidation = _ref.onValidationFail,
      uploadHandler = _ref.uploadHandler,
      onRemove = _ref.onRemove;

  // adding validation message because Prime don't do it in basic mode
  var onValidationFail = function onValidationFail(file) {
    var message = null;

    if (maxFileSize && file.size > Number(maxFileSize)) {
      message = getValidationMessage(file, maxFileSize)[locale().locale];
    }

    handleFailedValidation && handleFailedValidation({
      file: file,
      message: message
    });
  };

  return /*#__PURE__*/React.createElement(FileUpload$1, {
    ref: ref,
    mode: "basic",
    id: id,
    name: name,
    url: url,
    multiple: multiple,
    accept: accept,
    disabled: disabled,
    auto: auto,
    maxFileSize: maxFileSize,
    style: style,
    className: className,
    withCredentials: withCredentials,
    chooseLabel: chooseLabel,
    chooseOptions: chooseOptions,
    customUpload: customUpload,
    onBeforeUpload: onBeforeUpload,
    onBeforeSend: onBeforeSend,
    onUpload: onUpload,
    onError: onError,
    onClear: onClear,
    onSelect: onSelect,
    onProgress: onProgress,
    onValidationFail: onValidationFail,
    uploadHandler: uploadHandler,
    onRemove: onRemove
  });
});

function _classCallCheck$j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$j(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$j(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$j(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$j(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$j(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$j(o, p) {
  _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$j(o, p);
}

function _inherits$j(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$j(subClass, superClass);
}

function _typeof$j(obj) {
  "@babel/helpers - typeof";

  return _typeof$j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$j(obj);
}

function _possibleConstructorReturn$j(self, call) {
  if (call && (_typeof$j(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$j(self);
}

function _getPrototypeOf$j(o) {
  _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$j(o);
}

function _defineProperty$j(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$j(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$j(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$j(this, result);
  };
}

function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Image$1 = /*#__PURE__*/function (_Component) {
  _inherits$j(Image, _Component);

  var _super = _createSuper$p(Image);

  function Image(props) {
    var _this;

    _classCallCheck$j(this, Image);

    _this = _super.call(this, props);
    _this.state = {
      maskVisible: false,
      previewVisible: false,
      rotate: 0,
      scale: 1
    };
    _this.onImageClick = _this.onImageClick.bind(_assertThisInitialized$j(_this));
    _this.onMaskClick = _this.onMaskClick.bind(_assertThisInitialized$j(_this));
    _this.onDownload = _this.onDownload.bind(_assertThisInitialized$j(_this));
    _this.rotateRight = _this.rotateRight.bind(_assertThisInitialized$j(_this));
    _this.rotateLeft = _this.rotateLeft.bind(_assertThisInitialized$j(_this));
    _this.zoomIn = _this.zoomIn.bind(_assertThisInitialized$j(_this));
    _this.zoomOut = _this.zoomOut.bind(_assertThisInitialized$j(_this));
    _this.onEntering = _this.onEntering.bind(_assertThisInitialized$j(_this));
    _this.onEntered = _this.onEntered.bind(_assertThisInitialized$j(_this));
    _this.onPreviewImageClick = _this.onPreviewImageClick.bind(_assertThisInitialized$j(_this));
    _this.onExit = _this.onExit.bind(_assertThisInitialized$j(_this));
    _this.onExiting = _this.onExiting.bind(_assertThisInitialized$j(_this));
    _this.onExited = _this.onExited.bind(_assertThisInitialized$j(_this));
    _this.previewRef = /*#__PURE__*/React.createRef();
    return _this;
  }

  _createClass$j(Image, [{
    key: "onImageClick",
    value: function onImageClick() {
      var _this2 = this;

      if (this.props.preview) {
        this.setState({
          maskVisible: true
        });
        setTimeout(function () {
          _this2.setState({
            previewVisible: true
          });
        }, 25);
      }
    }
  }, {
    key: "onPreviewImageClick",
    value: function onPreviewImageClick() {
      this.previewClick = true;
    }
  }, {
    key: "onMaskClick",
    value: function onMaskClick() {
      if (!this.previewClick) {
        this.setState({
          previewVisible: false
        });
        this.setState({
          rotate: 0
        });
        this.setState({
          scale: 1
        });
      }

      this.previewClick = false;
    }
  }, {
    key: "onDownload",
    value: function onDownload() {
      var _this$props = this.props,
          name = _this$props.alt,
          src = _this$props.src;
      DomHandler$1.saveAs({
        name: name,
        src: src
      });
      this.previewClick = true;
    }
  }, {
    key: "rotateRight",
    value: function rotateRight() {
      this.setState(function (prevState) {
        return {
          rotate: prevState.rotate + 90
        };
      });
      this.previewClick = true;
    }
  }, {
    key: "rotateLeft",
    value: function rotateLeft() {
      this.setState(function (prevState) {
        return {
          rotate: prevState.rotate - 90
        };
      });
      this.previewClick = true;
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      this.setState(function (prevState) {
        return {
          scale: prevState.scale + 0.1
        };
      });
      this.previewClick = true;
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      this.setState(function (prevState) {
        return {
          scale: prevState.scale - 0.1
        };
      });
      this.previewClick = true;
    }
  }, {
    key: "onEntering",
    value: function onEntering() {
      ZIndexUtils.set('modal', this.mask, PrimeReact.autoZIndex, PrimeReact.zIndex['modal']);
    }
  }, {
    key: "onEntered",
    value: function onEntered() {
      if (this.props.onShow) {
        this.props.onShow();
      }
    }
  }, {
    key: "onExit",
    value: function onExit() {
      DomHandler$1.addClass(this.mask, 'p-component-overlay-leave');
    }
  }, {
    key: "onExiting",
    value: function onExiting() {
      if (this.props.onHide) {
        this.props.onHide();
      }
    }
  }, {
    key: "onExited",
    value: function onExited(el) {
      ZIndexUtils.clear(el);
      this.setState({
        maskVisible: false
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.mask) {
        ZIndexUtils.clear(this.container);
      }
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var _this3 = this;

      var downloadable = this.props.downloadable;
      var imagePreviewStyle = {
        transform: 'rotate(' + this.state.rotate + 'deg) scale(' + this.state.scale + ')'
      };
      var zoomDisabled = this.state.scale <= 0.5 || this.state.scale >= 1.5; // const rotateClassName = 'p-image-preview-rotate-' + this.state.rotate;

      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this3.mask = el;
        },
        className: "p-image-mask p-component-overlay p-component-overlay-enter",
        onClick: this.onMaskClick
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-image-toolbar"
      }, downloadable && /*#__PURE__*/React.createElement("button", {
        className: "p-image-action p-link",
        onClick: this.onDownload,
        type: "button"
      }, /*#__PURE__*/React.createElement("i", {
        className: "pi pi-download"
      })), /*#__PURE__*/React.createElement("button", {
        className: "p-image-action p-link",
        onClick: this.rotateRight,
        type: "button"
      }, /*#__PURE__*/React.createElement("i", {
        className: "pi pi-refresh"
      })), /*#__PURE__*/React.createElement("button", {
        className: "p-image-action p-link",
        onClick: this.rotateLeft,
        type: "button"
      }, /*#__PURE__*/React.createElement("i", {
        className: "pi pi-undo"
      })), /*#__PURE__*/React.createElement("button", {
        className: "p-image-action p-link",
        onClick: this.zoomOut,
        type: "button",
        disabled: zoomDisabled
      }, /*#__PURE__*/React.createElement("i", {
        className: "pi pi-search-minus"
      })), /*#__PURE__*/React.createElement("button", {
        className: "p-image-action p-link",
        onClick: this.zoomIn,
        type: "button",
        disabled: zoomDisabled
      }, /*#__PURE__*/React.createElement("i", {
        className: "pi pi-search-plus"
      })), /*#__PURE__*/React.createElement("button", {
        className: "p-image-action p-link",
        type: "button",
        onClick: this.hidePreview
      }, /*#__PURE__*/React.createElement("i", {
        className: "pi pi-times"
      }))), /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: this.previewRef,
        classNames: "p-image-preview",
        "in": this.state.previewVisible,
        timeout: {
          enter: 150,
          exit: 150
        },
        unmountOnExit: true,
        onEntering: this.onEntering,
        onEntered: this.onEntered,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }, /*#__PURE__*/React.createElement("div", {
        ref: this.previewRef
      }, /*#__PURE__*/React.createElement("img", {
        src: this.props.src,
        className: "p-image-preview",
        style: imagePreviewStyle,
        onClick: this.onPreviewImageClick,
        alt: this.props.alt
      }))));
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var containerClassName = classNames('p-image p-component', this.props.className, {
        'p-image-preview-container': this.props.preview
      });
      var element = this.renderElement();
      var content = this.props.template ? ObjectUtils.getJSXElement(this.props.template, this.props) : /*#__PURE__*/React.createElement("i", {
        className: "p-image-preview-icon pi pi-eye"
      });
      var _this$props2 = this.props,
          src = _this$props2.src,
          alt = _this$props2.alt,
          width = _this$props2.width,
          height = _this$props2.height;
      return /*#__PURE__*/React.createElement("span", {
        ref: function ref(el) {
          return _this4.container = el;
        },
        className: containerClassName,
        style: this.props.style
      }, /*#__PURE__*/React.createElement("img", {
        src: src,
        className: this.props.imageClassName,
        width: width,
        height: height,
        style: this.props.imageStyle,
        alt: alt
      }), this.props.preview && /*#__PURE__*/React.createElement("div", {
        className: "p-image-preview-indicator",
        onClick: this.onImageClick
      }, content), this.state.maskVisible && /*#__PURE__*/React.createElement(Portal, {
        element: element,
        appendTo: document.body
      }));
    }
  }]);

  return Image;
}(Component);

_defineProperty$j(Image$1, "defaultProps", {
  preview: false,
  className: null,
  downloadable: false,
  style: null,
  imageStyle: null,
  imageClassName: null,
  template: null,
  src: null,
  alt: null,
  width: null,
  height: null
});

var Image = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$preview = _ref.preview,
      preview = _ref$preview === void 0 ? false : _ref$preview,
      src = _ref.src,
      alt = _ref.alt,
      width = _ref.width,
      height = _ref.height,
      _ref$downloadable = _ref.downloadable,
      downloadable = _ref$downloadable === void 0 ? false : _ref$downloadable,
      containerStyle = _ref.containerStyle,
      containerClassName = _ref.containerClassName,
      imageStyle = _ref.imageStyle,
      imageClassName = _ref.imageClassName,
      onShow = _ref.onShow,
      onHide = _ref.onHide;
  return /*#__PURE__*/React.createElement(Image$1, {
    ref: ref,
    preview: preview,
    downloadable: downloadable,
    src: src,
    alt: alt,
    width: width,
    height: height,
    style: containerStyle,
    className: containerClassName,
    imageStyle: imageStyle,
    imageClassName: imageClassName,
    onShow: onShow,
    onHide: onHide
  });
});

var InputNumber = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var value = _ref.value,
      inputRef = _ref.inputRef,
      _ref$format = _ref.format,
      format = _ref$format === void 0 ? true : _ref$format,
      _ref$showButtons = _ref.showButtons,
      showButtons = _ref$showButtons === void 0 ? false : _ref$showButtons,
      locale = _ref.locale,
      suffix = _ref.suffix,
      prefix = _ref.prefix,
      _ref$useGrouping = _ref.useGrouping,
      useGrouping = _ref$useGrouping === void 0 ? true : _ref$useGrouping,
      minFractionDigits = _ref.minFractionDigits,
      maxFractionDigits = _ref.maxFractionDigits,
      id = _ref.id,
      name = _ref.name,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? "text" : _ref$type,
      _ref$allowEmpty = _ref.allowEmpty,
      allowEmpty = _ref$allowEmpty === void 0 ? true : _ref$allowEmpty,
      _ref$step = _ref.step,
      step = _ref$step === void 0 ? 1 : _ref$step,
      min = _ref.min,
      max = _ref.max,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$required = _ref.required,
      required = _ref$required === void 0 ? false : _ref$required,
      tabIndex = _ref.tabIndex,
      pattern = _ref.pattern,
      inputMode = _ref.inputMode,
      placeholder = _ref.placeholder,
      _ref$readOnly = _ref.readOnly,
      readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly,
      size = _ref.size,
      style = _ref.style,
      className = _ref.className,
      inputId = _ref.inputId,
      _ref$autoFocus = _ref.autoFocus,
      autoFocus = _ref$autoFocus === void 0 ? false : _ref$autoFocus,
      inputStyle = _ref.inputStyle,
      inputClassName = _ref.inputClassName,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onValueChange = _ref.onValueChange,
      onChange = _ref.onChange,
      onBlur = _ref.onBlur,
      onFocus = _ref.onFocus,
      onKeyDown = _ref.onKeyDown;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(InputNumber$1, {
    ref: ref,
    value: value,
    inputRef: inputRef,
    format: format,
    showButtons: showButtons,
    locale: locale,
    suffix: suffix,
    prefix: prefix,
    useGrouping: useGrouping,
    minFractionDigits: minFractionDigits,
    maxFractionDigits: maxFractionDigits,
    id: id,
    name: name,
    type: type,
    allowEmpty: allowEmpty,
    step: step,
    min: min,
    max: max,
    disabled: disabled,
    required: required,
    tabIndex: tabIndex,
    pattern: pattern,
    inputMode: inputMode,
    placeholder: placeholder,
    readOnly: readOnly,
    size: size,
    style: style,
    className: className,
    inputId: inputId,
    autoFocus: autoFocus,
    inputStyle: inputStyle,
    inputClassName: inputClassName,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onValueChange: onValueChange,
    onChange: onChange,
    onBlur: onBlur,
    onFocus: onFocus,
    onKeyDown: onKeyDown
  });
});

function _classCallCheck$i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$i(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$i(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$i(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$i(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$i(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$i(o, p) {
  _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$i(o, p);
}

function _inherits$i(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$i(subClass, superClass);
}

function _typeof$i(obj) {
  "@babel/helpers - typeof";

  return _typeof$i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$i(obj);
}

function _possibleConstructorReturn$i(self, call) {
  if (call && (_typeof$i(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$i(self);
}

function _getPrototypeOf$i(o) {
  _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$i(o);
}

function _defineProperty$i(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$c(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$c(Object(source), !0).forEach(function (key) {
      _defineProperty$i(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$i(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$i(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$i(this, result);
  };
}

function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var InputMask$1 = /*#__PURE__*/function (_Component) {
  _inherits$i(InputMask, _Component);

  var _super = _createSuper$o(InputMask);

  function InputMask(props) {
    var _this;

    _classCallCheck$i(this, InputMask);

    _this = _super.call(this, props);
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$i(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$i(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$i(_this));
    _this.onKeyPress = _this.onKeyPress.bind(_assertThisInitialized$i(_this));
    _this.onInput = _this.onInput.bind(_assertThisInitialized$i(_this));
    _this.handleInputChange = _this.handleInputChange.bind(_assertThisInitialized$i(_this));
    _this.inputRef = /*#__PURE__*/createRef(_this.props.inputRef);
    return _this;
  }

  _createClass$i(InputMask, [{
    key: "caret",
    value: function caret(first, last) {
      var range, begin, end;
      var inputEl = this.inputRef && this.inputRef.current;

      if (!inputEl || !inputEl.offsetParent || inputEl !== document.activeElement) {
        return;
      }

      if (typeof first === 'number') {
        begin = first;
        end = typeof last === 'number' ? last : begin;

        if (inputEl.setSelectionRange) {
          inputEl.setSelectionRange(begin, end);
        } else if (inputEl['createTextRange']) {
          range = inputEl['createTextRange']();
          range.collapse(true);
          range.moveEnd('character', end);
          range.moveStart('character', begin);
          range.select();
        }
      } else {
        if (inputEl.setSelectionRange) {
          begin = inputEl.selectionStart;
          end = inputEl.selectionEnd;
        } else if (document['selection'] && document['selection'].createRange) {
          range = document['selection'].createRange();
          begin = 0 - range.duplicate().moveStart('character', -100000);
          end = begin + range.text.length;
        }

        return {
          begin: begin,
          end: end
        };
      }
    }
  }, {
    key: "isCompleted",
    value: function isCompleted() {
      for (var i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {
        if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "getPlaceholder",
    value: function getPlaceholder(i) {
      if (i < this.props.slotChar.length) {
        return this.props.slotChar.charAt(i);
      }

      return this.props.slotChar.charAt(0);
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this.props.unmask ? this.getUnmaskedValue() : this.inputRef && this.inputRef.current && this.inputRef.current.value;
    }
  }, {
    key: "seekNext",
    value: function seekNext(pos) {
      while (++pos < this.len && !this.tests[pos]) {}

      return pos;
    }
  }, {
    key: "seekPrev",
    value: function seekPrev(pos) {
      while (--pos >= 0 && !this.tests[pos]) {}

      return pos;
    }
  }, {
    key: "shiftL",
    value: function shiftL(begin, end) {
      var i, j;

      if (begin < 0) {
        return;
      }

      for (i = begin, j = this.seekNext(end); i < this.len; i++) {
        if (this.tests[i]) {
          if (j < this.len && this.tests[i].test(this.buffer[j])) {
            this.buffer[i] = this.buffer[j];
            this.buffer[j] = this.getPlaceholder(j);
          } else {
            break;
          }

          j = this.seekNext(j);
        }
      }

      this.writeBuffer();
      this.caret(Math.max(this.firstNonMaskPos, begin));
    }
  }, {
    key: "shiftR",
    value: function shiftR(pos) {
      var i, c, j, t;

      for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {
        if (this.tests[i]) {
          j = this.seekNext(i);
          t = this.buffer[i];
          this.buffer[i] = c;

          if (j < this.len && this.tests[j].test(t)) {
            c = t;
          } else {
            break;
          }
        }
      }
    }
  }, {
    key: "handleAndroidInput",
    value: function handleAndroidInput(e) {
      var curVal = this.inputRef.current.value;
      var pos = this.caret();

      if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {
        // a deletion or backspace happened
        this.checkVal(true);

        while (pos.begin > 0 && !this.tests[pos.begin - 1]) {
          pos.begin--;
        }

        if (pos.begin === 0) {
          while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) {
            pos.begin++;
          }
        }

        this.caret(pos.begin, pos.begin);
      } else {
        this.checkVal(true);

        while (pos.begin < this.len && !this.tests[pos.begin]) {
          pos.begin++;
        }

        this.caret(pos.begin, pos.begin);
      }

      if (this.props.onComplete && this.isCompleted()) {
        this.props.onComplete({
          originalEvent: e,
          value: this.getValue()
        });
      }
    }
  }, {
    key: "onBlur",
    value: function onBlur(e) {
      this.focus = false;
      this.checkVal();
      this.updateModel(e);
      this.updateFilledState();

      if (this.props.onBlur) {
        this.props.onBlur(e);
      }

      if (this.inputRef.current.value !== this.focusText) {
        var event = document.createEvent('HTMLEvents');
        event.initEvent('change', true, false);
        this.inputRef.current.dispatchEvent(event);
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(e) {
      if (this.props.readOnly) {
        return;
      }

      var k = e.which || e.keyCode,
          pos,
          begin,
          end;
      var iPhone = /iphone/i.test(DomHandler$1.getUserAgent());
      this.oldVal = this.inputRef.current.value; //backspace, delete, and escape get special treatment

      if (k === 8 || k === 46 || iPhone && k === 127) {
        pos = this.caret();
        begin = pos.begin;
        end = pos.end;

        if (end - begin === 0) {
          begin = k !== 46 ? this.seekPrev(begin) : end = this.seekNext(begin - 1);
          end = k === 46 ? this.seekNext(end) : end;
        }

        this.clearBuffer(begin, end);
        this.shiftL(begin, end - 1);
        this.updateModel(e);
        e.preventDefault();
      } else if (k === 13) {
        // enter
        this.onBlur(e);
        this.updateModel(e);
      } else if (k === 27) {
        // escape
        this.inputRef.current.value = this.focusText;
        this.caret(0, this.checkVal());
        this.updateModel(e);
        e.preventDefault();
      }
    }
  }, {
    key: "onKeyPress",
    value: function onKeyPress(e) {
      var _this2 = this;

      if (this.props.readOnly) {
        return;
      }

      var k = e.which || e.keyCode,
          pos = this.caret(),
          p,
          c,
          next,
          completed;

      if (e.ctrlKey || e.altKey || e.metaKey || k < 32) {
        //Ignore
        return;
      } else if (k && k !== 13) {
        if (pos.end - pos.begin !== 0) {
          this.clearBuffer(pos.begin, pos.end);
          this.shiftL(pos.begin, pos.end - 1);
        }

        p = this.seekNext(pos.begin - 1);

        if (p < this.len) {
          c = String.fromCharCode(k);

          if (this.tests[p].test(c)) {
            this.shiftR(p);
            this.buffer[p] = c;
            this.writeBuffer();
            next = this.seekNext(p);

            if (/android/i.test(DomHandler$1.getUserAgent())) {
              //Path for CSP Violation on FireFox OS 1.1
              var proxy = function proxy() {
                _this2.caret(next);
              };

              setTimeout(proxy, 0);
            } else {
              this.caret(next);
            }

            if (pos.begin <= this.lastRequiredNonMaskPos) {
              completed = this.isCompleted();
            }
          }
        }

        e.preventDefault();
      }

      this.updateModel(e);

      if (this.props.onComplete && completed) {
        this.props.onComplete({
          originalEvent: e,
          value: this.getValue()
        });
      }
    }
  }, {
    key: "clearBuffer",
    value: function clearBuffer(start, end) {
      var i;

      for (i = start; i < end && i < this.len; i++) {
        if (this.tests[i]) {
          this.buffer[i] = this.getPlaceholder(i);
        }
      }
    }
  }, {
    key: "writeBuffer",
    value: function writeBuffer() {
      this.inputRef.current.value = this.buffer.join('');
    }
  }, {
    key: "checkVal",
    value: function checkVal(allow) {
      this.isValueChecked = true; //try to place characters where they belong

      var test = this.inputRef.current.value,
          lastMatch = -1,
          i,
          c,
          pos;

      for (i = 0, pos = 0; i < this.len; i++) {
        if (this.tests[i]) {
          this.buffer[i] = this.getPlaceholder(i);

          while (pos++ < test.length) {
            c = test.charAt(pos - 1);

            if (this.tests[i].test(c)) {
              this.buffer[i] = c;
              lastMatch = i;
              break;
            }
          }

          if (pos > test.length) {
            this.clearBuffer(i + 1, this.len);
            break;
          }
        } else {
          if (this.buffer[i] === test.charAt(pos)) {
            pos++;
          }

          if (i < this.partialPosition) {
            lastMatch = i;
          }
        }
      }

      if (allow) {
        this.writeBuffer();
      } else if (lastMatch + 1 < this.partialPosition) {
        if (this.props.autoClear || this.buffer.join('') === this.defaultBuffer) {
          // Invalid value. Remove it and replace it with the
          // mask, which is the default behavior.
          if (this.inputRef.current.value) this.inputRef.current.value = '';
          this.clearBuffer(0, this.len);
        } else {
          // Invalid value, but we opt to show the value to the
          // user and allow them to correct their mistake.
          this.writeBuffer();
        }
      } else {
        this.writeBuffer();
        this.inputRef.current.value = this.inputRef.current.value.substring(0, lastMatch + 1);
      }

      return this.partialPosition ? i : this.firstNonMaskPos;
    }
  }, {
    key: "onFocus",
    value: function onFocus(e) {
      var _this3 = this;

      if (this.props.readOnly) {
        return;
      }

      this.focus = true;
      clearTimeout(this.caretTimeoutId);
      var pos;
      this.focusText = this.inputRef.current.value;
      pos = this.checkVal();
      this.caretTimeoutId = setTimeout(function () {
        if (_this3.inputRef.current !== document.activeElement) {
          return;
        }

        _this3.writeBuffer();

        if (pos === _this3.props.mask.replace("?", "").length) {
          _this3.caret(0, pos);
        } else {
          _this3.caret(pos);
        }

        _this3.updateFilledState();
      }, 10);

      if (this.props.onFocus) {
        this.props.onFocus(e);
      }
    }
  }, {
    key: "onInput",
    value: function onInput(event) {
      if (this.androidChrome) this.handleAndroidInput(event);else this.handleInputChange(event);
    }
  }, {
    key: "handleInputChange",
    value: function handleInputChange(e) {
      if (this.props.readOnly) {
        return;
      }

      var pos = this.checkVal(true);
      this.caret(pos);
      this.updateModel(e);

      if (this.props.onComplete && this.isCompleted()) {
        this.props.onComplete({
          originalEvent: e,
          value: this.getValue()
        });
      }
    }
  }, {
    key: "getUnmaskedValue",
    value: function getUnmaskedValue() {
      var unmaskedBuffer = [];

      for (var i = 0; i < this.buffer.length; i++) {
        var c = this.buffer[i];

        if (this.tests[i] && c !== this.getPlaceholder(i)) {
          unmaskedBuffer.push(c);
        }
      }

      return unmaskedBuffer.join('');
    }
  }, {
    key: "updateModel",
    value: function updateModel(e) {
      if (this.props.onChange) {
        var val = this.props.unmask ? this.getUnmaskedValue() : e && e.target.value;
        this.props.onChange({
          originalEvent: e,
          value: this.defaultBuffer !== val ? val : '',
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: this.defaultBuffer !== val ? val : ''
          }
        });
      }
    }
  }, {
    key: "updateFilledState",
    value: function updateFilledState() {
      if (this.inputRef && this.inputRef.current && this.inputRef.current.value && this.inputRef.current.value.length > 0) DomHandler$1.addClass(this.inputRef.current, 'p-filled');else DomHandler$1.removeClass(this.inputRef.current, 'p-filled');
    }
  }, {
    key: "updateValue",
    value: function updateValue(allow) {
      var _this4 = this;

      var pos;

      if (this.inputRef && this.inputRef.current) {
        if (this.props.value == null) {
          this.inputRef.current.value = '';
        } else {
          this.inputRef.current.value = this.props.value;
          pos = this.checkVal(allow);
          setTimeout(function () {
            if (_this4.inputRef && _this4.inputRef.current) {
              _this4.writeBuffer();

              return _this4.checkVal(allow);
            }
          }, 10);
        }

        this.focusText = this.inputRef.current.value;
      }

      this.updateFilledState();
      return pos;
    }
  }, {
    key: "isValueUpdated",
    value: function isValueUpdated() {
      return this.props.unmask ? this.props.value !== this.getUnmaskedValue() : this.defaultBuffer !== this.inputRef.current.value && this.inputRef.current.value !== this.props.value;
    }
  }, {
    key: "init",
    value: function init() {
      if (this.props.mask) {
        this.tests = [];
        this.partialPosition = this.props.mask.length;
        this.len = this.props.mask.length;
        this.firstNonMaskPos = null;
        this.defs = {
          '9': '[0-9]',
          'a': '[A-Za-z]',
          '*': '[A-Za-z0-9]'
        };
        var ua = DomHandler$1.getUserAgent();
        this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);
        var maskTokens = this.props.mask.split('');

        for (var i = 0; i < maskTokens.length; i++) {
          var c = maskTokens[i];

          if (c === '?') {
            this.len--;
            this.partialPosition = i;
          } else if (this.defs[c]) {
            this.tests.push(new RegExp(this.defs[c]));

            if (this.firstNonMaskPos === null) {
              this.firstNonMaskPos = this.tests.length - 1;
            }

            if (i < this.partialPosition) {
              this.lastRequiredNonMaskPos = this.tests.length - 1;
            }
          } else {
            this.tests.push(null);
          }
        }

        this.buffer = [];

        for (var _i = 0; _i < maskTokens.length; _i++) {
          var _c = maskTokens[_i];

          if (_c !== '?') {
            if (this.defs[_c]) this.buffer.push(this.getPlaceholder(_i));else this.buffer.push(_c);
          }
        }

        this.defaultBuffer = this.buffer.join('');
      }
    }
  }, {
    key: "updateInputRef",
    value: function updateInputRef() {
      var ref = this.props.inputRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.inputRef.current);
        } else {
          ref.current = this.inputRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateInputRef();
      this.init();
      this.updateValue();

      if (this.props.tooltip) {
        this.renderTooltip();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$c({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }

      if (this.isValueUpdated()) {
        this.updateValue();
      }

      if (prevProps.mask !== this.props.mask) {
        this.init();
        this.caret(this.updateValue(true));
        this.updateModel();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.inputRef.current,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "render",
    value: function render() {
      var inputMaskClassName = classNames('p-inputmask', this.props.className);
      return /*#__PURE__*/React.createElement(InputText$1, {
        id: this.props.id,
        ref: this.inputRef,
        type: this.props.type,
        name: this.props.name,
        style: this.props.style,
        className: inputMaskClassName,
        placeholder: this.props.placeholder,
        size: this.props.size,
        maxLength: this.props.maxLength,
        tabIndex: this.props.tabIndex,
        disabled: this.props.disabled,
        readOnly: this.props.readOnly,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyDown: this.onKeyDown,
        onKeyPress: this.onKeyPress,
        onInput: this.onInput,
        onPaste: this.handleInputChange,
        required: this.props.required,
        "aria-labelledby": this.props.ariaLabelledBy
      });
    }
  }]);

  return InputMask;
}(Component);

_defineProperty$i(InputMask$1, "defaultProps", {
  id: null,
  inputRef: null,
  value: null,
  type: 'text',
  mask: null,
  slotChar: '_',
  autoClear: true,
  unmask: false,
  style: null,
  className: null,
  placeholder: null,
  size: null,
  maxLength: null,
  tabIndex: null,
  disabled: false,
  readOnly: false,
  name: null,
  required: false,
  tooltip: null,
  tooltipOptions: null,
  ariaLabelledBy: null,
  onComplete: null,
  onChange: null,
  onFocus: null,
  onBlur: null
});

var InputMask = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      inputRef = _ref.inputRef,
      value = _ref.value,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? "text" : _ref$type,
      mask = _ref.mask,
      _ref$slotChar = _ref.slotChar,
      slotChar = _ref$slotChar === void 0 ? "_" : _ref$slotChar,
      _ref$autoClear = _ref.autoClear,
      autoClear = _ref$autoClear === void 0 ? false : _ref$autoClear,
      _ref$unmask = _ref.unmask,
      unmask = _ref$unmask === void 0 ? true : _ref$unmask,
      style = _ref.style,
      className = _ref.className,
      placeholder = _ref.placeholder,
      size = _ref.size,
      maxLength = _ref.maxLength,
      tabIndex = _ref.tabIndex,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$readOnly = _ref.readOnly,
      readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly,
      name = _ref.name,
      _ref$required = _ref.required,
      required = _ref$required === void 0 ? false : _ref$required,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onComplete = _ref.onComplete,
      onChange = _ref.onChange,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(InputMask$1, {
    ref: ref,
    id: id,
    inputRef: inputRef,
    value: value,
    type: type,
    mask: mask,
    slotChar: slotChar,
    autoClear: autoClear,
    unmask: unmask,
    style: style,
    className: className,
    placeholder: placeholder,
    size: size,
    maxLength: maxLength,
    tabIndex: tabIndex,
    disabled: disabled,
    readOnly: readOnly,
    name: name,
    required: required,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onComplete: onComplete,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur
  });
});

function _extends$4() {
  _extends$4 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$4.apply(this, arguments);
}

function _classCallCheck$h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$h(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$h(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$h(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$h(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$h(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$h(o, p) {
  _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$h(o, p);
}

function _inherits$h(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$h(subClass, superClass);
}

function _typeof$h(obj) {
  "@babel/helpers - typeof";

  return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$h(obj);
}

function _possibleConstructorReturn$h(self, call) {
  if (call && (_typeof$h(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$h(self);
}

function _getPrototypeOf$h(o) {
  _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$h(o);
}

function _defineProperty$h(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$b(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$b(Object(source), !0).forEach(function (key) {
      _defineProperty$h(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$h(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$h(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$h(this, result);
  };
}

function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var InputSwitch$1 = /*#__PURE__*/function (_Component) {
  _inherits$h(InputSwitch, _Component);

  var _super = _createSuper$n(InputSwitch);

  function InputSwitch(props) {
    var _this;

    _classCallCheck$h(this, InputSwitch);

    _this = _super.call(this, props);
    _this.state = {
      focused: false
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized$h(_this));
    _this.toggle = _this.toggle.bind(_assertThisInitialized$h(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$h(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$h(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$h(_this));
    _this.inputRef = /*#__PURE__*/createRef(_this.props.inputRef);
    return _this;
  }

  _createClass$h(InputSwitch, [{
    key: "onClick",
    value: function onClick(event) {
      if (this.props.disabled) {
        return;
      }

      this.toggle(event);
      this.inputRef.current.focus();
      event.preventDefault();
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      if (this.props.onChange) {
        var value = this.isChecked() ? this.props.falseValue : this.props.trueValue;
        this.props.onChange({
          originalEvent: event,
          value: value,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: value
          }
        });
      }
    }
  }, {
    key: "onFocus",
    value: function onFocus(event) {
      var _this2 = this;

      var currentEvent = event;
      this.setState({
        focused: true
      }, function () {
        if (_this2.props.onFocus) {
          _this2.props.onFocus(currentEvent);
        }
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur(event) {
      var _this3 = this;

      var currentEvent = event;
      this.setState({
        focused: false
      }, function () {
        if (_this3.props.onBlur) {
          _this3.props.onBlur(currentEvent);
        }
      });
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (event.key === 'Enter') {
        this.onClick(event);
      }
    }
  }, {
    key: "updateInputRef",
    value: function updateInputRef() {
      var ref = this.props.inputRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.inputRef.current);
        } else {
          ref.current = this.inputRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateInputRef();

      if (this.props.tooltip) {
        this.renderTooltip();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$b({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.container,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "isChecked",
    value: function isChecked() {
      return this.props.checked === this.props.trueValue;
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var checked = this.isChecked();
      var className = classNames('p-inputswitch p-component', {
        'p-inputswitch-checked': checked,
        'p-disabled': this.props.disabled,
        'p-inputswitch-focus': this.state.focused
      }, this.props.className);
      var inputSwitchProps = ObjectUtils.findDiffKeys(this.props, InputSwitch.defaultProps);
      return /*#__PURE__*/React.createElement("div", _extends$4({
        ref: function ref(el) {
          return _this4.container = el;
        },
        id: this.props.id,
        className: className,
        style: this.props.style,
        onClick: this.onClick,
        role: "checkbox",
        "aria-checked": checked
      }, inputSwitchProps), /*#__PURE__*/React.createElement("div", {
        className: "p-hidden-accessible"
      }, /*#__PURE__*/React.createElement("input", {
        ref: this.inputRef,
        type: "checkbox",
        id: this.props.inputId,
        name: this.props.name,
        checked: checked,
        onChange: this.toggle,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyDown: this.onKeyDown,
        disabled: this.props.disabled,
        role: "switch",
        "aria-checked": checked,
        "aria-labelledby": this.props.ariaLabelledBy
      })), /*#__PURE__*/React.createElement("span", {
        className: "p-inputswitch-slider"
      }));
    }
  }]);

  return InputSwitch;
}(Component);

_defineProperty$h(InputSwitch$1, "defaultProps", {
  id: null,
  inputRef: null,
  style: null,
  className: null,
  inputId: null,
  name: null,
  checked: false,
  trueValue: true,
  falseValue: false,
  disabled: false,
  tooltip: null,
  tooltipOptions: null,
  ariaLabelledBy: null,
  onChange: null,
  onFocus: null,
  onBlur: null
});

var InputSwitch = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      inputRef = _ref.inputRef,
      style = _ref.style,
      className = _ref.className,
      inputId = _ref.inputId,
      name = _ref.name,
      _ref$checked = _ref.checked,
      checked = _ref$checked === void 0 ? false : _ref$checked,
      _ref$trueValue = _ref.trueValue,
      trueValue = _ref$trueValue === void 0 ? true : _ref$trueValue,
      _ref$falseValue = _ref.falseValue,
      falseValue = _ref$falseValue === void 0 ? false : _ref$falseValue,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onChange = _ref.onChange,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(InputSwitch$1, {
    ref: ref,
    id: id,
    inputRef: inputRef,
    inputId: inputId,
    checked: checked,
    trueValue: trueValue,
    falseValue: falseValue,
    style: style,
    className: className,
    disabled: disabled,
    name: name,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur
  });
});

var _excluded$3 = ["keyfilter", "tooltip", "tooltipOptions", "validateOnly"];
var InputText = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var keyfilter = _ref.keyfilter,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions;
      _ref.validateOnly;
      var props = _objectWithoutProperties$1(_ref, _excluded$3);

  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(InputText$1, _extends$c({}, props, {
    ref: ref,
    keyfilter: keyfilter,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions
  }));
});

function _extends$3() {
  _extends$3 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$3.apply(this, arguments);
}

function _classCallCheck$g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$g(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$g(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$g(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$g(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$g(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$g(o, p) {
  _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$g(o, p);
}

function _inherits$g(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$g(subClass, superClass);
}

function _typeof$g(obj) {
  "@babel/helpers - typeof";

  return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$g(obj);
}

function _possibleConstructorReturn$g(self, call) {
  if (call && (_typeof$g(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$g(self);
}

function _getPrototypeOf$g(o) {
  _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$g(o);
}

function _defineProperty$g(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$a(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$a(Object(source), !0).forEach(function (key) {
      _defineProperty$g(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$g(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$g(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$g(this, result);
  };
}

function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var InputTextareaComponent = /*#__PURE__*/function (_Component) {
  _inherits$g(InputTextareaComponent, _Component);

  var _super = _createSuper$m(InputTextareaComponent);

  function InputTextareaComponent(props) {
    var _this;

    _classCallCheck$g(this, InputTextareaComponent);

    _this = _super.call(this, props);
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$g(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$g(_this));
    _this.onKeyUp = _this.onKeyUp.bind(_assertThisInitialized$g(_this));
    _this.onInput = _this.onInput.bind(_assertThisInitialized$g(_this));
    _this.elementRef = /*#__PURE__*/createRef(_this.props.forwardRef);
    return _this;
  }

  _createClass$g(InputTextareaComponent, [{
    key: "onFocus",
    value: function onFocus(e) {
      if (this.props.autoResize) {
        this.resize();
      }

      if (this.props.onFocus) {
        this.props.onFocus(e);
      }
    }
  }, {
    key: "onBlur",
    value: function onBlur(e) {
      if (this.props.autoResize) {
        this.resize();
      }

      if (this.props.onBlur) {
        this.props.onBlur(e);
      }
    }
  }, {
    key: "onKeyUp",
    value: function onKeyUp(e) {
      if (this.props.autoResize) {
        this.resize();
      }

      if (this.props.onKeyUp) {
        this.props.onKeyUp(e);
      }
    }
  }, {
    key: "onInput",
    value: function onInput(e) {
      if (this.props.autoResize) {
        this.resize();
      }

      if (e.target.value.length > 0) DomHandler$1.addClass(e.target, 'p-filled');else DomHandler$1.removeClass(e.target, 'p-filled');

      if (this.props.onInput) {
        this.props.onInput(e);
      }
    }
  }, {
    key: "resize",
    value: function resize(initial) {
      var inputEl = this.elementRef && this.elementRef.current;

      if (inputEl && DomHandler$1.isVisible(inputEl)) {
        if (!this.cachedScrollHeight) {
          this.cachedScrollHeight = inputEl.scrollHeight;
          inputEl.style.overflow = "hidden";
        }

        if (this.cachedScrollHeight !== inputEl.scrollHeight || initial) {
          inputEl.style.height = '';
          inputEl.style.height = inputEl.scrollHeight + 'px';

          if (parseFloat(inputEl.style.height) >= parseFloat(inputEl.style.maxHeight)) {
            inputEl.style.overflowY = "scroll";
            inputEl.style.height = inputEl.style.maxHeight;
          } else {
            inputEl.style.overflow = "hidden";
          }

          this.cachedScrollHeight = inputEl.scrollHeight;
        }
      }
    }
  }, {
    key: "isFilled",
    value: function isFilled() {
      return this.props.value != null && this.props.value.toString().length > 0 || this.props.defaultValue != null && this.props.defaultValue.toString().length > 0 || this.elementRef && this.elementRef.current && this.elementRef.current.value.toString().length > 0;
    }
  }, {
    key: "updateForwardRef",
    value: function updateForwardRef() {
      var ref = this.props.forwardRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.elementRef.current);
        } else {
          ref.current = this.elementRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateForwardRef();

      if (this.props.tooltip) {
        this.renderTooltip();
      }

      if (this.props.autoResize) {
        this.resize(true);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$a({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }

      if (this.props.autoResize) {
        this.resize(true);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.elementRef.current,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-inputtextarea p-inputtext p-component', {
        'p-disabled': this.props.disabled,
        'p-filled': this.isFilled(),
        'p-inputtextarea-resizable': this.props.autoResize
      }, this.props.className);
      var textareaProps = ObjectUtils.findDiffKeys(this.props, InputTextareaComponent.defaultProps);
      return /*#__PURE__*/React.createElement("textarea", _extends$3({
        ref: this.elementRef
      }, textareaProps, {
        className: className,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyUp: this.onKeyUp,
        onInput: this.onInput
      }));
    }
  }]);

  return InputTextareaComponent;
}(Component);

_defineProperty$g(InputTextareaComponent, "defaultProps", {
  autoResize: false,
  tooltip: null,
  tooltipOptions: null,
  onInput: null,
  forwardRef: null
});

var InputTextarea$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(InputTextareaComponent, _extends$3({
    forwardRef: ref
  }, props));
});

var _excluded$2 = ["autoResize", "tooltip", "tooltipOptions"];
var InputTextarea = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$autoResize = _ref.autoResize,
      autoResize = _ref$autoResize === void 0 ? false : _ref$autoResize,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      props = _objectWithoutProperties$1(_ref, _excluded$2);

  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(InputTextarea$1, _extends$c({}, props, {
    ref: ref,
    autoResize: autoResize,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions
  }));
});

function _classCallCheck$f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$f(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$f(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$f(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$f(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$f(o, p) {
  _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$f(o, p);
}

function _inherits$f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$f(subClass, superClass);
}

function _typeof$f(obj) {
  "@babel/helpers - typeof";

  return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$f(obj);
}

function _assertThisInitialized$f(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$f(self, call) {
  if (call && (_typeof$f(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$f(self);
}

function _getPrototypeOf$f(o) {
  _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$f(o);
}

function _defineProperty$f(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$f(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$f(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$f(this, result);
  };
}

function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Message$1 = /*#__PURE__*/function (_Component) {
  _inherits$f(Message, _Component);

  var _super = _createSuper$l(Message);

  function Message() {
    _classCallCheck$f(this, Message);

    return _super.apply(this, arguments);
  }

  _createClass$f(Message, [{
    key: "getContent",
    value: function getContent() {
      if (this.props.content) {
        return ObjectUtils.getJSXElement(this.props.content, this.props);
      }

      var text = ObjectUtils.getJSXElement(this.props.text, this.props);
      var icon = classNames('p-inline-message-icon pi', {
        'pi-info-circle': this.props.severity === 'info',
        'pi-exclamation-triangle': this.props.severity === 'warn',
        'pi-times-circle': this.props.severity === 'error',
        'pi-check': this.props.severity === 'success'
      });
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
        className: icon
      }), /*#__PURE__*/React.createElement("span", {
        className: "p-inline-message-text"
      }, text));
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-inline-message p-component', {
        'p-inline-message-info': this.props.severity === 'info',
        'p-inline-message-warn': this.props.severity === 'warn',
        'p-inline-message-error': this.props.severity === 'error',
        'p-inline-message-success': this.props.severity === 'success',
        'p-inline-message-icon-only': !this.props.text
      }, this.props.className);
      var content = this.getContent();
      return /*#__PURE__*/React.createElement("div", {
        id: this.props.id,
        "aria-live": "polite",
        className: className,
        style: this.props.style,
        role: "alert"
      }, content);
    }
  }]);

  return Message;
}(Component);

_defineProperty$f(Message$1, "defaultProps", {
  id: null,
  className: null,
  style: null,
  text: null,
  severity: 'info',
  content: null
});

var Message = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      className = _ref.className,
      style = _ref.style,
      severity = _ref.severity,
      text = _ref.text,
      content = _ref.content;
  var messageClassName = classNames(className, {
    "p-inline-message-secondary": severity === "secondary",
    "p-inline-message-help": severity === "help"
  });
  return /*#__PURE__*/React.createElement(Message$1, {
    ref: ref,
    id: id,
    style: style,
    className: messageClassName,
    severity: severity,
    text: text,
    content: content
  });
});

/*
 *      bignumber.js v9.0.2
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2021 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,
    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',
    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,
    // 2^53 - 1
// MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,
    // EDITABLE
// The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
// the arguments to toExponential, toFixed, toFormat, and toPrecision.
MAX = 1E9; // 0 to MAX_INT32

/*
 * Create and return a BigNumber constructor.
 */

function clone(configObject) {
  var div,
      convertBase,
      parseNumeric,
      P = BigNumber.prototype = {
    constructor: BigNumber,
    toString: null,
    valueOf: null
  },
      ONE = new BigNumber(1),
      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------
  // The default values below must be integers within the inclusive ranges stated.
  // The values can also be changed at run-time using BigNumber.set.
  // The maximum number of decimal places for operations involving division.
  DECIMAL_PLACES = 20,
      // 0 to MAX
  // The rounding mode used when rounding to the above decimal places, and when using
  // toExponential, toFixed, toFormat and toPrecision, and round (default value).
  // UP         0 Away from zero.
  // DOWN       1 Towards zero.
  // CEIL       2 Towards +Infinity.
  // FLOOR      3 Towards -Infinity.
  // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  ROUNDING_MODE = 4,
      // 0 to 8
  // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]
  // The exponent value at and beneath which toString returns exponential notation.
  // Number type: -7
  TO_EXP_NEG = -7,
      // 0 to -MAX
  // The exponent value at and above which toString returns exponential notation.
  // Number type: 21
  TO_EXP_POS = 21,
      // 0 to MAX
  // RANGE : [MIN_EXP, MAX_EXP]
  // The minimum exponent value, beneath which underflow to zero occurs.
  // Number type: -324  (5e-324)
  MIN_EXP = -1e7,
      // -1 to -MAX
  // The maximum exponent value, above which overflow to Infinity occurs.
  // Number type:  308  (1.7976931348623157e+308)
  // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
  MAX_EXP = 1e7,
      // 1 to MAX
  // Whether to use cryptographically-secure random number generation, if available.
  CRYPTO = false,
      // true or false
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP        0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN      1 The remainder has the same sign as the dividend.
  //             This modulo mode is commonly known as 'truncated division' and is
  //             equivalent to (a % n) in JavaScript.
  // FLOOR     3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
  // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
  //             The remainder is always positive.
  //
  // The truncated division, floored division, Euclidian division and IEEE 754 remainder
  // modes are commonly used for the modulus operation.
  // Although the other rounding modes can also be used, they may not give useful results.
  MODULO_MODE = 1,
      // 0 to 9
  // The maximum number of significant digits of the result of the exponentiatedBy operation.
  // If POW_PRECISION is 0, there will be unlimited significant digits.
  POW_PRECISION = 0,
      // 0 to MAX
  // The format specification used by the BigNumber.prototype.toFormat method.
  FORMAT = {
    prefix: '',
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ',',
    decimalSeparator: '.',
    fractionGroupSize: 0,
    fractionGroupSeparator: '\xA0',
    // non-breaking space
    suffix: ''
  },
      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
  // '-', '.', whitespace, or repeated character.
  // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
  ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true; //------------------------------------------------------------------------------------------
  // CONSTRUCTOR

  /*
   * The BigNumber constructor and exported function.
   * Create and return a new instance of a BigNumber object.
   *
   * v {number|string|BigNumber} A numeric value.
   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
   */

  function BigNumber(v, b) {
    var alphabet,
        c,
        caseChanged,
        e,
        i,
        isNum,
        len,
        str,
        x = this; // Enable constructor call without `new`.

    if (!(x instanceof BigNumber)) return new BigNumber(v, b);

    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;

        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }

        return;
      }

      if ((isNum = typeof v == 'number') && v * 0 == 0) {
        // Use `1 / n` to handle minus zero also.
        x.s = 1 / v < 0 ? (v = -v, -1) : 1; // Fast path for integers, where n < 2147483648 (2**31).

        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++);

          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }

          return;
        }

        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      } // Decimal point?


      if ((e = str.indexOf('.')) > -1) str = str.replace('.', ''); // Exponential form?

      if ((i = str.search(/e/i)) > 0) {
        // Determine exponent.
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        // Integer.
        e = str.length;
      }
    } else {
      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
      intCheck(b, 2, ALPHABET.length, 'Base'); // Allow exponential notation to be used with base 10 argument, while
      // also rounding to DECIMAL_PLACES as with other bases.

      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }

      str = String(v);

      if (isNum = typeof v == 'number') {
        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1; // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'

        if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }

      alphabet = ALPHABET.slice(0, b);
      e = i = 0; // Check that str is a valid base b number.
      // Don't use RegExp, so alphabet can contain special characters.

      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == '.') {
            // If '.' is not the first character and it has not be found before.
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            // Allow e.g. hexadecimal 'FF' as well as 'ff'.
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }

          return parseNumeric(x, String(v), isNum, b);
        }
      } // Prevent later check for length on converted number.


      isNum = false;
      str = convertBase(str, b, 10, x.s); // Decimal point?

      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');else e = str.length;
    } // Determine leading zeros.


    for (i = 0; str.charCodeAt(i) === 48; i++); // Determine trailing zeros.


    for (len = str.length; str.charCodeAt(--len) === 48;);

    if (str = str.slice(i, ++len)) {
      len -= i; // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'

      if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      } // Overflow?


      if ((e = e - i - 1) > MAX_EXP) {
        // Infinity.
        x.c = x.e = null; // Underflow?
      } else if (e < MIN_EXP) {
        // Zero.
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = []; // Transform base
        // e is the base 10 exponent.
        // i is where to slice str to get the first element of the coefficient array.

        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE; // i < 1

        if (i < len) {
          if (i) x.c.push(+str.slice(0, i));

          for (len -= LOG_BASE; i < len;) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }

          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }

        for (; i--; str += '0');

        x.c.push(+str);
      }
    } else {
      // Zero.
      x.c = [x.e = 0];
    }
  } // CONSTRUCTOR PROPERTIES


  BigNumber.clone = clone;
  BigNumber.ROUND_UP = 0;
  BigNumber.ROUND_DOWN = 1;
  BigNumber.ROUND_CEIL = 2;
  BigNumber.ROUND_FLOOR = 3;
  BigNumber.ROUND_HALF_UP = 4;
  BigNumber.ROUND_HALF_DOWN = 5;
  BigNumber.ROUND_HALF_EVEN = 6;
  BigNumber.ROUND_HALF_CEIL = 7;
  BigNumber.ROUND_HALF_FLOOR = 8;
  BigNumber.EUCLID = 9;
  /*
   * Configure infrequently-changing library-wide settings.
   *
   * Accept an object with the following optional properties (if the value of a property is
   * a number, it must be an integer within the inclusive range stated):
   *
   *   DECIMAL_PLACES   {number}           0 to MAX
   *   ROUNDING_MODE    {number}           0 to 8
   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
   *   CRYPTO           {boolean}          true or false
   *   MODULO_MODE      {number}           0 to 9
   *   POW_PRECISION       {number}           0 to MAX
   *   ALPHABET         {string}           A string of two or more unique characters which does
   *                                       not contain '.'.
   *   FORMAT           {object}           An object with some of the following properties:
   *     prefix                 {string}
   *     groupSize              {number}
   *     secondaryGroupSize     {number}
   *     groupSeparator         {string}
   *     decimalSeparator       {string}
   *     fractionGroupSize      {number}
   *     fractionGroupSeparator {string}
   *     suffix                 {string}
   *
   * (The values assigned to the above FORMAT object properties are not checked for validity.)
   *
   * E.g.
   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
   *
   * Ignore properties/parameters set to null or undefined, except for ALPHABET.
   *
   * Return an object with the properties current values.
   */

  BigNumber.config = BigNumber.set = function (obj) {
    var p, v;

    if (obj != null) {
      if (typeof obj == 'object') {
        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        } // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'


        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        } // EXPONENTIAL_AT {number|number[]}
        // Integer, -MAX to MAX inclusive or
        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'


        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
          v = obj[p];

          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        } // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'


        if (obj.hasOwnProperty(p = 'RANGE')) {
          v = obj[p];

          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);

            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + ' cannot be zero: ' + v);
            }
          }
        } // CRYPTO {boolean} true or false.
        // '[BigNumber Error] CRYPTO not true or false: {v}'
        // '[BigNumber Error] crypto unavailable'


        if (obj.hasOwnProperty(p = 'CRYPTO')) {
          v = obj[p];

          if (v === !!v) {
            if (v) {
              if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + 'crypto unavailable');
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + ' not true or false: ' + v);
          }
        } // MODULO_MODE {number} Integer, 0 to 9 inclusive.
        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'


        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        } // POW_PRECISION {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'


        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        } // FORMAT {object}
        // '[BigNumber Error] FORMAT not an object: {v}'


        if (obj.hasOwnProperty(p = 'FORMAT')) {
          v = obj[p];
          if (typeof v == 'object') FORMAT = v;else throw Error(bignumberError + p + ' not an object: ' + v);
        } // ALPHABET {string}
        // '[BigNumber Error] ALPHABET invalid: {v}'


        if (obj.hasOwnProperty(p = 'ALPHABET')) {
          v = obj[p]; // Disallow if less than two characters,
          // or if it contains '+', '-', '.', whitespace, or a repeated character.

          if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + ' invalid: ' + v);
          }
        }
      } else {
        // '[BigNumber Error] Object expected: {v}'
        throw Error(bignumberError + 'Object expected: ' + obj);
      }
    }

    return {
      DECIMAL_PLACES: DECIMAL_PLACES,
      ROUNDING_MODE: ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO: CRYPTO,
      MODULO_MODE: MODULO_MODE,
      POW_PRECISION: POW_PRECISION,
      FORMAT: FORMAT,
      ALPHABET: ALPHABET
    };
  };
  /*
   * Return true if v is a BigNumber instance, otherwise return false.
   *
   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
   *
   * v {any}
   *
   * '[BigNumber Error] Invalid BigNumber: {v}'
   */


  BigNumber.isBigNumber = function (v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber.DEBUG) return true;
    var i,
        n,
        c = v.c,
        e = v.e,
        s = v.s;

    out: if ({}.toString.call(c) == '[object Array]') {
      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
        // If the first element is zero, the BigNumber value must be zero.
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        } // Calculate number of digits that c[0] should have, based on the exponent.


        i = (e + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE; // Calculate number of digits of c[0].
        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {

        if (String(c[0]).length == i) {
          for (i = 0; i < c.length; i++) {
            n = c[i];
            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
          } // Last element cannot be zero, unless it is the only element.


          if (n !== 0) return true;
        }
      } // Infinity/NaN

    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }

    throw Error(bignumberError + 'Invalid BigNumber: ' + v);
  };
  /*
   * Return a new BigNumber whose value is the maximum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */


  BigNumber.maximum = BigNumber.max = function () {
    return maxOrMin(arguments, P.lt);
  };
  /*
   * Return a new BigNumber whose value is the minimum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */


  BigNumber.minimum = BigNumber.min = function () {
    return maxOrMin(arguments, P.gt);
  };
  /*
   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
   * zeros are produced).
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
   * '[BigNumber Error] crypto unavailable'
   */


  BigNumber.random = function () {
    var pow2_53 = 0x20000000000000; // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
    // Check if Math.random() produces more than 32 bits of randomness.
    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.

    var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function () {
      return mathfloor(Math.random() * pow2_53);
    } : function () {
      return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);
    };
    return function (dp) {
      var a,
          b,
          e,
          k,
          v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);
      if (dp == null) dp = DECIMAL_PLACES;else intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);

      if (CRYPTO) {
        // Browsers supporting crypto.getRandomValues.
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));

          for (; i < k;) {
            // 53 bits:
            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
            //                                     11111 11111111 11111111
            // 0x20000 is 2^21.
            v = a[i] * 0x20000 + (a[i + 1] >>> 11); // Rejection sampling:
            // 0 <= v < 9007199254740992
            // Probability that v >= 9e15, is
            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251

            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              // 0 <= v <= 8999999999999999
              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 2;
            }
          }

          i = k / 2; // Node.js supporting crypto.randomBytes.
        } else if (crypto.randomBytes) {
          // buffer
          a = crypto.randomBytes(k *= 7);

          for (; i < k;) {
            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
            // 0x100000000 is 2^32, 0x1000000 is 2^24
            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
            // 0 <= v < 9007199254740992
            v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 7;
            }
          }

          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + 'crypto unavailable');
        }
      } // Use Math.random.


      if (!CRYPTO) {
        for (; i < k;) {
          v = random53bitInt();
          if (v < 9e15) c[i++] = v % 1e14;
        }
      }

      k = c[--i];
      dp %= LOG_BASE; // Convert trailing digits to zeros according to dp.

      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      } // Remove trailing elements which are zero.


      for (; c[i] === 0; c.pop(), i--); // Zero?


      if (i < 0) {
        c = [e = 0];
      } else {
        // Remove leading elements which are zero and adjust exponent accordingly.
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE); // Count the digits of the first element of c to determine leading zeros, and...


        for (i = 1, v = c[0]; v >= 10; v /= 10, i++); // adjust the exponent accordingly.


        if (i < LOG_BASE) e -= LOG_BASE - i;
      }

      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  /*
  * Return a BigNumber whose value is the sum of the arguments.
  *
  * arguments {number|string|BigNumber}
  */


  BigNumber.sum = function () {
    var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);

    for (; i < args.length;) sum = sum.plus(args[i++]);

    return sum;
  }; // PRIVATE FUNCTIONS
  // Called by BigNumber and BigNumber.prototype.toString.


  convertBase = function () {
    var decimal = '0123456789';
    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. toBaseOut('255', 10, 16) returns [15, 15].
     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
     */

    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

      for (; i < len;) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

        arr[0] += alphabet.indexOf(str.charAt(i++));

        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }

      return arr.reverse();
    } // Convert a numeric string of baseIn to a numeric string of baseOut.
    // If the caller is toString, we are converting from base 10 to baseOut.
    // If the caller is BigNumber, we are converting from baseIn to base 10.


    return function (str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet,
          d,
          e,
          k,
          r,
          x,
          xc,
          y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE; // Non-integer.

      if (i >= 0) {
        k = POW_PRECISION; // Unlimited precision.

        POW_PRECISION = 0;
        str = str.replace('.', '');
        y = new BigNumber(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k; // Convert str as if an integer, then restore the fraction part by dividing the
        // result by its base raised to a power.

        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal);
        y.e = y.c.length;
      } // Convert the number as integer.


      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET)); // xc now represents str as an integer and converted to baseOut. e is the exponent.

      e = k = xc.length; // Remove trailing zeros.

      for (; xc[--k] == 0; xc.pop()); // Zero?


      if (!xc[0]) return alphabet.charAt(0); // Does str represent an integer? If so, no need for the division.

      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e; // The sign is needed for correct rounding.

        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      } // xc now represents str converted to baseOut.
      // THe index of the rounding digit.


      d = e + dp + 1; // The rounding digit: the digit to the right of the digit that may be rounded up.

      i = xc[d]; // Look at the rounding digits and mode to determine whether to round up.

      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7)); // If the index of the rounding digit is not greater than zero, or xc represents
      // zero, then the result of the base conversion is zero or, if rounding up, a value
      // such as 0.00001.

      if (d < 1 || !xc[0]) {
        // 1^-dp or 0
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        // Truncate xc to the required number of decimal places.
        xc.length = d; // Round up?

        if (r) {
          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (--baseOut; ++xc[--d] > baseOut;) {
            xc[d] = 0;

            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        } // Determine trailing zeros.


        for (k = xc.length; !xc[--k];); // E.g. [4, 11, 15] becomes 4bf.


        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++])); // Add leading zeros, decimal point and trailing zeros as required.


        str = toFixedPoint(str, e, alphabet.charAt(0));
      } // The caller will add the sign.


      return str;
    };
  }(); // Perform division in the specified base. Called by div and convertBase.


  div = function () {
    // Assume non-zero x and k.
    function multiply(x, k, base) {
      var m,
          temp,
          xlo,
          xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

      for (x = x.slice(); i--;) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }

      if (carry) x = [carry].concat(x);
      return x;
    }

    function compare(a, b, aL, bL) {
      var i, cmp;

      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return cmp;
    }

    function subtract(a, b, aL, base) {
      var i = 0; // Subtract b from a.

      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      } // Remove leading zeros.


      for (; !a[0] && a.length > 1; a.splice(0, 1));
    } // x: dividend, y: divisor.


    return function (x, y, dp, rm, base) {
      var cmp,
          e,
          i,
          more,
          n,
          prod,
          prodL,
          q,
          qc,
          rem,
          remL,
          rem0,
          xi,
          xL,
          yc0,
          yL,
          yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c; // Either NaN, Infinity or 0?

      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber( // Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
        xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
      }

      q = new BigNumber(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;

      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      } // Result exponent may be one less then the current value of e.
      // The coefficients of the BigNumbers from convertBase may have trailing zeros.


      for (i = 0; yc[i] == (xc[i] || 0); i++);

      if (yc[i] > (xc[i] || 0)) e--;

      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2; // Normalise xc and yc so highest order digit of yc is >= base / 2.

        n = mathfloor(base / (yc[0] + 1)); // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {

        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }

        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length; // Add zeros to make remainder as long as divisor.

        for (; remL < yL; rem[remL++] = 0);

        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2) yc0++; // Not necessary, but to prevent trial digit n > base, when using base 3.
        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

        do {
          n = 0; // Compare divisor and remainder.

          cmp = compare(yc, rem, yL, remL); // If divisor < remainder.

          if (cmp < 0) {
            // Calculate trial digit, n.
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0); // n is how many times the divisor goes into the current remainder.

            n = mathfloor(rem0 / yc0); //  Algorithm:
            //  product = divisor multiplied by trial digit (n).
            //  Compare product and remainder.
            //  If product is greater than remainder:
            //    Subtract divisor from product, decrement trial digit.
            //  Subtract product from remainder.
            //  If product was less than remainder at the last compare:
            //    Compare new remainder and divisor.
            //    If remainder is greater than divisor:
            //      Subtract divisor from remainder, increment trial digit.

            if (n > 1) {
              // n may be > base only when base is 3.
              if (n >= base) n = base - 1; // product = divisor * trial digit.

              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length; // Compare product and remainder.
              // If product > remainder then trial digit n too high.
              // n is 1 too high about 5% of the time, and is not known to have
              // ever been more than 1 too high.

              while (compare(prod, rem, prodL, remL) == 1) {
                n--; // Subtract divisor from product.

                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              // n is 0 or 1, cmp is -1.
              // If n is 0, there is no need to compare yc and rem again below,
              // so change cmp to 1 to avoid it.
              // If n is 1, leave cmp as -1, so yc and rem are compared again.
              if (n == 0) {
                // divisor < remainder, so n must be at least 1.
                cmp = n = 1;
              } // product = divisor


              prod = yc.slice();
              prodL = prod.length;
            }

            if (prodL < remL) prod = [0].concat(prod); // Subtract product from remainder.

            subtract(rem, prod, remL, base);
            remL = rem.length; // If product was < remainder.

            if (cmp == -1) {
              // Compare divisor and new remainder.
              // If divisor < new remainder, subtract divisor from remainder.
              // Trial digit n too low.
              // n is 1 too low about 5% of the time, and very rarely 2 too low.
              while (compare(yc, rem, yL, remL) < 1) {
                n++; // Subtract divisor from remainder.

                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          } // else cmp === 1 and n will be 0
          // Add the next digit, n, to the result array.


          qc[i++] = n; // Update the remainder.

          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);

        more = rem[0] != null; // Leading zero?

        if (!qc[0]) qc.splice(0, 1);
      }

      if (base == BASE) {
        // To calculate q.e, first get the number of digits of qc[0].
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more); // Caller is convertBase.
      } else {
        q.e = e;
        q.r = +more;
      }

      return q;
    };
  }();
  /*
   * Return a string representing the value of BigNumber n in fixed-point or exponential
   * notation rounded to the specified decimal places or significant digits.
   *
   * n: a BigNumber.
   * i: the index of the last digit required (i.e. the digit that may be rounded up).
   * rm: the rounding mode.
   * id: 1 (toExponential) or 2 (toPrecision).
   */


  function format(n, i, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
    if (!n.c) return n.toString();
    c0 = n.c[0];
    ne = n.e;

    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, '0');
    } else {
      n = round(new BigNumber(n), i, rm); // n.e may have changed if the value was rounded up.

      e = n.e;
      str = coeffToString(n.c);
      len = str.length; // toPrecision returns exponential notation if the number of significant digits
      // specified is less than the number of digits necessary to represent the integer
      // part of the value in fixed-point notation.
      // Exponential notation.

      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        // Append zeros?
        for (; len < i; str += '0', len++);

        str = toExponential(str, e); // Fixed-point notation.
      } else {
        i -= ne;
        str = toFixedPoint(str, e, '0'); // Append zeros?

        if (e + 1 > len) {
          if (--i > 0) for (str += '.'; i--; str += '0');
        } else {
          i += e - len;

          if (i > 0) {
            if (e + 1 == len) str += '.';

            for (; i--; str += '0');
          }
        }
      }
    }

    return n.s < 0 && c0 ? '-' + str : str;
  } // Handle BigNumber.max and BigNumber.min.


  function maxOrMin(args, method) {
    var n,
        i = 1,
        m = new BigNumber(args[0]);

    for (; i < args.length; i++) {
      n = new BigNumber(args[i]); // If any number is NaN, return NaN.

      if (!n.s) {
        m = n;
        break;
      } else if (method.call(m, n)) {
        m = n;
      }
    }

    return m;
  }
  /*
   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
   * Called by minus, plus and times.
   */


  function normalise(n, c, e) {
    var i = 1,
        j = c.length; // Remove trailing zeros.

    for (; !c[--j]; c.pop()); // Calculate the base 10 exponent. First get the number of digits of c[0].


    for (j = c[0]; j >= 10; j /= 10, i++); // Overflow?


    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      // Infinity.
      n.c = n.e = null; // Underflow?
    } else if (e < MIN_EXP) {
      // Zero.
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }

    return n;
  } // Handle values that fail the validity test in BigNumber.


  parseNumeric = function () {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function (x, str, isNum, b) {
      var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, ''); // No exception on Infinity or NaN.

      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
          s = s.replace(basePrefix, function (m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
            return !b || b == base ? p1 : m;
          });

          if (b) {
            base = b; // E.g. '1.' to '1', '.1' to '0.1'

            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
          }

          if (str != s) return new BigNumber(s, base);
        } // '[BigNumber Error] Not a number: {n}'
        // '[BigNumber Error] Not a base {b} number: {n}'


        if (BigNumber.DEBUG) {
          throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
        } // NaN


        x.s = null;
      }

      x.c = x.e = null;
    };
  }();
  /*
   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
   * If r is truthy, it is known that there are more digits after the rounding digit.
   */


  function round(x, sd, rm, r) {
    var d,
        i,
        j,
        k,
        n,
        ni,
        rd,
        xc = x.c,
        pows10 = POWS_TEN; // if x is not Infinity or NaN...

    if (xc) {
      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
      // n is a base 1e14 number, the value of the element of array x.c containing rd.
      // ni is the index of n within x.c.
      // d is the number of digits of n.
      // i is the index of rd within n including leading zeros.
      // j is the actual index of rd within n (if < 0, rd is a leading zero).
      out: {
        // Get the number of digits of the first element of xc.
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);

        i = sd - d; // If the rounding digit is in the first element of xc...

        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0]; // Get the rounding digit at index j of n.

          rd = n / pows10[d - j - 1] % 10 | 0;
        } else {
          ni = mathceil((i + 1) / LOG_BASE);

          if (ni >= xc.length) {
            if (r) {
              // Needed by sqrt.
              for (; xc.length <= ni; xc.push(0));

              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni]; // Get the number of digits of n.

            for (d = 1; k >= 10; k /= 10, d++); // Get the index of rd within n.


            i %= LOG_BASE; // Get the index of rd within n, adjusted for leading zeros.
            // The number of leading zeros of n is given by LOG_BASE - d.

            j = i - LOG_BASE + d; // Get the rounding digit at index j of n.

            rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
          }
        }

        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));

        if (sd < 1 || !xc[0]) {
          xc.length = 0;

          if (r) {
            // Convert sd to decimal places.
            sd -= x.e + 1; // 1, 0.1, 0.01, 0.001, 0.0001 etc.

            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            // Zero.
            xc[0] = x.e = 0;
          }

          return x;
        } // Remove excess digits.


        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i]; // E.g. 56700 becomes 56000 if 7 is the rounding digit.
          // j > 0 means i > number of leading zeros of n.

          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        } // Round up?


        if (r) {
          for (;;) {
            // If the digit to be rounded up is in the first element of xc...
            if (ni == 0) {
              // i will be the length of xc[0] before k is added.
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);

              j = xc[0] += k;

              for (k = 1; j >= 10; j /= 10, k++); // if i != k the length has increased.


              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }

              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        } // Remove trailing zeros.


        for (i = xc.length; xc[--i] === 0; xc.pop());
      } // Overflow? Infinity.


      if (x.e > MAX_EXP) {
        x.c = x.e = null; // Underflow? Zero.
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }

    return x;
  }

  function valueOf(n) {
    var str,
        e = n.e;
    if (e === null) return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0');
    return n.s < 0 ? '-' + str : str;
  } // PROTOTYPE/INSTANCE METHODS

  /*
   * Return a new BigNumber whose value is the absolute value of this BigNumber.
   */


  P.absoluteValue = P.abs = function () {
    var x = new BigNumber(this);
    if (x.s < 0) x.s = 1;
    return x;
  };
  /*
   * Return
   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
   *   0 if they have the same value,
   *   or null if the value of either is NaN.
   */


  P.comparedTo = function (y, b) {
    return compare(this, new BigNumber(y, b));
  };
  /*
   * If dp is undefined or null or true or false, return the number of decimal places of the
   * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
   *
   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */


  P.decimalPlaces = P.dp = function (dp, rm) {
    var c,
        n,
        v,
        x = this;

    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
      return round(new BigNumber(x), dp + x.e + 1, rm);
    }

    if (!(c = x.c)) return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE; // Subtract the number of trailing zeros of the last number.

    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
    if (n < 0) n = 0;
    return n;
  };
  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */


  P.dividedBy = P.div = function (y, b) {
    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  /*
   * Return a new BigNumber whose value is the integer part of dividing the value of this
   * BigNumber by the value of BigNumber(y, b).
   */


  P.dividedToIntegerBy = P.idiv = function (y, b) {
    return div(this, new BigNumber(y, b), 0, 1);
  };
  /*
   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
   *
   * If m is present, return the result modulo m.
   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
   *
   * The modular power operation works efficiently when x, n, and m are integers, otherwise it
   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
   *
   * n {number|string|BigNumber} The exponent. An integer.
   * [m] {number|string|BigNumber} The modulus.
   *
   * '[BigNumber Error] Exponent not an integer: {n}'
   */


  P.exponentiatedBy = P.pow = function (n, m) {
    var half,
        isModExp,
        i,
        k,
        more,
        nIsBig,
        nIsNeg,
        nIsOdd,
        y,
        x = this;
    n = new BigNumber(n); // Allow NaN and Infinity, but not other non-integers.

    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
    }

    if (m != null) m = new BigNumber(m); // Exponent of MAX_SAFE_INTEGER is 15.

    nIsBig = n.e > 14; // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.

    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      // The sign of the result of pow when x is negative depends on the evenness of n.
      // If +n overflows to Infinity, the evenness of n would be not be known.
      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }

    nIsNeg = n.s < 0;

    if (m) {
      // x % m returns NaN if abs(m) is zero, or m is NaN.
      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp) x = x.mod(m); // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 // [1, 240000000]
    ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 // [80000000000000]  [99999750000000]
    : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      // If x is negative and n is odd, k = -0, else k = 0.
      k = x.s < 0 && isOdd(n) ? -0 : 0; // If x >= 1, k = Infinity.

      if (x.e > -1) k = 1 / k; // If n is negative return 0, else return Infinity.

      return new BigNumber(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      // Truncating each coefficient array to a length of k after each multiplication
      // equates to truncating significant digits to POW_PRECISION + [28, 41],
      // i.e. there will be a minimum of 28 guard digits retained.
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }

    if (nIsBig) {
      half = new BigNumber(0.5);
      if (nIsNeg) n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }

    y = new BigNumber(ONE); // Performs 54 loop iterations for n of 9007199254740991.

    for (;;) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;

        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
        }
      }

      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);

        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }

      x = x.times(x);

      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
      }
    }

    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  /*
   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
   */


  P.integerValue = function (rm) {
    var n = new BigNumber(this);
    if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  /*
   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
   * otherwise return false.
   */


  P.isEqualTo = P.eq = function (y, b) {
    return compare(this, new BigNumber(y, b)) === 0;
  };
  /*
   * Return true if the value of this BigNumber is a finite number, otherwise return false.
   */


  P.isFinite = function () {
    return !!this.c;
  };
  /*
   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
   * otherwise return false.
   */


  P.isGreaterThan = P.gt = function (y, b) {
    return compare(this, new BigNumber(y, b)) > 0;
  };
  /*
   * Return true if the value of this BigNumber is greater than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */


  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
  };
  /*
   * Return true if the value of this BigNumber is an integer, otherwise return false.
   */


  P.isInteger = function () {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  /*
   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
   * otherwise return false.
   */


  P.isLessThan = P.lt = function (y, b) {
    return compare(this, new BigNumber(y, b)) < 0;
  };
  /*
   * Return true if the value of this BigNumber is less than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */


  P.isLessThanOrEqualTo = P.lte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
  };
  /*
   * Return true if the value of this BigNumber is NaN, otherwise return false.
   */


  P.isNaN = function () {
    return !this.s;
  };
  /*
   * Return true if the value of this BigNumber is negative, otherwise return false.
   */


  P.isNegative = function () {
    return this.s < 0;
  };
  /*
   * Return true if the value of this BigNumber is positive, otherwise return false.
   */


  P.isPositive = function () {
    return this.s > 0;
  };
  /*
   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
   */


  P.isZero = function () {
    return !!this.c && this.c[0] == 0;
  };
  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber minus the value of
   * BigNumber(y, b).
   */


  P.minus = function (y, b) {
    var i,
        j,
        t,
        xLTy,
        x = this,
        a = x.s;
    y = new BigNumber(y, b);
    b = y.s; // Either NaN?

    if (!a || !b) return new BigNumber(NaN); // Signs differ?

    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }

    var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

    if (!xe || !ye) {
      // Either Infinity?
      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN); // Either zero?

      if (!xc[0] || !yc[0]) {
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
        ROUNDING_MODE == 3 ? -0 : 0);
      }
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice(); // Determine which is the bigger number.

    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }

      t.reverse(); // Prepend zeros to equalise exponents.

      for (b = a; b--; t.push(0));

      t.reverse();
    } else {
      // Exponents equal. Check digit by digit.
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    } // x < y? Point xc to the array of the bigger number.


    if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;
    b = (j = yc.length) - (i = xc.length); // Append zeros to xc if shorter.
    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.

    if (b > 0) for (; b--; xc[i++] = 0);
    b = BASE - 1; // Subtract yc from xc.

    for (; j > a;) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b);

        --xc[i];
        xc[j] += BASE;
      }

      xc[j] -= yc[j];
    } // Remove leading zeros and adjust exponent accordingly.


    for (; xc[0] == 0; xc.splice(0, 1), --ye); // Zero?


    if (!xc[0]) {
      // Following IEEE 754 (2008) 6.3,
      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    } // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
    // for finite x and y.


    return normalise(y, xc, ye);
  };
  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
   * BigNumber(y, b). The result depends on the value of MODULO_MODE.
   */


  P.modulo = P.mod = function (y, b) {
    var q,
        s,
        x = this;
    y = new BigNumber(y, b); // Return NaN if x is Infinity or NaN, or y is NaN or zero.

    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber(NaN); // Return x if y is Infinity or x is zero.
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber(x);
    }

    if (MODULO_MODE == 9) {
      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // r = x - qy    where  0 <= r < abs(y)
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }

    y = x.minus(q.times(y)); // To match JavaScript %, ensure sign of zero is sign of dividend.

    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
    return y;
  };
  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
   * of BigNumber(y, b).
   */


  P.multipliedBy = P.times = function (y, b) {
    var c,
        e,
        i,
        j,
        k,
        m,
        xcL,
        xlo,
        xhi,
        ycL,
        ylo,
        yhi,
        zc,
        base,
        sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c; // Either NaN, Infinity or 0?

    if (!xc || !yc || !xc[0] || !yc[0]) {
      // Return NaN if either is NaN, or one is 0 and the other is Infinity.
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s; // Return Infinity if either is Infinity.

        if (!xc || !yc) {
          y.c = y.e = null; // Return 0 if either is 0.
        } else {
          y.c = [0];
          y.e = 0;
        }
      }

      return y;
    }

    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length; // Ensure xc points to longer array and xcL to its length.

    if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i; // Initialise the result array with zeros.

    for (i = xcL + ycL, zc = []; i--; zc.push(0));

    base = BASE;
    sqrtBase = SQRT_BASE;

    for (i = ycL; --i >= 0;) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;

      for (k = xcL, j = i + k; j > i;) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }

      zc[j] = c;
    }

    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }

    return normalise(y, zc, e);
  };
  /*
   * Return a new BigNumber whose value is the value of this BigNumber negated,
   * i.e. multiplied by -1.
   */


  P.negated = function () {
    var x = new BigNumber(this);
    x.s = -x.s || null;
    return x;
  };
  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber plus the value of
   * BigNumber(y, b).
   */


  P.plus = function (y, b) {
    var t,
        x = this,
        a = x.s;
    y = new BigNumber(y, b);
    b = y.s; // Either NaN?

    if (!a || !b) return new BigNumber(NaN); // Signs differ?

    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }

    var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

    if (!xe || !ye) {
      // Return Infinity if either Infinity.
      if (!xc || !yc) return new BigNumber(a / 0); // Either zero?
      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.

      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice(); // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.

    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }

      t.reverse();

      for (; a--; t.push(0));

      t.reverse();
    }

    a = xc.length;
    b = yc.length; // Point xc to the longer array, and b to the shorter length.

    if (a - b < 0) t = yc, yc = xc, xc = t, b = a; // Only start adding at yc.length - 1 as the further digits of xc can be ignored.

    for (a = 0; b;) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }

    if (a) {
      xc = [a].concat(xc);
      ++ye;
    } // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    // ye = MAX_EXP + 1 possible


    return normalise(y, xc, ye);
  };
  /*
   * If sd is undefined or null or true or false, return the number of significant digits of
   * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
   * If sd is true include integer-part trailing zeros in the count.
   *
   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
   *                     boolean: whether to count integer-part trailing zeros: true or false.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */


  P.precision = P.sd = function (sd, rm) {
    var c,
        n,
        v,
        x = this;

    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
      return round(new BigNumber(x), sd, rm);
    }

    if (!(c = x.c)) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;

    if (v = c[v]) {
      // Subtract the number of trailing zeros of the last element.
      for (; v % 10 == 0; v /= 10, n--); // Add the number of digits of the first element.


      for (v = c[0]; v >= 10; v /= 10, n++);
    }

    if (sd && x.e + 1 > n) n = x.e + 1;
    return n;
  };
  /*
   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
   *
   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
   */


  P.shiftedBy = function (k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times('1e' + k);
  };
  /*
   *  sqrt(-n) =  N
   *  sqrt(N) =  N
   *  sqrt(-I) =  N
   *  sqrt(I) =  I
   *  sqrt(0) =  0
   *  sqrt(-0) = -0
   *
   * Return a new BigNumber whose value is the square root of the value of this BigNumber,
   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */


  P.squareRoot = P.sqrt = function () {
    var m,
        n,
        r,
        rep,
        t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5'); // Negative/NaN/Infinity/zero?

    if (s !== 1 || !c || !c[0]) {
      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    } // Initial estimate.


    s = Math.sqrt(+valueOf(x)); // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.

    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new BigNumber(n);
    } else {
      r = new BigNumber(s + '');
    } // Check for zero.
    // r could be zero if MIN_EXP is changed after the this value was created.
    // This would cause a division by zero (x/t) and hence Infinity below, which would cause
    // coeffToString to throw.


    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3) s = 0; // Newton-Raphson iteration.

      for (;;) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));

        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          // The exponent of r may here be one less than the final result exponent,
          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
          // are indexed correctly.
          if (r.e < e) --s;
          n = n.slice(s - 3, s + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
          // iteration.

          if (n == '9999' || !rep && n == '4999') {
            // On the first iteration only, check to see if rounding up gives the
            // exact result as the nines may infinitely repeat.
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);

              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }

            dp += 4;
            s += 4;
            rep = 1;
          } else {
            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
            // result. If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
              // Truncate to the first rounding digit.
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }

            break;
          }
        }
      }
    }

    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  /*
   * Return a string representing the value of this BigNumber in exponential notation and
   * rounded using ROUNDING_MODE to dp fixed decimal places.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */


  P.toExponential = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }

    return format(this, dp, rm, 1);
  };
  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounding
   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
   * but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */


  P.toFixed = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }

    return format(this, dp, rm);
  };
  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounded
   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
   * of the format or FORMAT object (see BigNumber.set).
   *
   * The formatting object may contain some or all of the properties shown below.
   *
   * FORMAT = {
   *   prefix: '',
   *   groupSize: 3,
   *   secondaryGroupSize: 0,
   *   groupSeparator: ',',
   *   decimalSeparator: '.',
   *   fractionGroupSize: 0,
   *   fractionGroupSeparator: '\xA0',      // non-breaking space
   *   suffix: ''
   * };
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   * [format] {object} Formatting options. See FORMAT pbject above.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   * '[BigNumber Error] Argument not an object: {format}'
   */


  P.toFormat = function (dp, rm, format) {
    var str,
        x = this;

    if (format == null) {
      if (dp != null && rm && typeof rm == 'object') {
        format = rm;
        rm = null;
      } else if (dp && typeof dp == 'object') {
        format = dp;
        dp = rm = null;
      } else {
        format = FORMAT;
      }
    } else if (typeof format != 'object') {
      throw Error(bignumberError + 'Argument not an object: ' + format);
    }

    str = x.toFixed(dp, rm);

    if (x.c) {
      var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;
      if (g2) i = g1, g1 = g2, g2 = i, len -= i;

      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);

        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);

        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = '-' + intPart;
      }

      str = fractionPart ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'), '$&' + (format.fractionGroupSeparator || '')) : fractionPart) : intPart;
    }

    return (format.prefix || '') + str + (format.suffix || '');
  };
  /*
   * Return an array of two BigNumbers representing the value of this BigNumber as a simple
   * fraction with an integer numerator and an integer denominator.
   * The denominator will be a positive non-zero value less than or equal to the specified
   * maximum denominator. If a maximum denominator is not specified, the denominator will be
   * the lowest value necessary to represent the number exactly.
   *
   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
   *
   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
   */


  P.toFraction = function (md) {
    var d,
        d0,
        d1,
        d2,
        e,
        exp,
        n,
        n0,
        n1,
        q,
        r,
        s,
        x = this,
        xc = x.c;

    if (md != null) {
      n = new BigNumber(md); // Throw if md is less than one or is not an integer, unless it is Infinity.

      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error(bignumberError + 'Argument ' + (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
      }
    }

    if (!xc) return new BigNumber(x);
    d = new BigNumber(ONE);
    n1 = d0 = new BigNumber(ONE);
    d1 = n0 = new BigNumber(ONE);
    s = coeffToString(xc); // Determine initial denominator.
    // d is a power of 10 and the minimum max denominator that specifies the value exactly.

    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber(s); // n0 = d1 = 0

    n0.c[0] = 0;

    for (;;) {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }

    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2; // Determine which fraction is closer to x, n0/d0 or n1/d1

    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  /*
   * Return the value of this BigNumber converted to a number primitive.
   */


  P.toNumber = function () {
    return +valueOf(this);
  };
  /*
   * Return a string representing the value of this BigNumber rounded to sd significant digits
   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
   * necessary to represent the integer part of the value in fixed-point notation, then use
   * exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */


  P.toPrecision = function (sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  /*
   * Return a string representing the value of this BigNumber in base b, or base 10 if b is
   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
   * TO_EXP_NEG, return exponential notation.
   *
   * [b] {number} Integer, 2 to ALPHABET.length inclusive.
   *
   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
   */


  P.toString = function (b) {
    var str,
        n = this,
        s = n.s,
        e = n.e; // Infinity or NaN?

    if (e === null) {
      if (s) {
        str = 'Infinity';
        if (s < 0) str = '-' + str;
      } else {
        str = 'NaN';
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, '0');
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, '0');
      } else {
        intCheck(b, 2, ALPHABET.length, 'Base');
        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
      }

      if (s < 0 && n.c[0]) str = '-' + str;
    }

    return str;
  };
  /*
   * Return as toString, but do not accept a base argument, and include the minus sign for
   * negative zero.
   */


  P.valueOf = P.toJSON = function () {
    return valueOf(this);
  };

  P._isBigNumber = true;
  P[Symbol.toStringTag] = 'BigNumber'; // Node.js v10.12.0+

  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;
  if (configObject != null) BigNumber.set(configObject);
  return BigNumber;
} // PRIVATE HELPER FUNCTIONS
// These functions don't need access to variables,
// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
} // Return a coefficient array as a string of base 10 digits.


function coeffToString(a) {
  var s,
      z,
      i = 1,
      j = a.length,
      r = a[0] + '';

  for (; i < j;) {
    s = a[i++] + '';
    z = LOG_BASE - s.length;

    for (; z--; s = '0' + s);

    r += s;
  } // Determine trailing zeros.


  for (j = r.length; r.charCodeAt(--j) === 48;);

  return r.slice(0, j + 1 || 1);
} // Compare the value of BigNumbers x and y.


function compare(x, y) {
  var a,
      b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e; // Either NaN?

  if (!i || !j) return null;
  a = xc && !xc[0];
  b = yc && !yc[0]; // Either zero?

  if (a || b) return a ? b ? 0 : -j : i; // Signs differ?

  if (i != j) return i;
  a = i < 0;
  b = k == l; // Either Infinity?

  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1; // Compare exponents.

  if (!b) return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l; // Compare digit by digit.

  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1; // Compare lengths.


  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
/*
 * Check that n is a primitive number, an integer, and in range, otherwise throw.
 */


function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ? n < min || n > max ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n));
  }
} // Assumes finite n.


function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}

function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e;
}

function toFixedPoint(str, e, z) {
  var len, zs; // Negative exponent?

  if (e < 0) {
    // Prepend zeros.
    for (zs = z + '.'; ++e; zs += z);

    str = zs + str; // Positive exponent
  } else {
    len = str.length; // Append zeros.

    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z);

      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + '.' + str.slice(e);
    }
  }

  return str;
} // EXPORT


var BigNumber = clone();

var _excluded$1 = ["value", "enforcePrecision"];
var DEFAULT_PRECISION = 2;
var DEFAULT_DELIMITER = ",";
var DEFAULT_SEPARATOR = "\xA0";
var Number$1 = function Number(_ref) {
  var value = _ref.value,
      _ref$enforcePrecision = _ref.enforcePrecision,
      enforcePrecision = _ref$enforcePrecision === void 0 ? true : _ref$enforcePrecision,
      options = _objectWithoutProperties$1(_ref, _excluded$1);

  var instance = new BigNumber(value);
  var format = {
    groupSize: 3
  };
  var precision = options.precision == null ? DEFAULT_PRECISION : options.precision;
  format.decimalSeparator = options.delimiter == null ? DEFAULT_DELIMITER : options.delimiter;
  format.groupSeparator = options.separator == null ? DEFAULT_SEPARATOR : options.separator;
  var string = instance.toFormat(precision, undefined, format);
  return enforcePrecision ? string : string.replace(new RegExp("(\\".concat(DEFAULT_DELIMITER, "\\d+)0+")), "$1");
};

var _excluded = ["money", "precision"];

var Money = function Money(_ref) {
  var _ref$money = _slicedToArray$2(_ref.money, 2),
      amount = _ref$money[0],
      currency = _ref$money[1],
      _ref$precision = _ref.precision,
      precision = _ref$precision === void 0 ? 2 : _ref$precision,
      options = _objectWithoutProperties$1(_ref, _excluded);

  return /*#__PURE__*/React.createElement(Fragment, null, /*#__PURE__*/React.createElement(Number$1, _extends$c({
    value: amount
  }, options, {
    precision: precision
  })), " ", currency);
};

Money.build = function (amount, currency) {
  return /*#__PURE__*/React.createElement(Money, {
    money: [amount, currency]
  });
};

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$2.apply(this, arguments);
}

function _arrayLikeToArray$1$3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$6(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1$3(arr);
}

function _iterableToArray$6(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$1$3(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$3(o, minLen);
}

function _nonIterableSpread$6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$6(arr) {
  return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$1$3(arr) || _nonIterableSpread$6();
}

function _classCallCheck$e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$e(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$e(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$e(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$e(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$e(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$e(o, p) {
  _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$e(o, p);
}

function _inherits$e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$e(subClass, superClass);
}

function _typeof$e(obj) {
  "@babel/helpers - typeof";

  return _typeof$e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$e(obj);
}

function _possibleConstructorReturn$e(self, call) {
  if (call && (_typeof$e(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$e(self);
}

function _getPrototypeOf$e(o) {
  _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$e(o);
}

function _defineProperty$e(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$2$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2$1(Object(source), !0).forEach(function (key) {
      _defineProperty$e(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$4$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$e(this, result);
  };
}

function _isNativeReflectConstruct$4$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Checkbox = /*#__PURE__*/function (_Component) {
  _inherits$e(Checkbox, _Component);

  var _super = _createSuper$4$1(Checkbox);

  function Checkbox(props) {
    var _this;

    _classCallCheck$e(this, Checkbox);

    _this = _super.call(this, props);
    _this.state = {
      focused: false
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized$e(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$e(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$e(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$e(_this));
    _this.inputRef = /*#__PURE__*/createRef(_this.props.inputRef);
    return _this;
  }

  _createClass$e(Checkbox, [{
    key: "onClick",
    value: function onClick(e) {
      if (!this.props.disabled && !this.props.readOnly && this.props.onChange) {
        var value = this.isChecked() ? this.props.falseValue : this.props.trueValue;
        this.props.onChange({
          originalEvent: e,
          value: this.props.value,
          checked: value,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            type: 'checkbox',
            name: this.props.name,
            id: this.props.id,
            value: this.props.value,
            checked: value
          }
        });
        this.inputRef.current.checked = !this.isChecked();
        this.inputRef.current.focus();
        e.preventDefault();
      }
    }
  }, {
    key: "updateInputRef",
    value: function updateInputRef() {
      var ref = this.props.inputRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.inputRef.current);
        } else {
          ref.current = this.inputRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateInputRef();

      if (this.props.tooltip) {
        this.renderTooltip();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this.inputRef.current.checked = this.isChecked();

      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$2$1({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }
    }
  }, {
    key: "onFocus",
    value: function onFocus() {
      this.setState({
        focused: true
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        focused: false
      });
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (event.key === 'Enter') {
        this.onClick(event);
        event.preventDefault();
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.element,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "isChecked",
    value: function isChecked() {
      return this.props.checked === this.props.trueValue;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var checked = this.isChecked();
      var containerClass = classNames('p-checkbox p-component', {
        'p-checkbox-checked': checked,
        'p-checkbox-disabled': this.props.disabled,
        'p-checkbox-focused': this.state.focused
      }, this.props.className);
      var boxClass = classNames('p-checkbox-box', {
        'p-highlight': checked,
        'p-disabled': this.props.disabled,
        'p-focus': this.state.focused
      });
      var icon = checked && this.props.icon;
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this2.element = el;
        },
        id: this.props.id,
        className: containerClass,
        style: this.props.style,
        onClick: this.onClick,
        onContextMenu: this.props.onContextMenu,
        onMouseDown: this.props.onMouseDown
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-hidden-accessible"
      }, /*#__PURE__*/React.createElement("input", {
        ref: this.inputRef,
        type: "checkbox",
        "aria-labelledby": this.props.ariaLabelledBy,
        id: this.props.inputId,
        name: this.props.name,
        tabIndex: this.props.tabIndex,
        defaultChecked: checked,
        onKeyDown: this.onKeyDown,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        disabled: this.props.disabled,
        readOnly: this.props.readOnly,
        required: this.props.required
      })), /*#__PURE__*/React.createElement("div", {
        className: boxClass,
        ref: function ref(el) {
          return _this2.box = el;
        },
        role: "checkbox",
        "aria-checked": checked
      }, IconUtils.getJSXIcon(icon, {
        className: 'p-checkbox-icon p-c'
      }, {
        props: this.props,
        checked: checked
      })));
    }
  }]);

  return Checkbox;
}(Component);

_defineProperty$e(Checkbox, "defaultProps", {
  id: null,
  inputRef: null,
  inputId: null,
  value: null,
  name: null,
  checked: false,
  trueValue: true,
  falseValue: false,
  style: null,
  className: null,
  disabled: false,
  required: false,
  readOnly: false,
  tabIndex: null,
  icon: 'pi pi-check',
  tooltip: null,
  tooltipOptions: null,
  ariaLabelledBy: null,
  onChange: null,
  onMouseDown: null,
  onContextMenu: null
});

function _createSuper$3$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$e(this, result);
  };
}

function _isNativeReflectConstruct$3$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var MultiSelectHeader = /*#__PURE__*/function (_Component) {
  _inherits$e(MultiSelectHeader, _Component);

  var _super = _createSuper$3$1(MultiSelectHeader);

  function MultiSelectHeader(props) {
    var _this;

    _classCallCheck$e(this, MultiSelectHeader);

    _this = _super.call(this, props);
    _this.onFilter = _this.onFilter.bind(_assertThisInitialized$e(_this));
    _this.onSelectAll = _this.onSelectAll.bind(_assertThisInitialized$e(_this));
    return _this;
  }

  _createClass$e(MultiSelectHeader, [{
    key: "onFilter",
    value: function onFilter(event) {
      if (this.props.onFilter) {
        this.props.onFilter({
          originalEvent: event,
          query: event.target.value
        });
      }
    }
  }, {
    key: "onSelectAll",
    value: function onSelectAll(event) {
      if (this.props.onSelectAll) {
        this.props.onSelectAll({
          originalEvent: event,
          checked: this.props.selectAll
        });
      }
    }
  }, {
    key: "renderFilterElement",
    value: function renderFilterElement() {
      if (this.props.filter) {
        return /*#__PURE__*/React.createElement("div", {
          className: "p-multiselect-filter-container"
        }, /*#__PURE__*/React.createElement(InputText$1, {
          type: "text",
          role: "textbox",
          value: this.props.filterValue,
          onChange: this.onFilter,
          className: "p-multiselect-filter",
          placeholder: this.props.filterPlaceholder
        }), /*#__PURE__*/React.createElement("span", {
          className: "p-multiselect-filter-icon pi pi-search"
        }));
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var filterElement = this.renderFilterElement();
      var checkboxElement = this.props.showSelectAll && /*#__PURE__*/React.createElement(Checkbox, {
        checked: this.props.selectAll,
        onChange: this.onSelectAll,
        role: "checkbox",
        "aria-checked": this.props.selectAll
      });
      var closeElement = /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-multiselect-close p-link",
        onClick: this.props.onClose
      }, /*#__PURE__*/React.createElement("span", {
        className: "p-multiselect-close-icon pi pi-times"
      }), /*#__PURE__*/React.createElement(Ripple, null));
      var element = /*#__PURE__*/React.createElement("div", {
        className: "p-multiselect-header"
      }, checkboxElement, filterElement, closeElement);

      if (this.props.template) {
        var defaultOptions = {
          className: 'p-multiselect-header',
          checkboxElement: checkboxElement,
          checked: this.props.selectAll,
          onChange: this.onSelectAll,
          filterElement: filterElement,
          closeElement: closeElement,
          closeElementClassName: 'p-multiselect-close p-link',
          closeIconClassName: 'p-multiselect-close-icon pi pi-times',
          onCloseClick: this.props.onClose,
          element: element,
          props: this.props
        };
        return ObjectUtils.getJSXElement(this.props.template, defaultOptions);
      }

      return element;
    }
  }]);

  return MultiSelectHeader;
}(Component);

function _createSuper$2$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$e(this, result);
  };
}

function _isNativeReflectConstruct$2$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var MultiSelectItem = /*#__PURE__*/function (_Component) {
  _inherits$e(MultiSelectItem, _Component);

  var _super = _createSuper$2$1(MultiSelectItem);

  function MultiSelectItem(props) {
    var _this;

    _classCallCheck$e(this, MultiSelectItem);

    _this = _super.call(this, props);
    _this.onClick = _this.onClick.bind(_assertThisInitialized$e(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$e(_this));
    return _this;
  }

  _createClass$e(MultiSelectItem, [{
    key: "onClick",
    value: function onClick(event) {
      if (this.props.onClick) {
        this.props.onClick({
          originalEvent: event,
          option: this.props.option
        });
      }

      event.preventDefault();
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (this.props.onKeyDown) {
        this.props.onKeyDown({
          originalEvent: event,
          option: this.props.option
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-multiselect-item', {
        'p-highlight': this.props.selected,
        'p-disabled': this.props.disabled
      }, this.props.option.className);
      var checkboxClassName = classNames('p-checkbox-box', {
        'p-highlight': this.props.selected
      });
      var checkboxIcon = classNames('p-checkbox-icon p-c', {
        'pi pi-check': this.props.selected
      });
      var content = this.props.template ? ObjectUtils.getJSXElement(this.props.template, this.props.option) : this.props.label;
      var tabIndex = this.props.disabled ? null : this.props.tabIndex || 0;
      return /*#__PURE__*/React.createElement("li", {
        className: className,
        onClick: this.onClick,
        tabIndex: tabIndex,
        onKeyDown: this.onKeyDown,
        role: "option",
        "aria-selected": this.props.selected
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-checkbox p-component"
      }, /*#__PURE__*/React.createElement("div", {
        className: checkboxClassName
      }, /*#__PURE__*/React.createElement("span", {
        className: checkboxIcon
      }))), /*#__PURE__*/React.createElement("span", null, content), /*#__PURE__*/React.createElement(Ripple, null));
    }
  }]);

  return MultiSelectItem;
}(Component);

_defineProperty$e(MultiSelectItem, "defaultProps", {
  option: null,
  label: null,
  selected: false,
  disabled: false,
  tabIndex: null,
  template: null,
  onClick: null,
  onKeyDown: null
});

function ownKeys$1$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1$2(Object(source), !0).forEach(function (key) {
      _defineProperty$e(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$2(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$1$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$5();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$e(this, result);
  };
}

function _isNativeReflectConstruct$1$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var MultiSelectPanelComponent = /*#__PURE__*/function (_Component) {
  _inherits$e(MultiSelectPanelComponent, _Component);

  var _super = _createSuper$1$5(MultiSelectPanelComponent);

  function MultiSelectPanelComponent(props) {
    var _this;

    _classCallCheck$e(this, MultiSelectPanelComponent);

    _this = _super.call(this, props);
    _this.onEnter = _this.onEnter.bind(_assertThisInitialized$e(_this));
    _this.onFilterInputChange = _this.onFilterInputChange.bind(_assertThisInitialized$e(_this));
    return _this;
  }

  _createClass$e(MultiSelectPanelComponent, [{
    key: "onEnter",
    value: function onEnter() {
      var _this2 = this;

      this.props.onEnter(function () {
        if (_this2.virtualScrollerRef) {
          var selectedIndex = _this2.props.getSelectedOptionIndex();

          if (selectedIndex !== -1) {
            _this2.virtualScrollerRef.scrollToIndex(selectedIndex);
          }
        }
      });
    }
  }, {
    key: "onFilterInputChange",
    value: function onFilterInputChange(event) {
      if (this.virtualScrollerRef) {
        this.virtualScrollerRef.scrollToIndex(0);
      }

      this.props.onFilterInputChange && this.props.onFilterInputChange(event);
    }
  }, {
    key: "isEmptyFilter",
    value: function isEmptyFilter() {
      return !(this.props.visibleOptions && this.props.visibleOptions.length) && this.props.hasFilter();
    }
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      return /*#__PURE__*/React.createElement(MultiSelectHeader, {
        filter: this.props.filter,
        filterValue: this.props.filterValue,
        onFilter: this.onFilterInputChange,
        filterPlaceholder: this.props.filterPlaceholder,
        onClose: this.props.onCloseClick,
        showSelectAll: this.props.showSelectAll,
        selectAll: this.props.isAllSelected(),
        onSelectAll: this.props.onSelectAll,
        template: this.props.panelHeaderTemplate
      });
    }
  }, {
    key: "renderFooter",
    value: function renderFooter() {
      if (this.props.panelFooterTemplate) {
        var content = ObjectUtils.getJSXElement(this.props.panelFooterTemplate, this.props, this.props.onOverlayHide);
        return /*#__PURE__*/React.createElement("div", {
          className: "p-multiselect-footer"
        }, content);
      }

      return null;
    }
  }, {
    key: "renderGroupChildren",
    value: function renderGroupChildren(optionGroup) {
      var _this3 = this;

      var groupChildren = this.props.getOptionGroupChildren(optionGroup);
      return groupChildren.map(function (option, j) {
        var optionLabel = _this3.props.getOptionLabel(option);

        var optionKey = j + '_' + _this3.props.getOptionRenderKey(option);

        var disabled = _this3.props.isOptionDisabled(option);

        var tabIndex = disabled ? null : _this3.props.tabIndex || 0;
        return /*#__PURE__*/React.createElement(MultiSelectItem, {
          key: optionKey,
          label: optionLabel,
          option: option,
          template: _this3.props.itemTemplate,
          selected: _this3.props.isSelected(option),
          onClick: _this3.props.onOptionSelect,
          onKeyDown: _this3.props.onOptionKeyDown,
          tabIndex: tabIndex,
          disabled: disabled
        });
      });
    }
  }, {
    key: "renderEmptyFilter",
    value: function renderEmptyFilter() {
      var emptyFilterMessage = ObjectUtils.getJSXElement(this.props.emptyFilterMessage, this.props) || localeOption('emptyFilterMessage');
      return /*#__PURE__*/React.createElement("li", {
        className: "p-multiselect-empty-message"
      }, emptyFilterMessage);
    }
  }, {
    key: "renderItem",
    value: function renderItem(option, index) {
      if (this.props.optionGroupLabel) {
        var groupContent = this.props.optionGroupTemplate ? ObjectUtils.getJSXElement(this.props.optionGroupTemplate, option, index) : this.props.getOptionGroupLabel(option);
        var groupChildrenContent = this.renderGroupChildren(option);
        var key = index + '_' + this.props.getOptionGroupRenderKey(option);
        return /*#__PURE__*/React.createElement(React.Fragment, {
          key: key
        }, /*#__PURE__*/React.createElement("li", {
          className: "p-multiselect-item-group"
        }, groupContent), groupChildrenContent);
      } else {
        var optionLabel = this.props.getOptionLabel(option);
        var optionKey = index + '_' + this.props.getOptionRenderKey(option);
        var disabled = this.props.isOptionDisabled(option);
        var tabIndex = disabled ? null : this.props.tabIndex || 0;
        return /*#__PURE__*/React.createElement(MultiSelectItem, {
          key: optionKey,
          label: optionLabel,
          option: option,
          template: this.props.itemTemplate,
          selected: this.props.isSelected(option),
          onClick: this.props.onOptionSelect,
          onKeyDown: this.props.onOptionKeyDown,
          tabIndex: tabIndex,
          disabled: disabled
        });
      }
    }
  }, {
    key: "renderItems",
    value: function renderItems() {
      var _this4 = this;

      if (this.props.visibleOptions && this.props.visibleOptions.length) {
        return this.props.visibleOptions.map(function (option, index) {
          return _this4.renderItem(option, index);
        });
      } else if (this.props.hasFilter()) {
        return this.renderEmptyFilter();
      }

      return null;
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this5 = this;

      if (this.props.virtualScrollerOptions) {
        var virtualScrollerProps = _objectSpread$1$2(_objectSpread$1$2({}, this.props.virtualScrollerOptions), {
          style: _objectSpread$1$2(_objectSpread$1$2({}, this.props.virtualScrollerOptions.style), {
            height: this.props.scrollHeight
          }),
          className: classNames('p-multiselect-items-wrapper', this.props.virtualScrollerOptions.className),
          items: this.props.visibleOptions,
          onLazyLoad: function onLazyLoad(event) {
            return _this5.props.virtualScrollerOptions.onLazyLoad(_objectSpread$1$2(_objectSpread$1$2({}, event), {
              filter: _this5.props.filterValue
            }));
          },
          itemTemplate: function itemTemplate(item, options) {
            return item && _this5.renderItem(item, options.index);
          },
          contentTemplate: function contentTemplate(options) {
            var className = classNames('p-multiselect-items p-component', options.className);
            var content = _this5.isEmptyFilter() ? _this5.renderEmptyFilter() : options.children;
            return /*#__PURE__*/React.createElement("ul", {
              ref: options.contentRef,
              className: className,
              role: "listbox",
              "aria-multiselectable": true
            }, content);
          }
        });

        return /*#__PURE__*/React.createElement(VirtualScroller, _extends$2({
          ref: function ref(el) {
            return _this5.virtualScrollerRef = el;
          }
        }, virtualScrollerProps));
      } else {
        var items = this.renderItems();
        return /*#__PURE__*/React.createElement("div", {
          className: "p-multiselect-items-wrapper",
          style: {
            maxHeight: this.props.scrollHeight
          }
        }, /*#__PURE__*/React.createElement("ul", {
          className: "p-multiselect-items p-component",
          role: "listbox",
          "aria-multiselectable": true
        }, items));
      }
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var panelClassName = classNames('p-multiselect-panel p-component', {
        'p-multiselect-limited': !this.props.allowOptionSelect()
      }, this.props.panelClassName);
      var header = this.renderHeader();
      var content = this.renderContent();
      var footer = this.renderFooter();
      return /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: this.props.forwardRef,
        classNames: "p-connected-overlay",
        "in": this.props["in"],
        timeout: {
          enter: 120,
          exit: 100
        },
        options: this.props.transitionOptions,
        unmountOnExit: true,
        onEnter: this.onEnter,
        onEntered: this.props.onEntered,
        onExit: this.props.onExit,
        onExited: this.props.onExited
      }, /*#__PURE__*/React.createElement("div", {
        ref: this.props.forwardRef,
        className: panelClassName,
        style: this.props.panelStyle,
        onClick: this.props.onClick
      }, header, content, footer));
    }
  }, {
    key: "render",
    value: function render() {
      var element = this.renderElement();
      return /*#__PURE__*/React.createElement(Portal, {
        element: element,
        appendTo: this.props.appendTo
      });
    }
  }]);

  return MultiSelectPanelComponent;
}(Component);

var MultiSelectPanel = /*#__PURE__*/React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(MultiSelectPanelComponent, _extends$2({
    forwardRef: ref
  }, props));
});

function ownKeys$9(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$9(Object(source), !0).forEach(function (key) {
      _defineProperty$e(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createForOfIteratorHelper$7(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$b(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$b(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$b(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen);
}

function _arrayLikeToArray$b(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$e(this, result);
  };
}

function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var MultiSelect$1 = /*#__PURE__*/function (_Component) {
  _inherits$e(MultiSelect, _Component);

  var _super = _createSuper$k(MultiSelect);

  function MultiSelect(props) {
    var _this;

    _classCallCheck$e(this, MultiSelect);

    _this = _super.call(this, props);
    _this.state = {
      filter: '',
      focused: false,
      overlayVisible: false
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized$e(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$e(_this));
    _this.onOptionSelect = _this.onOptionSelect.bind(_assertThisInitialized$e(_this));
    _this.onOptionKeyDown = _this.onOptionKeyDown.bind(_assertThisInitialized$e(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$e(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$e(_this));
    _this.onFilterInputChange = _this.onFilterInputChange.bind(_assertThisInitialized$e(_this));
    _this.onCloseClick = _this.onCloseClick.bind(_assertThisInitialized$e(_this));
    _this.onSelectAll = _this.onSelectAll.bind(_assertThisInitialized$e(_this));
    _this.onOverlayEnter = _this.onOverlayEnter.bind(_assertThisInitialized$e(_this));
    _this.onOverlayEntered = _this.onOverlayEntered.bind(_assertThisInitialized$e(_this));
    _this.onOverlayExit = _this.onOverlayExit.bind(_assertThisInitialized$e(_this));
    _this.onOverlayExited = _this.onOverlayExited.bind(_assertThisInitialized$e(_this));
    _this.onPanelClick = _this.onPanelClick.bind(_assertThisInitialized$e(_this));
    _this.getOptionLabel = _this.getOptionLabel.bind(_assertThisInitialized$e(_this));
    _this.getOptionRenderKey = _this.getOptionRenderKey.bind(_assertThisInitialized$e(_this));
    _this.isOptionDisabled = _this.isOptionDisabled.bind(_assertThisInitialized$e(_this));
    _this.getOptionGroupChildren = _this.getOptionGroupChildren.bind(_assertThisInitialized$e(_this));
    _this.getOptionGroupLabel = _this.getOptionGroupLabel.bind(_assertThisInitialized$e(_this));
    _this.getOptionGroupRenderKey = _this.getOptionGroupRenderKey.bind(_assertThisInitialized$e(_this));
    _this.allowOptionSelect = _this.allowOptionSelect.bind(_assertThisInitialized$e(_this));
    _this.isSelected = _this.isSelected.bind(_assertThisInitialized$e(_this));
    _this.isAllSelected = _this.isAllSelected.bind(_assertThisInitialized$e(_this));
    _this.hasFilter = _this.hasFilter.bind(_assertThisInitialized$e(_this));
    _this.getSelectedOptionIndex = _this.getSelectedOptionIndex.bind(_assertThisInitialized$e(_this));
    _this.hide = _this.hide.bind(_assertThisInitialized$e(_this));
    _this.onOptionKeyDown = _this.onOptionKeyDown.bind(_assertThisInitialized$e(_this));
    _this.overlayRef = /*#__PURE__*/createRef();
    _this.inputRef = /*#__PURE__*/createRef(_this.props.inputRef);
    return _this;
  }

  _createClass$e(MultiSelect, [{
    key: "onPanelClick",
    value: function onPanelClick(event) {
      OverlayService.emit('overlay-click', {
        originalEvent: event,
        target: this.container
      });
    }
  }, {
    key: "allowOptionSelect",
    value: function allowOptionSelect() {
      return !this.props.selectionLimit || !this.props.value || this.props.value && this.props.value.length < this.props.selectionLimit;
    }
  }, {
    key: "onOptionSelect",
    value: function onOptionSelect(event) {
      var _this2 = this;

      var originalEvent = event.originalEvent,
          option = event.option;

      if (this.props.disabled || this.isOptionDisabled(option)) {
        return;
      }

      var optionValue = this.getOptionValue(option);
      var isOptionValueUsed = this.isOptionValueUsed(option);
      var selected = this.isSelected(option);
      var allowOptionSelect = this.allowOptionSelect();
      if (selected) this.updateModel(originalEvent, this.props.value.filter(function (val) {
        return !ObjectUtils.equals(isOptionValueUsed ? val : _this2.getOptionValue(val), optionValue, _this2.equalityKey());
      }));else if (allowOptionSelect) this.updateModel(originalEvent, [].concat(_toConsumableArray$6(this.props.value || []), [optionValue]));
    }
  }, {
    key: "onOptionKeyDown",
    value: function onOptionKeyDown(event) {
      var originalEvent = event.originalEvent;
      var listItem = originalEvent.currentTarget;

      switch (originalEvent.which) {
        //down
        case 40:
          var nextItem = this.findNextItem(listItem);

          if (nextItem) {
            nextItem.focus();
          }

          originalEvent.preventDefault();
          break;
        //up

        case 38:
          var prevItem = this.findPrevItem(listItem);

          if (prevItem) {
            prevItem.focus();
          }

          originalEvent.preventDefault();
          break;
        //enter and space

        case 13:
        case 32:
          this.onOptionSelect(event);
          originalEvent.preventDefault();
          break;
        //escape

        case 27:
          this.hide();
          this.inputRef.current.focus();
          break;
      }
    }
  }, {
    key: "findNextItem",
    value: function findNextItem(item) {
      var nextItem = item.nextElementSibling;
      if (nextItem) return DomHandler$1.hasClass(nextItem, 'p-disabled') || DomHandler$1.hasClass(nextItem, 'p-multiselect-item-group') ? this.findNextItem(nextItem) : nextItem;else return null;
    }
  }, {
    key: "findPrevItem",
    value: function findPrevItem(item) {
      var prevItem = item.previousElementSibling;
      if (prevItem) return DomHandler$1.hasClass(prevItem, 'p-disabled') || DomHandler$1.hasClass(prevItem, 'p-multiselect-item-group') ? this.findPrevItem(prevItem) : prevItem;else return null;
    }
  }, {
    key: "onClick",
    value: function onClick(event) {
      if (!this.props.disabled && !this.isPanelClicked(event) && !DomHandler$1.hasClass(event.target, 'p-multiselect-token-icon') && !this.isClearClicked(event)) {
        if (this.state.overlayVisible) {
          this.hide();
        } else {
          this.show();
        }

        this.inputRef.current.focus();
        event.preventDefault();
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      switch (event.which) {
        //down
        case 40:
          if (!this.state.overlayVisible && event.altKey) {
            this.show();
            event.preventDefault();
          }

          break;
        //space

        case 32:
          if (this.state.overlayVisible) this.hide();else this.show();
          event.preventDefault();
          break;
        //escape

        case 27:
          this.hide();
          break;
        //tab

        case 9:
          if (this.state.overlayVisible) {
            var firstFocusableElement = DomHandler$1.getFirstFocusableElement(this.overlayRef.current);

            if (firstFocusableElement) {
              firstFocusableElement.focus();
              event.preventDefault();
            }
          }

          break;
      }
    }
  }, {
    key: "onSelectAll",
    value: function onSelectAll(event) {
      var _this3 = this;

      if (this.props.onSelectAll) {
        this.props.onSelectAll(event);
      } else {
        var value = null;
        var visibleOptions = this.getVisibleOptions();

        if (event.checked) {
          value = [];

          if (visibleOptions) {
            var selectedOptions = visibleOptions.filter(function (option) {
              return _this3.isOptionDisabled(option) && _this3.isSelected(option);
            });
            value = selectedOptions.map(function (option) {
              return _this3.getOptionValue(option);
            });
          }
        } else if (visibleOptions) {
          visibleOptions = visibleOptions.filter(function (option) {
            return !_this3.isOptionDisabled(option);
          });

          if (this.props.optionGroupLabel) {
            value = [];
            visibleOptions.forEach(function (optionGroup) {
              return value = [].concat(_toConsumableArray$6(value), _toConsumableArray$6(_this3.getOptionGroupChildren(optionGroup).filter(function (option) {
                return !_this3.isOptionDisabled(option);
              }).map(function (option) {
                return _this3.getOptionValue(option);
              })));
            });
          } else {
            value = visibleOptions.map(function (option) {
              return _this3.getOptionValue(option);
            });
          }
        }

        this.updateModel(event.originalEvent, value);
      }
    }
  }, {
    key: "updateModel",
    value: function updateModel(event, value) {
      if (this.props.onChange) {
        this.props.onChange({
          originalEvent: event,
          value: value,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: value
          }
        });
      }
    }
  }, {
    key: "onFilterInputChange",
    value: function onFilterInputChange(event) {
      var _this4 = this;

      var filter = event.query;
      this.setState({
        filter: filter
      }, function () {
        if (_this4.props.onFilter) {
          _this4.props.onFilter({
            originalEvent: event,
            filter: filter
          });
        }
      });
    }
  }, {
    key: "resetFilter",
    value: function resetFilter() {
      var _this5 = this;

      var filter = '';
      this.setState({
        filter: filter
      }, function () {
        _this5.props.onFilter && _this5.props.onFilter({
          filter: filter
        });
      });
    }
  }, {
    key: "show",
    value: function show() {
      this.setState({
        overlayVisible: true
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      this.setState({
        overlayVisible: false
      });
    }
  }, {
    key: "onOverlayEnter",
    value: function onOverlayEnter(callback) {
      ZIndexUtils.set('overlay', this.overlayRef.current, PrimeReact.autoZIndex, PrimeReact.zIndex['overlay']);
      this.alignOverlay();
      this.scrollInView();
      callback && callback();
    }
  }, {
    key: "onOverlayEntered",
    value: function onOverlayEntered() {
      this.bindDocumentClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.props.onShow && this.props.onShow();
    }
  }, {
    key: "onOverlayExit",
    value: function onOverlayExit() {
      this.unbindDocumentClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
    }
  }, {
    key: "onOverlayExited",
    value: function onOverlayExited() {
      if (this.props.filter && this.props.resetFilterOnHide) {
        this.resetFilter();
      }

      ZIndexUtils.clear(this.overlayRef.current);
      this.props.onHide && this.props.onHide();
    }
  }, {
    key: "alignOverlay",
    value: function alignOverlay() {
      DomHandler$1.alignOverlay(this.overlayRef.current, this.label.parentElement, this.props.appendTo || PrimeReact.appendTo);
    }
  }, {
    key: "scrollInView",
    value: function scrollInView() {
      var highlightItem = DomHandler$1.findSingle(this.overlayRef.current, 'li.p-highlight');

      if (highlightItem && highlightItem.scrollIntoView) {
        highlightItem.scrollIntoView({
          block: 'nearest',
          inline: 'start'
        });
      }
    }
  }, {
    key: "onCloseClick",
    value: function onCloseClick(event) {
      this.hide();
      this.inputRef.current.focus();
      event.preventDefault();
      event.stopPropagation();
    }
  }, {
    key: "getSelectedOptionIndex",
    value: function getSelectedOptionIndex() {
      if (this.props.value != null && this.props.options) {
        if (this.props.optionGroupLabel) {
          for (var i = 0; i < this.props.options.length; i++) {
            var selectedOptionIndex = this.findOptionIndexInList(this.props.value, this.getOptionGroupChildren(this.props.options[i]));

            if (selectedOptionIndex !== -1) {
              return {
                group: i,
                option: selectedOptionIndex
              };
            }
          }
        } else {
          return this.findOptionIndexInList(this.props.value, this.props.options);
        }
      }

      return -1;
    }
  }, {
    key: "findOptionIndexInList",
    value: function findOptionIndexInList(value, list) {
      var _this6 = this;

      var key = this.equalityKey();
      return list.findIndex(function (item) {
        return value.some(function (val) {
          return ObjectUtils.equals(val, _this6.getOptionValue(item), key);
        });
      });
    }
  }, {
    key: "isSelected",
    value: function isSelected(option) {
      var _this7 = this;

      var selected = false;

      if (this.props.value) {
        var optionValue = this.getOptionValue(option);
        var isOptionValueUsed = this.isOptionValueUsed(option);
        var key = this.equalityKey();
        selected = this.props.value.some(function (val) {
          return ObjectUtils.equals(isOptionValueUsed ? val : _this7.getOptionValue(val), optionValue, key);
        });
      }

      return selected;
    }
  }, {
    key: "getLabelByValue",
    value: function getLabelByValue(val) {
      var option;

      if (this.props.options) {
        if (this.props.optionGroupLabel) {
          var _iterator = _createForOfIteratorHelper$7(this.props.options),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var optionGroup = _step.value;
              option = this.findOptionByValue(val, this.getOptionGroupChildren(optionGroup));

              if (option) {
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } else {
          option = this.findOptionByValue(val, this.props.options);
        }
      }

      return option ? this.getOptionLabel(option) : null;
    }
  }, {
    key: "findOptionByValue",
    value: function findOptionByValue(val, list) {
      var key = this.equalityKey();

      var _iterator2 = _createForOfIteratorHelper$7(list),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var option = _step2.value;
          var optionValue = this.getOptionValue(option);

          if (ObjectUtils.equals(optionValue, val, key)) {
            return option;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return null;
    }
  }, {
    key: "onFocus",
    value: function onFocus(event) {
      var _this8 = this;

      event.persist();
      this.setState({
        focused: true
      }, function () {
        if (_this8.props.onFocus) {
          _this8.props.onFocus(event);
        }
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur(event) {
      var _this9 = this;

      event.persist();
      this.setState({
        focused: false
      }, function () {
        if (_this9.props.onBlur) {
          _this9.props.onBlur(event);
        }
      });
    }
  }, {
    key: "bindDocumentClickListener",
    value: function bindDocumentClickListener() {
      var _this10 = this;

      if (!this.documentClickListener) {
        this.documentClickListener = function (event) {
          if (_this10.state.overlayVisible && _this10.isOutsideClicked(event)) {
            _this10.hide();
          }
        };

        document.addEventListener('click', this.documentClickListener);
      }
    }
  }, {
    key: "bindScrollListener",
    value: function bindScrollListener() {
      var _this11 = this;

      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.container, function () {
          if (_this11.state.overlayVisible) {
            _this11.hide();
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    }
  }, {
    key: "unbindScrollListener",
    value: function unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }
  }, {
    key: "bindResizeListener",
    value: function bindResizeListener() {
      var _this12 = this;

      if (!this.resizeListener) {
        this.resizeListener = function () {
          if (_this12.state.overlayVisible && !DomHandler$1.isTouchDevice()) {
            _this12.hide();
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    }
  }, {
    key: "unbindResizeListener",
    value: function unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    }
  }, {
    key: "isOutsideClicked",
    value: function isOutsideClicked(event) {
      return this.container && !(this.container.isSameNode(event.target) || this.isClearClicked(event) || this.container.contains(event.target) || this.isPanelClicked(event));
    }
  }, {
    key: "isClearClicked",
    value: function isClearClicked(event) {
      return DomHandler$1.hasClass(event.target, 'p-multiselect-clear-icon');
    }
  }, {
    key: "isPanelClicked",
    value: function isPanelClicked(event) {
      return this.overlayRef && this.overlayRef.current && this.overlayRef.current.contains(event.target);
    }
  }, {
    key: "unbindDocumentClickListener",
    value: function unbindDocumentClickListener() {
      if (this.documentClickListener) {
        document.removeEventListener('click', this.documentClickListener);
        this.documentClickListener = null;
      }
    }
  }, {
    key: "updateInputRef",
    value: function updateInputRef() {
      var ref = this.props.inputRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.inputRef.current);
        } else {
          ref.current = this.inputRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateInputRef();

      if (this.props.tooltip) {
        this.renderTooltip();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$9({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }

      if (this.state.overlayVisible && this.hasFilter()) {
        this.alignOverlay();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindDocumentClickListener();
      this.unbindResizeListener();

      if (this.scrollHandler) {
        this.scrollHandler.destroy();
        this.scrollHandler = null;
      }

      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }

      ZIndexUtils.clear(this.overlayRef.current);
    }
  }, {
    key: "hasFilter",
    value: function hasFilter() {
      return this.state.filter && this.state.filter.trim().length > 0;
    }
  }, {
    key: "isAllSelected",
    value: function isAllSelected() {
      var _this13 = this;

      if (this.props.onSelectAll) {
        return this.props.selectAll;
      } else {
        var visibleOptions = this.getVisibleOptions();

        if (ObjectUtils.isEmpty(visibleOptions)) {
          return false;
        }

        visibleOptions = visibleOptions.filter(function (option) {
          return !_this13.isOptionDisabled(option);
        });

        if (this.props.optionGroupLabel) {
          var _iterator3 = _createForOfIteratorHelper$7(visibleOptions),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var optionGroup = _step3.value;
              var visibleOptionsGroupChildren = this.getOptionGroupChildren(optionGroup).filter(function (option) {
                return !_this13.isOptionDisabled(option);
              });

              var _iterator4 = _createForOfIteratorHelper$7(visibleOptionsGroupChildren),
                  _step4;

              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  var option = _step4.value;

                  if (!this.isSelected(option)) {
                    return false;
                  }
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        } else {
          var _iterator5 = _createForOfIteratorHelper$7(visibleOptions),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var _option = _step5.value;

              if (!this.isSelected(_option)) {
                return false;
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      }

      return true;
    }
  }, {
    key: "getOptionLabel",
    value: function getOptionLabel(option) {
      return this.props.optionLabel ? ObjectUtils.resolveFieldData(option, this.props.optionLabel) : option && option['label'] !== undefined ? option['label'] : option;
    }
  }, {
    key: "getOptionValue",
    value: function getOptionValue(option) {
      if (this.props.optionValue) {
        var data = ObjectUtils.resolveFieldData(option, this.props.optionValue);
        return data !== null ? data : option;
      }

      return option && option['value'] !== undefined ? option['value'] : option;
    }
  }, {
    key: "getOptionRenderKey",
    value: function getOptionRenderKey(option) {
      return this.props.dataKey ? ObjectUtils.resolveFieldData(option, this.props.dataKey) : this.getOptionLabel(option);
    }
  }, {
    key: "getOptionGroupRenderKey",
    value: function getOptionGroupRenderKey(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.props.optionGroupLabel);
    }
  }, {
    key: "getOptionGroupLabel",
    value: function getOptionGroupLabel(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.props.optionGroupLabel);
    }
  }, {
    key: "getOptionGroupChildren",
    value: function getOptionGroupChildren(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.props.optionGroupChildren);
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled(option) {
      if (this.props.optionDisabled) {
        return ObjectUtils.isFunction(this.props.optionDisabled) ? this.props.optionDisabled(option) : ObjectUtils.resolveFieldData(option, this.props.optionDisabled);
      }

      return option && option['disabled'] !== undefined ? option['disabled'] : false;
    }
  }, {
    key: "isOptionValueUsed",
    value: function isOptionValueUsed(option) {
      return this.props.optionValue || option && option['value'] !== undefined;
    }
  }, {
    key: "getVisibleOptions",
    value: function getVisibleOptions() {
      if (this.hasFilter()) {
        var filterValue = this.state.filter.trim().toLocaleLowerCase(this.props.filterLocale);
        var searchFields = this.props.filterBy ? this.props.filterBy.split(',') : [this.props.optionLabel || 'label'];

        if (this.props.optionGroupLabel) {
          var filteredGroups = [];

          var _iterator6 = _createForOfIteratorHelper$7(this.props.options),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var optgroup = _step6.value;
              var filteredSubOptions = FilterService.filter(this.getOptionGroupChildren(optgroup), searchFields, filterValue, this.props.filterMatchMode, this.props.filterLocale);

              if (filteredSubOptions && filteredSubOptions.length) {
                filteredGroups.push(_objectSpread$9(_objectSpread$9({}, optgroup), {
                  items: filteredSubOptions
                }));
              }
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }

          return filteredGroups;
        } else {
          return FilterService.filter(this.props.options, searchFields, filterValue, this.props.filterMatchMode, this.props.filterLocale);
        }
      } else {
        return this.props.options;
      }
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return !this.props.value || this.props.value.length === 0;
    }
  }, {
    key: "equalityKey",
    value: function equalityKey() {
      return this.props.optionValue ? null : this.props.dataKey;
    }
  }, {
    key: "checkValidity",
    value: function checkValidity() {
      return this.inputRef.current.checkValidity();
    }
  }, {
    key: "removeChip",
    value: function removeChip(event, item) {
      var key = this.equalityKey();
      var value = this.props.value.filter(function (val) {
        return !ObjectUtils.equals(val, item, key);
      });
      this.updateModel(event, value);
    }
  }, {
    key: "getSelectedItemsLabel",
    value: function getSelectedItemsLabel() {
      var pattern = /{(.*?)}/;

      if (pattern.test(this.props.selectedItemsLabel)) {
        return this.props.selectedItemsLabel.replace(this.props.selectedItemsLabel.match(pattern)[0], this.props.value.length + '');
      }

      return this.props.selectedItemsLabel;
    }
  }, {
    key: "getLabel",
    value: function getLabel() {
      var label;

      if (!this.isEmpty() && !this.props.fixedPlaceholder) {
        if (this.props.maxSelectedLabels && this.props.value.length > this.props.maxSelectedLabels) {
          return this.getSelectedItemsLabel();
        } else {
          label = '';

          for (var i = 0; i < this.props.value.length; i++) {
            if (i !== 0) {
              label += ',';
            }

            label += this.getLabelByValue(this.props.value[i]);
          }

          return label;
        }
      }

      return label;
    }
  }, {
    key: "getLabelContent",
    value: function getLabelContent() {
      var _this14 = this;

      if (this.props.selectedItemTemplate) {
        if (!this.isEmpty()) {
          if (this.props.maxSelectedLabels && this.props.value.length > this.props.maxSelectedLabels) {
            return this.getSelectedItemsLabel();
          } else {
            return this.props.value.map(function (val, index) {
              var item = ObjectUtils.getJSXElement(_this14.props.selectedItemTemplate, val);
              return /*#__PURE__*/React.createElement(React.Fragment, {
                key: index
              }, item);
            });
          }
        } else {
          return ObjectUtils.getJSXElement(this.props.selectedItemTemplate);
        }
      } else {
        if (this.props.display === 'chip' && !this.isEmpty()) {
          var value = this.props.value.slice(0, this.props.maxSelectedLabels || this.props.value.length);
          return value.map(function (val) {
            var label = _this14.getLabelByValue(val);

            return /*#__PURE__*/React.createElement("div", {
              className: "p-multiselect-token",
              key: label
            }, /*#__PURE__*/React.createElement("span", {
              className: "p-multiselect-token-label"
            }, label), !_this14.props.disabled && IconUtils.getJSXIcon(_this14.props.removeIcon, {
              className: 'p-multiselect-token-icon',
              onClick: function onClick(e) {
                return _this14.removeChip(e, val);
              }
            }, {
              props: _this14.props
            }));
          });
        }

        return this.getLabel();
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.container,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "renderClearIcon",
    value: function renderClearIcon() {
      var _this15 = this;

      var empty = this.isEmpty();

      if (!empty && this.props.showClear && !this.props.disabled) {
        return /*#__PURE__*/React.createElement("i", {
          className: "p-multiselect-clear-icon pi pi-times",
          onClick: function onClick(e) {
            return _this15.updateModel(e, null);
          }
        });
      }

      return null;
    }
  }, {
    key: "renderLabel",
    value: function renderLabel() {
      var _this16 = this;

      var empty = this.isEmpty();
      var content = this.getLabelContent();
      var labelClassName = classNames('p-multiselect-label', {
        'p-placeholder': empty && this.props.placeholder,
        'p-multiselect-label-empty': empty && !this.props.placeholder && !this.props.selectedItemTemplate,
        'p-multiselect-items-label': !empty && this.props.display !== 'chip' && this.props.value.length > this.props.maxSelectedLabels
      });
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this16.label = el;
        },
        className: "p-multiselect-label-container"
      }, /*#__PURE__*/React.createElement("div", {
        className: labelClassName
      }, content || this.props.placeholder || 'empty'));
    }
  }, {
    key: "render",
    value: function render() {
      var _this17 = this;

      var className = classNames('p-multiselect p-component p-inputwrapper', {
        'p-multiselect-chip': this.props.display === 'chip',
        'p-disabled': this.props.disabled,
        'p-multiselect-clearable': this.props.showClear && !this.props.disabled,
        'p-focus': this.state.focused,
        'p-inputwrapper-filled': this.props.value && this.props.value.length > 0,
        'p-inputwrapper-focus': this.state.focused || this.state.overlayVisible
      }, this.props.className);
      var visibleOptions = this.getVisibleOptions();
      var label = this.renderLabel();
      var clearIcon = this.renderClearIcon();
      return /*#__PURE__*/React.createElement("div", {
        id: this.props.id,
        className: className,
        onClick: this.onClick,
        ref: function ref(el) {
          return _this17.container = el;
        },
        style: this.props.style
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-hidden-accessible"
      }, /*#__PURE__*/React.createElement("input", {
        ref: this.inputRef,
        id: this.props.inputId,
        name: this.props.name,
        readOnly: true,
        type: "text",
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyDown: this.onKeyDown,
        role: "listbox",
        "aria-haspopup": "listbox",
        "aria-labelledby": this.props.ariaLabelledBy,
        "aria-expanded": this.state.overlayVisible,
        disabled: this.props.disabled,
        tabIndex: this.props.tabIndex
      })), label, clearIcon, /*#__PURE__*/React.createElement("div", {
        className: "p-multiselect-trigger"
      }, IconUtils.getJSXIcon(this.props.dropdownIcon, {
        className: 'p-multiselect-trigger-icon p-c'
      }, {
        props: this.props
      })), /*#__PURE__*/React.createElement(MultiSelectPanel, _extends$2({
        ref: this.overlayRef,
        visibleOptions: visibleOptions
      }, this.props, {
        onClick: this.onPanelClick,
        onOverlayHide: this.hide,
        filterValue: this.state.filter,
        hasFilter: this.hasFilter,
        onFilterInputChange: this.onFilterInputChange,
        onCloseClick: this.onCloseClick,
        onSelectAll: this.onSelectAll,
        getOptionLabel: this.getOptionLabel,
        getOptionRenderKey: this.getOptionRenderKey,
        isOptionDisabled: this.isOptionDisabled,
        getOptionGroupChildren: this.getOptionGroupChildren,
        getOptionGroupLabel: this.getOptionGroupLabel,
        getOptionGroupRenderKey: this.getOptionGroupRenderKey,
        isSelected: this.isSelected,
        getSelectedOptionIndex: this.getSelectedOptionIndex,
        isAllSelected: this.isAllSelected,
        onOptionSelect: this.onOptionSelect,
        allowOptionSelect: this.allowOptionSelect,
        onOptionKeyDown: this.onOptionKeyDown,
        "in": this.state.overlayVisible,
        onEnter: this.onOverlayEnter,
        onEntered: this.onOverlayEntered,
        onExit: this.onOverlayExit,
        onExited: this.onOverlayExited
      })));
    }
  }]);

  return MultiSelect;
}(Component);

_defineProperty$e(MultiSelect$1, "defaultProps", {
  id: null,
  inputRef: null,
  name: null,
  value: null,
  options: null,
  optionLabel: null,
  optionValue: null,
  optionDisabled: null,
  optionGroupLabel: null,
  optionGroupChildren: null,
  optionGroupTemplate: null,
  display: 'comma',
  style: null,
  className: null,
  panelClassName: null,
  panelStyle: null,
  virtualScrollerOptions: null,
  scrollHeight: '200px',
  placeholder: null,
  fixedPlaceholder: false,
  disabled: false,
  showClear: false,
  filter: false,
  filterBy: null,
  filterMatchMode: 'contains',
  filterPlaceholder: null,
  filterLocale: undefined,
  emptyFilterMessage: null,
  resetFilterOnHide: false,
  tabIndex: 0,
  dataKey: null,
  inputId: null,
  appendTo: null,
  tooltip: null,
  tooltipOptions: null,
  maxSelectedLabels: null,
  selectionLimit: null,
  selectedItemsLabel: '{0} items selected',
  ariaLabelledBy: null,
  itemTemplate: null,
  selectedItemTemplate: null,
  panelHeaderTemplate: null,
  panelFooterTemplate: null,
  transitionOptions: null,
  dropdownIcon: 'pi pi-chevron-down',
  removeIcon: 'pi pi-times-circle',
  showSelectAll: true,
  selectAll: false,
  onChange: null,
  onFocus: null,
  onBlur: null,
  onShow: null,
  onHide: null,
  onFilter: null,
  onSelectAll: null
});

var LOCALES_BUTTONS_SET = {
  ru: {
    selectAll: " ",
    clearAll: ""
  },
  en: {
    selectAll: "Select All",
    clearAll: "Clear"
  }
};

var MultiSelect = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var options = _ref.options,
      value = _ref.value,
      onChange = _ref.onChange,
      filter = _ref.filter,
      filterBy = _ref.filterBy,
      className = _ref.className,
      placeholder = _ref.placeholder,
      optionLabel = _ref.optionLabel,
      optionValue = _ref.optionValue,
      optionGroupLabel = _ref.optionGroupLabel,
      optionGroupChildren = _ref.optionGroupChildren,
      inputId = _ref.inputId,
      dropdownIcon = _ref.dropdownIcon,
      maxSelectedLabels = _ref.maxSelectedLabels,
      panelClassName = _ref.panelClassName,
      panelStyle = _ref.panelStyle,
      style = _ref.style,
      selectedItemsLabel = _ref.selectedItemsLabel,
      display = _ref.display,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      dataKey = _ref.dataKey,
      _ref$optionDisabled = _ref.optionDisabled,
      optionDisabled = _ref$optionDisabled === void 0 ? null : _ref$optionDisabled,
      _ref$name = _ref.name,
      name = _ref$name === void 0 ? null : _ref$name,
      _ref$id = _ref.id,
      id = _ref$id === void 0 ? null : _ref$id,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$showClear = _ref.showClear,
      showClear = _ref$showClear === void 0 ? false : _ref$showClear;
  var multiselectRef = useRef(ref);
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);

  var getRef = function getRef() {
    return ref || multiselectRef;
  };

  var handleSelectAll = function handleSelectAll(event) {
    var _getRef, _getRef$current;

    return (_getRef = getRef()) === null || _getRef === void 0 ? void 0 : (_getRef$current = _getRef.current) === null || _getRef$current === void 0 ? void 0 : _getRef$current.onSelectAll(event);
  };

  var handleClearAll = function handleClearAll() {
    var newValue = {
      target: {
        name: name,
        value: [],
        id: id
      }
    };
    onChange(newValue);
  };

  var isOptionDisabled = function isOptionDisabled() {
    if (!optionDisabled) return false;
    var isFunction = optionDisabled instanceof Function;
    return isFunction ? optionDisabled() : optionDisabled;
  };

  var removeIcon = function removeIcon() {
    return isOptionDisabled() ? false : "pi pi-times-circle";
  };

  var renderHeader = function renderHeader() {
    return filter ? null : /*#__PURE__*/React.createElement(React.Fragment, null);
  };

  var renderFooter = function renderFooter() {
    var translations = LOCALES_BUTTONS_SET[locale().locale];

    if (isOptionDisabled()) {
      return null;
    }

    return /*#__PURE__*/React.createElement("div", {
      className: "p-buttonset flex flex-row justify-content-center"
    }, /*#__PURE__*/React.createElement("button", {
      className: "p-button",
      onClick: handleSelectAll
    }, translations.selectAll), /*#__PURE__*/React.createElement("button", {
      className: "p-button",
      onClick: handleClearAll
    }, translations.clearAll));
  };

  return /*#__PURE__*/React.createElement(MultiSelect$1, {
    ref: getRef(),
    options: options,
    optionDisabled: optionDisabled,
    optionLabel: optionLabel,
    optionValue: optionValue,
    optionGroupLabel: optionGroupLabel,
    optionGroupChildren: optionGroupChildren,
    value: value,
    onChange: onChange,
    filter: filter,
    filterBy: filterBy,
    selectAll: false,
    showSelectAll: false,
    panelHeaderTemplate: renderHeader(),
    panelFooterTemplate: renderFooter(),
    className: className,
    placeholder: placeholder,
    inputId: inputId,
    dropdownIcon: dropdownIcon,
    maxSelectedLabels: maxSelectedLabels,
    panelClassName: panelClassName,
    panelStyle: panelStyle,
    style: style,
    name: name,
    id: id,
    disabled: disabled,
    selectedItemsLabel: selectedItemsLabel,
    showClear: showClear,
    display: display,
    removeIcon: removeIcon(),
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    dataKey: dataKey
  });
});

var Pagination = function Pagination(_ref) {
  var page = _ref.page,
      pages = _ref.pages,
      onPageClick = _ref.onPageClick;
  var prevPage = page > 1 ? page - 1 : 1;
  var nextPage = // eslint-disable-next-line no-nested-ternary
  pages ? page < pages ? page + 1 : pages : page + 1;
  var showPrevPage = prevPage > 1;
  var showNextPage = pages ? nextPage < pages : true;
  var showPrevDots = prevPage - 1 > 1;
  var showNextDots = nextPage + 1 < pages;
  var showFirstPage = page !== 1;
  var showLastPage = pages && page !== pages;
  var isTheFirstPage = page === 1;
  var isTheLastPage = page === pages;

  var goToFirst = function goToFirst() {
    return onPageClick(1);
  };

  var goToLast = function goToLast() {
    return onPageClick(pages);
  };

  var goToPrev = function goToPrev() {
    return onPageClick(prevPage);
  };

  var goToNext = function goToNext() {
    return onPageClick(nextPage);
  };

  return /*#__PURE__*/React.createElement("div", {
    className: "p-paginator"
  }, /*#__PURE__*/React.createElement("div", {
    className: "p-paginator-pages"
  }, /*#__PURE__*/React.createElement(Button$1, {
    className: "p-paginator-page",
    disabled: isTheFirstPage,
    icon: "pi pi-angle-left",
    onClick: goToPrev
  }), showFirstPage && /*#__PURE__*/React.createElement(Button$1, {
    className: "p-paginator-page",
    onClick: goToFirst
  }, "1"), showPrevDots && /*#__PURE__*/React.createElement("span", {
    className: "p-paginator-dots"
  }, "..."), showPrevPage && /*#__PURE__*/React.createElement(Button$1, {
    className: "p-paginator-page",
    onClick: goToPrev
  }, prevPage), /*#__PURE__*/React.createElement(Button$1, {
    className: "p-paginator-page p-highlight"
  }, page), showNextPage && /*#__PURE__*/React.createElement(Button$1, {
    className: "p-paginator-page",
    onClick: goToNext
  }, nextPage), showNextDots && /*#__PURE__*/React.createElement("span", {
    className: "p-paginator-dots"
  }, "..."), showLastPage && /*#__PURE__*/React.createElement(Button$1, {
    className: "p-paginator-page",
    onClick: goToLast
  }, pages), /*#__PURE__*/React.createElement(Button$1, {
    className: "p-paginator-page",
    disabled: isTheLastPage,
    icon: "pi pi-angle-right",
    onClick: goToNext
  })));
};

function _arrayLikeToArray$a(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$5(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$a(arr);
}

function _iterableToArray$5(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$a(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$a(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen);
}

function _nonIterableSpread$5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$5(arr) {
  return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$a(arr) || _nonIterableSpread$5();
}

function _classCallCheck$d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$d(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$d(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$d(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$d(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$d(o, p) {
  _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$d(o, p);
}

function _inherits$d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$d(subClass, superClass);
}

function _typeof$d(obj) {
  "@babel/helpers - typeof";

  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$d(obj);
}

function _assertThisInitialized$d(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$d(self, call) {
  if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$d(self);
}

function _getPrototypeOf$d(o) {
  _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$d(o);
}

function _defineProperty$d(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$d(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$d(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$d(this, result);
  };
}

function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var PanelMenuSub = /*#__PURE__*/function (_Component) {
  _inherits$d(PanelMenuSub, _Component);

  var _super = _createSuper$j(PanelMenuSub);

  function PanelMenuSub(props) {
    var _this;

    _classCallCheck$d(this, PanelMenuSub);

    _this = _super.call(this, props);
    _this.state = {
      activeItem: _this.findActiveItem()
    };
    return _this;
  }

  _createClass$d(PanelMenuSub, [{
    key: "onItemClick",
    value: function onItemClick(event, item) {
      if (item.disabled) {
        event.preventDefault();
        return;
      }

      if (!item.url) {
        event.preventDefault();
      }

      if (item.command) {
        item.command({
          originalEvent: event,
          item: item
        });
      }

      var activeItem = this.state.activeItem;
      var active = this.isItemActive(item);

      if (active) {
        item.expanded = false;
        this.setState({
          activeItem: this.props.multiple ? activeItem.filter(function (a_item) {
            return a_item !== item;
          }) : null
        });
      } else {
        if (!this.props.multiple && activeItem) {
          activeItem.expanded = false;
        }

        item.expanded = true;
        this.setState({
          activeItem: this.props.multiple ? [].concat(_toConsumableArray$5(activeItem || []), [item]) : item
        });
      }
    }
  }, {
    key: "findActiveItem",
    value: function findActiveItem() {
      if (this.props.model) {
        if (this.props.multiple) {
          return this.props.model.filter(function (item) {
            return item.expanded;
          });
        } else {
          var activeItem = null;
          this.props.model.forEach(function (item) {
            if (item.expanded) {
              if (!activeItem) activeItem = item;else item.expanded = false;
            }
          });
          return activeItem;
        }
      }

      return null;
    }
  }, {
    key: "isItemActive",
    value: function isItemActive(item) {
      return this.state.activeItem && (this.props.multiple ? this.state.activeItem.indexOf(item) > -1 : this.state.activeItem === item);
    }
  }, {
    key: "renderSeparator",
    value: function renderSeparator(index) {
      return /*#__PURE__*/React.createElement("li", {
        key: 'separator_' + index,
        className: "p-menu-separator"
      });
    }
  }, {
    key: "renderSubmenu",
    value: function renderSubmenu(item, active) {
      var submenuWrapperClassName = classNames('p-toggleable-content', {
        'p-toggleable-content-collapsed': !active
      });
      var submenuContentRef = /*#__PURE__*/React.createRef();

      if (item.items) {
        return /*#__PURE__*/React.createElement(CSSTransition, {
          nodeRef: submenuContentRef,
          classNames: "p-toggleable-content",
          timeout: {
            enter: 1000,
            exit: 450
          },
          "in": active,
          unmountOnExit: true
        }, /*#__PURE__*/React.createElement("div", {
          ref: submenuContentRef,
          className: submenuWrapperClassName
        }, /*#__PURE__*/React.createElement(PanelMenuSub, {
          model: item.items,
          multiple: this.props.multiple
        })));
      }

      return null;
    }
  }, {
    key: "renderMenuitem",
    value: function renderMenuitem(item, index) {
      var _this2 = this;

      var active = this.isItemActive(item);
      var className = classNames('p-menuitem', item.className);
      var linkClassName = classNames('p-menuitem-link', {
        'p-disabled': item.disabled
      });
      var iconClassName = classNames('p-menuitem-icon', item.icon);
      var submenuIconClassName = classNames('p-panelmenu-icon pi pi-fw', {
        'pi-angle-right': !active,
        'pi-angle-down': active
      });
      var icon = item.icon && /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      });
      var label = item.label && /*#__PURE__*/React.createElement("span", {
        className: "p-menuitem-text"
      }, item.label);
      var submenuIcon = item.items && /*#__PURE__*/React.createElement("span", {
        className: submenuIconClassName
      });
      var submenu = this.renderSubmenu(item, active);
      var content = /*#__PURE__*/React.createElement("a", {
        href: item.url || '#',
        className: linkClassName,
        target: item.target,
        onClick: function onClick(event) {
          return _this2.onItemClick(event, item, index);
        },
        role: "menuitem",
        "aria-disabled": item.disabled
      }, submenuIcon, icon, label);

      if (item.template) {
        var defaultContentOptions = {
          onClick: function onClick(event) {
            return _this2.onItemClick(event, item, index);
          },
          className: linkClassName,
          labelClassName: 'p-menuitem-text',
          iconClassName: iconClassName,
          submenuIconClassName: submenuIconClassName,
          element: content,
          props: this.props,
          leaf: !item.items,
          active: active
        };
        content = ObjectUtils.getJSXElement(item.template, item, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement("li", {
        key: item.label + '_' + index,
        className: className,
        style: item.style,
        role: "none"
      }, content, submenu);
    }
  }, {
    key: "renderItem",
    value: function renderItem(item, index) {
      if (item.separator) return this.renderSeparator(index);else return this.renderMenuitem(item, index);
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this3 = this;

      if (this.props.model) {
        return this.props.model.map(function (item, index) {
          return _this3.renderItem(item, index);
        });
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-submenu-list', this.props.className);
      var menu = this.renderMenu();
      return /*#__PURE__*/React.createElement("ul", {
        className: className,
        role: "tree"
      }, menu);
    }
  }]);

  return PanelMenuSub;
}(Component);

_defineProperty$d(PanelMenuSub, "defaultProps", {
  model: null,
  multiple: false
});

var PanelMenu$1 = /*#__PURE__*/function (_Component2) {
  _inherits$d(PanelMenu, _Component2);

  var _super2 = _createSuper$j(PanelMenu);

  function PanelMenu(props) {
    var _this4;

    _classCallCheck$d(this, PanelMenu);

    _this4 = _super2.call(this, props);
    _this4.state = {
      id: props.id,
      activeItem: _this4.findActiveItem()
    };
    return _this4;
  }

  _createClass$d(PanelMenu, [{
    key: "onItemClick",
    value: function onItemClick(event, item) {
      if (item.disabled) {
        event.preventDefault();
        return;
      }

      if (!item.url) {
        event.preventDefault();
      }

      if (item.command) {
        item.command({
          originalEvent: event,
          item: item
        });
      }

      var activeItem = this.state.activeItem;
      var active = this.isItemActive(item);

      if (active) {
        item.expanded = false;
        this.setState({
          activeItem: this.props.multiple ? activeItem.filter(function (a_item) {
            return a_item !== item;
          }) : null
        });
      } else {
        if (!this.props.multiple && activeItem) {
          activeItem.expanded = false;
        }

        item.expanded = true;
        this.setState({
          activeItem: this.props.multiple ? [].concat(_toConsumableArray$5(activeItem || []), [item]) : item
        });
      }
    }
  }, {
    key: "findActiveItem",
    value: function findActiveItem() {
      if (this.props.model) {
        if (this.props.multiple) {
          return this.props.model.filter(function (item) {
            return item.expanded;
          });
        } else {
          var activeItem = null;
          this.props.model.forEach(function (item) {
            if (item.expanded) {
              if (!activeItem) activeItem = item;else item.expanded = false;
            }
          });
          return activeItem;
        }
      }

      return null;
    }
  }, {
    key: "isItemActive",
    value: function isItemActive(item) {
      return this.state.activeItem && (this.props.multiple ? this.state.activeItem.indexOf(item) > -1 : this.state.activeItem === item);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (!this.state.id) {
        this.setState({
          id: UniqueComponentId()
        });
      }
    }
  }, {
    key: "renderPanel",
    value: function renderPanel(item, index) {
      var _this5 = this;

      var active = this.isItemActive(item);
      var className = classNames('p-panelmenu-panel', item.className);
      var headerClassName = classNames('p-component p-panelmenu-header', {
        'p-highlight': active,
        'p-disabled': item.disabled
      });
      var submenuIconClassName = classNames('p-panelmenu-icon pi', {
        'pi-chevron-right': !active,
        ' pi-chevron-down': active
      });
      var iconClassName = classNames('p-menuitem-icon', item.icon);
      var submenuIcon = item.items && /*#__PURE__*/React.createElement("span", {
        className: submenuIconClassName
      });
      var itemIcon = item.icon && /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      });
      var label = item.label && /*#__PURE__*/React.createElement("span", {
        className: "p-menuitem-text"
      }, item.label);
      var contentWrapperClassName = classNames('p-toggleable-content', {
        'p-toggleable-content-collapsed': !active
      });
      var menuContentRef = /*#__PURE__*/React.createRef();
      var content = /*#__PURE__*/React.createElement("a", {
        href: item.url || '#',
        className: "p-panelmenu-header-link",
        onClick: function onClick(e) {
          return _this5.onItemClick(e, item);
        },
        "aria-expanded": active,
        id: this.state.id + '_header',
        "aria-controls": this.state.id + 'content',
        "aria-disabled": item.disabled
      }, submenuIcon, itemIcon, label);

      if (item.template) {
        var defaultContentOptions = {
          onClick: function onClick(event) {
            return _this5.onItemClick(event, item);
          },
          className: 'p-panelmenu-header-link',
          labelClassName: 'p-menuitem-text',
          submenuIconClassName: submenuIconClassName,
          iconClassName: iconClassName,
          element: content,
          props: this.props,
          leaf: !item.items,
          active: active
        };
        content = ObjectUtils.getJSXElement(item.template, item, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement("div", {
        key: item.label + '_' + index,
        className: className,
        style: item.style
      }, /*#__PURE__*/React.createElement("div", {
        className: headerClassName,
        style: item.style
      }, content), /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: menuContentRef,
        classNames: "p-toggleable-content",
        timeout: {
          enter: 1000,
          exit: 450
        },
        "in": active,
        unmountOnExit: true,
        options: this.props.transitionOptions
      }, /*#__PURE__*/React.createElement("div", {
        ref: menuContentRef,
        className: contentWrapperClassName,
        role: "region",
        id: this.state.id + '_content',
        "aria-labelledby": this.state.id + '_header'
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-panelmenu-content"
      }, /*#__PURE__*/React.createElement(PanelMenuSub, {
        model: item.items,
        className: "p-panelmenu-root-submenu",
        multiple: this.props.multiple
      })))));
    }
  }, {
    key: "renderPanels",
    value: function renderPanels() {
      var _this6 = this;

      if (this.props.model) {
        return this.props.model.map(function (item, index) {
          return _this6.renderPanel(item, index);
        });
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-panelmenu p-component', this.props.className);
      var panels = this.renderPanels();
      return /*#__PURE__*/React.createElement("div", {
        id: this.props.id,
        className: className,
        style: this.props.style
      }, panels);
    }
  }]);

  return PanelMenu;
}(Component);

_defineProperty$d(PanelMenu$1, "defaultProps", {
  id: null,
  model: null,
  style: null,
  className: null,
  multiple: false,
  transitionOptions: null
});

var PanelMenu = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      model = _ref.model,
      style = _ref.style,
      className = _ref.className;
  return /*#__PURE__*/React.createElement(PanelMenu$1, {
    ref: ref,
    id: id,
    model: model,
    style: style,
    className: className,
    multiple: true
  });
});

var ProgressBar = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      showValue = _ref.showValue,
      unit = _ref.unit,
      color = _ref.color,
      style = _ref.style,
      className = _ref.className,
      displayValueTemplate = _ref.displayValueTemplate;
  return /*#__PURE__*/React.createElement(ProgressBar$1, {
    ref: ref,
    id: id,
    value: value,
    showValue: showValue,
    unit: unit,
    displayValueTemplate: displayValueTemplate,
    color: color,
    style: style,
    className: className
  });
});

function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$c(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$c(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$c(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$c(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$c(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$c(o, p) {
  _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$c(o, p);
}

function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$c(subClass, superClass);
}

function _typeof$c(obj) {
  "@babel/helpers - typeof";

  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$c(obj);
}

function _possibleConstructorReturn$c(self, call) {
  if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$c(self);
}

function _getPrototypeOf$c(o) {
  _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$c(o);
}

function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$8(Object(source), !0).forEach(function (key) {
      _defineProperty$c(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$c(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$c(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$c(this, result);
  };
}

function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var RadioButton$1 = /*#__PURE__*/function (_Component) {
  _inherits$c(RadioButton, _Component);

  var _super = _createSuper$i(RadioButton);

  function RadioButton(props) {
    var _this;

    _classCallCheck$c(this, RadioButton);

    _this = _super.call(this, props);
    _this.state = {};
    _this.onClick = _this.onClick.bind(_assertThisInitialized$c(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$c(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$c(_this));
    _this.inputRef = /*#__PURE__*/createRef(_this.props.inputRef);
    return _this;
  }

  _createClass$c(RadioButton, [{
    key: "select",
    value: function select(e) {
      this.inputRef.current.checked = true;
      this.onClick(e);
    }
  }, {
    key: "onClick",
    value: function onClick(e) {
      if (!this.props.disabled && this.props.onChange) {
        this.props.onChange({
          originalEvent: e,
          value: this.props.value,
          checked: !this.props.checked,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: this.props.value,
            checked: !this.props.checked
          }
        });
        this.inputRef.current.checked = !this.props.checked;
        this.inputRef.current.focus();
      }
    }
  }, {
    key: "onFocus",
    value: function onFocus() {
      this.setState({
        focused: true
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        focused: false
      });
    }
  }, {
    key: "updateInputRef",
    value: function updateInputRef() {
      var ref = this.props.inputRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.inputRef.current);
        } else {
          ref.current = this.inputRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateInputRef();

      if (this.props.tooltip) {
        this.renderTooltip();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$8({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.element,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      if (this.inputRef && this.inputRef.current) {
        this.inputRef.current.checked = this.props.checked;
      }

      var containerClass = classNames('p-radiobutton p-component', {
        'p-radiobutton-checked': this.props.checked,
        'p-radiobutton-disabled': this.props.disabled,
        'p-radiobutton-focused': this.state.focused
      }, this.props.className);
      var boxClass = classNames('p-radiobutton-box', {
        'p-highlight': this.props.checked,
        'p-disabled': this.props.disabled,
        'p-focus': this.state.focused
      });
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this2.element = el;
        },
        id: this.props.id,
        className: containerClass,
        style: this.props.style,
        onClick: this.onClick
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-hidden-accessible"
      }, /*#__PURE__*/React.createElement("input", {
        ref: this.inputRef,
        id: this.props.inputId,
        type: "radio",
        "aria-labelledby": this.props.ariaLabelledBy,
        name: this.props.name,
        defaultChecked: this.props.checked,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        disabled: this.props.disabled,
        required: this.props.required,
        tabIndex: this.props.tabIndex
      })), /*#__PURE__*/React.createElement("div", {
        className: boxClass,
        ref: function ref(el) {
          _this2.box = el;
        },
        role: "radio",
        "aria-checked": this.props.checked
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-radiobutton-icon"
      })));
    }
  }]);

  return RadioButton;
}(Component);

_defineProperty$c(RadioButton$1, "defaultProps", {
  id: null,
  inputRef: null,
  inputId: null,
  name: null,
  value: null,
  checked: false,
  style: null,
  className: null,
  disabled: false,
  required: false,
  tabIndex: null,
  tooltip: null,
  tooltipOptions: null,
  ariaLabelledBy: null,
  onChange: null
});

var RadioButton = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      inputId = _ref.inputId,
      name = _ref.name,
      value = _ref.value,
      checked = _ref.checked,
      style = _ref.style,
      className = _ref.className,
      disabled = _ref.disabled,
      required = _ref.required,
      tabIndex = _ref.tabIndex,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onChange = _ref.onChange;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(RadioButton$1, {
    ref: ref,
    id: id,
    inputId: inputId,
    name: name,
    value: value,
    checked: checked,
    style: style,
    className: className,
    disabled: disabled,
    required: required,
    tabIndex: tabIndex,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onChange: onChange
  });
});

function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$b(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$b(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$b(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$b(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$b(o, p) {
  _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$b(o, p);
}

function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$b(subClass, superClass);
}

function _typeof$b(obj) {
  "@babel/helpers - typeof";

  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$b(obj);
}

function _assertThisInitialized$b(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$b(self, call) {
  if (call && (_typeof$b(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$b(self);
}

function _getPrototypeOf$b(o) {
  _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$b(o);
}

function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$b(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$b(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$b(this, result);
  };
}

function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Row = /*#__PURE__*/function (_Component) {
  _inherits$b(Row, _Component);

  var _super = _createSuper$h(Row);

  function Row() {
    _classCallCheck$b(this, Row);

    return _super.apply(this, arguments);
  }

  _createClass$b(Row, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/React.createElement("tr", null, this.props.children);
    }
  }]);

  return Row;
}(Component);

_defineProperty$b(Row, "defaultProps", {
  style: null,
  className: null
});

function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$a(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$a(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$a(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$a(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$a(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$a(o, p) {
  _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$a(o, p);
}

function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$a(subClass, superClass);
}

function _typeof$a(obj) {
  "@babel/helpers - typeof";

  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$a(obj);
}

function _possibleConstructorReturn$a(self, call) {
  if (call && (_typeof$a(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$a(self);
}

function _getPrototypeOf$a(o) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$a(o);
}

function _defineProperty$a(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$a(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$a(this, result);
  };
}

function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var ScrollTop$1 = /*#__PURE__*/function (_Component) {
  _inherits$a(ScrollTop, _Component);

  var _super = _createSuper$g(ScrollTop);

  function ScrollTop(props) {
    var _this;

    _classCallCheck$a(this, ScrollTop);

    _this = _super.call(this, props);
    _this.state = {
      visible: false
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized$a(_this));
    _this.onEnter = _this.onEnter.bind(_assertThisInitialized$a(_this));
    _this.onEntered = _this.onEntered.bind(_assertThisInitialized$a(_this));
    _this.onExited = _this.onExited.bind(_assertThisInitialized$a(_this));
    _this.scrollElementRef = /*#__PURE__*/React.createRef();
    return _this;
  }

  _createClass$a(ScrollTop, [{
    key: "onClick",
    value: function onClick() {
      var scrollElement = this.props.target === 'window' ? window : this.helper.parentElement;
      scrollElement.scroll({
        top: 0,
        behavior: this.props.behavior
      });
    }
  }, {
    key: "checkVisibility",
    value: function checkVisibility(scrollY) {
      this.setState({
        visible: scrollY > this.props.threshold
      });
    }
  }, {
    key: "bindParentScrollListener",
    value: function bindParentScrollListener() {
      var _this2 = this;

      this.scrollListener = function () {
        _this2.checkVisibility(_this2.helper.parentElement.scrollTop);
      };

      this.helper.parentElement.addEventListener('scroll', this.scrollListener);
    }
  }, {
    key: "bindDocumentScrollListener",
    value: function bindDocumentScrollListener() {
      var _this3 = this;

      this.scrollListener = function () {
        _this3.checkVisibility(DomHandler$1.getWindowScrollTop());
      };

      window.addEventListener('scroll', this.scrollListener);
    }
  }, {
    key: "unbindParentScrollListener",
    value: function unbindParentScrollListener() {
      if (this.scrollListener) {
        this.helper.parentElement.removeEventListener('scroll', this.scrollListener);
        this.scrollListener = null;
      }
    }
  }, {
    key: "unbindDocumentScrollListener",
    value: function unbindDocumentScrollListener() {
      if (this.scrollListener) {
        window.removeEventListener('scroll', this.scrollListener);
        this.scrollListener = null;
      }
    }
  }, {
    key: "onEnter",
    value: function onEnter() {
      ZIndexUtils.set('overlay', this.scrollElementRef.current, PrimeReact.autoZIndex, PrimeReact.zIndex['overlay']);
    }
  }, {
    key: "onEntered",
    value: function onEntered() {
      this.props.onShow && this.props.onShow();
    }
  }, {
    key: "onExited",
    value: function onExited() {
      ZIndexUtils.clear(this.scrollElementRef.current);
      this.props.onHide && this.props.onHide();
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.target === 'window') this.bindDocumentScrollListener();else if (this.props.target === 'parent') this.bindParentScrollListener();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.props.target === 'window') this.unbindDocumentScrollListener();else if (this.props.target === 'parent') this.unbindParentScrollListener();
      ZIndexUtils.clear(this.scrollElementRef.current);
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var className = classNames('p-scrolltop p-link p-component', {
        'p-scrolltop-sticky': this.props.target !== 'window'
      }, this.props.className);
      var isTargetParent = this.props.target === 'parent';
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: this.scrollElementRef,
        classNames: "p-scrolltop",
        "in": this.state.visible,
        timeout: {
          enter: 150,
          exit: 150
        },
        options: this.props.transitionOptions,
        unmountOnExit: true,
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onExited: this.onExited
      }, /*#__PURE__*/React.createElement("button", {
        ref: this.scrollElementRef,
        type: "button",
        className: className,
        style: this.props.style,
        onClick: this.onClick
      }, IconUtils.getJSXIcon(this.props.icon, {
        className: 'p-scrolltop-icon'
      }, {
        props: this.props
      }), /*#__PURE__*/React.createElement(Ripple, null))), isTargetParent && /*#__PURE__*/React.createElement("span", {
        ref: function ref(el) {
          return _this4.helper = el;
        },
        className: "p-scrolltop-helper"
      }));
    }
  }]);

  return ScrollTop;
}(Component);

_defineProperty$a(ScrollTop$1, "defaultProps", {
  target: 'window',
  threshold: 400,
  icon: 'pi pi-chevron-up',
  behavior: 'smooth',
  className: null,
  style: null,
  transitionOptions: null,
  onShow: null,
  onHide: null
});

var ScrollTop = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var target = _ref.target,
      threshold = _ref.threshold,
      behavior = _ref.behavior,
      onShow = _ref.onShow,
      onHide = _ref.onHide,
      className = _ref.className,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? "large" : _ref$size,
      style = _ref.style;
  var scrollTopClassName = classNames(className, "custom-scrolltop", {
    "custom-scrolltop_small": size === "small"
  });
  return /*#__PURE__*/React.createElement(ScrollTop$1, {
    ref: ref,
    target: target,
    threshold: threshold,
    behavior: behavior,
    className: scrollTopClassName,
    style: style,
    onShow: onShow,
    onHide: onHide,
    icon: "pi pi-arrow-up"
  });
});

function _arrayLikeToArray$1$2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$4(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1$2(arr);
}

function _iterableToArray$4(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$1$2(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$2(o, minLen);
}

function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$4(arr) {
  return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$1$2(arr) || _nonIterableSpread$4();
}

function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$9(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$9(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$9(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$9(o, p) {
  _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$9(o, p);
}

function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$9(subClass, superClass);
}

function _typeof$9(obj) {
  "@babel/helpers - typeof";

  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$9(obj);
}

function _possibleConstructorReturn$9(self, call) {
  if (call && (_typeof$9(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$9(self);
}

function _getPrototypeOf$9(o) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$9(o);
}

function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$1$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$4();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$9(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$9(this, result);
  };
}

function _isNativeReflectConstruct$1$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var SelectButtonItem = /*#__PURE__*/function (_Component) {
  _inherits$9(SelectButtonItem, _Component);

  var _super = _createSuper$1$4(SelectButtonItem);

  function SelectButtonItem(props) {
    var _this;

    _classCallCheck$9(this, SelectButtonItem);

    _this = _super.call(this, props);
    _this.state = {
      focused: false
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized$9(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized$9(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized$9(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$9(_this));
    return _this;
  }

  _createClass$9(SelectButtonItem, [{
    key: "onClick",
    value: function onClick(event) {
      if (this.props.onClick) {
        this.props.onClick({
          originalEvent: event,
          option: this.props.option
        });
      }
    }
  }, {
    key: "onFocus",
    value: function onFocus() {
      this.setState({
        focused: true
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        focused: false
      });
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      var keyCode = event.which;

      if (keyCode === 32 || keyCode === 13) {
        //space and enter
        this.onClick(event);
        event.preventDefault();
      }
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      if (this.props.template) {
        return this.props.template(this.props.option);
      } else {
        return /*#__PURE__*/React.createElement("span", {
          className: "p-button-label p-c"
        }, this.props.label);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-button p-component', {
        'p-highlight': this.props.selected,
        'p-disabled': this.props.disabled,
        'p-focus': this.state.focused
      }, this.props.className);
      var content = this.renderContent();
      return /*#__PURE__*/React.createElement("div", {
        className: className,
        role: "button",
        "aria-label": this.props.label,
        "aria-pressed": this.props.selected,
        "aria-labelledby": this.props.ariaLabelledBy,
        onClick: this.onClick,
        onKeyDown: this.onKeyDown,
        tabIndex: this.props.tabIndex,
        onFocus: this.onFocus,
        onBlur: this.onBlur
      }, content, !this.props.disabled && /*#__PURE__*/React.createElement(Ripple, null));
    }
  }]);

  return SelectButtonItem;
}(Component);

_defineProperty$9(SelectButtonItem, "defaultProps", {
  option: null,
  label: null,
  className: null,
  selected: null,
  tabIndex: null,
  ariaLabelledBy: null,
  template: null,
  onClick: null
});

function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), !0).forEach(function (key) {
      _defineProperty$9(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createForOfIteratorHelper$6(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$9(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$9(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen);
}

function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$9(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$9(this, result);
  };
}

function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var SelectButton$1 = /*#__PURE__*/function (_Component) {
  _inherits$9(SelectButton, _Component);

  var _super = _createSuper$f(SelectButton);

  function SelectButton(props) {
    var _this;

    _classCallCheck$9(this, SelectButton);

    _this = _super.call(this, props);
    _this.onOptionClick = _this.onOptionClick.bind(_assertThisInitialized$9(_this));
    return _this;
  }

  _createClass$9(SelectButton, [{
    key: "onOptionClick",
    value: function onOptionClick(event) {
      var _this2 = this;

      if (this.props.disabled || this.isOptionDisabled(event.option)) {
        return;
      }

      var selected = this.isSelected(event.option);

      if (selected && !this.props.unselectable) {
        return;
      }

      var optionValue = this.getOptionValue(event.option);
      var newValue;

      if (this.props.multiple) {
        var currentValue = this.props.value ? _toConsumableArray$4(this.props.value) : [];
        if (selected) newValue = currentValue.filter(function (val) {
          return !ObjectUtils.equals(val, optionValue, _this2.props.dataKey);
        });else newValue = [].concat(_toConsumableArray$4(currentValue), [optionValue]);
      } else {
        if (selected) newValue = null;else newValue = optionValue;
      }

      if (this.props.onChange) {
        this.props.onChange({
          originalEvent: event.originalEvent,
          value: newValue,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: newValue
          }
        });
      }
    }
  }, {
    key: "getOptionLabel",
    value: function getOptionLabel(option) {
      return this.props.optionLabel ? ObjectUtils.resolveFieldData(option, this.props.optionLabel) : option && option['label'] !== undefined ? option['label'] : option;
    }
  }, {
    key: "getOptionValue",
    value: function getOptionValue(option) {
      return this.props.optionValue ? ObjectUtils.resolveFieldData(option, this.props.optionValue) : option && option['value'] !== undefined ? option['value'] : option;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled(option) {
      if (this.props.optionDisabled) {
        return ObjectUtils.isFunction(this.props.optionDisabled) ? this.props.optionDisabled(option) : ObjectUtils.resolveFieldData(option, this.props.optionDisabled);
      }

      return option && option['disabled'] !== undefined ? option['disabled'] : false;
    }
  }, {
    key: "isSelected",
    value: function isSelected(option) {
      var selected = false;
      var optionValue = this.getOptionValue(option);

      if (this.props.multiple) {
        if (this.props.value && this.props.value.length) {
          var _iterator = _createForOfIteratorHelper$6(this.props.value),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var val = _step.value;

              if (ObjectUtils.equals(val, optionValue, this.props.dataKey)) {
                selected = true;
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      } else {
        selected = ObjectUtils.equals(this.props.value, optionValue, this.props.dataKey);
      }

      return selected;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.tooltip) {
        this.renderTooltip();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread$7({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.element,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "renderItems",
    value: function renderItems() {
      var _this3 = this;

      if (this.props.options && this.props.options.length) {
        return this.props.options.map(function (option, index) {
          var isDisabled = _this3.props.disabled || _this3.isOptionDisabled(option);

          var optionLabel = _this3.getOptionLabel(option);

          var tabIndex = isDisabled ? null : 0;
          return /*#__PURE__*/React.createElement(SelectButtonItem, {
            key: "".concat(optionLabel, "_").concat(index),
            label: optionLabel,
            className: option.className,
            option: option,
            onClick: _this3.onOptionClick,
            template: _this3.props.itemTemplate,
            selected: _this3.isSelected(option),
            tabIndex: tabIndex,
            disabled: isDisabled,
            ariaLabelledBy: _this3.props.ariaLabelledBy
          });
        });
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var className = classNames('p-selectbutton p-buttonset p-component', this.props.className);
      var items = this.renderItems();
      return /*#__PURE__*/React.createElement("div", {
        id: this.props.id,
        ref: function ref(el) {
          return _this4.element = el;
        },
        className: className,
        style: this.props.style,
        role: "group"
      }, items);
    }
  }]);

  return SelectButton;
}(Component);

_defineProperty$9(SelectButton$1, "defaultProps", {
  id: null,
  value: null,
  options: null,
  optionLabel: null,
  optionValue: null,
  optionDisabled: null,
  tabIndex: null,
  multiple: false,
  unselectable: true,
  disabled: false,
  style: null,
  className: null,
  dataKey: null,
  tooltip: null,
  tooltipOptions: null,
  ariaLabelledBy: null,
  itemTemplate: null,
  onChange: null
});

var SelectButton = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      options = _ref.options,
      optionDisabled = _ref.optionDisabled,
      tabIndex = _ref.tabIndex,
      multiple = _ref.multiple,
      unselectable = _ref.unselectable,
      disabled = _ref.disabled,
      style = _ref.style,
      className = _ref.className,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onChange = _ref.onChange,
      name = _ref.name;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(SelectButton$1, {
    ref: ref,
    id: id,
    value: value,
    options: options,
    optionDisabled: optionDisabled,
    tabIndex: tabIndex,
    multiple: multiple,
    unselectable: unselectable,
    disabled: disabled,
    style: style,
    className: className,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onChange: onChange,
    name: name
  });
});

function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$8(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$8(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$8(o, p) {
  _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$8(o, p);
}

function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$8(subClass, superClass);
}

function _typeof$8(obj) {
  "@babel/helpers - typeof";

  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$8(obj);
}

function _assertThisInitialized$8(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$8(self, call) {
  if (call && (_typeof$8(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$8(self);
}

function _getPrototypeOf$8(o) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$8(o);
}

function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$8(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$8(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$8(this, result);
  };
}

function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Skeleton$1 = /*#__PURE__*/function (_Component) {
  _inherits$8(Skeleton, _Component);

  var _super = _createSuper$e(Skeleton);

  function Skeleton() {
    _classCallCheck$8(this, Skeleton);

    return _super.apply(this, arguments);
  }

  _createClass$8(Skeleton, [{
    key: "skeletonStyle",
    value: function skeletonStyle() {
      if (this.props.size) return {
        width: this.props.size,
        height: this.props.size,
        borderRadius: this.props.borderRadius
      };else return {
        width: this.props.width,
        height: this.props.height,
        borderRadius: this.props.borderRadius
      };
    }
  }, {
    key: "render",
    value: function render() {
      var skeletonClassName = classNames('p-skeleton p-component', {
        'p-skeleton-circle': this.props.shape === 'circle',
        'p-skeleton-none': this.props.animation === 'none'
      }, this.props.className);
      var style = this.skeletonStyle();
      return /*#__PURE__*/React.createElement("div", {
        style: style,
        className: skeletonClassName
      });
    }
  }]);

  return Skeleton;
}(Component);

_defineProperty$8(Skeleton$1, "defaultProps", {
  shape: 'rectangle',
  size: null,
  width: '100%',
  height: '1rem',
  borderRadius: null,
  animation: 'wave',
  style: null,
  className: null
});

var Skeleton = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var shape = _ref.shape,
      size = _ref.size,
      width = _ref.width,
      height = _ref.height,
      borderRadius = _ref.borderRadius,
      animation = _ref.animation,
      style = _ref.style,
      className = _ref.className;
  return /*#__PURE__*/React.createElement(Skeleton$1, {
    ref: ref,
    shape: shape,
    size: size,
    width: width,
    height: height,
    borderRadius: borderRadius,
    animation: animation,
    style: style,
    className: className
  });
});

function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$7(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$7(o, p) {
  _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$7(o, p);
}

function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$7(subClass, superClass);
}

function _typeof$7(obj) {
  "@babel/helpers - typeof";

  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$7(obj);
}

function _assertThisInitialized$7(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$7(self, call) {
  if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$7(self);
}

function _getPrototypeOf$7(o) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$7(o);
}

function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$7(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$7(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$7(this, result);
  };
}

function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var ProgressSpinner = /*#__PURE__*/function (_Component) {
  _inherits$7(ProgressSpinner, _Component);

  var _super = _createSuper$d(ProgressSpinner);

  function ProgressSpinner() {
    _classCallCheck$7(this, ProgressSpinner);

    return _super.apply(this, arguments);
  }

  _createClass$7(ProgressSpinner, [{
    key: "render",
    value: function render() {
      var spinnerClass = classNames('p-progress-spinner', this.props.className);
      return /*#__PURE__*/React.createElement("div", {
        id: this.props.id,
        style: this.props.style,
        className: spinnerClass,
        role: "alert",
        "aria-busy": true
      }, /*#__PURE__*/React.createElement("svg", {
        className: "p-progress-spinner-svg",
        viewBox: "25 25 50 50",
        style: {
          animationDuration: this.props.animationDuration
        }
      }, /*#__PURE__*/React.createElement("circle", {
        className: "p-progress-spinner-circle",
        cx: "50",
        cy: "50",
        r: "20",
        fill: this.props.fill,
        strokeWidth: this.props.strokeWidth,
        strokeMiterlimit: "10"
      })));
    }
  }]);

  return ProgressSpinner;
}(Component);

_defineProperty$7(ProgressSpinner, "defaultProps", {
  id: null,
  style: null,
  className: null,
  strokeWidth: "2",
  fill: "none",
  animationDuration: "2s"
});

var Spinner = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? true : _ref$loading,
      style = _ref.style,
      className = _ref.className,
      strokeWidth = _ref.strokeWidth,
      children = _ref.children;

  if (loading) {
    return /*#__PURE__*/React.createElement("div", {
      className: "flex justify-content-center"
    }, /*#__PURE__*/React.createElement(ProgressSpinner, {
      ref: ref,
      loading: loading,
      strokeWidth: strokeWidth,
      style: style,
      className: className
    }));
  }

  return children;
});

function _arrayLikeToArray$8(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$3(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$8(arr);
}

function _iterableToArray$3(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$8(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$8(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen);
}

function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$3(arr) {
  return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$3();
}

function _assertThisInitialized$6(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _defineProperties$6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$6(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _setPrototypeOf$6(o, p) {
  _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$6(o, p);
}

function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$6(subClass, superClass);
}

function _typeof$6(obj) {
  "@babel/helpers - typeof";

  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$6(obj);
}

function _possibleConstructorReturn$6(self, call) {
  if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$6(self);
}

function _getPrototypeOf$6(o) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$6(o);
}

function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$6(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$6(this, result);
  };
}

function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TabPanel = /*#__PURE__*/function (_Component) {
  _inherits$6(TabPanel, _Component);

  var _super = _createSuper$c(TabPanel);

  function TabPanel() {
    _classCallCheck$6(this, TabPanel);

    return _super.apply(this, arguments);
  }

  return _createClass$6(TabPanel);
}(Component);

_defineProperty$6(TabPanel, "defaultProps", {
  header: null,
  headerTemplate: null,
  leftIcon: null,
  rightIcon: null,
  closable: false,
  disabled: false,
  style: null,
  className: null,
  headerStyle: null,
  headerClassName: null,
  contentStyle: null,
  contentClassName: null
});

var TabView$1 = /*#__PURE__*/function (_Component2) {
  _inherits$6(TabView, _Component2);

  var _super2 = _createSuper$c(TabView);

  function TabView(props) {
    var _this;

    _classCallCheck$6(this, TabView);

    _this = _super2.call(this, props);
    var state = {
      id: props.id,
      backwardIsDisabled: true,
      forwardIsDisabled: false,
      hiddenTabs: []
    };

    if (!_this.props.onTabChange) {
      state = _objectSpread$6(_objectSpread$6({}, state), {}, {
        activeIndex: props.activeIndex
      });
    }

    _this.state = state;
    _this.navBackward = _this.navBackward.bind(_assertThisInitialized$6(_this));
    _this.navForward = _this.navForward.bind(_assertThisInitialized$6(_this));
    _this.onScroll = _this.onScroll.bind(_assertThisInitialized$6(_this));
    return _this;
  }

  _createClass$6(TabView, [{
    key: "getActiveIndex",
    value: function getActiveIndex() {
      return this.props.onTabChange ? this.props.activeIndex : this.state.activeIndex;
    }
  }, {
    key: "isSelected",
    value: function isSelected(index) {
      return index === this.getActiveIndex();
    }
  }, {
    key: "shouldTabRender",
    value: function shouldTabRender(tab, index) {
      return tab && tab.type === TabPanel && this.state.hiddenTabs.every(function (_i) {
        return _i !== index;
      });
    }
  }, {
    key: "findVisibleActiveTab",
    value: function findVisibleActiveTab(i) {
      var _this2 = this;

      var tabsInfo = React.Children.map(this.props.children, function (tab, index) {
        if (_this2.shouldTabRender(tab, index)) {
          return {
            tab: tab,
            index: index
          };
        }
      });
      return tabsInfo.find(function (_ref) {
        var tab = _ref.tab,
            index = _ref.index;
        return !tab.props.disabled && index >= i;
      }) || tabsInfo.reverse().find(function (_ref2) {
        var tab = _ref2.tab,
            index = _ref2.index;
        return !tab.props.disabled && i > index;
      });
    }
  }, {
    key: "onTabHeaderClose",
    value: function onTabHeaderClose(event, index) {
      var _this3 = this;

      var hiddenTabs = [].concat(_toConsumableArray$3(this.state.hiddenTabs), [index]);
      this.setState({
        hiddenTabs: hiddenTabs
      }, function () {
        var tabInfo = _this3.findVisibleActiveTab(index);

        tabInfo && _this3.onTabHeaderClick(event, tabInfo.tab, tabInfo.index);
      });

      if (this.props.onTabClose) {
        this.props.onTabClose({
          originalEvent: event,
          index: index
        });
      }

      event.preventDefault();
    }
  }, {
    key: "onTabHeaderClick",
    value: function onTabHeaderClick(event, tab, index) {
      if (!tab.props.disabled) {
        if (this.props.onTabChange) {
          this.props.onTabChange({
            originalEvent: event,
            index: index
          });
        } else {
          this.setState({
            activeIndex: index
          });
        }
      }

      this.updateScrollBar(index);
      event.preventDefault();
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event, tab, index) {
      if (event.code === 'Enter') {
        this.onTabHeaderClick(event, tab, index);
      }
    }
  }, {
    key: "updateInkBar",
    value: function updateInkBar() {
      var activeIndex = this.getActiveIndex();
      var tabHeader = this["tab_".concat(activeIndex)];
      this.inkbar.style.width = DomHandler$1.getWidth(tabHeader) + 'px';
      this.inkbar.style.left = DomHandler$1.getOffset(tabHeader).left - DomHandler$1.getOffset(this.nav).left + 'px';
    }
  }, {
    key: "updateScrollBar",
    value: function updateScrollBar(index) {
      var tabHeader = this["tab_".concat(index)];

      if (tabHeader && tabHeader.scrollIntoView) {
        tabHeader.scrollIntoView({
          block: 'nearest'
        });
      }
    }
  }, {
    key: "updateButtonState",
    value: function updateButtonState() {
      var content = this.content;
      var scrollLeft = content.scrollLeft,
          scrollWidth = content.scrollWidth;
      var width = DomHandler$1.getWidth(content);
      this.setState({
        backwardIsDisabled: scrollLeft === 0
      });
      this.setState({
        forwardIsDisabled: scrollLeft === scrollWidth - width
      });
    }
  }, {
    key: "onScroll",
    value: function onScroll(event) {
      this.props.scrollable && this.updateButtonState();
      event.preventDefault();
    }
  }, {
    key: "getVisibleButtonWidths",
    value: function getVisibleButtonWidths() {
      var prevBtn = this.prevBtn;
      var nextBtn = this.nextBtn;
      return [prevBtn, nextBtn].reduce(function (acc, el) {
        return el ? acc + DomHandler$1.getWidth(el) : acc;
      }, 0);
    }
  }, {
    key: "navBackward",
    value: function navBackward() {
      var content = this.content;
      var width = DomHandler$1.getWidth(content) - this.getVisibleButtonWidths();
      var pos = content.scrollLeft - width;
      content.scrollLeft = pos <= 0 ? 0 : pos;
    }
  }, {
    key: "navForward",
    value: function navForward() {
      var content = this.content;
      var width = DomHandler$1.getWidth(content) - this.getVisibleButtonWidths();
      var pos = content.scrollLeft + width;
      var lastPos = content.scrollWidth - width;
      content.scrollLeft = pos >= lastPos ? lastPos : pos;
    }
  }, {
    key: "reset",
    value: function reset() {
      var state = {
        backwardIsDisabled: true,
        forwardIsDisabled: false,
        hiddenTabs: []
      };

      if (this.props.onTabChange) {
        this.props.onTabChange({
          index: this.props.activeIndex
        });
      } else {
        state = _objectSpread$6(_objectSpread$6({}, state), {}, {
          activeIndex: this.props.activeIndex
        });
      }

      this.setState(state);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (!this.state.id) {
        this.setState({
          id: UniqueComponentId()
        });
      }

      this.updateInkBar();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this.updateInkBar();

      if (prevProps.activeIndex !== this.props.activeIndex) {
        this.updateScrollBar(this.props.activeIndex);
      }
    }
  }, {
    key: "renderTabHeader",
    value: function renderTabHeader(tab, index) {
      var _this4 = this;

      var selected = this.isSelected(index);

      var style = _objectSpread$6(_objectSpread$6({}, tab.props.headerStyle || {}), tab.props.style || {});

      var className = classNames('p-unselectable-text', {
        'p-tabview-selected p-highlight': selected,
        'p-disabled': tab.props.disabled
      }, tab.props.headerClassName, tab.props.className);
      var id = this.state.id + '_header_' + index;
      var ariaControls = this.state.id + '_content_' + index;
      var tabIndex = tab.props.disabled ? null : 0;
      var leftIconElement = tab.props.leftIcon && /*#__PURE__*/React.createElement("i", {
        className: tab.props.leftIcon
      });
      var titleElement = /*#__PURE__*/React.createElement("span", {
        className: "p-tabview-title"
      }, tab.props.header);
      var rightIconElement = tab.props.rightIcon && /*#__PURE__*/React.createElement("i", {
        className: tab.props.rightIcon
      });
      var closableIconElement = tab.props.closable && /*#__PURE__*/React.createElement("i", {
        className: "p-tabview-close pi pi-times",
        onClick: function onClick(e) {
          return _this4.onTabHeaderClose(e, index);
        }
      });
      var content =
      /*#__PURE__*/

      /* eslint-disable */
      React.createElement("a", {
        role: "tab",
        className: "p-tabview-nav-link",
        onClick: function onClick(event) {
          return _this4.onTabHeaderClick(event, tab, index);
        },
        id: id,
        onKeyDown: function onKeyDown(event) {
          return _this4.onKeyDown(event, tab, index);
        },
        "aria-controls": ariaControls,
        "aria-selected": selected,
        tabIndex: tabIndex
      }, leftIconElement, titleElement, rightIconElement, closableIconElement, /*#__PURE__*/React.createElement(Ripple, null))
      /* eslint-enable */
      ;

      if (tab.props.headerTemplate) {
        var defaultContentOptions = {
          className: 'p-tabview-nav-link',
          titleClassName: 'p-tabview-title',
          onClick: function onClick(event) {
            return _this4.onTabHeaderClick(event, tab, index);
          },
          onKeyDown: function onKeyDown(event) {
            return _this4.onKeyDown(event, tab, index);
          },
          leftIconElement: leftIconElement,
          titleElement: titleElement,
          rightIconElement: rightIconElement,
          element: content,
          props: this.props,
          index: index,
          selected: selected,
          ariaControls: ariaControls
        };
        content = ObjectUtils.getJSXElement(tab.props.headerTemplate, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement("li", {
        ref: function ref(el) {
          return _this4["tab_".concat(index)] = el;
        },
        className: className,
        style: style,
        role: "presentation"
      }, content);
    }
  }, {
    key: "renderTabHeaders",
    value: function renderTabHeaders() {
      var _this5 = this;

      return React.Children.map(this.props.children, function (tab, index) {
        if (_this5.shouldTabRender(tab, index)) {
          return _this5.renderTabHeader(tab, index);
        }
      });
    }
  }, {
    key: "renderNavigator",
    value: function renderNavigator() {
      var _this6 = this;

      var headers = this.renderTabHeaders();
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this6.content = el;
        },
        id: this.props.id,
        className: "p-tabview-nav-content",
        style: this.props.style,
        onScroll: this.onScroll
      }, /*#__PURE__*/React.createElement("ul", {
        ref: function ref(el) {
          return _this6.nav = el;
        },
        className: "p-tabview-nav",
        role: "tablist"
      }, headers, /*#__PURE__*/React.createElement("li", {
        ref: function ref(el) {
          return _this6.inkbar = el;
        },
        className: "p-tabview-ink-bar"
      })));
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this7 = this;

      var contents = React.Children.map(this.props.children, function (tab, index) {
        if (_this7.shouldTabRender(tab, index) && (!_this7.props.renderActiveOnly || _this7.isSelected(index))) {
          return _this7.createContent(tab, index);
        }
      });
      return /*#__PURE__*/React.createElement("div", {
        className: "p-tabview-panels"
      }, contents);
    }
  }, {
    key: "createContent",
    value: function createContent(tab, index) {
      var selected = this.isSelected(index);

      var style = _objectSpread$6(_objectSpread$6({}, tab.props.contentStyle || {}), tab.props.style || {});

      var className = classNames(tab.props.contentClassName, tab.props.className, 'p-tabview-panel', {
        'p-hidden': !selected
      });
      var id = this.state.id + '_content_' + index;
      var ariaLabelledBy = this.state.id + '_header_' + index;
      return /*#__PURE__*/React.createElement("div", {
        id: id,
        "aria-labelledby": ariaLabelledBy,
        "aria-hidden": !selected,
        className: className,
        style: style,
        role: "tabpanel"
      }, !this.props.renderActiveOnly ? tab.props.children : selected && tab.props.children);
    }
  }, {
    key: "renderPrevButton",
    value: function renderPrevButton() {
      var _this8 = this;

      if (this.props.scrollable && !this.state.backwardIsDisabled) {
        return /*#__PURE__*/React.createElement("button", {
          ref: function ref(el) {
            return _this8.prevBtn = el;
          },
          className: "p-tabview-nav-prev p-tabview-nav-btn p-link",
          onClick: this.navBackward,
          type: "button"
        }, /*#__PURE__*/React.createElement("span", {
          className: "pi pi-chevron-left"
        }), /*#__PURE__*/React.createElement(Ripple, null));
      }

      return null;
    }
  }, {
    key: "renderNextButton",
    value: function renderNextButton() {
      var _this9 = this;

      if (this.props.scrollable && !this.state.forwardIsDisabled) {
        return /*#__PURE__*/React.createElement("button", {
          ref: function ref(el) {
            return _this9.nextBtn = el;
          },
          className: "p-tabview-nav-next p-tabview-nav-btn p-link",
          onClick: this.navForward,
          type: "button"
        }, /*#__PURE__*/React.createElement("span", {
          className: "pi pi-chevron-right"
        }), /*#__PURE__*/React.createElement(Ripple, null));
      }
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-tabview p-component', this.props.className, {
        'p-tabview-scrollable': this.props.scrollable
      });
      var navigator = this.renderNavigator();
      var content = this.renderContent();
      var prevButton = this.renderPrevButton();
      var nextButton = this.renderNextButton();
      return /*#__PURE__*/React.createElement("div", {
        className: className
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-tabview-nav-container"
      }, prevButton, navigator, nextButton), content);
    }
  }]);

  return TabView;
}(Component);

_defineProperty$6(TabView$1, "defaultProps", {
  id: null,
  activeIndex: 0,
  style: null,
  className: null,
  renderActiveOnly: true,
  onTabChange: null,
  onTabClose: null,
  scrollable: false
});

var TabView = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      activeIndex = _ref.activeIndex,
      style = _ref.style,
      className = _ref.className,
      renderActiveOnly = _ref.renderActiveOnly,
      scrollable = _ref.scrollable,
      onTabChange = _ref.onTabChange,
      children = _ref.children;
  return /*#__PURE__*/React.createElement(TabView$1, {
    ref: ref,
    id: id,
    activeIndex: activeIndex,
    renderActiveOnly: renderActiveOnly,
    scrollable: scrollable,
    style: style,
    onTabChange: onTabChange,
    className: className
  }, children);
});

function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$5(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf$5(o, p) {
  _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$5(o, p);
}

function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$5(subClass, superClass);
}

function _typeof$5(obj) {
  "@babel/helpers - typeof";

  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$5(obj);
}

function _assertThisInitialized$5(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$5(self, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$5(self);
}

function _getPrototypeOf$5(o) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$5(o);
}

function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$5(this, result);
  };
}

function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Tag$1 = /*#__PURE__*/function (_Component) {
  _inherits$5(Tag, _Component);

  var _super = _createSuper$b(Tag);

  function Tag() {
    _classCallCheck$5(this, Tag);

    return _super.apply(this, arguments);
  }

  _createClass$5(Tag, [{
    key: "render",
    value: function render() {
      var tagClassName = classNames('p-tag p-component', {
        'p-tag-info': this.props.severity === 'info',
        'p-tag-success': this.props.severity === 'success',
        'p-tag-warning': this.props.severity === 'warning',
        'p-tag-danger': this.props.severity === 'danger',
        'p-tag-rounded': this.props.rounded
      }, this.props.className);
      return /*#__PURE__*/React.createElement("span", {
        className: tagClassName,
        style: this.props.style
      }, IconUtils.getJSXIcon(this.props.icon, {
        className: 'p-tag-icon'
      }, {
        props: this.props
      }), /*#__PURE__*/React.createElement("span", {
        className: "p-tag-value"
      }, this.props.value), /*#__PURE__*/React.createElement("span", null, this.props.children));
    }
  }]);

  return Tag;
}(Component);

_defineProperty$5(Tag$1, "defaultProps", {
  value: null,
  severity: null,
  rounded: false,
  icon: null,
  style: null,
  className: null
});

var Tag = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var value = _ref.value,
      severity = _ref.severity,
      icon = _ref.icon,
      style = _ref.style,
      className = _ref.className;
  var tagClassName = classNames(className, {
    "p-tag-secondary": severity === "secondary",
    "p-tag-help": severity === "help"
  });
  return /*#__PURE__*/React.createElement(Tag$1, {
    ref: ref,
    value: value,
    severity: severity,
    icon: icon,
    className: tagClassName,
    style: style
  });
});

function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$4(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$4(o, p) {
  _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$4(o, p);
}

function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$4(subClass, superClass);
}

function _typeof$4(obj) {
  "@babel/helpers - typeof";

  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$4(obj);
}

function _possibleConstructorReturn$4(self, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$4(self);
}

function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$4(o);
}

function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createSuper$1$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$3();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$4(this, result);
  };
}

function _isNativeReflectConstruct$1$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TieredMenuSub = /*#__PURE__*/function (_Component) {
  _inherits$4(TieredMenuSub, _Component);

  var _super = _createSuper$1$3(TieredMenuSub);

  function TieredMenuSub(props) {
    var _this;

    _classCallCheck$4(this, TieredMenuSub);

    _this = _super.call(this, props);
    _this.state = {
      activeItem: null
    };
    _this.onLeafClick = _this.onLeafClick.bind(_assertThisInitialized$4(_this));
    _this.onChildItemKeyDown = _this.onChildItemKeyDown.bind(_assertThisInitialized$4(_this));
    return _this;
  }

  _createClass$4(TieredMenuSub, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.parentActive && !this.props.parentActive) {
        this.setState({
          activeItem: null
        });
      }

      if (this.props.parentActive && !this.props.root) {
        this.position();
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      if (!this.documentClickListener) {
        this.documentClickListener = function (event) {
          if (_this2.element && !_this2.element.contains(event.target)) {
            _this2.setState({
              activeItem: null
            });
          }
        };

        document.addEventListener('click', this.documentClickListener);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.documentClickListener) {
        document.removeEventListener('click', this.documentClickListener);
        this.documentClickListener = null;
      }
    }
  }, {
    key: "position",
    value: function position() {
      if (this.element) {
        var parentItem = this.element.parentElement;
        var containerOffset = DomHandler$1.getOffset(parentItem);
        var viewport = DomHandler$1.getViewport();
        var sublistWidth = this.element.offsetParent ? this.element.offsetWidth : DomHandler$1.getHiddenElementOuterWidth(this.element);
        var itemOuterWidth = DomHandler$1.getOuterWidth(parentItem.children[0]);

        if (parseInt(containerOffset.left, 10) + itemOuterWidth + sublistWidth > viewport.width - DomHandler$1.calculateScrollbarWidth()) {
          DomHandler$1.addClass(this.element, 'p-submenu-list-flipped');
        }
      }
    }
  }, {
    key: "onItemMouseEnter",
    value: function onItemMouseEnter(event, item) {
      if (item.disabled) {
        event.preventDefault();
        return;
      }

      if (this.props.root) {
        if (this.state.activeItem || this.props.popup) {
          this.setState({
            activeItem: item
          });
        }
      } else {
        this.setState({
          activeItem: item
        });
      }
    }
  }, {
    key: "onItemClick",
    value: function onItemClick(event, item) {
      if (item.disabled) {
        event.preventDefault();
        return;
      }

      if (!item.url) {
        event.preventDefault();
      }

      if (item.command) {
        item.command({
          originalEvent: event,
          item: item
        });
      }

      if (this.props.root) {
        if (item.items) {
          if (this.state.activeItem && item === this.state.activeItem) {
            this.setState({
              activeItem: null
            });
          } else {
            this.setState({
              activeItem: item
            });
          }
        }
      }

      if (!item.items) {
        this.onLeafClick();
      }
    }
  }, {
    key: "onItemKeyDown",
    value: function onItemKeyDown(event, item) {
      var listItem = event.currentTarget.parentElement;

      switch (event.which) {
        //down
        case 40:
          var nextItem = this.findNextItem(listItem);

          if (nextItem) {
            nextItem.children[0].focus();
          }

          event.preventDefault();
          break;
        //up

        case 38:
          var prevItem = this.findPrevItem(listItem);

          if (prevItem) {
            prevItem.children[0].focus();
          }

          event.preventDefault();
          break;
        //right

        case 39:
          if (item.items) {
            this.setState({
              activeItem: item
            });
            setTimeout(function () {
              listItem.children[1].children[0].children[0].focus();
            }, 50);
          }

          event.preventDefault();
          break;
      }

      if (this.props.onKeyDown) {
        this.props.onKeyDown(event, listItem);
      }
    }
  }, {
    key: "onChildItemKeyDown",
    value: function onChildItemKeyDown(event, childListItem) {
      //left
      if (event.which === 37) {
        this.setState({
          activeItem: null
        });
        childListItem.parentElement.previousElementSibling.focus();
      }
    }
  }, {
    key: "findNextItem",
    value: function findNextItem(item) {
      var nextItem = item.nextElementSibling;
      if (nextItem) return DomHandler$1.hasClass(nextItem, 'p-disabled') || !DomHandler$1.hasClass(nextItem, 'p-menuitem') ? this.findNextItem(nextItem) : nextItem;else return null;
    }
  }, {
    key: "findPrevItem",
    value: function findPrevItem(item) {
      var prevItem = item.previousElementSibling;
      if (prevItem) return DomHandler$1.hasClass(prevItem, 'p-disabled') || !DomHandler$1.hasClass(prevItem, 'p-menuitem') ? this.findPrevItem(prevItem) : prevItem;else return null;
    }
  }, {
    key: "onLeafClick",
    value: function onLeafClick() {
      this.setState({
        activeItem: null
      });

      if (this.props.onLeafClick) {
        this.props.onLeafClick();
      }
    }
  }, {
    key: "renderSeparator",
    value: function renderSeparator(index) {
      return /*#__PURE__*/React.createElement("li", {
        key: 'separator_' + index,
        className: "p-menu-separator",
        role: "separator"
      });
    }
  }, {
    key: "renderSubmenu",
    value: function renderSubmenu(item) {
      if (item.items) {
        return /*#__PURE__*/React.createElement(TieredMenuSub, {
          model: item.items,
          onLeafClick: this.onLeafClick,
          popup: this.props.popup,
          onKeyDown: this.onChildItemKeyDown,
          parentActive: item === this.state.activeItem
        });
      }

      return null;
    }
  }, {
    key: "renderMenuitem",
    value: function renderMenuitem(item, index) {
      var _this3 = this;

      var active = this.state.activeItem === item;
      var className = classNames('p-menuitem', {
        'p-menuitem-active': active
      }, item.className);
      var linkClassName = classNames('p-menuitem-link', {
        'p-disabled': item.disabled
      });
      var iconClassName = classNames('p-menuitem-icon', item.icon);
      var submenuIconClassName = 'p-submenu-icon pi pi-angle-right';
      var icon = item.icon && /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      });
      var label = item.label && /*#__PURE__*/React.createElement("span", {
        className: "p-menuitem-text"
      }, item.label);
      var submenuIcon = item.items && /*#__PURE__*/React.createElement("span", {
        className: submenuIconClassName
      });
      var submenu = this.renderSubmenu(item);
      var content = /*#__PURE__*/React.createElement("a", {
        href: item.url || '#',
        className: linkClassName,
        target: item.target,
        role: "menuitem",
        "aria-haspopup": item.items != null,
        onClick: function onClick(event) {
          return _this3.onItemClick(event, item);
        },
        onKeyDown: function onKeyDown(event) {
          return _this3.onItemKeyDown(event, item);
        },
        "aria-disabled": item.disabled
      }, icon, label, submenuIcon, /*#__PURE__*/React.createElement(Ripple, null));

      if (item.template) {
        var defaultContentOptions = {
          onClick: function onClick(event) {
            return _this3.onItemClick(event, item);
          },
          onKeyDown: function onKeyDown(event) {
            return _this3.onItemKeyDown(event, item);
          },
          className: linkClassName,
          labelClassName: 'p-menuitem-text',
          iconClassName: iconClassName,
          submenuIconClassName: submenuIconClassName,
          element: content,
          props: this.props,
          active: active
        };
        content = ObjectUtils.getJSXElement(item.template, item, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement("li", {
        key: item.label + '_' + index,
        className: className,
        style: item.style,
        onMouseEnter: function onMouseEnter(event) {
          return _this3.onItemMouseEnter(event, item);
        },
        role: "none"
      }, content, submenu);
    }
  }, {
    key: "renderItem",
    value: function renderItem(item, index) {
      if (item.separator) return this.renderSeparator(index);else return this.renderMenuitem(item, index);
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;

      if (this.props.model) {
        return this.props.model.map(function (item, index) {
          return _this4.renderItem(item, index);
        });
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var className = classNames({
        'p-submenu-list': !this.props.root
      });
      var submenu = this.renderMenu();
      return /*#__PURE__*/React.createElement("ul", {
        ref: function ref(el) {
          return _this5.element = el;
        },
        className: className,
        role: this.props.root ? 'menubar' : 'menu',
        "aria-orientation": "horizontal"
      }, submenu);
    }
  }]);

  return TieredMenuSub;
}(Component);

_defineProperty$4(TieredMenuSub, "defaultProps", {
  model: null,
  root: false,
  className: null,
  popup: false,
  onLeafClick: null,
  onKeyDown: null,
  parentActive: false
});

function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$4(this, result);
  };
}

function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TieredMenu$1 = /*#__PURE__*/function (_Component) {
  _inherits$4(TieredMenu, _Component);

  var _super = _createSuper$a(TieredMenu);

  function TieredMenu(props) {
    var _this;

    _classCallCheck$4(this, TieredMenu);

    _this = _super.call(this, props);
    _this.state = {
      visible: !props.popup
    };
    _this.onEnter = _this.onEnter.bind(_assertThisInitialized$4(_this));
    _this.onEntered = _this.onEntered.bind(_assertThisInitialized$4(_this));
    _this.onExit = _this.onExit.bind(_assertThisInitialized$4(_this));
    _this.onExited = _this.onExited.bind(_assertThisInitialized$4(_this));
    _this.onPanelClick = _this.onPanelClick.bind(_assertThisInitialized$4(_this));
    _this.menuRef = /*#__PURE__*/React.createRef();
    return _this;
  }

  _createClass$4(TieredMenu, [{
    key: "onPanelClick",
    value: function onPanelClick(event) {
      if (this.props.popup) {
        OverlayService.emit('overlay-click', {
          originalEvent: event,
          target: this.target
        });
      }
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      if (this.props.popup) {
        if (this.state.visible) this.hide(event);else this.show(event);
      }
    }
  }, {
    key: "show",
    value: function show(event) {
      var _this2 = this;

      this.target = event.currentTarget;
      var currentEvent = event;
      this.setState({
        visible: true
      }, function () {
        if (_this2.props.onShow) {
          _this2.props.onShow(currentEvent);
        }
      });
    }
  }, {
    key: "hide",
    value: function hide(event) {
      var _this3 = this;

      var currentEvent = event;
      this.setState({
        visible: false
      }, function () {
        if (_this3.props.onHide) {
          _this3.props.onHide(currentEvent);
        }
      });
    }
  }, {
    key: "onEnter",
    value: function onEnter() {
      if (this.props.autoZIndex) {
        ZIndexUtils.set('menu', this.menuRef.current, PrimeReact.autoZIndex, this.props.baseZIndex || PrimeReact.zIndex['menu']);
      }

      DomHandler$1.absolutePosition(this.menuRef.current, this.target);
    }
  }, {
    key: "onEntered",
    value: function onEntered() {
      this.bindDocumentListeners();
      this.bindScrollListener();
    }
  }, {
    key: "onExit",
    value: function onExit() {
      this.target = null;
      this.unbindDocumentListeners();
      this.unbindScrollListener();
    }
  }, {
    key: "onExited",
    value: function onExited() {
      ZIndexUtils.clear(this.menuRef.current);
    }
  }, {
    key: "bindDocumentListeners",
    value: function bindDocumentListeners() {
      this.bindDocumentClickListener();
      this.bindDocumentResizeListener();
    }
  }, {
    key: "unbindDocumentListeners",
    value: function unbindDocumentListeners() {
      this.unbindDocumentClickListener();
      this.unbindDocumentResizeListener();
    }
  }, {
    key: "bindDocumentClickListener",
    value: function bindDocumentClickListener() {
      var _this4 = this;

      if (!this.documentClickListener) {
        this.documentClickListener = function (event) {
          if (_this4.props.popup && _this4.state.visible && _this4.menuRef.current && !_this4.menuRef.current.contains(event.target)) {
            _this4.hide(event);
          }
        };

        document.addEventListener('click', this.documentClickListener);
      }
    }
  }, {
    key: "unbindDocumentClickListener",
    value: function unbindDocumentClickListener() {
      if (this.documentClickListener) {
        document.removeEventListener('click', this.documentClickListener);
        this.documentClickListener = null;
      }
    }
  }, {
    key: "bindDocumentResizeListener",
    value: function bindDocumentResizeListener() {
      var _this5 = this;

      if (!this.documentResizeListener) {
        this.documentResizeListener = function (event) {
          if (_this5.state.visible && !DomHandler$1.isTouchDevice()) {
            _this5.hide(event);
          }
        };

        window.addEventListener('resize', this.documentResizeListener);
      }
    }
  }, {
    key: "unbindDocumentResizeListener",
    value: function unbindDocumentResizeListener() {
      if (this.documentResizeListener) {
        window.removeEventListener('resize', this.documentResizeListener);
        this.documentResizeListener = null;
      }
    }
  }, {
    key: "bindScrollListener",
    value: function bindScrollListener() {
      var _this6 = this;

      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.target, function (event) {
          if (_this6.state.visible) {
            _this6.hide(event);
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    }
  }, {
    key: "unbindScrollListener",
    value: function unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindDocumentListeners();

      if (this.scrollHandler) {
        this.scrollHandler.destroy();
        this.scrollHandler = null;
      }

      ZIndexUtils.clear(this.menuRef.current);
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var className = classNames('p-tieredmenu p-component', {
        'p-tieredmenu-overlay': this.props.popup
      }, this.props.className);
      return /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: this.menuRef,
        classNames: "p-connected-overlay",
        "in": this.state.visible,
        timeout: {
          enter: 120,
          exit: 100
        },
        options: this.props.transitionOptions,
        unmountOnExit: true,
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onExit: this.onExit,
        onExited: this.onExited
      }, /*#__PURE__*/React.createElement("div", {
        ref: this.menuRef,
        id: this.props.id,
        className: className,
        style: this.props.style,
        onClick: this.onPanelClick
      }, /*#__PURE__*/React.createElement(TieredMenuSub, {
        model: this.props.model,
        root: true,
        popup: this.props.popup
      })));
    }
  }, {
    key: "render",
    value: function render() {
      var element = this.renderElement();
      return this.props.popup ? /*#__PURE__*/React.createElement(Portal, {
        element: element,
        appendTo: this.props.appendTo
      }) : element;
    }
  }]);

  return TieredMenu;
}(Component);

_defineProperty$4(TieredMenu$1, "defaultProps", {
  id: null,
  model: null,
  popup: false,
  style: null,
  className: null,
  autoZIndex: true,
  baseZIndex: 0,
  appendTo: null,
  transitionOptions: null,
  onShow: null,
  onHide: null
});

var TieredMenu = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      model = _ref.model,
      style = _ref.style,
      className = _ref.className,
      _ref$autoZIndex = _ref.autoZIndex,
      autoZIndex = _ref$autoZIndex === void 0 ? true : _ref$autoZIndex,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 150 : _ref$baseZIndex;
  return /*#__PURE__*/React.createElement(TieredMenu$1, {
    ref: ref,
    id: id,
    model: model,
    style: style,
    className: className,
    autoZIndex: autoZIndex,
    baseZIndex: baseZIndex
  });
});

var TimePicker = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      name = _ref.name,
      value = _ref.value,
      onChange = _ref.onChange,
      _ref$showSeconds = _ref.showSeconds,
      showSeconds = _ref$showSeconds === void 0 ? false : _ref$showSeconds,
      _ref$showMillisec = _ref.showMillisec,
      showMillisec = _ref$showMillisec === void 0 ? false : _ref$showMillisec,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$stepHour = _ref.stepHour,
      stepHour = _ref$stepHour === void 0 ? 1 : _ref$stepHour,
      _ref$stepSecond = _ref.stepSecond,
      stepSecond = _ref$stepSecond === void 0 ? 1 : _ref$stepSecond,
      _ref$stepMinute = _ref.stepMinute,
      stepMinute = _ref$stepMinute === void 0 ? 1 : _ref$stepMinute,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder,
      _ref$showIcon = _ref.showIcon,
      showIcon = _ref$showIcon === void 0 ? false : _ref$showIcon,
      _ref$viewDate = _ref.viewDate,
      viewDate = _ref$viewDate === void 0 ? null : _ref$viewDate;
  return /*#__PURE__*/React.createElement(Calendar, {
    id: id,
    name: name,
    ref: ref,
    value: value,
    onChange: onChange,
    showSeconds: showSeconds,
    showMillisec: showMillisec,
    stepHour: stepHour,
    stepSecond: stepSecond,
    stepMinute: stepMinute,
    disabled: disabled,
    placeholder: placeholder,
    showIcon: showIcon,
    viewDate: viewDate,
    hourFormat: "24",
    showTime: true,
    timeOnly: true
  });
});

function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$2(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$7(arr);
}

function _iterableToArray$2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$7(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
}

function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$2(arr) {
  return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$2();
}

function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$3(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$3(o, p) {
  _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$3(o, p);
}

function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$3(subClass, superClass);
}

function _typeof$3(obj) {
  "@babel/helpers - typeof";

  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$3(obj);
}

function _possibleConstructorReturn$3(self, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$3(self);
}

function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$3(o);
}

function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) {
      _defineProperty$3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$1$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$2();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$3(this, result);
  };
}

function _isNativeReflectConstruct$1$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var ToastMessageComponent = /*#__PURE__*/function (_Component) {
  _inherits$3(ToastMessageComponent, _Component);

  var _super = _createSuper$1$2(ToastMessageComponent);

  function ToastMessageComponent(props) {
    var _this;

    _classCallCheck$3(this, ToastMessageComponent);

    _this = _super.call(this, props);
    _this.onClick = _this.onClick.bind(_assertThisInitialized$3(_this));
    _this.onClose = _this.onClose.bind(_assertThisInitialized$3(_this));
    return _this;
  }

  _createClass$3(ToastMessageComponent, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      if (!this.props.message.sticky) {
        this.timeout = setTimeout(function () {
          _this2.onClose(null);
        }, this.props.message.life || 3000);
      }
    }
  }, {
    key: "onClose",
    value: function onClose() {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }

      if (this.props.onClose) {
        this.props.onClose(this.props.message);
      }
    }
  }, {
    key: "onClick",
    value: function onClick(event) {
      if (this.props.onClick && !(DomHandler$1.hasClass(event.target, 'p-toast-icon-close') || DomHandler$1.hasClass(event.target, 'p-toast-icon-close-icon'))) {
        this.props.onClick(this.props.message);
      }
    }
  }, {
    key: "renderCloseIcon",
    value: function renderCloseIcon() {
      if (this.props.message.closable !== false) {
        return /*#__PURE__*/React.createElement("button", {
          type: "button",
          className: "p-toast-icon-close p-link",
          onClick: this.onClose
        }, /*#__PURE__*/React.createElement("span", {
          className: "p-toast-icon-close-icon pi pi-times"
        }), /*#__PURE__*/React.createElement(Ripple, null));
      }

      return null;
    }
  }, {
    key: "renderMessage",
    value: function renderMessage() {
      if (this.props.message) {
        var _this$props$message = this.props.message,
            severity = _this$props$message.severity,
            content = _this$props$message.content,
            summary = _this$props$message.summary,
            detail = _this$props$message.detail;
        var contentEl = ObjectUtils.getJSXElement(content, _objectSpread$5(_objectSpread$5({}, this.props), {}, {
          onClose: this.onClose
        }));
        var iconClassName = classNames('p-toast-message-icon pi', {
          'pi-info-circle': severity === 'info',
          'pi-exclamation-triangle': severity === 'warn',
          'pi-times': severity === 'error',
          'pi-check': severity === 'success'
        });
        return contentEl || /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
          className: iconClassName
        }), /*#__PURE__*/React.createElement("div", {
          className: "p-toast-message-text"
        }, /*#__PURE__*/React.createElement("span", {
          className: "p-toast-summary"
        }, summary), detail && /*#__PURE__*/React.createElement("div", {
          className: "p-toast-detail"
        }, detail)));
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var severity = this.props.message.severity;
      var contentClassName = this.props.message.contentClassName;
      var contentStyle = this.props.message.contentStyle;
      var style = this.props.message.style;
      var className = classNames('p-toast-message', {
        'p-toast-message-info': severity === 'info',
        'p-toast-message-warn': severity === 'warn',
        'p-toast-message-error': severity === 'error',
        'p-toast-message-success': severity === 'success'
      }, this.props.message.className);
      var message = this.renderMessage();
      var closeIcon = this.renderCloseIcon();
      return /*#__PURE__*/React.createElement("div", {
        ref: this.props.forwardRef,
        className: className,
        style: style,
        role: "alert",
        "aria-live": "assertive",
        "aria-atomic": "true",
        onClick: this.onClick
      }, /*#__PURE__*/React.createElement("div", {
        className: classNames('p-toast-message-content', contentClassName),
        style: contentStyle
      }, message, closeIcon));
    }
  }]);

  return ToastMessageComponent;
}(Component);

_defineProperty$3(ToastMessageComponent, "defaultProps", {
  message: null,
  onClose: null,
  onClick: null
});

var ToastMessage = /*#__PURE__*/React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(ToastMessageComponent, _extends$1({
    forwardRef: ref
  }, props));
});

function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$3(this, result);
  };
}

function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var messageIdx = 0;

var Toast$1 = /*#__PURE__*/function (_Component) {
  _inherits$3(Toast, _Component);

  var _super = _createSuper$9(Toast);

  function Toast(props) {
    var _this;

    _classCallCheck$3(this, Toast);

    _this = _super.call(this, props);
    _this.state = {
      messages: []
    };
    _this.onClose = _this.onClose.bind(_assertThisInitialized$3(_this));
    _this.onEntered = _this.onEntered.bind(_assertThisInitialized$3(_this));
    _this.onExited = _this.onExited.bind(_assertThisInitialized$3(_this));
    return _this;
  }

  _createClass$3(Toast, [{
    key: "show",
    value: function show(value) {
      if (value) {
        if (value) {
          var newMessages;

          if (Array.isArray(value)) {
            for (var i = 0; i < value.length; i++) {
              value[i].id = messageIdx++;
              newMessages = [].concat(_toConsumableArray$2(this.state.messages), _toConsumableArray$2(value));
            }
          } else {
            value.id = messageIdx++;
            newMessages = this.state.messages ? [].concat(_toConsumableArray$2(this.state.messages), [value]) : [value];
          }

          this.state.messages.length === 0 && ZIndexUtils.set('toast', this.container, PrimeReact.autoZIndex, this.props.baseZIndex || PrimeReact.zIndex['toast']);
          this.setState({
            messages: newMessages
          });
        }
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      ZIndexUtils.clear(this.container);
      this.setState({
        messages: []
      });
    }
  }, {
    key: "onClose",
    value: function onClose(message) {
      var newMessages = this.state.messages.filter(function (msg) {
        return msg.id !== message.id;
      });
      this.setState({
        messages: newMessages
      });

      if (this.props.onRemove) {
        this.props.onRemove(message);
      }
    }
  }, {
    key: "onEntered",
    value: function onEntered() {
      this.props.onShow && this.props.onShow();
    }
  }, {
    key: "onExited",
    value: function onExited() {
      this.state.messages.length === 0 && ZIndexUtils.clear(this.container);
      this.props.onHide && this.props.onHide();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      ZIndexUtils.clear(this.container);
    }
  }, {
    key: "renderElement",
    value: function renderElement() {
      var _this2 = this;

      var className = classNames('p-toast p-component p-toast-' + this.props.position, this.props.className);
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          _this2.container = el;
        },
        id: this.props.id,
        className: className,
        style: this.props.style
      }, /*#__PURE__*/React.createElement(TransitionGroup$1, null, this.state.messages.map(function (message) {
        var messageRef = /*#__PURE__*/React.createRef();
        return /*#__PURE__*/React.createElement(CSSTransition, {
          nodeRef: messageRef,
          key: message.id,
          classNames: "p-toast-message",
          unmountOnExit: true,
          timeout: {
            enter: 300,
            exit: 300
          },
          onEntered: _this2.onEntered,
          onExited: _this2.onExited,
          options: _this2.props.transitionOptions
        }, /*#__PURE__*/React.createElement(ToastMessage, {
          ref: messageRef,
          message: message,
          onClick: _this2.props.onClick,
          onClose: _this2.onClose
        }));
      })));
    }
  }, {
    key: "render",
    value: function render() {
      var element = this.renderElement();
      return /*#__PURE__*/React.createElement(Portal, {
        element: element,
        appendTo: this.props.appendTo
      });
    }
  }]);

  return Toast;
}(Component);

_defineProperty$3(Toast$1, "defaultProps", {
  id: null,
  className: null,
  style: null,
  baseZIndex: 0,
  position: 'top-right',
  transitionOptions: null,
  appendTo: 'self',
  onClick: null,
  onRemove: null,
  onShow: null,
  onHide: null
});

var Toast = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      className = _ref.className,
      style = _ref.style,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 300 : _ref$baseZIndex,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? "top-right" : _ref$position,
      onClick = _ref.onClick,
      onRemove = _ref.onRemove,
      onShow = _ref.onShow,
      onHide = _ref.onHide;
  return /*#__PURE__*/React.createElement(Toast$1, {
    ref: ref,
    id: id,
    className: className,
    style: style,
    position: position,
    event: event,
    baseZIndex: baseZIndex,
    onClick: onClick,
    onRemove: onRemove,
    onShow: onShow,
    onHide: onHide
  });
});

var Tooltip = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      target = _ref.target,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      className = _ref.className,
      style = _ref.style,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? "right" : _ref$position,
      at = _ref.at,
      event = _ref.event,
      _ref$showEvent = _ref.showEvent,
      showEvent = _ref$showEvent === void 0 ? "mouseenter" : _ref$showEvent,
      _ref$hideEvent = _ref.hideEvent,
      hideEvent = _ref$hideEvent === void 0 ? "mouseleave" : _ref$hideEvent,
      _ref$autoZIndex = _ref.autoZIndex,
      autoZIndex = _ref$autoZIndex === void 0 ? true : _ref$autoZIndex,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 200 : _ref$baseZIndex,
      _ref$showDelay = _ref.showDelay,
      showDelay = _ref$showDelay === void 0 ? 0 : _ref$showDelay,
      _ref$hideDelay = _ref.hideDelay,
      hideDelay = _ref$hideDelay === void 0 ? 0 : _ref$hideDelay,
      _ref$autoHide = _ref.autoHide,
      autoHide = _ref$autoHide === void 0 ? true : _ref$autoHide,
      _ref$showOnDisabled = _ref.showOnDisabled,
      showOnDisabled = _ref$showOnDisabled === void 0 ? false : _ref$showOnDisabled,
      onShow = _ref.onShow,
      onHide = _ref.onHide,
      children = _ref.children;
  return /*#__PURE__*/React.createElement(Tooltip$1, {
    ref: ref,
    id: id,
    target: target,
    disabled: disabled,
    className: className,
    style: style,
    position: position,
    at: at,
    event: event,
    showEvent: showEvent,
    hideEvent: hideEvent,
    autoZIndex: autoZIndex,
    baseZIndex: baseZIndex,
    showDelay: showDelay,
    hideDelay: hideDelay,
    autoHide: autoHide,
    showOnDisabled: showOnDisabled,
    onShow: onShow,
    onHide: onHide
  }, children);
});

function _arrayLikeToArray$2$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$2$1(arr);
}

function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$2$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$2$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2$1(o, minLen);
}

function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$2$1(arr) || _nonIterableSpread$1();
}

function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$2(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$2(o, p) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$2(o, p);
}

function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$2(subClass, superClass);
}

function _typeof$2(obj) {
  "@babel/helpers - typeof";

  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$2(obj);
}

function _possibleConstructorReturn$2(self, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$2(self);
}

function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$2(o);
}

function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createForOfIteratorHelper$1$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$1$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$1(o, minLen);
}

function _arrayLikeToArray$1$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function ownKeys$1$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1$1(Object(source), !0).forEach(function (key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$1$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$2(this, result);
  };
}

function _isNativeReflectConstruct$1$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var UITreeNode = /*#__PURE__*/function (_Component) {
  _inherits$2(UITreeNode, _Component);

  var _super = _createSuper$1$1(UITreeNode);

  function UITreeNode(props) {
    var _this;

    _classCallCheck$2(this, UITreeNode);

    _this = _super.call(this, props);
    _this.onClick = _this.onClick.bind(_assertThisInitialized$2(_this));
    _this.onDoubleClick = _this.onDoubleClick.bind(_assertThisInitialized$2(_this));
    _this.onRightClick = _this.onRightClick.bind(_assertThisInitialized$2(_this));
    _this.onTouchEnd = _this.onTouchEnd.bind(_assertThisInitialized$2(_this));
    _this.onTogglerClick = _this.onTogglerClick.bind(_assertThisInitialized$2(_this));
    _this.onNodeKeyDown = _this.onNodeKeyDown.bind(_assertThisInitialized$2(_this));
    _this.propagateUp = _this.propagateUp.bind(_assertThisInitialized$2(_this));
    _this.onDrop = _this.onDrop.bind(_assertThisInitialized$2(_this));
    _this.onDragOver = _this.onDragOver.bind(_assertThisInitialized$2(_this));
    _this.onDragEnter = _this.onDragEnter.bind(_assertThisInitialized$2(_this));
    _this.onDragLeave = _this.onDragLeave.bind(_assertThisInitialized$2(_this));
    _this.onDragStart = _this.onDragStart.bind(_assertThisInitialized$2(_this));
    _this.onDragEnd = _this.onDragEnd.bind(_assertThisInitialized$2(_this));
    _this.onDropPointDragOver = _this.onDropPointDragOver.bind(_assertThisInitialized$2(_this));
    _this.onDropPointDragEnter = _this.onDropPointDragEnter.bind(_assertThisInitialized$2(_this));
    _this.onDropPointDragLeave = _this.onDropPointDragLeave.bind(_assertThisInitialized$2(_this));
    return _this;
  }

  _createClass$2(UITreeNode, [{
    key: "isLeaf",
    value: function isLeaf() {
      return this.props.isNodeLeaf(this.props.node);
    }
  }, {
    key: "expand",
    value: function expand(event) {
      var expandedKeys = this.props.expandedKeys ? _objectSpread$1$1({}, this.props.expandedKeys) : {};
      expandedKeys[this.props.node.key] = true;
      this.props.onToggle({
        originalEvent: event,
        value: expandedKeys
      });
      this.invokeToggleEvents(event, true);
    }
  }, {
    key: "collapse",
    value: function collapse(event) {
      var expandedKeys = _objectSpread$1$1({}, this.props.expandedKeys);

      delete expandedKeys[this.props.node.key];
      this.props.onToggle({
        originalEvent: event,
        value: expandedKeys
      });
      this.invokeToggleEvents(event, false);
    }
  }, {
    key: "onTogglerClick",
    value: function onTogglerClick(event) {
      if (this.props.disabled) {
        return;
      }

      if (this.isExpanded()) this.collapse(event);else this.expand(event);
    }
  }, {
    key: "invokeToggleEvents",
    value: function invokeToggleEvents(event, expanded) {
      if (expanded) {
        if (this.props.onExpand) {
          this.props.onExpand({
            originalEvent: event,
            node: this.props.node
          });
        }
      } else {
        if (this.props.onCollapse) {
          this.props.onCollapse({
            originalEvent: event,
            node: this.props.node
          });
        }
      }
    }
  }, {
    key: "isExpanded",
    value: function isExpanded() {
      return (this.props.expandedKeys ? this.props.expandedKeys[this.props.node.key] !== undefined : false) || this.props.node.expanded;
    }
  }, {
    key: "onNodeKeyDown",
    value: function onNodeKeyDown(event) {
      if (this.props.disabled) {
        return;
      }

      var nodeElement = event.target.parentElement;

      if (!DomHandler$1.hasClass(nodeElement, 'p-treenode')) {
        return;
      }

      switch (event.which) {
        //down arrow
        case 40:
          var listElement = nodeElement.children[1];

          if (listElement) {
            this.focusNode(listElement.children[0]);
          } else {
            var nextNodeElement = nodeElement.nextElementSibling;

            if (nextNodeElement) {
              this.focusNode(nextNodeElement);
            } else {
              var nextSiblingAncestor = this.findNextSiblingOfAncestor(nodeElement);

              if (nextSiblingAncestor) {
                this.focusNode(nextSiblingAncestor);
              }
            }
          }

          event.preventDefault();
          break;
        //up arrow

        case 38:
          if (nodeElement.previousElementSibling) {
            this.focusNode(this.findLastVisibleDescendant(nodeElement.previousElementSibling));
          } else {
            var parentNodeElement = this.getParentNodeElement(nodeElement);

            if (parentNodeElement) {
              this.focusNode(parentNodeElement);
            }
          }

          event.preventDefault();
          break;
        //right arrow

        case 39:
          if (!this.isExpanded()) {
            this.expand(event);
          }

          event.preventDefault();
          break;
        //left arrow

        case 37:
          if (this.isExpanded()) {
            this.collapse(event);
          }

          event.preventDefault();
          break;
        //enter

        case 13:
          this.onClick(event);
          event.preventDefault();
          break;
      }
    }
  }, {
    key: "findNextSiblingOfAncestor",
    value: function findNextSiblingOfAncestor(nodeElement) {
      var parentNodeElement = this.getParentNodeElement(nodeElement);

      if (parentNodeElement) {
        if (parentNodeElement.nextElementSibling) return parentNodeElement.nextElementSibling;else return this.findNextSiblingOfAncestor(parentNodeElement);
      } else {
        return null;
      }
    }
  }, {
    key: "findLastVisibleDescendant",
    value: function findLastVisibleDescendant(nodeElement) {
      var childrenListElement = nodeElement.children[1];

      if (childrenListElement) {
        var lastChildElement = childrenListElement.children[childrenListElement.children.length - 1];
        return this.findLastVisibleDescendant(lastChildElement);
      } else {
        return nodeElement;
      }
    }
  }, {
    key: "getParentNodeElement",
    value: function getParentNodeElement(nodeElement) {
      var parentNodeElement = nodeElement.parentElement.parentElement;
      return DomHandler$1.hasClass(parentNodeElement, 'p-treenode') ? parentNodeElement : null;
    }
  }, {
    key: "focusNode",
    value: function focusNode(element) {
      element.children[0].focus();
    }
  }, {
    key: "onClick",
    value: function onClick(event) {
      if (this.props.onClick) {
        this.props.onClick({
          originalEvent: event,
          node: this.props.node
        });
      }

      if (event.target.className && event.target.className.constructor === String && event.target.className.indexOf('p-tree-toggler') === 0 || this.props.disabled) {
        return;
      }

      if (this.props.selectionMode && this.props.node.selectable !== false) {
        var selectionKeys;

        if (this.isCheckboxSelectionMode()) {
          var checked = this.isChecked();
          selectionKeys = this.props.selectionKeys ? _objectSpread$1$1({}, this.props.selectionKeys) : {};

          if (checked) {
            if (this.props.propagateSelectionDown) this.propagateDown(this.props.node, false, selectionKeys);else delete selectionKeys[this.props.node.key];

            if (this.props.propagateSelectionUp && this.props.onPropagateUp) {
              this.props.onPropagateUp({
                originalEvent: event,
                check: false,
                selectionKeys: selectionKeys
              });
            }

            if (this.props.onUnselect) {
              this.props.onUnselect({
                originalEvent: event,
                node: this.props.node
              });
            }
          } else {
            if (this.props.propagateSelectionDown) this.propagateDown(this.props.node, true, selectionKeys);else selectionKeys[this.props.node.key] = {
              checked: true
            };

            if (this.props.propagateSelectionUp && this.props.onPropagateUp) {
              this.props.onPropagateUp({
                originalEvent: event,
                check: true,
                selectionKeys: selectionKeys
              });
            }

            if (this.props.onSelect) {
              this.props.onSelect({
                originalEvent: event,
                node: this.props.node
              });
            }
          }
        } else {
          var selected = this.isSelected();
          var metaSelection = this.nodeTouched ? false : this.props.metaKeySelection;

          if (metaSelection) {
            var metaKey = event.metaKey || event.ctrlKey;

            if (selected && metaKey) {
              if (this.isSingleSelectionMode()) {
                selectionKeys = null;
              } else {
                selectionKeys = _objectSpread$1$1({}, this.props.selectionKeys);
                delete selectionKeys[this.props.node.key];
              }

              if (this.props.onUnselect) {
                this.props.onUnselect({
                  originalEvent: event,
                  node: this.props.node
                });
              }
            } else {
              if (this.isSingleSelectionMode()) {
                selectionKeys = this.props.node.key;
              } else if (this.isMultipleSelectionMode()) {
                selectionKeys = !metaKey ? {} : this.props.selectionKeys ? _objectSpread$1$1({}, this.props.selectionKeys) : {};
                selectionKeys[this.props.node.key] = true;
              }

              if (this.props.onSelect) {
                this.props.onSelect({
                  originalEvent: event,
                  node: this.props.node
                });
              }
            }
          } else {
            if (this.isSingleSelectionMode()) {
              if (selected) {
                selectionKeys = null;

                if (this.props.onUnselect) {
                  this.props.onUnselect({
                    originalEvent: event,
                    node: this.props.node
                  });
                }
              } else {
                selectionKeys = this.props.node.key;

                if (this.props.onSelect) {
                  this.props.onSelect({
                    originalEvent: event,
                    node: this.props.node
                  });
                }
              }
            } else {
              if (selected) {
                selectionKeys = _objectSpread$1$1({}, this.props.selectionKeys);
                delete selectionKeys[this.props.node.key];

                if (this.props.onUnselect) {
                  this.props.onUnselect({
                    originalEvent: event,
                    node: this.props.node
                  });
                }
              } else {
                selectionKeys = this.props.selectionKeys ? _objectSpread$1$1({}, this.props.selectionKeys) : {};
                selectionKeys[this.props.node.key] = true;

                if (this.props.onSelect) {
                  this.props.onSelect({
                    originalEvent: event,
                    node: this.props.node
                  });
                }
              }
            }
          }
        }

        if (this.props.onSelectionChange) {
          this.props.onSelectionChange({
            originalEvent: event,
            value: selectionKeys
          });
        }
      }

      this.nodeTouched = false;
    }
  }, {
    key: "onDoubleClick",
    value: function onDoubleClick(event) {
      if (this.props.onDoubleClick) {
        this.props.onDoubleClick({
          originalEvent: event,
          node: this.props.node
        });
      }
    }
  }, {
    key: "onRightClick",
    value: function onRightClick(event) {
      if (this.props.disabled) {
        return;
      }

      DomHandler$1.clearSelection();

      if (this.props.onContextMenuSelectionChange) {
        this.props.onContextMenuSelectionChange({
          originalEvent: event,
          value: this.props.node.key
        });
      }

      if (this.props.onContextMenu) {
        this.props.onContextMenu({
          originalEvent: event,
          node: this.props.node
        });
      }
    }
  }, {
    key: "propagateUp",
    value: function propagateUp(event) {
      var check = event.check;
      var selectionKeys = event.selectionKeys;
      var checkedChildCount = 0;
      var childPartialSelected = false;

      var _iterator = _createForOfIteratorHelper$1$1(this.props.node.children),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;
          if (selectionKeys[child.key] && selectionKeys[child.key].checked) checkedChildCount++;else if (selectionKeys[child.key] && selectionKeys[child.key].partialChecked) childPartialSelected = true;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (check && checkedChildCount === this.props.node.children.length) {
        selectionKeys[this.props.node.key] = {
          checked: true,
          partialChecked: false
        };
      } else {
        if (!check) {
          delete selectionKeys[this.props.node.key];
        }

        if (childPartialSelected || checkedChildCount > 0 && checkedChildCount !== this.props.node.children.length) selectionKeys[this.props.node.key] = {
          checked: false,
          partialChecked: true
        };else delete selectionKeys[this.props.node.key];
      }

      if (this.props.propagateSelectionUp && this.props.onPropagateUp) {
        this.props.onPropagateUp(event);
      }
    }
  }, {
    key: "propagateDown",
    value: function propagateDown(node, check, selectionKeys) {
      if (check) selectionKeys[node.key] = {
        checked: true,
        partialChecked: false
      };else delete selectionKeys[node.key];

      if (node.children && node.children.length) {
        for (var i = 0; i < node.children.length; i++) {
          this.propagateDown(node.children[i], check, selectionKeys);
        }
      }
    }
  }, {
    key: "isSelected",
    value: function isSelected() {
      if (this.props.selectionMode && this.props.selectionKeys) return this.isSingleSelectionMode() ? this.props.selectionKeys === this.props.node.key : this.props.selectionKeys[this.props.node.key] !== undefined;else return false;
    }
  }, {
    key: "isChecked",
    value: function isChecked() {
      return this.props.selectionKeys ? this.props.selectionKeys[this.props.node.key] && this.props.selectionKeys[this.props.node.key].checked : false;
    }
  }, {
    key: "isPartialChecked",
    value: function isPartialChecked() {
      return this.props.selectionKeys ? this.props.selectionKeys[this.props.node.key] && this.props.selectionKeys[this.props.node.key].partialChecked : false;
    }
  }, {
    key: "isSingleSelectionMode",
    value: function isSingleSelectionMode() {
      return this.props.selectionMode && this.props.selectionMode === 'single';
    }
  }, {
    key: "isMultipleSelectionMode",
    value: function isMultipleSelectionMode() {
      return this.props.selectionMode && this.props.selectionMode === 'multiple';
    }
  }, {
    key: "isCheckboxSelectionMode",
    value: function isCheckboxSelectionMode() {
      return this.props.selectionMode && this.props.selectionMode === 'checkbox';
    }
  }, {
    key: "onTouchEnd",
    value: function onTouchEnd() {
      this.nodeTouched = true;
    }
  }, {
    key: "onDropPoint",
    value: function onDropPoint(event, position) {
      event.preventDefault();

      if (this.props.node.droppable !== false) {
        DomHandler$1.removeClass(event.target, 'p-treenode-droppoint-active');

        if (this.props.onDropPoint) {
          var dropIndex = position === -1 ? this.props.index : this.props.index + 1;
          this.props.onDropPoint({
            originalEvent: event,
            path: this.props.path,
            index: dropIndex,
            position: position
          });
        }
      }
    }
  }, {
    key: "onDropPointDragOver",
    value: function onDropPointDragOver(event) {
      if (event.dataTransfer.types[1] === this.props.dragdropScope.toLocaleLowerCase()) {
        event.dataTransfer.dropEffect = 'move';
        event.preventDefault();
      }
    }
  }, {
    key: "onDropPointDragEnter",
    value: function onDropPointDragEnter(event) {
      if (event.dataTransfer.types[1] === this.props.dragdropScope.toLocaleLowerCase()) {
        DomHandler$1.addClass(event.target, 'p-treenode-droppoint-active');
      }
    }
  }, {
    key: "onDropPointDragLeave",
    value: function onDropPointDragLeave(event) {
      if (event.dataTransfer.types[1] === this.props.dragdropScope.toLocaleLowerCase()) {
        DomHandler$1.removeClass(event.target, 'p-treenode-droppoint-active');
      }
    }
  }, {
    key: "onDrop",
    value: function onDrop(event) {
      if (this.props.dragdropScope && this.props.node.droppable !== false) {
        DomHandler$1.removeClass(this.contentElement, 'p-treenode-dragover');
        event.preventDefault();
        event.stopPropagation();

        if (this.props.onDrop) {
          this.props.onDrop({
            originalEvent: event,
            path: this.props.path,
            index: this.props.index
          });
        }
      }
    }
  }, {
    key: "onDragOver",
    value: function onDragOver(event) {
      if (event.dataTransfer.types[1] === this.props.dragdropScope.toLocaleLowerCase() && this.props.node.droppable !== false) {
        event.dataTransfer.dropEffect = 'move';
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }, {
    key: "onDragEnter",
    value: function onDragEnter(event) {
      if (event.dataTransfer.types[1] === this.props.dragdropScope.toLocaleLowerCase() && this.props.node.droppable !== false) {
        DomHandler$1.addClass(this.contentElement, 'p-treenode-dragover');
      }
    }
  }, {
    key: "onDragLeave",
    value: function onDragLeave(event) {
      if (event.dataTransfer.types[1] === this.props.dragdropScope.toLocaleLowerCase() && this.props.node.droppable !== false) {
        var rect = event.currentTarget.getBoundingClientRect();

        if (event.nativeEvent.x > rect.left + rect.width || event.nativeEvent.x < rect.left || event.nativeEvent.y >= Math.floor(rect.top + rect.height) || event.nativeEvent.y < rect.top) {
          DomHandler$1.removeClass(this.contentElement, 'p-treenode-dragover');
        }
      }
    }
  }, {
    key: "onDragStart",
    value: function onDragStart(event) {
      event.dataTransfer.setData("text", this.props.dragdropScope);
      event.dataTransfer.setData(this.props.dragdropScope, this.props.dragdropScope);

      if (this.props.onDragStart) {
        this.props.onDragStart({
          originalEvent: event,
          path: this.props.path,
          index: this.props.index
        });
      }
    }
  }, {
    key: "onDragEnd",
    value: function onDragEnd(event) {
      if (this.props.onDragEnd) {
        this.props.onDragEnd({
          originalEvent: event
        });
      }
    }
  }, {
    key: "renderLabel",
    value: function renderLabel() {
      var content = /*#__PURE__*/React.createElement("span", {
        className: "p-treenode-label"
      }, this.props.node.label);

      if (this.props.nodeTemplate) {
        var defaultContentOptions = {
          onTogglerClick: this.onTogglerClick,
          className: 'p-treenode-label',
          element: content,
          props: this.props,
          expanded: this.isExpanded()
        };
        content = ObjectUtils.getJSXElement(this.props.nodeTemplate, this.props.node, defaultContentOptions);
      }

      return content;
    }
  }, {
    key: "renderCheckbox",
    value: function renderCheckbox() {
      if (this.isCheckboxSelectionMode() && this.props.node.selectable !== false) {
        var checked = this.isChecked();
        var partialChecked = this.isPartialChecked();
        var className = classNames('p-checkbox-box', {
          'p-highlight': checked,
          'p-indeterminate': partialChecked,
          'p-disabled': this.props.disabled
        });
        var icon = classNames('p-checkbox-icon p-c', {
          'pi pi-check': checked,
          'pi pi-minus': partialChecked
        });
        return /*#__PURE__*/React.createElement("div", {
          className: "p-checkbox p-component"
        }, /*#__PURE__*/React.createElement("div", {
          className: className,
          role: "checkbox",
          "aria-checked": checked
        }, /*#__PURE__*/React.createElement("span", {
          className: icon
        })));
      }

      return null;
    }
  }, {
    key: "renderIcon",
    value: function renderIcon(expanded) {
      var icon = this.props.node.icon || (expanded ? this.props.node.expandedIcon : this.props.node.collapsedIcon);

      if (icon) {
        var className = classNames('p-treenode-icon', icon);
        return /*#__PURE__*/React.createElement("span", {
          className: className
        });
      }

      return null;
    }
  }, {
    key: "renderToggler",
    value: function renderToggler(expanded) {
      var iconClassName = classNames('p-tree-toggler-icon pi pi-fw', {
        'pi-chevron-right': !expanded,
        'pi-chevron-down': expanded
      });
      var content = /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-tree-toggler p-link",
        tabIndex: -1,
        onClick: this.onTogglerClick
      }, /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      }), /*#__PURE__*/React.createElement(Ripple, null));

      if (this.props.togglerTemplate) {
        var defaultContentOptions = {
          onClick: this.onTogglerClick,
          containerClassName: 'p-tree-toggler p-link',
          iconClassName: 'p-tree-toggler-icon',
          element: content,
          props: this.props,
          expanded: expanded
        };
        content = ObjectUtils.getJSXElement(this.props.togglerTemplate, this.props.node, defaultContentOptions);
      }

      return content;
    }
  }, {
    key: "renderDropPoint",
    value: function renderDropPoint(position) {
      var _this2 = this;

      if (this.props.dragdropScope) {
        return /*#__PURE__*/React.createElement("li", {
          className: "p-treenode-droppoint",
          onDrop: function onDrop(event) {
            return _this2.onDropPoint(event, position);
          },
          onDragOver: this.onDropPointDragOver,
          onDragEnter: this.onDropPointDragEnter,
          onDragLeave: this.onDropPointDragLeave
        });
      }

      return null;
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this3 = this;

      var selected = this.isSelected();
      var checked = this.isChecked();
      var className = classNames('p-treenode-content', this.props.node.className, {
        'p-treenode-selectable': this.props.selectionMode && this.props.node.selectable !== false,
        'p-highlight': this.isCheckboxSelectionMode() ? checked : selected,
        'p-highlight-contextmenu': this.props.contextMenuSelectionKey && this.props.contextMenuSelectionKey === this.props.node.key,
        'p-disabled': this.props.disabled
      });
      var expanded = this.isExpanded();
      var toggler = this.renderToggler(expanded);
      var checkbox = this.renderCheckbox();
      var icon = this.renderIcon(expanded);
      var label = this.renderLabel();
      var tabIndex = this.props.disabled ? undefined : 0;
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this3.contentElement = el;
        },
        className: className,
        style: this.props.node.style,
        onClick: this.onClick,
        onDoubleClick: this.onDoubleClick,
        onContextMenu: this.onRightClick,
        onTouchEnd: this.onTouchEnd,
        draggable: this.props.dragdropScope && this.props.node.draggable !== false && !this.props.disabled,
        onDrop: this.onDrop,
        onDragOver: this.onDragOver,
        onDragEnter: this.onDragEnter,
        onDragLeave: this.onDragLeave,
        onDragStart: this.onDragStart,
        onDragEnd: this.onDragEnd,
        tabIndex: tabIndex,
        onKeyDown: this.onNodeKeyDown,
        role: "treeitem",
        "aria-posinset": this.props.index + 1,
        "aria-expanded": this.isExpanded(),
        "aria-selected": checked || selected
      }, toggler, checkbox, icon, label);
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var _this4 = this;

      if (this.props.node.children && this.props.node.children.length && this.isExpanded()) {
        return /*#__PURE__*/React.createElement("ul", {
          className: "p-treenode-children",
          role: "group"
        }, this.props.node.children.map(function (childNode, index) {
          return /*#__PURE__*/React.createElement(UITreeNode, {
            key: childNode.key || childNode.label,
            node: childNode,
            parent: _this4.props.node,
            index: index,
            last: index === _this4.props.node.children.length - 1,
            path: _this4.props.path + '-' + index,
            disabled: _this4.props.disabled,
            selectionMode: _this4.props.selectionMode,
            selectionKeys: _this4.props.selectionKeys,
            onSelectionChange: _this4.props.onSelectionChange,
            metaKeySelection: _this4.props.metaKeySelection,
            propagateSelectionDown: _this4.props.propagateSelectionDown,
            propagateSelectionUp: _this4.props.propagateSelectionUp,
            contextMenuSelectionKey: _this4.props.contextMenuSelectionKey,
            onContextMenuSelectionChange: _this4.props.onContextMenuSelectionChange,
            onContextMenu: _this4.props.onContextMenu,
            onExpand: _this4.props.onExpand,
            onCollapse: _this4.props.onCollapse,
            onSelect: _this4.props.onSelect,
            onUnselect: _this4.props.onUnselect,
            expandedKeys: _this4.props.expandedKeys,
            onToggle: _this4.props.onToggle,
            onPropagateUp: _this4.propagateUp,
            nodeTemplate: _this4.props.nodeTemplate,
            togglerTemplate: _this4.props.togglerTemplate,
            isNodeLeaf: _this4.props.isNodeLeaf,
            dragdropScope: _this4.props.dragdropScope,
            onDragStart: _this4.props.onDragStart,
            onDragEnd: _this4.props.onDragEnd,
            onDrop: _this4.props.onDrop,
            onDropPoint: _this4.props.onDropPoint
          });
        }));
      }

      return null;
    }
  }, {
    key: "renderNode",
    value: function renderNode() {
      var className = classNames('p-treenode', {
        'p-treenode-leaf': this.isLeaf()
      }, this.props.node.className);
      var content = this.renderContent();
      var children = this.renderChildren();
      return /*#__PURE__*/React.createElement("li", {
        className: className,
        style: this.props.node.style
      }, content, children);
    }
  }, {
    key: "render",
    value: function render() {
      var node = this.renderNode();

      if (this.props.dragdropScope && !this.props.disabled) {
        var beforeDropPoint = this.renderDropPoint(-1);
        var afterDropPoint = this.props.last ? this.renderDropPoint(1) : null;
        return /*#__PURE__*/React.createElement(React.Fragment, null, beforeDropPoint, node, afterDropPoint);
      } else {
        return node;
      }
    }
  }]);

  return UITreeNode;
}(Component);

_defineProperty$2(UITreeNode, "defaultProps", {
  node: null,
  index: null,
  last: null,
  parent: null,
  path: null,
  disabled: false,
  selectionMode: null,
  selectionKeys: null,
  contextMenuSelectionKey: null,
  metaKeySelection: true,
  expandedKeys: null,
  propagateSelectionUp: true,
  propagateSelectionDown: true,
  dragdropScope: null,
  ariaLabel: null,
  ariaLabelledBy: null,
  nodeTemplate: null,
  togglerTemplate: null,
  isNodeLeaf: null,
  onSelect: null,
  onUnselect: null,
  onExpand: null,
  onCollapse: null,
  onToggle: null,
  onSelectionChange: null,
  onContextMenuSelectionChange: null,
  onPropagateUp: null,
  onDragStart: null,
  onDragEnd: null,
  onDrop: null,
  onDropPoint: null,
  onContextMenu: null,
  onNodeClick: null,
  onNodeDoubleClick: null
});

function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createForOfIteratorHelper$5(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$6(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
}

function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$2(this, result);
  };
}

function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var Tree$1 = /*#__PURE__*/function (_Component) {
  _inherits$2(Tree, _Component);

  var _super = _createSuper$8(Tree);

  function Tree(props) {
    var _this;

    _classCallCheck$2(this, Tree);

    _this = _super.call(this, props);
    _this.state = {};

    if (!_this.props.onFilterValueChange) {
      _this.state['filterValue'] = '';
    }

    if (!_this.props.onToggle) {
      _this.state['expandedKeys'] = _this.props.expandedKeys;
    }

    _this.isNodeLeaf = _this.isNodeLeaf.bind(_assertThisInitialized$2(_this));
    _this.onToggle = _this.onToggle.bind(_assertThisInitialized$2(_this));
    _this.onDragStart = _this.onDragStart.bind(_assertThisInitialized$2(_this));
    _this.onDragEnd = _this.onDragEnd.bind(_assertThisInitialized$2(_this));
    _this.onDrop = _this.onDrop.bind(_assertThisInitialized$2(_this));
    _this.onDropPoint = _this.onDropPoint.bind(_assertThisInitialized$2(_this));
    _this.onFilterInputChange = _this.onFilterInputChange.bind(_assertThisInitialized$2(_this));
    _this.onFilterInputKeyDown = _this.onFilterInputKeyDown.bind(_assertThisInitialized$2(_this));
    return _this;
  }

  _createClass$2(Tree, [{
    key: "getFilterValue",
    value: function getFilterValue() {
      return this.props.onFilterValueChange ? this.props.filterValue : this.state.filterValue;
    }
  }, {
    key: "getExpandedKeys",
    value: function getExpandedKeys() {
      return this.props.onToggle ? this.props.expandedKeys : this.state.expandedKeys;
    }
  }, {
    key: "getRootNode",
    value: function getRootNode() {
      return this.props.filter && this.filteredNodes ? this.filteredNodes : this.props.value;
    }
  }, {
    key: "onToggle",
    value: function onToggle(event) {
      if (this.props.onToggle) {
        this.props.onToggle(event);
      } else {
        this.setState({
          expandedKeys: event.value
        });
      }
    }
  }, {
    key: "onDragStart",
    value: function onDragStart(event) {
      this.dragState = {
        path: event.path,
        index: event.index
      };
    }
  }, {
    key: "onDragEnd",
    value: function onDragEnd() {
      this.dragState = null;
    }
  }, {
    key: "onDrop",
    value: function onDrop(event) {
      if (this.validateDropNode(this.dragState.path, event.path)) {
        var value = JSON.parse(JSON.stringify(this.props.value));
        var dragPaths = this.dragState.path.split('-');
        dragPaths.pop();
        var dragNodeParent = this.findNode(value, dragPaths);
        var dragNode = dragNodeParent ? dragNodeParent.children[this.dragState.index] : value[this.dragState.index];
        var dropNode = this.findNode(value, event.path.split('-'));
        if (dropNode.children) dropNode.children.push(dragNode);else dropNode.children = [dragNode];
        if (dragNodeParent) dragNodeParent.children.splice(this.dragState.index, 1);else value.splice(this.dragState.index, 1);

        if (this.props.onDragDrop) {
          this.props.onDragDrop({
            originalEvent: event.originalEvent,
            value: value,
            dragNode: dragNode,
            dropNode: dropNode,
            dropIndex: event.index
          });
        }
      }
    }
  }, {
    key: "onDropPoint",
    value: function onDropPoint(event) {
      if (this.validateDropPoint(event)) {
        var value = JSON.parse(JSON.stringify(this.props.value));
        var dragPaths = this.dragState.path.split('-');
        dragPaths.pop();
        var dropPaths = event.path.split('-');
        dropPaths.pop();
        var dragNodeParent = this.findNode(value, dragPaths);
        var dropNodeParent = this.findNode(value, dropPaths);
        var dragNode = dragNodeParent ? dragNodeParent.children[this.dragState.index] : value[this.dragState.index];
        var siblings = this.areSiblings(this.dragState.path, event.path);
        if (dragNodeParent) dragNodeParent.children.splice(this.dragState.index, 1);else value.splice(this.dragState.index, 1);

        if (event.position < 0) {
          var dropIndex = siblings ? this.dragState.index > event.index ? event.index : event.index - 1 : event.index;
          if (dropNodeParent) dropNodeParent.children.splice(dropIndex, 0, dragNode);else value.splice(dropIndex, 0, dragNode);
        } else {
          if (dropNodeParent) dropNodeParent.children.push(dragNode);else value.push(dragNode);
        }

        if (this.props.onDragDrop) {
          this.props.onDragDrop({
            originalEvent: event.originalEvent,
            value: value,
            dragNode: dragNode,
            dropNode: dropNodeParent,
            dropIndex: event.index
          });
        }
      }
    }
  }, {
    key: "validateDrop",
    value: function validateDrop(dragPath, dropPath) {
      if (!dragPath) {
        return false;
      } else {
        //same node
        if (dragPath === dropPath) {
          return false;
        } //parent dropped on an descendant


        if (dropPath.indexOf(dragPath) === 0) {
          return false;
        }

        return true;
      }
    }
  }, {
    key: "validateDropNode",
    value: function validateDropNode(dragPath, dropPath) {
      var validateDrop = this.validateDrop(dragPath, dropPath);

      if (validateDrop) {
        //child dropped on parent
        if (dragPath.indexOf('-') > 0 && dragPath.substring(0, dragPath.lastIndexOf('-')) === dropPath) {
          return false;
        }

        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "validateDropPoint",
    value: function validateDropPoint(event) {
      var validateDrop = this.validateDrop(this.dragState.path, event.path);

      if (validateDrop) {
        //child dropped to next sibling's drop point
        if (event.position === -1 && this.areSiblings(this.dragState.path, event.path) && this.dragState.index + 1 === event.index) {
          return false;
        }

        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "areSiblings",
    value: function areSiblings(path1, path2) {
      if (path1.length === 1 && path2.length === 1) return true;else return path1.substring(0, path1.lastIndexOf('-')) === path2.substring(0, path2.lastIndexOf('-'));
    }
  }, {
    key: "findNode",
    value: function findNode(value, path) {
      if (path.length === 0) {
        return null;
      } else {
        var index = parseInt(path[0], 10);
        var nextSearchRoot = value.children ? value.children[index] : value[index];

        if (path.length === 1) {
          return nextSearchRoot;
        } else {
          path.shift();
          return this.findNode(nextSearchRoot, path);
        }
      }
    }
  }, {
    key: "isNodeLeaf",
    value: function isNodeLeaf(node) {
      return node.leaf === false ? false : !(node.children && node.children.length);
    }
  }, {
    key: "onFilterInputKeyDown",
    value: function onFilterInputKeyDown(event) {
      //enter
      if (event.which === 13) {
        event.preventDefault();
      }
    }
  }, {
    key: "onFilterInputChange",
    value: function onFilterInputChange(event) {
      this.filterChanged = true;
      var filterValue = event.target.value;

      if (this.props.onFilterValueChange) {
        this.props.onFilterValueChange({
          originalEvent: event,
          value: filterValue
        });
      } else {
        this.setState({
          filterValue: filterValue
        });
      }
    }
  }, {
    key: "filter",
    value: function filter(value) {
      this.setState({
        filterValue: ObjectUtils.isNotEmpty(value) ? value : ''
      }, this._filter);
    }
  }, {
    key: "_filter",
    value: function _filter() {
      if (!this.filterChanged) {
        return;
      }

      var filterValue = this.getFilterValue();

      if (ObjectUtils.isEmpty(filterValue)) {
        this.filteredNodes = this.props.value;
      } else {
        this.filteredNodes = [];
        var searchFields = this.props.filterBy.split(',');
        var filterText = filterValue.toLocaleLowerCase(this.props.filterLocale);
        var isStrictMode = this.props.filterMode === 'strict';

        var _iterator = _createForOfIteratorHelper$5(this.props.value),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var node = _step.value;

            var copyNode = _objectSpread$4({}, node);

            var paramsWithoutNode = {
              searchFields: searchFields,
              filterText: filterText,
              isStrictMode: isStrictMode
            };

            if (isStrictMode && (this.findFilteredNodes(copyNode, paramsWithoutNode) || this.isFilterMatched(copyNode, paramsWithoutNode)) || !isStrictMode && (this.isFilterMatched(copyNode, paramsWithoutNode) || this.findFilteredNodes(copyNode, paramsWithoutNode))) {
              this.filteredNodes.push(copyNode);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      this.filterChanged = false;
    }
  }, {
    key: "findFilteredNodes",
    value: function findFilteredNodes(node, paramsWithoutNode) {
      if (node) {
        var matched = false;

        if (node.children) {
          var childNodes = _toConsumableArray$1(node.children);

          node.children = [];

          var _iterator2 = _createForOfIteratorHelper$5(childNodes),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var childNode = _step2.value;

              var copyChildNode = _objectSpread$4({}, childNode);

              if (this.isFilterMatched(copyChildNode, paramsWithoutNode)) {
                matched = true;
                node.children.push(copyChildNode);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }

        if (matched) {
          node.expanded = true;
          return true;
        }
      }
    }
  }, {
    key: "isFilterMatched",
    value: function isFilterMatched(node, _ref) {
      var searchFields = _ref.searchFields,
          filterText = _ref.filterText,
          isStrictMode = _ref.isStrictMode;
      var matched = false;

      var _iterator3 = _createForOfIteratorHelper$5(searchFields),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var field = _step3.value;
          var fieldValue = String(ObjectUtils.resolveFieldData(node, field)).toLocaleLowerCase(this.props.filterLocale);

          if (fieldValue.indexOf(filterText) > -1) {
            matched = true;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      if (!matched || isStrictMode && !this.isNodeLeaf(node)) {
        matched = this.findFilteredNodes(node, {
          searchFields: searchFields,
          filterText: filterText,
          isStrictMode: isStrictMode
        }) || matched;
      }

      return matched;
    }
  }, {
    key: "renderRootChild",
    value: function renderRootChild(node, index, last) {
      return /*#__PURE__*/React.createElement(UITreeNode, {
        key: node.key || node.label,
        node: node,
        index: index,
        last: last,
        path: String(index),
        disabled: this.props.disabled,
        selectionMode: this.props.selectionMode,
        selectionKeys: this.props.selectionKeys,
        onSelectionChange: this.props.onSelectionChange,
        metaKeySelection: this.props.metaKeySelection,
        contextMenuSelectionKey: this.props.contextMenuSelectionKey,
        onContextMenuSelectionChange: this.props.onContextMenuSelectionChange,
        onContextMenu: this.props.onContextMenu,
        propagateSelectionDown: this.props.propagateSelectionDown,
        propagateSelectionUp: this.props.propagateSelectionUp,
        onExpand: this.props.onExpand,
        onCollapse: this.props.onCollapse,
        onSelect: this.props.onSelect,
        onUnselect: this.props.onUnselect,
        expandedKeys: this.getExpandedKeys(),
        onToggle: this.onToggle,
        nodeTemplate: this.props.nodeTemplate,
        togglerTemplate: this.props.togglerTemplate,
        isNodeLeaf: this.isNodeLeaf,
        dragdropScope: this.props.dragdropScope,
        onDragStart: this.onDragStart,
        onDragEnd: this.onDragEnd,
        onDrop: this.onDrop,
        onDropPoint: this.onDropPoint,
        onNodeClick: this.props.onNodeClick,
        onNodeDoubleClick: this.props.onNodeDoubleClick
      });
    }
  }, {
    key: "renderRootChildren",
    value: function renderRootChildren() {
      var _this2 = this;

      if (this.props.filter) {
        this.filterChanged = true;

        this._filter();
      }

      var value = this.getRootNode();
      return value.map(function (node, index) {
        return _this2.renderRootChild(node, index, index === value.length - 1);
      });
    }
  }, {
    key: "renderModel",
    value: function renderModel() {
      if (this.props.value) {
        var rootNodes = this.renderRootChildren();
        var contentClass = classNames('p-tree-container', this.props.contentClassName);
        return /*#__PURE__*/React.createElement("ul", {
          className: contentClass,
          role: "tree",
          "aria-label": this.props.ariaLabel,
          "aria-labelledby": this.props.ariaLabelledBy,
          style: this.props.contentStyle
        }, rootNodes);
      }

      return null;
    }
  }, {
    key: "renderLoader",
    value: function renderLoader() {
      if (this.props.loading) {
        var icon = classNames('p-tree-loading-icon pi-spin', this.props.loadingIcon);
        return /*#__PURE__*/React.createElement("div", {
          className: "p-tree-loading-overlay p-component-overlay"
        }, /*#__PURE__*/React.createElement("i", {
          className: icon
        }));
      }

      return null;
    }
  }, {
    key: "renderFilter",
    value: function renderFilter() {
      if (this.props.filter) {
        var filterValue = this.getFilterValue();
        filterValue = ObjectUtils.isNotEmpty(filterValue) ? filterValue : '';
        return /*#__PURE__*/React.createElement("div", {
          className: "p-tree-filter-container"
        }, /*#__PURE__*/React.createElement("input", {
          type: "text",
          value: filterValue,
          autoComplete: "off",
          className: "p-tree-filter p-inputtext p-component",
          placeholder: this.props.filterPlaceholder,
          onKeyDown: this.onFilterInputKeyDown,
          onChange: this.onFilterInputChange,
          disabled: this.props.disabled
        }), /*#__PURE__*/React.createElement("span", {
          className: "p-tree-filter-icon pi pi-search"
        }));
      }

      return null;
    }
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      if (this.props.showHeader) {
        var filterElement = this.renderFilter();
        var content = filterElement;

        if (this.props.header) {
          var defaultContentOptions = {
            filterContainerClassName: 'p-tree-filter-container',
            filterIconClasssName: 'p-tree-filter-icon pi pi-search',
            filterInput: {
              className: 'p-tree-filter p-inputtext p-component',
              onKeyDown: this.onFilterInputKeyDown,
              onChange: this.onFilterInputChange
            },
            filterElement: filterElement,
            element: content,
            props: this.props
          };
          content = ObjectUtils.getJSXElement(this.props.header, defaultContentOptions);
        }

        return /*#__PURE__*/React.createElement("div", {
          className: "p-tree-header"
        }, content);
      }

      return null;
    }
  }, {
    key: "renderFooter",
    value: function renderFooter() {
      var content = ObjectUtils.getJSXElement(this.props.footer, this.props);
      return /*#__PURE__*/React.createElement("div", {
        className: "p-tree-footer"
      }, content);
    }
  }, {
    key: "render",
    value: function render() {
      var className = classNames('p-tree p-component', this.props.className, {
        'p-tree-selectable': this.props.selectionMode,
        'p-tree-loading': this.props.loading,
        'p-disabled': this.props.disabled
      });
      var loader = this.renderLoader();
      var content = this.renderModel();
      var header = this.renderHeader();
      var footer = this.renderFooter();
      return /*#__PURE__*/React.createElement("div", {
        id: this.props.id,
        className: className,
        style: this.props.style
      }, loader, header, content, footer);
    }
  }]);

  return Tree;
}(Component);

_defineProperty$2(Tree$1, "defaultProps", {
  id: null,
  value: null,
  disabled: false,
  selectionMode: null,
  selectionKeys: null,
  onSelectionChange: null,
  contextMenuSelectionKey: null,
  onContextMenuSelectionChange: null,
  expandedKeys: null,
  style: null,
  className: null,
  contentStyle: null,
  contentClassName: null,
  metaKeySelection: true,
  propagateSelectionUp: true,
  propagateSelectionDown: true,
  loading: false,
  loadingIcon: 'pi pi-spinner',
  dragdropScope: null,
  header: null,
  footer: null,
  showHeader: true,
  filter: false,
  filterValue: null,
  filterBy: 'label',
  filterMode: 'lenient',
  filterPlaceholder: null,
  filterLocale: undefined,
  nodeTemplate: null,
  togglerTemplate: null,
  onSelect: null,
  onUnselect: null,
  onExpand: null,
  onCollapse: null,
  onToggle: null,
  onDragDrop: null,
  onContextMenu: null,
  onFilterValueChange: null,
  onNodeClick: null,
  onNodeDoubleClick: null
});

var Tree = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      selectionMode = _ref.selectionMode,
      selectionKeys = _ref.selectionKeys,
      expandedKeys = _ref.expandedKeys,
      style = _ref.style,
      className = _ref.className,
      contentStyle = _ref.contentStyle,
      contentClassName = _ref.contentClassName,
      _ref$metaKeySelection = _ref.metaKeySelection,
      metaKeySelection = _ref$metaKeySelection === void 0 ? true : _ref$metaKeySelection,
      _ref$propagateSelecti = _ref.propagateSelectionUp,
      propagateSelectionUp = _ref$propagateSelecti === void 0 ? true : _ref$propagateSelecti,
      _ref$propagateSelecti2 = _ref.propagateSelectionDown,
      propagateSelectionDown = _ref$propagateSelecti2 === void 0 ? true : _ref$propagateSelecti2,
      _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? false : _ref$loading,
      dragdropScope = _ref.dragdropScope,
      header = _ref.header,
      footer = _ref.footer,
      ariaLabel = _ref.ariaLabel,
      ariaLabelledBy = _ref.ariaLabelledBy,
      nodeTemplate = _ref.nodeTemplate,
      togglerTemplate = _ref.togglerTemplate,
      _ref$showHeader = _ref.showHeader,
      showHeader = _ref$showHeader === void 0 ? true : _ref$showHeader,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      onSelect = _ref.onSelect,
      onUnselect = _ref.onUnselect,
      onExpand = _ref.onExpand,
      onCollapse = _ref.onCollapse,
      onSelectionChange = _ref.onSelectionChange,
      onToggle = _ref.onToggle,
      onDragDrop = _ref.onDragDrop,
      onNodeClick = _ref.onNodeClick;
  return /*#__PURE__*/React.createElement(Tree$1, {
    ref: ref,
    id: id,
    value: value,
    selectionMode: selectionMode,
    selectionKeys: selectionKeys,
    expandedKeys: expandedKeys,
    style: style,
    className: className,
    contentStyle: contentStyle,
    contentClassName: contentClassName,
    metaKeySelection: metaKeySelection,
    propagateSelectionUp: propagateSelectionUp,
    propagateSelectionDown: propagateSelectionDown,
    loading: loading,
    dragdropScope: dragdropScope,
    header: header,
    footer: footer,
    ariaLabel: ariaLabel,
    ariaLabelledBy: ariaLabelledBy,
    nodeTemplate: nodeTemplate,
    togglerTemplate: togglerTemplate,
    showHeader: showHeader,
    disabled: disabled,
    onSelect: onSelect,
    onUnselect: onUnselect,
    onExpand: onExpand,
    onCollapse: onCollapse,
    onSelectionChange: onSelectionChange,
    onToggle: onToggle,
    onDragDrop: onDragDrop,
    onNodeClick: onNodeClick
  });
});

function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$5(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$5(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread();
}

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized$1(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$1(o, p);
}

function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}

function _typeof$1(obj) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$1(obj);
}

function _possibleConstructorReturn$1(self, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized$1(self);
}

function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$1(o);
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createForOfIteratorHelper$4(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$4(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
}

function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$1(this, result);
  };
}

function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TreeTableHeader = /*#__PURE__*/function (_Component) {
  _inherits$1(TreeTableHeader, _Component);

  var _super = _createSuper$6(TreeTableHeader);

  function TreeTableHeader(props) {
    var _this;

    _classCallCheck$1(this, TreeTableHeader);

    _this = _super.call(this, props);
    _this.state = {
      badgeVisible: false
    };
    _this.onFilterInput = _this.onFilterInput.bind(_assertThisInitialized$1(_this));
    return _this;
  }

  _createClass$1(TreeTableHeader, [{
    key: "onHeaderClick",
    value: function onHeaderClick(event, column) {
      if (column.props.sortable) {
        var targetNode = event.target;

        if (DomHandler$1.hasClass(targetNode, 'p-sortable-column') || DomHandler$1.hasClass(targetNode, 'p-column-title') || DomHandler$1.hasClass(targetNode, 'p-sortable-column-icon') || DomHandler$1.hasClass(targetNode.parentElement, 'p-sortable-column-icon')) {
          this.props.onSort({
            originalEvent: event,
            sortField: column.props.sortField || column.props.field,
            sortFunction: column.props.sortFunction,
            sortable: column.props.sortable
          });
          DomHandler$1.clearSelection();
        }
      }
    }
  }, {
    key: "onHeaderMouseDown",
    value: function onHeaderMouseDown(event, column) {
      if (this.props.reorderableColumns && column.props.reorderable) {
        if (event.target.nodeName !== 'INPUT') event.currentTarget.draggable = true;else if (event.target.nodeName === 'INPUT') event.currentTarget.draggable = false;
      }
    }
  }, {
    key: "onHeaderKeyDown",
    value: function onHeaderKeyDown(event, column) {
      if (event.key === 'Enter') {
        this.onHeaderClick(event, column);
        event.preventDefault();
      }
    }
  }, {
    key: "getMultiSortMetaDataIndex",
    value: function getMultiSortMetaDataIndex(column) {
      if (this.props.multiSortMeta) {
        for (var i = 0; i < this.props.multiSortMeta.length; i++) {
          if (this.props.multiSortMeta[i].field === column.props.field) {
            return i;
          }
        }
      }

      return -1;
    }
  }, {
    key: "onResizerMouseDown",
    value: function onResizerMouseDown(event, column) {
      if (this.props.resizableColumns && this.props.onResizeStart) {
        this.props.onResizeStart({
          originalEvent: event,
          columnEl: event.target.parentElement,
          column: column
        });
      }
    }
  }, {
    key: "onDragStart",
    value: function onDragStart(event, column) {
      if (this.props.onDragStart) {
        this.props.onDragStart({
          originalEvent: event,
          column: column
        });
      }
    }
  }, {
    key: "onDragOver",
    value: function onDragOver(event, column) {
      if (this.props.onDragOver) {
        this.props.onDragOver({
          originalEvent: event,
          column: column
        });
      }
    }
  }, {
    key: "onDragLeave",
    value: function onDragLeave(event, column) {
      if (this.props.onDragLeave) {
        this.props.onDragLeave({
          originalEvent: event,
          column: column
        });
      }
    }
  }, {
    key: "onDrop",
    value: function onDrop(event, column) {
      if (this.props.onDrop) {
        this.props.onDrop({
          originalEvent: event,
          column: column
        });
      }
    }
  }, {
    key: "onFilterInput",
    value: function onFilterInput(e, column) {
      var _this2 = this;

      if (column.props.filter && this.props.onFilter) {
        if (this.filterTimeout) {
          clearTimeout(this.filterTimeout);
        }

        var filterValue = e.target.value;
        this.filterTimeout = setTimeout(function () {
          _this2.props.onFilter({
            value: filterValue,
            field: column.props.field,
            matchMode: column.props.filterMatchMode || 'startsWith'
          });

          _this2.filterTimeout = null;
        }, this.props.filterDelay);
      }
    }
  }, {
    key: "hasColumnFilter",
    value: function hasColumnFilter(columns) {
      if (columns) {
        var _iterator = _createForOfIteratorHelper$4(columns),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var col = _step.value;

            if (col.props.filter) {
              return true;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return false;
    }
  }, {
    key: "renderSortIcon",
    value: function renderSortIcon(column, sorted, sortOrder) {
      if (column.props.sortable) {
        var sortIcon = sorted ? sortOrder < 0 ? 'pi-sort-amount-down' : 'pi-sort-amount-up-alt' : 'pi-sort-alt';
        var sortIconClassName = classNames('p-sortable-column-icon', 'pi pi-fw', sortIcon);
        return /*#__PURE__*/React.createElement("span", {
          className: sortIconClassName
        });
      } else {
        return null;
      }
    }
  }, {
    key: "renderResizer",
    value: function renderResizer(column) {
      var _this3 = this;

      if (this.props.resizableColumns) {
        return /*#__PURE__*/React.createElement("span", {
          className: "p-column-resizer p-clickable",
          onMouseDown: function onMouseDown(e) {
            return _this3.onResizerMouseDown(e, column);
          }
        });
      } else {
        return null;
      }
    }
  }, {
    key: "getAriaSort",
    value: function getAriaSort(column, sorted, sortOrder) {
      if (column.props.sortable) {
        var sortIcon = sorted ? sortOrder < 0 ? 'pi-sort-down' : 'pi-sort-up' : 'pi-sort';
        if (sortIcon === 'pi-sort-down') return 'descending';else if (sortIcon === 'pi-sort-up') return 'ascending';else return 'none';
      } else {
        return null;
      }
    }
  }, {
    key: "renderSortBadge",
    value: function renderSortBadge(sortMetaDataIndex) {
      if (sortMetaDataIndex !== -1 && this.state.badgeVisible) {
        return /*#__PURE__*/React.createElement("span", {
          className: "p-sortable-column-badge"
        }, sortMetaDataIndex + 1);
      }

      return null;
    }
  }, {
    key: "renderHeaderCell",
    value: function renderHeaderCell(column, options) {
      var _this4 = this;

      var filterElement;

      if (column.props.filter && options.renderFilter) {
        filterElement = column.props.filterElement || /*#__PURE__*/React.createElement(InputText$1, {
          onInput: function onInput(e) {
            return _this4.onFilterInput(e, column);
          },
          type: this.props.filterType,
          defaultValue: this.props.filters && this.props.filters[column.props.field] ? this.props.filters[column.props.field].value : null,
          className: "p-column-filter",
          placeholder: column.props.filterPlaceholder,
          maxLength: column.props.filterMaxLength
        });
      }

      if (options.filterOnly) {
        return /*#__PURE__*/React.createElement("th", {
          key: column.props.columnKey || column.props.field || options.index,
          className: classNames('p-filter-column', column.props.filterHeaderClassName),
          style: column.props.filterHeaderStyle || column.props.style,
          rowSpan: column.props.rowSpan,
          colSpan: column.props.colSpan
        }, filterElement);
      } else {
        var sortMetaDataIndex = this.getMultiSortMetaDataIndex(column);
        var multiSortMetaData = sortMetaDataIndex !== -1 ? this.props.multiSortMeta[sortMetaDataIndex] : null;
        var singleSorted = column.props.field === this.props.sortField;
        var multipleSorted = multiSortMetaData !== null;
        var sorted = column.props.sortable && (singleSorted || multipleSorted);
        var sortOrder = 0;
        if (singleSorted) sortOrder = this.props.sortOrder;else if (multipleSorted) sortOrder = multiSortMetaData.order;
        var sortIconElement = this.renderSortIcon(column, sorted, sortOrder);
        var ariaSortData = this.getAriaSort(column, sorted, sortOrder);
        var sortBadge = this.renderSortBadge(sortMetaDataIndex);
        var className = classNames(column.props.headerClassName || column.props.className, {
          'p-sortable-column': column.props.sortable,
          'p-highlight': sorted,
          'p-resizable-column': this.props.resizableColumns
        });
        var resizer = this.renderResizer(column);
        return /*#__PURE__*/React.createElement("th", {
          key: column.columnKey || column.field || options.index,
          className: className,
          style: column.props.headerStyle || column.props.style,
          tabIndex: column.props.sortable ? this.props.tabIndex : null,
          onClick: function onClick(e) {
            return _this4.onHeaderClick(e, column);
          },
          onMouseDown: function onMouseDown(e) {
            return _this4.onHeaderMouseDown(e, column);
          },
          onKeyDown: function onKeyDown(e) {
            return _this4.onHeaderKeyDown(e, column);
          },
          rowSpan: column.props.rowSpan,
          colSpan: column.props.colSpan,
          "aria-sort": ariaSortData,
          onDragStart: function onDragStart(e) {
            return _this4.onDragStart(e, column);
          },
          onDragOver: function onDragOver(e) {
            return _this4.onDragOver(e, column);
          },
          onDragLeave: function onDragLeave(e) {
            return _this4.onDragLeave(e, column);
          },
          onDrop: function onDrop(e) {
            return _this4.onDrop(e, column);
          }
        }, resizer, /*#__PURE__*/React.createElement("span", {
          className: "p-column-title"
        }, column.props.header), sortIconElement, sortBadge, filterElement);
      }
    }
  }, {
    key: "renderHeaderRow",
    value: function renderHeaderRow(row, index) {
      var _this5 = this;

      var rowColumns = React.Children.toArray(row.props.children);
      var rowHeaderCells = rowColumns.map(function (col, i) {
        return _this5.renderHeaderCell(col, {
          index: i,
          filterOnly: false,
          renderFilter: true
        });
      });
      return /*#__PURE__*/React.createElement("tr", {
        key: index
      }, rowHeaderCells);
    }
  }, {
    key: "renderColumnGroup",
    value: function renderColumnGroup() {
      var _this6 = this;

      var rows = React.Children.toArray(this.props.columnGroup.props.children);
      return rows.map(function (row, i) {
        return _this6.renderHeaderRow(row, i);
      });
    }
  }, {
    key: "renderColumns",
    value: function renderColumns(columns) {
      var _this7 = this;

      if (columns) {
        if (this.hasColumnFilter(columns)) {
          return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("tr", null, columns.map(function (col, i) {
            return _this7.renderHeaderCell(col, {
              index: i,
              filterOnly: false,
              renderFilter: false
            });
          })), /*#__PURE__*/React.createElement("tr", null, columns.map(function (col, i) {
            return _this7.renderHeaderCell(col, {
              index: i,
              filterOnly: true,
              renderFilter: true
            });
          })));
        } else {
          return /*#__PURE__*/React.createElement("tr", null, columns.map(function (col, i) {
            return _this7.renderHeaderCell(col, {
              index: i,
              filterOnly: false,
              renderFilter: false
            });
          }));
        }
      } else {
        return null;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var content = this.props.columnGroup ? this.renderColumnGroup() : this.renderColumns(this.props.columns);
      return /*#__PURE__*/React.createElement("thead", {
        className: "p-treetable-thead"
      }, content);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      return {
        badgeVisible: nextProps.multiSortMeta && nextProps.multiSortMeta.length > 1
      };
    }
  }]);

  return TreeTableHeader;
}(Component);

function _createForOfIteratorHelper$3(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$3(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
}

function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var DomHandler = /*#__PURE__*/function () {
  function DomHandler() {
    _classCallCheck$1(this, DomHandler);
  }

  _createClass$1(DomHandler, null, [{
    key: "innerWidth",
    value: function innerWidth(el) {
      if (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
      }

      return 0;
    }
  }, {
    key: "width",
    value: function width(el) {
      if (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
      }

      return 0;
    }
  }, {
    key: "getBrowserLanguage",
    value: function getBrowserLanguage() {
      return navigator.userLanguage || navigator.languages && navigator.languages.length && navigator.languages[0] || navigator.language || navigator.browserLanguage || navigator.systemLanguage || 'en';
    }
  }, {
    key: "getWindowScrollTop",
    value: function getWindowScrollTop() {
      var doc = document.documentElement;
      return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    }
  }, {
    key: "getWindowScrollLeft",
    value: function getWindowScrollLeft() {
      var doc = document.documentElement;
      return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    }
  }, {
    key: "getOuterWidth",
    value: function getOuterWidth(el, margin) {
      if (el) {
        var width = el.offsetWidth || el.getBoundingClientRect().width;

        if (margin) {
          var style = getComputedStyle(el);
          width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }

        return width;
      }

      return 0;
    }
  }, {
    key: "getOuterHeight",
    value: function getOuterHeight(el, margin) {
      if (el) {
        var height = el.offsetHeight || el.getBoundingClientRect().height;

        if (margin) {
          var style = getComputedStyle(el);
          height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }

        return height;
      }

      return 0;
    }
  }, {
    key: "getClientHeight",
    value: function getClientHeight(el, margin) {
      if (el) {
        var height = el.clientHeight;

        if (margin) {
          var style = getComputedStyle(el);
          height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }

        return height;
      }

      return 0;
    }
  }, {
    key: "getClientWidth",
    value: function getClientWidth(el, margin) {
      if (el) {
        var width = el.clientWidth;

        if (margin) {
          var style = getComputedStyle(el);
          width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }

        return width;
      }

      return 0;
    }
  }, {
    key: "getViewport",
    value: function getViewport() {
      var win = window,
          d = document,
          e = d.documentElement,
          g = d.getElementsByTagName('body')[0],
          w = win.innerWidth || e.clientWidth || g.clientWidth,
          h = win.innerHeight || e.clientHeight || g.clientHeight;
      return {
        width: w,
        height: h
      };
    }
  }, {
    key: "getOffset",
    value: function getOffset(el) {
      if (el) {
        var rect = el.getBoundingClientRect();
        return {
          top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
          left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0)
        };
      }

      return {
        top: 'auto',
        left: 'auto'
      };
    }
  }, {
    key: "index",
    value: function index(element) {
      if (element) {
        var children = element.parentNode.childNodes;
        var num = 0;

        for (var i = 0; i < children.length; i++) {
          if (children[i] === element) return num;
          if (children[i].nodeType === 1) num++;
        }
      }

      return -1;
    }
  }, {
    key: "addMultipleClasses",
    value: function addMultipleClasses(element, className) {
      if (element && className) {
        if (element.classList) {
          var styles = className.split(' ');

          for (var i = 0; i < styles.length; i++) {
            element.classList.add(styles[i]);
          }
        } else {
          var _styles = className.split(' ');

          for (var _i = 0; _i < _styles.length; _i++) {
            element.className += ' ' + _styles[_i];
          }
        }
      }
    }
  }, {
    key: "removeMultipleClasses",
    value: function removeMultipleClasses(element, className) {
      if (element && className) {
        if (element.classList) {
          var styles = className.split(' ');

          for (var i = 0; i < styles.length; i++) {
            element.classList.remove(styles[i]);
          }
        } else {
          var _styles2 = className.split(' ');

          for (var _i2 = 0; _i2 < _styles2.length; _i2++) {
            element.className = element.className.replace(new RegExp('(^|\\b)' + _styles2[_i2].split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
          }
        }
      }
    }
  }, {
    key: "addClass",
    value: function addClass(element, className) {
      if (element && className) {
        if (element.classList) element.classList.add(className);else element.className += ' ' + className;
      }
    }
  }, {
    key: "removeClass",
    value: function removeClass(element, className) {
      if (element && className) {
        if (element.classList) element.classList.remove(className);else element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
      }
    }
  }, {
    key: "hasClass",
    value: function hasClass(element, className) {
      if (element) {
        if (element.classList) return element.classList.contains(className);else return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);
      }
    }
  }, {
    key: "find",
    value: function find(element, selector) {
      return element ? Array.from(element.querySelectorAll(selector)) : [];
    }
  }, {
    key: "findSingle",
    value: function findSingle(element, selector) {
      if (element) {
        return element.querySelector(selector);
      }

      return null;
    }
  }, {
    key: "getHeight",
    value: function getHeight(el) {
      if (el) {
        var height = el.offsetHeight;
        var style = getComputedStyle(el);
        height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
        return height;
      }

      return 0;
    }
  }, {
    key: "getWidth",
    value: function getWidth(el) {
      if (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
        return width;
      }

      return 0;
    }
  }, {
    key: "alignOverlay",
    value: function alignOverlay(overlay, target, appendTo) {
      var calculateMinWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (overlay && target) {
        if (appendTo === 'self') {
          this.relativePosition(overlay, target);
        } else {
          calculateMinWidth && (overlay.style.minWidth = DomHandler.getOuterWidth(target) + 'px');
          this.absolutePosition(overlay, target);
        }
      }
    }
  }, {
    key: "absolutePosition",
    value: function absolutePosition(element, target) {
      if (element) {
        var elementDimensions = element.offsetParent ? {
          width: element.offsetWidth,
          height: element.offsetHeight
        } : this.getHiddenElementDimensions(element);
        var elementOuterHeight = elementDimensions.height;
        var elementOuterWidth = elementDimensions.width;
        var targetOuterHeight = target.offsetHeight;
        var targetOuterWidth = target.offsetWidth;
        var targetOffset = target.getBoundingClientRect();
        var windowScrollTop = this.getWindowScrollTop();
        var windowScrollLeft = this.getWindowScrollLeft();
        var viewport = this.getViewport();
        var top, left;

        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
          top = targetOffset.top + windowScrollTop - elementOuterHeight;

          if (top < 0) {
            top = windowScrollTop;
          }

          element.style.transformOrigin = 'bottom';
        } else {
          top = targetOuterHeight + targetOffset.top + windowScrollTop;
          element.style.transformOrigin = 'top';
        }

        if (targetOffset.left + targetOuterWidth + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);else left = targetOffset.left + windowScrollLeft;
        element.style.top = top + 'px';
        element.style.left = left + 'px';
      }
    }
  }, {
    key: "relativePosition",
    value: function relativePosition(element, target) {
      if (element) {
        var elementDimensions = element.offsetParent ? {
          width: element.offsetWidth,
          height: element.offsetHeight
        } : this.getHiddenElementDimensions(element);
        var targetHeight = target.offsetHeight;
        var targetOffset = target.getBoundingClientRect();
        var viewport = this.getViewport();
        var top, left;

        if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {
          top = -1 * elementDimensions.height;

          if (targetOffset.top + top < 0) {
            top = -1 * targetOffset.top;
          }

          element.style.transformOrigin = 'bottom';
        } else {
          top = targetHeight;
          element.style.transformOrigin = 'top';
        }

        if (elementDimensions.width > viewport.width) {
          // element wider then viewport and cannot fit on screen (align at left side of viewport)
          left = targetOffset.left * -1;
        } else if (targetOffset.left + elementDimensions.width > viewport.width) {
          // element wider then viewport but can be fit on screen (align at right side of viewport)
          left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;
        } else {
          // element fits on screen (align with target)
          left = 0;
        }

        element.style.top = top + 'px';
        element.style.left = left + 'px';
      }
    }
  }, {
    key: "flipfitCollision",
    value: function flipfitCollision(element, target) {
      var _this = this;

      var my = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'left top';
      var at = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'left bottom';
      var callback = arguments.length > 4 ? arguments[4] : undefined;
      var targetOffset = target.getBoundingClientRect();
      var viewport = this.getViewport();
      var myArr = my.split(' ');
      var atArr = at.split(' ');

      var getPositionValue = function getPositionValue(arr, isOffset) {
        return isOffset ? +arr.substring(arr.search(/(\+|-)/g)) || 0 : arr.substring(0, arr.search(/(\+|-)/g)) || arr;
      };

      var position = {
        my: {
          x: getPositionValue(myArr[0]),
          y: getPositionValue(myArr[1] || myArr[0]),
          offsetX: getPositionValue(myArr[0], true),
          offsetY: getPositionValue(myArr[1] || myArr[0], true)
        },
        at: {
          x: getPositionValue(atArr[0]),
          y: getPositionValue(atArr[1] || atArr[0]),
          offsetX: getPositionValue(atArr[0], true),
          offsetY: getPositionValue(atArr[1] || atArr[0], true)
        }
      };
      var myOffset = {
        left: function left() {
          var totalOffset = position.my.offsetX + position.at.offsetX;
          return totalOffset + targetOffset.left + (position.my.x === 'left' ? 0 : -1 * (position.my.x === 'center' ? _this.getOuterWidth(element) / 2 : _this.getOuterWidth(element)));
        },
        top: function top() {
          var totalOffset = position.my.offsetY + position.at.offsetY;
          return totalOffset + targetOffset.top + (position.my.y === 'top' ? 0 : -1 * (position.my.y === 'center' ? _this.getOuterHeight(element) / 2 : _this.getOuterHeight(element)));
        }
      };
      var alignWithAt = {
        count: {
          x: 0,
          y: 0
        },
        left: function left() {
          var left = myOffset.left();
          var scrollLeft = DomHandler.getWindowScrollLeft();
          element.style.left = left + scrollLeft + 'px';

          if (this.count.x === 2) {
            element.style.left = scrollLeft + 'px';
            this.count.x = 0;
          } else if (left < 0) {
            this.count.x++;
            position.my.x = 'left';
            position.at.x = 'right';
            position.my.offsetX *= -1;
            position.at.offsetX *= -1;
            this.right();
          }
        },
        right: function right() {
          var left = myOffset.left() + DomHandler.getOuterWidth(target);
          var scrollLeft = DomHandler.getWindowScrollLeft();
          element.style.left = left + scrollLeft + 'px';

          if (this.count.x === 2) {
            element.style.left = viewport.width - DomHandler.getOuterWidth(element) + scrollLeft + 'px';
            this.count.x = 0;
          } else if (left + DomHandler.getOuterWidth(element) > viewport.width) {
            this.count.x++;
            position.my.x = 'right';
            position.at.x = 'left';
            position.my.offsetX *= -1;
            position.at.offsetX *= -1;
            this.left();
          }
        },
        top: function top() {
          var top = myOffset.top();
          var scrollTop = DomHandler.getWindowScrollTop();
          element.style.top = top + scrollTop + 'px';

          if (this.count.y === 2) {
            element.style.left = scrollTop + 'px';
            this.count.y = 0;
          } else if (top < 0) {
            this.count.y++;
            position.my.y = 'top';
            position.at.y = 'bottom';
            position.my.offsetY *= -1;
            position.at.offsetY *= -1;
            this.bottom();
          }
        },
        bottom: function bottom() {
          var top = myOffset.top() + DomHandler.getOuterHeight(target);
          var scrollTop = DomHandler.getWindowScrollTop();
          element.style.top = top + scrollTop + 'px';

          if (this.count.y === 2) {
            element.style.left = viewport.height - DomHandler.getOuterHeight(element) + scrollTop + 'px';
            this.count.y = 0;
          } else if (top + DomHandler.getOuterHeight(target) > viewport.height) {
            this.count.y++;
            position.my.y = 'bottom';
            position.at.y = 'top';
            position.my.offsetY *= -1;
            position.at.offsetY *= -1;
            this.top();
          }
        },
        center: function center(axis) {
          if (axis === 'y') {
            var top = myOffset.top() + DomHandler.getOuterHeight(target) / 2;
            element.style.top = top + DomHandler.getWindowScrollTop() + 'px';

            if (top < 0) {
              this.bottom();
            } else if (top + DomHandler.getOuterHeight(target) > viewport.height) {
              this.top();
            }
          } else {
            var left = myOffset.left() + DomHandler.getOuterWidth(target) / 2;
            element.style.left = left + DomHandler.getWindowScrollLeft() + 'px';

            if (left < 0) {
              this.left();
            } else if (left + DomHandler.getOuterWidth(element) > viewport.width) {
              this.right();
            }
          }
        }
      };
      alignWithAt[position.at.x]('x');
      alignWithAt[position.at.y]('y');

      if (this.isFunction(callback)) {
        callback(position);
      }
    }
  }, {
    key: "findCollisionPosition",
    value: function findCollisionPosition(position) {
      if (position) {
        var isAxisY = position === 'top' || position === 'bottom';
        var myXPosition = position === 'left' ? 'right' : 'left';
        var myYPosition = position === 'top' ? 'bottom' : 'top';

        if (isAxisY) {
          return {
            axis: 'y',
            my: "center ".concat(myYPosition),
            at: "center ".concat(position)
          };
        }

        return {
          axis: 'x',
          my: "".concat(myXPosition, " center"),
          at: "".concat(position, " center")
        };
      }
    }
  }, {
    key: "getParents",
    value: function getParents(element) {
      var parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return element['parentNode'] === null ? parents : this.getParents(element.parentNode, parents.concat([element.parentNode]));
    }
  }, {
    key: "getScrollableParents",
    value: function getScrollableParents(element) {
      var scrollableParents = [];

      if (element) {
        var parents = this.getParents(element);
        var overflowRegex = /(auto|scroll)/;

        var overflowCheck = function overflowCheck(node) {
          var styleDeclaration = node ? getComputedStyle(node) : null;
          return styleDeclaration && (overflowRegex.test(styleDeclaration.getPropertyValue('overflow')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowX')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowY')));
        };

        var _iterator = _createForOfIteratorHelper$3(parents),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var parent = _step.value;
            var scrollSelectors = parent.nodeType === 1 && parent.dataset['scrollselectors'];

            if (scrollSelectors) {
              var selectors = scrollSelectors.split(',');

              var _iterator2 = _createForOfIteratorHelper$3(selectors),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var selector = _step2.value;
                  var el = this.findSingle(parent, selector);

                  if (el && overflowCheck(el)) {
                    scrollableParents.push(el);
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }

            if (parent.nodeType !== 9 && overflowCheck(parent)) {
              scrollableParents.push(parent);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return scrollableParents;
    }
  }, {
    key: "getHiddenElementOuterHeight",
    value: function getHiddenElementOuterHeight(element) {
      if (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        var elementHeight = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementHeight;
      }

      return 0;
    }
  }, {
    key: "getHiddenElementOuterWidth",
    value: function getHiddenElementOuterWidth(element) {
      if (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        var elementWidth = element.offsetWidth;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementWidth;
      }

      return 0;
    }
  }, {
    key: "getHiddenElementDimensions",
    value: function getHiddenElementDimensions(element) {
      var dimensions = {};

      if (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        dimensions.width = element.offsetWidth;
        dimensions.height = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
      }

      return dimensions;
    }
  }, {
    key: "fadeIn",
    value: function fadeIn(element, duration) {
      if (element) {
        element.style.opacity = 0;
        var last = +new Date();
        var opacity = 0;

        var tick = function tick() {
          opacity = +element.style.opacity + (new Date().getTime() - last) / duration;
          element.style.opacity = opacity;
          last = +new Date();

          if (+opacity < 1) {
            window.requestAnimationFrame && requestAnimationFrame(tick) || setTimeout(tick, 16);
          }
        };

        tick();
      }
    }
  }, {
    key: "fadeOut",
    value: function fadeOut(element, duration) {
      if (element) {
        var opacity = 1,
            interval = 50,
            gap = interval / duration;
        var fading = setInterval(function () {
          opacity -= gap;

          if (opacity <= 0) {
            opacity = 0;
            clearInterval(fading);
          }

          element.style.opacity = opacity;
        }, interval);
      }
    }
  }, {
    key: "getUserAgent",
    value: function getUserAgent() {
      return navigator.userAgent;
    }
  }, {
    key: "isIOS",
    value: function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window['MSStream'];
    }
  }, {
    key: "isAndroid",
    value: function isAndroid() {
      return /(android)/i.test(navigator.userAgent);
    }
  }, {
    key: "isTouchDevice",
    value: function isTouchDevice() {
      return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    }
  }, {
    key: "isFunction",
    value: function isFunction(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
    }
  }, {
    key: "appendChild",
    value: function appendChild(element, target) {
      if (this.isElement(target)) target.appendChild(element);else if (target.el && target.el.nativeElement) target.el.nativeElement.appendChild(element);else throw new Error('Cannot append ' + target + ' to ' + element);
    }
  }, {
    key: "removeChild",
    value: function removeChild(element, target) {
      if (this.isElement(target)) target.removeChild(element);else if (target.el && target.el.nativeElement) target.el.nativeElement.removeChild(element);else throw new Error('Cannot remove ' + element + ' from ' + target);
    }
  }, {
    key: "isElement",
    value: function isElement(obj) {
      return (typeof HTMLElement === "undefined" ? "undefined" : _typeof$1(HTMLElement)) === "object" ? obj instanceof HTMLElement : obj && _typeof$1(obj) === "object" && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === "string";
    }
  }, {
    key: "scrollInView",
    value: function scrollInView(container, item) {
      var borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');
      var borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
      var paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');
      var paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
      var containerRect = container.getBoundingClientRect();
      var itemRect = item.getBoundingClientRect();
      var offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
      var scroll = container.scrollTop;
      var elementHeight = container.clientHeight;
      var itemHeight = this.getOuterHeight(item);

      if (offset < 0) {
        container.scrollTop = scroll + offset;
      } else if (offset + itemHeight > elementHeight) {
        container.scrollTop = scroll + offset - elementHeight + itemHeight;
      }
    }
  }, {
    key: "clearSelection",
    value: function clearSelection() {
      if (window.getSelection) {
        if (window.getSelection().empty) {
          window.getSelection().empty();
        } else if (window.getSelection().removeAllRanges && window.getSelection().rangeCount > 0 && window.getSelection().getRangeAt(0).getClientRects().length > 0) {
          window.getSelection().removeAllRanges();
        }
      } else if (document['selection'] && document['selection'].empty) {
        try {
          document['selection'].empty();
        } catch (error) {//ignore IE bug
        }
      }
    }
  }, {
    key: "calculateScrollbarWidth",
    value: function calculateScrollbarWidth(el) {
      if (el) {
        var style = getComputedStyle(el);
        return el.offsetWidth - el.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);
      } else {
        if (this.calculatedScrollbarWidth != null) return this.calculatedScrollbarWidth;
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "p-scrollbar-measure";
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        this.calculatedScrollbarWidth = scrollbarWidth;
        return scrollbarWidth;
      }
    }
  }, {
    key: "getBrowser",
    value: function getBrowser() {
      if (!this.browser) {
        var matched = this.resolveUserAgent();
        this.browser = {};

        if (matched.browser) {
          this.browser[matched.browser] = true;
          this.browser['version'] = matched.version;
        }

        if (this.browser['chrome']) {
          this.browser['webkit'] = true;
        } else if (this.browser['webkit']) {
          this.browser['safari'] = true;
        }
      }

      return this.browser;
    }
  }, {
    key: "resolveUserAgent",
    value: function resolveUserAgent() {
      var ua = navigator.userAgent.toLowerCase();
      var match = /(chrome)[ ]([\w.]+)/.exec(ua) || /(webkit)[ ]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
      return {
        browser: match[1] || "",
        version: match[2] || "0"
      };
    }
  }, {
    key: "isVisible",
    value: function isVisible(element) {
      return element && element.offsetParent != null;
    }
  }, {
    key: "isExist",
    value: function isExist(element) {
      return element !== null && typeof element !== 'undefined' && element.nodeName && element.parentNode;
    }
  }, {
    key: "hasDOM",
    value: function hasDOM() {
      return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
    }
  }, {
    key: "getFocusableElements",
    value: function getFocusableElements(element) {
      var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var focusableElements = DomHandler.find(element, "button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])".concat(selector, ",\n                [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector));
      var visibleFocusableElements = [];

      var _iterator3 = _createForOfIteratorHelper$3(focusableElements),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var focusableElement = _step3.value;
          if (getComputedStyle(focusableElement).display !== "none" && getComputedStyle(focusableElement).visibility !== "hidden") visibleFocusableElements.push(focusableElement);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return visibleFocusableElements;
    }
  }, {
    key: "getFirstFocusableElement",
    value: function getFirstFocusableElement(element, selector) {
      var focusableElements = DomHandler.getFocusableElements(element, selector);
      return focusableElements.length > 0 ? focusableElements[0] : null;
    }
  }, {
    key: "getLastFocusableElement",
    value: function getLastFocusableElement(element, selector) {
      var focusableElements = DomHandler.getFocusableElements(element, selector);
      return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
    }
  }, {
    key: "getCursorOffset",
    value: function getCursorOffset(el, prevText, nextText, currentText) {
      if (el) {
        var style = getComputedStyle(el);
        var ghostDiv = document.createElement('div');
        ghostDiv.style.position = 'absolute';
        ghostDiv.style.top = '0px';
        ghostDiv.style.left = '0px';
        ghostDiv.style.visibility = 'hidden';
        ghostDiv.style.pointerEvents = 'none';
        ghostDiv.style.overflow = style.overflow;
        ghostDiv.style.width = style.width;
        ghostDiv.style.height = style.height;
        ghostDiv.style.padding = style.padding;
        ghostDiv.style.border = style.border;
        ghostDiv.style.overflowWrap = style.overflowWrap;
        ghostDiv.style.whiteSpace = style.whiteSpace;
        ghostDiv.style.lineHeight = style.lineHeight;
        ghostDiv.innerHTML = prevText.replace(/\r\n|\r|\n/g, '<br />');
        var ghostSpan = document.createElement('span');
        ghostSpan.textContent = currentText;
        ghostDiv.appendChild(ghostSpan);
        var text = document.createTextNode(nextText);
        ghostDiv.appendChild(text);
        document.body.appendChild(ghostDiv);
        var offsetLeft = ghostSpan.offsetLeft,
            offsetTop = ghostSpan.offsetTop,
            clientHeight = ghostSpan.clientHeight;
        document.body.removeChild(ghostDiv);
        return {
          left: Math.abs(offsetLeft - el.scrollLeft),
          top: Math.abs(offsetTop - el.scrollTop) + clientHeight
        };
      }

      return {
        top: 'auto',
        left: 'auto'
      };
    }
  }, {
    key: "invokeElementMethod",
    value: function invokeElementMethod(element, methodName, args) {
      element[methodName].apply(element, args);
    }
  }, {
    key: "isClickable",
    value: function isClickable(element) {
      var targetNode = element.nodeName;
      var parentNode = element.parentElement && element.parentElement.nodeName;
      return targetNode === 'INPUT' || targetNode === 'TEXTAREA' || targetNode === 'BUTTON' || targetNode === 'A' || parentNode === 'INPUT' || parentNode === 'TEXTAREA' || parentNode === 'BUTTON' || parentNode === 'A' || this.hasClass(element, 'p-button') || this.hasClass(element.parentElement, 'p-button') || this.hasClass(element.parentElement, 'p-checkbox') || this.hasClass(element.parentElement, 'p-radiobutton');
    }
  }, {
    key: "applyStyle",
    value: function applyStyle(element, style) {
      if (typeof style === 'string') {
        element.style.cssText = this.style;
      } else {
        for (var prop in this.style) {
          element.style[prop] = style[prop];
        }
      }
    }
  }, {
    key: "exportCSV",
    value: function exportCSV(csv, filename) {
      var blob = new Blob([csv], {
        type: 'application/csv;charset=utf-8;'
      });

      if (window.navigator.msSaveOrOpenBlob) {
        navigator.msSaveOrOpenBlob(blob, filename + '.csv');
      } else {
        var isDownloaded = DomHandler.saveAs({
          name: filename + '.csv',
          src: URL.createObjectURL(blob)
        });

        if (!isDownloaded) {
          csv = 'data:text/csv;charset=utf-8,' + csv;
          window.open(encodeURI(csv));
        }
      }
    }
  }, {
    key: "saveAs",
    value: function saveAs(file) {
      if (file) {
        var link = document.createElement('a');

        if (link.download !== undefined) {
          var name = file.name,
              src = file.src;
          link.setAttribute('href', src);
          link.setAttribute('download', name);
          link.style.display = 'none';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          return true;
        }
      }

      return false;
    }
  }, {
    key: "createInlineStyle",
    value: function createInlineStyle(nonce) {
      var styleElement = document.createElement('style');

      try {
        if (!nonce) {
          nonce = process.env.REACT_APP_CSS_NONCE;
        }
      } catch (error) {// NOOP
      }

      nonce && styleElement.setAttribute('nonce', nonce);
      document.head.appendChild(styleElement);
      return styleElement;
    }
  }, {
    key: "removeInlineStyle",
    value: function removeInlineStyle(styleElement) {
      if (this.isExist(styleElement)) {
        try {
          document.head.removeChild(styleElement);
        } catch (error) {// style element may have already been removed in a fast refresh
        }

        styleElement = null;
      }

      return styleElement;
    }
  }]);

  return DomHandler;
}();

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$1(this, result);
  };
}

function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TreeTableBodyCell = /*#__PURE__*/function (_Component) {
  _inherits$1(TreeTableBodyCell, _Component);

  var _super = _createSuper$5(TreeTableBodyCell);

  function TreeTableBodyCell(props) {
    var _this;

    _classCallCheck$1(this, TreeTableBodyCell);

    _this = _super.call(this, props);

    if (_this.props.editor) {
      _this.state = {};
    }

    _this.onClick = _this.onClick.bind(_assertThisInitialized$1(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$1(_this));
    _this.onEditorFocus = _this.onEditorFocus.bind(_assertThisInitialized$1(_this));
    return _this;
  }

  _createClass$1(TreeTableBodyCell, [{
    key: "onClick",
    value: function onClick() {
      var _this2 = this;

      if (this.props.editor && !this.state.editing && (this.props.selectOnEdit || !this.props.selectOnEdit && this.props.selected)) {
        this.selfClick = true;
        this.setState({
          editing: true
        }, function () {
          _this2.bindDocumentEditListener();

          _this2.overlayEventListener = function (e) {
            if (!_this2.isOutsideClicked(e.target)) {
              _this2.selfClick = true;
            }
          };

          OverlayService.on('overlay-click', _this2.overlayEventListener);
        });
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (event.which === 13 || event.which === 9) {
        this.switchCellToViewMode(event);
      }
    }
  }, {
    key: "bindDocumentEditListener",
    value: function bindDocumentEditListener() {
      var _this3 = this;

      if (!this.documentEditListener) {
        this.documentEditListener = function (e) {
          if (!_this3.selfClick && _this3.isOutsideClicked(e.target)) {
            _this3.switchCellToViewMode(e);
          }

          _this3.selfClick = false;
        };

        document.addEventListener('click', this.documentEditListener);
      }
    }
  }, {
    key: "isOutsideClicked",
    value: function isOutsideClicked(target) {
      return this.container && !(this.container.isSameNode(target) || this.container.contains(target));
    }
  }, {
    key: "unbindDocumentEditListener",
    value: function unbindDocumentEditListener() {
      if (this.documentEditListener) {
        document.removeEventListener('click', this.documentEditListener);
        this.documentEditListener = null;
        this.selfClick = false;
      }
    }
  }, {
    key: "closeCell",
    value: function closeCell() {
      var _this4 = this;
      /* When using the 'tab' key, the focus event of the next cell is not called in IE. */


      setTimeout(function () {
        _this4.setState({
          editing: false
        }, function () {
          _this4.unbindDocumentEditListener();

          OverlayService.off('overlay-click', _this4.overlayEventListener);
          _this4.overlayEventListener = null;
        });
      }, 1);
    }
  }, {
    key: "onEditorFocus",
    value: function onEditorFocus(event) {
      this.onClick(event);
    }
  }, {
    key: "switchCellToViewMode",
    value: function switchCellToViewMode(event) {
      if (this.props.cellEditValidator) {
        var valid = this.props.cellEditValidator({
          originalEvent: event,
          columnProps: this.props
        });

        if (valid) {
          this.closeCell();
        }
      } else {
        this.closeCell();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this5 = this;

      if (this.container && this.props.editor) {
        clearTimeout(this.tabindexTimeout);

        if (this.state && this.state.editing) {
          var focusable = DomHandler$1.findSingle(this.container, 'input');

          if (focusable && document.activeElement !== focusable && !focusable.hasAttribute('data-isCellEditing')) {
            focusable.setAttribute('data-isCellEditing', true);
            focusable.focus();
          }

          this.keyHelper.tabIndex = -1;
        } else {
          this.tabindexTimeout = setTimeout(function () {
            if (_this5.keyHelper) {
              _this5.keyHelper.setAttribute('tabindex', 0);
            }
          }, 50);
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindDocumentEditListener();

      if (this.overlayEventListener) {
        OverlayService.off('overlay-click', this.overlayEventListener);
        this.overlayEventListener = null;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this6 = this;

      var className = classNames(this.props.bodyClassName || this.props.className, {
        'p-editable-column': this.props.editor,
        'p-cell-editing': this.props.editor ? this.state.editing : false
      });
      var style = this.props.bodyStyle || this.props.style;
      var content;

      if (this.state && this.state.editing) {
        if (this.props.editor) content = ObjectUtils.getJSXElement(this.props.editor, {
          node: this.props.node,
          rowData: this.props.node.data,
          value: ObjectUtils.resolveFieldData(this.props.node.data, this.props.field),
          field: this.props.field,
          rowIndex: this.props.rowIndex,
          props: this.props
        });else throw new Error("Editor is not found on column.");
      } else {
        if (this.props.body) content = ObjectUtils.getJSXElement(this.props.body, this.props.node, {
          field: this.props.field,
          rowIndex: this.props.rowIndex,
          props: this.props
        });else content = ObjectUtils.resolveFieldData(this.props.node.data, this.props.field);
      }
      /* eslint-disable */


      var editorKeyHelper = this.props.editor && /*#__PURE__*/React.createElement("a", {
        tabIndex: 0,
        ref: function ref(el) {
          _this6.keyHelper = el;
        },
        className: "p-cell-editor-key-helper p-hidden-accessible",
        onFocus: this.onEditorFocus
      }, /*#__PURE__*/React.createElement("span", null));
      /* eslint-enable */

      return /*#__PURE__*/React.createElement("td", {
        ref: function ref(el) {
          return _this6.container = el;
        },
        className: className,
        style: style,
        onClick: this.onClick,
        onKeyDown: this.onKeyDown
      }, this.props.children, editorKeyHelper, content);
    }
  }]);

  return TreeTableBodyCell;
}(Component);

function _createForOfIteratorHelper$2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$2(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
}

function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$1(this, result);
  };
}

function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TreeTableRow = /*#__PURE__*/function (_Component) {
  _inherits$1(TreeTableRow, _Component);

  var _super = _createSuper$4(TreeTableRow);

  function TreeTableRow(props) {
    var _this;

    _classCallCheck$1(this, TreeTableRow);

    _this = _super.call(this, props);
    _this.onTogglerClick = _this.onTogglerClick.bind(_assertThisInitialized$1(_this));
    _this.onClick = _this.onClick.bind(_assertThisInitialized$1(_this));
    _this.onTouchEnd = _this.onTouchEnd.bind(_assertThisInitialized$1(_this));
    _this.propagateUp = _this.propagateUp.bind(_assertThisInitialized$1(_this));
    _this.onCheckboxChange = _this.onCheckboxChange.bind(_assertThisInitialized$1(_this));
    _this.onCheckboxFocus = _this.onCheckboxFocus.bind(_assertThisInitialized$1(_this));
    _this.onCheckboxBlur = _this.onCheckboxBlur.bind(_assertThisInitialized$1(_this));
    _this.onRightClick = _this.onRightClick.bind(_assertThisInitialized$1(_this));
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized$1(_this));
    return _this;
  }

  _createClass$1(TreeTableRow, [{
    key: "isLeaf",
    value: function isLeaf() {
      return this.props.node.leaf === false ? false : !(this.props.node.children && this.props.node.children.length);
    }
  }, {
    key: "onTogglerClick",
    value: function onTogglerClick(event) {
      if (this.isExpanded()) this.collapse(event);else this.expand(event);
      event.preventDefault();
      event.stopPropagation();
    }
  }, {
    key: "expand",
    value: function expand(event) {
      var expandedKeys = this.props.expandedKeys ? _objectSpread$2({}, this.props.expandedKeys) : {};
      expandedKeys[this.props.node.key] = true;
      this.props.onToggle({
        originalEvent: event,
        value: expandedKeys
      });
      this.invokeToggleEvents(event, true);
    }
  }, {
    key: "collapse",
    value: function collapse(event) {
      var expandedKeys = _objectSpread$2({}, this.props.expandedKeys);

      delete expandedKeys[this.props.node.key];
      this.props.onToggle({
        originalEvent: event,
        value: expandedKeys
      });
      this.invokeToggleEvents(event, false);
    }
  }, {
    key: "invokeToggleEvents",
    value: function invokeToggleEvents(event, expanded) {
      if (expanded) {
        if (this.props.onExpand) {
          this.props.onExpand({
            originalEvent: event,
            node: this.props.node
          });
        }
      } else {
        if (this.props.onCollapse) {
          this.props.onCollapse({
            originalEvent: event,
            node: this.props.node
          });
        }
      }
    }
  }, {
    key: "onClick",
    value: function onClick(event) {
      if (this.props.onRowClick) {
        this.props.onRowClick(event, this.props.node);
      }

      this.nodeTouched = false;
    }
  }, {
    key: "onTouchEnd",
    value: function onTouchEnd() {
      this.nodeTouched = true;
    }
  }, {
    key: "onCheckboxChange",
    value: function onCheckboxChange(event) {
      var checked = this.isChecked();
      var selectionKeys = this.props.selectionKeys ? _objectSpread$2({}, this.props.selectionKeys) : {};

      if (checked) {
        if (this.props.propagateSelectionDown) this.propagateDown(this.props.node, false, selectionKeys);else delete selectionKeys[this.props.node.key];

        if (this.props.propagateSelectionUp && this.props.onPropagateUp) {
          this.props.onPropagateUp({
            originalEvent: event,
            check: false,
            selectionKeys: selectionKeys
          });
        }

        if (this.props.onUnselect) {
          this.props.onUnselect({
            originalEvent: event,
            node: this.props.node
          });
        }
      } else {
        if (this.props.propagateSelectionDown) this.propagateDown(this.props.node, true, selectionKeys);else selectionKeys[this.props.node.key] = {
          checked: true
        };

        if (this.props.propagateSelectionUp && this.props.onPropagateUp) {
          this.props.onPropagateUp({
            originalEvent: event,
            check: true,
            selectionKeys: selectionKeys
          });
        }

        if (this.props.onSelect) {
          this.props.onSelect({
            originalEvent: event,
            node: this.props.node
          });
        }
      }

      if (this.props.onSelectionChange) {
        this.props.onSelectionChange({
          originalEvent: event,
          value: selectionKeys
        });
      }

      DomHandler$1.clearSelection();
    }
  }, {
    key: "onCheckboxFocus",
    value: function onCheckboxFocus() {
      DomHandler$1.addClass(this.checkboxBox, 'p-focus');
      DomHandler$1.addClass(this.checkboxRef, 'p-checkbox-focused');
    }
  }, {
    key: "onCheckboxBlur",
    value: function onCheckboxBlur() {
      DomHandler$1.removeClass(this.checkboxBox, 'p-focus');
      DomHandler$1.removeClass(this.checkboxRef, 'p-checkbox-focused');
    }
  }, {
    key: "propagateUp",
    value: function propagateUp(event) {
      var check = event.check;
      var selectionKeys = event.selectionKeys;
      var checkedChildCount = 0;
      var childPartialSelected = false;

      var _iterator = _createForOfIteratorHelper$2(this.props.node.children),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;
          if (selectionKeys[child.key] && selectionKeys[child.key].checked) checkedChildCount++;else if (selectionKeys[child.key] && selectionKeys[child.key].partialChecked) childPartialSelected = true;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (check && checkedChildCount === this.props.node.children.length) {
        selectionKeys[this.props.node.key] = {
          checked: true,
          partialChecked: false
        };
      } else {
        if (!check) {
          delete selectionKeys[this.props.node.key];
        }

        if (childPartialSelected || checkedChildCount > 0 && checkedChildCount !== this.props.node.children.length) selectionKeys[this.props.node.key] = {
          checked: false,
          partialChecked: true
        };else selectionKeys[this.props.node.key] = {
          checked: false,
          partialChecked: false
        };
      }

      if (this.props.propagateSelectionUp && this.props.onPropagateUp) {
        this.props.onPropagateUp(event);
      }
    }
  }, {
    key: "propagateDown",
    value: function propagateDown(node, check, selectionKeys) {
      if (check) selectionKeys[node.key] = {
        checked: true,
        partialChecked: false
      };else delete selectionKeys[node.key];

      if (node.children && node.children.length) {
        for (var i = 0; i < node.children.length; i++) {
          this.propagateDown(node.children[i], check, selectionKeys);
        }
      }
    }
  }, {
    key: "onRightClick",
    value: function onRightClick(event) {
      DomHandler$1.clearSelection();

      if (this.props.onContextMenuSelectionChange) {
        this.props.onContextMenuSelectionChange({
          originalEvent: event,
          value: this.props.node.key
        });
      }

      if (this.props.onContextMenu) {
        this.props.onContextMenu({
          originalEvent: event,
          node: this.props.node
        });
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (event.target === this.container) {
        var rowElement = event.currentTarget;

        switch (event.which) {
          //down arrow
          case 40:
            var nextRow = rowElement.nextElementSibling;

            if (nextRow) {
              nextRow.focus();
            }

            event.preventDefault();
            break;
          //up arrow

          case 38:
            var previousRow = rowElement.previousElementSibling;

            if (previousRow) {
              previousRow.focus();
            }

            event.preventDefault();
            break;
          //right arrow

          case 39:
            if (!this.isExpanded()) {
              this.expand(event);
            }

            event.preventDefault();
            break;
          //left arrow

          case 37:
            if (this.isExpanded()) {
              this.collapse(event);
            }

            event.preventDefault();
            break;
          //enter

          case 13:
            this.onClick(event);
            event.preventDefault();
            break;
        }
      }
    }
  }, {
    key: "isExpanded",
    value: function isExpanded() {
      return this.props.expandedKeys ? this.props.expandedKeys[this.props.node.key] !== undefined : false;
    }
  }, {
    key: "isSelected",
    value: function isSelected() {
      if ((this.props.selectionMode === 'single' || this.props.selectionMode === 'multiple') && this.props.selectionKeys) return this.props.selectionMode === 'single' ? this.props.selectionKeys === this.props.node.key : this.props.selectionKeys[this.props.node.key] !== undefined;else return false;
    }
  }, {
    key: "isChecked",
    value: function isChecked() {
      return this.props.selectionKeys ? this.props.selectionKeys[this.props.node.key] && this.props.selectionKeys[this.props.node.key].checked : false;
    }
  }, {
    key: "isPartialChecked",
    value: function isPartialChecked() {
      return this.props.selectionKeys ? this.props.selectionKeys[this.props.node.key] && this.props.selectionKeys[this.props.node.key].partialChecked : false;
    }
  }, {
    key: "renderToggler",
    value: function renderToggler() {
      var expanded = this.isExpanded();
      var iconClassName = classNames('"p-treetable-toggler-icon pi pi-fw', {
        'pi-chevron-right': !expanded,
        'pi-chevron-down': expanded
      });
      var style = {
        marginLeft: this.props.level * 16 + 'px',
        visibility: this.props.node.leaf === false || this.props.node.children && this.props.node.children.length ? 'visible' : 'hidden'
      };
      return /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-treetable-toggler p-link p-unselectable-text",
        onClick: this.onTogglerClick,
        tabIndex: -1,
        style: style
      }, /*#__PURE__*/React.createElement("i", {
        className: iconClassName
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }
  }, {
    key: "renderCheckbox",
    value: function renderCheckbox() {
      var _this2 = this;

      if (this.props.selectionMode === 'checkbox' && this.props.node.selectable !== false) {
        var checked = this.isChecked();
        var partialChecked = this.isPartialChecked();
        var className = classNames('p-checkbox-box', {
          'p-highlight': checked,
          'p-indeterminate': partialChecked
        });
        var icon = classNames('p-checkbox-icon p-c', {
          'pi pi-check': checked,
          'pi pi-minus': partialChecked
        });
        return /*#__PURE__*/React.createElement("div", {
          className: "p-checkbox p-treetable-checkbox p-component",
          ref: function ref(el) {
            return _this2.checkboxRef = el;
          },
          onClick: this.onCheckboxChange,
          role: "checkbox",
          "aria-checked": checked
        }, /*#__PURE__*/React.createElement("div", {
          className: "p-hidden-accessible"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          onFocus: this.onCheckboxFocus,
          onBlur: this.onCheckboxBlur
        })), /*#__PURE__*/React.createElement("div", {
          className: className,
          ref: function ref(el) {
            return _this2.checkboxBox = el;
          }
        }, /*#__PURE__*/React.createElement("span", {
          className: icon
        })));
      } else {
        return null;
      }
    }
  }, {
    key: "renderCell",
    value: function renderCell(column) {
      var toggler, checkbox;

      if (column.props.expander) {
        toggler = this.renderToggler();
        checkbox = this.renderCheckbox();
      }

      return /*#__PURE__*/React.createElement(TreeTableBodyCell, _extends({
        key: column.props.columnKey || column.props.field
      }, column.props, {
        selectOnEdit: this.props.selectOnEdit,
        selected: this.isSelected(),
        node: this.props.node,
        rowIndex: this.props.rowIndex
      }), toggler, checkbox);
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var _this3 = this;

      if (this.isExpanded() && this.props.node.children) {
        return this.props.node.children.map(function (childNode, index) {
          return /*#__PURE__*/React.createElement(TreeTableRow, {
            key: childNode.key || JSON.stringify(childNode.data),
            level: _this3.props.level + 1,
            rowIndex: _this3.props.rowIndex + '_' + index,
            node: childNode,
            columns: _this3.props.columns,
            expandedKeys: _this3.props.expandedKeys,
            selectOnEdit: _this3.props.selectOnEdit,
            onToggle: _this3.props.onToggle,
            onExpand: _this3.props.onExpand,
            onCollapse: _this3.props.onCollapse,
            selectionMode: _this3.props.selectionMode,
            selectionKeys: _this3.props.selectionKeys,
            onSelectionChange: _this3.props.onSelectionChange,
            metaKeySelection: _this3.props.metaKeySelection,
            onRowClick: _this3.props.onRowClick,
            onSelect: _this3.props.onSelect,
            onUnselect: _this3.props.onUnselect,
            propagateSelectionUp: _this3.props.propagateSelectionUp,
            propagateSelectionDown: _this3.props.propagateSelectionDown,
            onPropagateUp: _this3.propagateUp,
            rowClassName: _this3.props.rowClassName,
            contextMenuSelectionKey: _this3.props.contextMenuSelectionKey,
            onContextMenuSelectionChange: _this3.props.onContextMenuSelectionChange,
            onContextMenu: _this3.props.onContextMenu
          });
        });
      } else {
        return null;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var cells = this.props.columns.map(function (col) {
        return _this4.renderCell(col);
      });
      var children = this.renderChildren();
      var className = {
        'p-highlight': this.isSelected(),
        'p-highlight-contextmenu': this.props.contextMenuSelectionKey && this.props.contextMenuSelectionKey === this.props.node.key
      };

      if (this.props.rowClassName) {
        var rowClassName = this.props.rowClassName(this.props.node);
        className = _objectSpread$2(_objectSpread$2({}, className), rowClassName);
      }

      className = classNames(className, this.props.node.className);
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("tr", {
        ref: function ref(el) {
          return _this4.container = el;
        },
        tabIndex: 0,
        className: className,
        style: this.props.node.style,
        onClick: this.onClick,
        onTouchEnd: this.onTouchEnd,
        onContextMenu: this.onRightClick,
        onKeyDown: this.onKeyDown
      }, cells), children);
    }
  }]);

  return TreeTableRow;
}(Component);

_defineProperty$1(TreeTableRow, "defaultProps", {
  node: null,
  level: null,
  columns: null,
  expandedKeys: null,
  contextMenuSelectionKey: null,
  selectionMode: null,
  selectionKeys: null,
  metaKeySelection: true,
  propagateSelectionUp: true,
  propagateSelectionDown: true,
  rowClassName: null,
  onExpand: null,
  onCollapse: null,
  onToggle: null,
  onRowClick: null,
  onSelect: null,
  onUnselect: null,
  onSelectionChange: null,
  onPropagateUp: null,
  onContextMenuSelectionChange: null,
  onContextMenu: null
});

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}

function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$1(this, result);
  };
}

function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TreeTableBody = /*#__PURE__*/function (_Component) {
  _inherits$1(TreeTableBody, _Component);

  var _super = _createSuper$3(TreeTableBody);

  function TreeTableBody(props) {
    var _this;

    _classCallCheck$1(this, TreeTableBody);

    _this = _super.call(this, props);
    _this.onRowClick = _this.onRowClick.bind(_assertThisInitialized$1(_this));
    return _this;
  }

  _createClass$1(TreeTableBody, [{
    key: "createRow",
    value: function createRow(node, index) {
      return /*#__PURE__*/React.createElement(TreeTableRow, {
        key: node.key || JSON.stringify(node.data),
        level: 0,
        rowIndex: index,
        selectOnEdit: this.props.selectOnEdit,
        node: node,
        columns: this.props.columns,
        expandedKeys: this.props.expandedKeys,
        onToggle: this.props.onToggle,
        onExpand: this.props.onExpand,
        onCollapse: this.props.onCollapse,
        selectionMode: this.props.selectionMode,
        selectionKeys: this.props.selectionKeys,
        onSelectionChange: this.props.onSelectionChange,
        metaKeySelection: this.props.metaKeySelection,
        onRowClick: this.onRowClick,
        onSelect: this.props.onSelect,
        onUnselect: this.props.onUnselect,
        propagateSelectionUp: this.props.propagateSelectionUp,
        propagateSelectionDown: this.props.propagateSelectionDown,
        rowClassName: this.props.rowClassName,
        contextMenuSelectionKey: this.props.contextMenuSelectionKey,
        onContextMenuSelectionChange: this.props.onContextMenuSelectionChange,
        onContextMenu: this.props.onContextMenu
      });
    }
  }, {
    key: "flattenizeTree",
    value: function flattenizeTree(nodes) {
      var rows = [];
      nodes = nodes || this.props.value;

      var _iterator = _createForOfIteratorHelper$1(nodes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var node = _step.value;
          rows.push(node.key);

          if (this.isExpandedKey(node.key)) {
            rows = rows.concat(this.flattenizeTree(node.children));
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return rows;
    }
  }, {
    key: "isExpandedKey",
    value: function isExpandedKey(key) {
      return this.props.expandedKeys && !!this.props.expandedKeys[key];
    }
  }, {
    key: "onRowClick",
    value: function onRowClick(event, node) {
      var _this2 = this;

      if (this.props.onRowClick) {
        this.props.onRowClick({
          originalEvent: event,
          node: node
        });
      }

      var targetNode = event.target.nodeName;

      if (targetNode === 'INPUT' || targetNode === 'BUTTON' || targetNode === 'A' || DomHandler.hasClass(event.target, 'p-clickable') || DomHandler.hasClass(event.target, 'p-treetable-toggler') || DomHandler.hasClass(event.target.parentElement, 'p-treetable-toggler')) {
        return;
      }

      if ((this.isSingleSelectionMode() || this.isMultipleSelectionMode()) && node.selectable !== false) {
        var selectionKeys;
        var selected = this.isSelected(node);
        var metaSelection = this.nodeTouched ? false : this.props.metaKeySelection;
        var flatKeys = this.flattenizeTree();
        var rowIndex = flatKeys.findIndex(function (key) {
          return key === node.key;
        });

        if (this.isMultipleSelectionMode() && event.shiftKey) {
          DomHandler.clearSelection(); // find first selected row

          var anchorRowIndex = flatKeys.findIndex(function (key) {
            return _this2.props.selectionKeys[key];
          });
          var rangeStart = Math.min(rowIndex, anchorRowIndex);
          var rangeEnd = Math.max(rowIndex, anchorRowIndex);
          selectionKeys = _objectSpread$1({}, this.props.selectionKeys);

          for (var i = rangeStart; i <= rangeEnd; i++) {
            var rowKey = flatKeys[i];
            selectionKeys[rowKey] = true;
          }
        } else {
          this.anchorRowIndex = rowIndex;

          if (metaSelection) {
            var metaKey = event.metaKey || event.ctrlKey;

            if (selected && metaKey) {
              if (this.isSingleSelectionMode()) {
                selectionKeys = null;
              } else {
                selectionKeys = _objectSpread$1({}, this.props.selectionKeys);
                delete selectionKeys[node.key];
              }

              if (this.props.onUnselect) {
                this.props.onUnselect({
                  originalEvent: event,
                  node: node
                });
              }
            } else {
              if (this.isSingleSelectionMode()) {
                selectionKeys = node.key;
              } else if (this.isMultipleSelectionMode()) {
                selectionKeys = !metaKey ? {} : this.props.selectionKeys ? _objectSpread$1({}, this.props.selectionKeys) : {};
                selectionKeys[node.key] = true;
              }

              if (this.props.onSelect) {
                this.props.onSelect({
                  originalEvent: event,
                  node: node
                });
              }
            }
          } else {
            if (this.isSingleSelectionMode()) {
              if (selected) {
                selectionKeys = null;

                if (this.props.onUnselect) {
                  this.props.onUnselect({
                    originalEvent: event,
                    node: node
                  });
                }
              } else {
                selectionKeys = node.key;

                if (this.props.onSelect) {
                  this.props.onSelect({
                    originalEvent: event,
                    node: node
                  });
                }
              }
            } else {
              if (selected) {
                selectionKeys = _objectSpread$1({}, this.props.selectionKeys);
                delete selectionKeys[node.key];

                if (this.props.onUnselect) {
                  this.props.onUnselect({
                    originalEvent: event,
                    node: node
                  });
                }
              } else {
                selectionKeys = this.props.selectionKeys ? _objectSpread$1({}, this.props.selectionKeys) : {};
                selectionKeys[node.key] = true;

                if (this.props.onSelect) {
                  this.props.onSelect({
                    originalEvent: event,
                    node: node
                  });
                }
              }
            }
          }
        }

        if (this.props.onSelectionChange) {
          this.props.onSelectionChange({
            originalEvent: event,
            value: selectionKeys
          });
        }
      }
    }
  }, {
    key: "isSingleSelectionMode",
    value: function isSingleSelectionMode() {
      return this.props.selectionMode && this.props.selectionMode === 'single';
    }
  }, {
    key: "isMultipleSelectionMode",
    value: function isMultipleSelectionMode() {
      return this.props.selectionMode && this.props.selectionMode === 'multiple';
    }
  }, {
    key: "isSelected",
    value: function isSelected(node) {
      if ((this.props.selectionMode === 'single' || this.props.selectionMode === 'multiple') && this.props.selectionKeys) return this.props.selectionMode === 'single' ? this.props.selectionKeys === node.key : this.props.selectionKeys[node.key] !== undefined;else return false;
    }
  }, {
    key: "renderRows",
    value: function renderRows() {
      var _this3 = this;

      if (this.props.paginator && !this.props.lazy) {
        var rpp = this.props.rows || 0;
        var startIndex = this.props.first || 0;
        var endIndex = startIndex + rpp;
        var rows = [];

        for (var i = startIndex; i < endIndex; i++) {
          var rowData = this.props.value[i];
          if (rowData) rows.push(this.createRow(this.props.value[i]));else break;
        }

        return rows;
      } else {
        return this.props.value.map(function (node, index) {
          return _this3.createRow(node, index);
        });
      }
    }
  }, {
    key: "renderEmptyMessage",
    value: function renderEmptyMessage() {
      if (this.props.loading) {
        return null;
      } else {
        var colSpan = this.props.columns ? this.props.columns.length : null;
        var content = this.props.emptyMessage || localeOption('emptyMessage');
        return /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("td", {
          className: "p-treetable-emptymessage",
          colSpan: colSpan
        }, content));
      }
    }
  }, {
    key: "render",
    value: function render() {
      var content = this.props.value && this.props.value.length ? this.renderRows() : this.renderEmptyMessage();
      return /*#__PURE__*/React.createElement("tbody", {
        className: "p-treetable-tbody"
      }, content);
    }
  }]);

  return TreeTableBody;
}(Component);

_defineProperty$1(TreeTableBody, "defaultProps", {
  value: null,
  columns: null,
  expandedKeys: null,
  contextMenuSelectionKey: null,
  paginator: false,
  first: null,
  rows: null,
  selectionMode: null,
  selectionKeys: null,
  metaKeySelection: true,
  propagateSelectionUp: true,
  propagateSelectionDown: true,
  lazy: false,
  rowClassName: null,
  emptyMessage: null,
  loading: false,
  onExpand: null,
  onCollapse: null,
  onToggle: null,
  onRowClick: null,
  onSelect: null,
  onUnselect: null,
  onSelectionChange: null,
  onContextMenuSelectionChange: null,
  onContextMenu: null
});

function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$1(this, result);
  };
}

function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TreeTableFooter = /*#__PURE__*/function (_Component) {
  _inherits$1(TreeTableFooter, _Component);

  var _super = _createSuper$2(TreeTableFooter);

  function TreeTableFooter() {
    _classCallCheck$1(this, TreeTableFooter);

    return _super.apply(this, arguments);
  }

  _createClass$1(TreeTableFooter, [{
    key: "renderFooterCell",
    value: function renderFooterCell(column, index) {
      return /*#__PURE__*/React.createElement("td", {
        key: column.field || index,
        className: column.props.footerClassName || column.props.className,
        style: column.props.footerStyle || column.props.style,
        rowSpan: column.props.rowSpan,
        colSpan: column.props.colSpan
      }, column.props.footer);
    }
  }, {
    key: "renderFooterRow",
    value: function renderFooterRow(row, index) {
      var _this = this;

      var rowColumns = React.Children.toArray(row.props.children);
      var rowFooterCells = rowColumns.map(function (col, index) {
        return _this.renderFooterCell(col, index);
      });
      return /*#__PURE__*/React.createElement("tr", {
        key: index
      }, rowFooterCells);
    }
  }, {
    key: "renderColumnGroup",
    value: function renderColumnGroup() {
      var _this2 = this;

      var rows = React.Children.toArray(this.props.columnGroup.props.children);
      return rows.map(function (row, i) {
        return _this2.renderFooterRow(row, i);
      });
    }
  }, {
    key: "renderColumns",
    value: function renderColumns(columns) {
      var _this3 = this;

      if (columns) {
        var headerCells = columns.map(function (col, index) {
          return _this3.renderFooterCell(col, index);
        });
        return /*#__PURE__*/React.createElement("tr", null, headerCells);
      } else {
        return null;
      }
    }
  }, {
    key: "hasFooter",
    value: function hasFooter() {
      if (this.props.columnGroup) {
        return true;
      } else {
        for (var i = 0; i < this.props.columns.length; i++) {
          if (this.props.columns[i].props.footer) {
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "render",
    value: function render() {
      var content = this.props.columnGroup ? this.renderColumnGroup() : this.renderColumns(this.props.columns);

      if (this.hasFooter()) {
        return /*#__PURE__*/React.createElement("tfoot", {
          className: "p-treetable-tfoot"
        }, content);
      } else {
        return null;
      }
    }
  }]);

  return TreeTableFooter;
}(Component);

_defineProperty$1(TreeTableFooter, "defaultProps", {
  columns: null,
  columnGroup: null
});

function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$1(this, result);
  };
}

function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TreeTableScrollableView = /*#__PURE__*/function (_Component) {
  _inherits$1(TreeTableScrollableView, _Component);

  var _super = _createSuper$1(TreeTableScrollableView);

  function TreeTableScrollableView(props) {
    var _this;

    _classCallCheck$1(this, TreeTableScrollableView);

    _this = _super.call(this, props);
    _this.onHeaderScroll = _this.onHeaderScroll.bind(_assertThisInitialized$1(_this));
    _this.onBodyScroll = _this.onBodyScroll.bind(_assertThisInitialized$1(_this));
    return _this;
  }

  _createClass$1(TreeTableScrollableView, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setScrollHeight();

      if (!this.props.frozen) {
        var scrollBarWidth = DomHandler$1.calculateScrollbarWidth();
        this.scrollHeaderBox.style.marginRight = scrollBarWidth + 'px';

        if (this.scrollFooterBox) {
          this.scrollFooterBox.style.marginRight = scrollBarWidth + 'px';
        }
      } else {
        this.scrollBody.style.paddingBottom = DomHandler$1.calculateScrollbarWidth() + 'px';
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.setScrollHeight();
    }
  }, {
    key: "setScrollHeight",
    value: function setScrollHeight() {
      if (this.props.scrollHeight) {
        if (this.props.scrollHeight.indexOf('%') !== -1) {
          var datatableContainer = this.findDataTableContainer(this.container);
          this.scrollBody.style.visibility = 'hidden';
          this.scrollBody.style.height = '100px'; //temporary height to calculate static height

          var containerHeight = DomHandler$1.getOuterHeight(datatableContainer);
          var relativeHeight = DomHandler$1.getOuterHeight(datatableContainer.parentElement) * parseInt(this.props.scrollHeight, 10) / 100;
          var staticHeight = containerHeight - 100; //total height of headers, footers, paginators

          var scrollBodyHeight = relativeHeight - staticHeight;
          this.scrollBody.style.height = 'auto';
          this.scrollBody.style.maxHeight = scrollBodyHeight + 'px';
          this.scrollBody.style.visibility = 'visible';
        } else {
          this.scrollBody.style.maxHeight = this.props.scrollHeight;
        }
      }
    }
  }, {
    key: "findDataTableContainer",
    value: function findDataTableContainer(element) {
      if (element) {
        var el = element;

        while (el && !DomHandler$1.hasClass(el, 'p-treetable')) {
          el = el.parentElement;
        }

        return el;
      } else {
        return null;
      }
    }
  }, {
    key: "onHeaderScroll",
    value: function onHeaderScroll() {
      this.scrollHeader.scrollLeft = 0;
    }
  }, {
    key: "onBodyScroll",
    value: function onBodyScroll() {
      var frozenView = this.container.previousElementSibling;
      var frozenScrollBody;

      if (frozenView) {
        frozenScrollBody = DomHandler$1.findSingle(frozenView, '.p-treetable-scrollable-body');
      }

      this.scrollHeaderBox.style.marginLeft = -1 * this.scrollBody.scrollLeft + 'px';

      if (this.scrollFooterBox) {
        this.scrollFooterBox.style.marginLeft = -1 * this.scrollBody.scrollLeft + 'px';
      }

      if (frozenScrollBody) {
        frozenScrollBody.scrollTop = this.scrollBody.scrollTop;
      }
    }
  }, {
    key: "calculateRowHeight",
    value: function calculateRowHeight() {
      var row = DomHandler$1.findSingle(this.scrollTable, 'tr:not(.p-treetable-emptymessage-row)');

      if (row) {
        this.rowHeight = DomHandler$1.getOuterHeight(row);
      }
    }
  }, {
    key: "renderColGroup",
    value: function renderColGroup() {
      if (this.props.columns && this.props.columns.length) {
        return /*#__PURE__*/React.createElement("colgroup", {
          className: "p-treetable-scrollable-colgroup"
        }, this.props.columns.map(function (col, i) {
          return /*#__PURE__*/React.createElement("col", {
            key: col.field + '_' + i
          });
        }));
      } else {
        return null;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var className = classNames('p-treetable-scrollable-view', {
        'p-treetable-frozen-view': this.props.frozen,
        'p-treetable-unfrozen-view': !this.props.frozen && this.props.frozenWidth
      });
      var width = this.props.frozen ? this.props.frozenWidth : 'calc(100% - ' + this.props.frozenWidth + ')';
      var left = this.props.frozen ? null : this.props.frozenWidth;
      var colGroup = this.renderColGroup();
      var scrollableBodyStyle = !this.props.frozen && this.props.scrollHeight ? {
        overflowY: 'scroll'
      } : null;
      return /*#__PURE__*/React.createElement("div", {
        className: className,
        style: {
          width: width,
          left: left
        },
        ref: function ref(el) {
          _this2.container = el;
        }
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-treetable-scrollable-header",
        ref: function ref(el) {
          _this2.scrollHeader = el;
        },
        onScroll: this.onHeaderScroll
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-treetable-scrollable-header-box",
        ref: function ref(el) {
          _this2.scrollHeaderBox = el;
        }
      }, /*#__PURE__*/React.createElement("table", {
        className: "p-treetable-scrollable-header-table"
      }, colGroup, this.props.header))), /*#__PURE__*/React.createElement("div", {
        className: "p-treetable-scrollable-body",
        ref: function ref(el) {
          _this2.scrollBody = el;
        },
        style: scrollableBodyStyle,
        onScroll: this.onBodyScroll
      }, /*#__PURE__*/React.createElement("table", {
        ref: function ref(el) {
          _this2.scrollTable = el;
        },
        style: {
          top: '0'
        },
        className: "p-treetable-scrollable-body-table"
      }, colGroup, this.props.body)), /*#__PURE__*/React.createElement("div", {
        className: "p-treetable-scrollable-footer",
        ref: function ref(el) {
          _this2.scrollFooter = el;
        }
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-treetable-scrollable-footer-box",
        ref: function ref(el) {
          _this2.scrollFooterBox = el;
        }
      }, /*#__PURE__*/React.createElement("table", {
        className: "p-treetable-scrollable-footer-table"
      }, colGroup, this.props.footer))));
    }
  }]);

  return TreeTableScrollableView;
}(Component);

_defineProperty$1(TreeTableScrollableView, "defaultProps", {
  header: null,
  body: null,
  footer: null,
  columns: null,
  frozen: null,
  frozenWidth: null,
  frozenBody: null
});

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$1(this, result);
  };
}

function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TreeTable$1 = /*#__PURE__*/function (_Component) {
  _inherits$1(TreeTable, _Component);

  var _super = _createSuper$7(TreeTable);

  function TreeTable(props) {
    var _this;

    _classCallCheck$1(this, TreeTable);

    _this = _super.call(this, props);
    var state = {};

    if (!_this.props.onToggle) {
      _this.state = {
        expandedKeys: _this.props.expandedKeys
      };
    }

    if (!_this.props.onPage) {
      state.first = props.first;
      state.rows = props.rows;
    }

    if (!_this.props.onSort) {
      state.sortField = props.sortField;
      state.sortOrder = props.sortOrder;
      state.multiSortMeta = props.multiSortMeta;
    }

    if (!_this.props.onFilter) {
      state.filters = props.filters;
    }

    if (Object.keys(state).length) {
      _this.state = state;
    }

    _this.onToggle = _this.onToggle.bind(_assertThisInitialized$1(_this));
    _this.onPageChange = _this.onPageChange.bind(_assertThisInitialized$1(_this));
    _this.onSort = _this.onSort.bind(_assertThisInitialized$1(_this));
    _this.onFilter = _this.onFilter.bind(_assertThisInitialized$1(_this));
    _this.onColumnResizeStart = _this.onColumnResizeStart.bind(_assertThisInitialized$1(_this));
    _this.onColumnDragStart = _this.onColumnDragStart.bind(_assertThisInitialized$1(_this));
    _this.onColumnDragOver = _this.onColumnDragOver.bind(_assertThisInitialized$1(_this));
    _this.onColumnDragLeave = _this.onColumnDragLeave.bind(_assertThisInitialized$1(_this));
    _this.onColumnDrop = _this.onColumnDrop.bind(_assertThisInitialized$1(_this));
    return _this;
  }

  _createClass$1(TreeTable, [{
    key: "onToggle",
    value: function onToggle(event) {
      if (this.props.onToggle) {
        this.props.onToggle(event);
      } else {
        this.setState({
          expandedKeys: event.value
        });
      }
    }
  }, {
    key: "onPageChange",
    value: function onPageChange(event) {
      if (this.props.onPage) this.props.onPage(event);else this.setState({
        first: event.first,
        rows: event.rows
      });
    }
  }, {
    key: "onSort",
    value: function onSort(event) {
      var sortField = event.sortField;
      var sortOrder = this.props.defaultSortOrder;
      var multiSortMeta;
      var eventMeta;
      this.columnSortable = event.sortable;
      this.columnSortFunction = event.sortFunction;
      this.columnField = event.sortField;

      if (this.props.sortMode === 'multiple') {
        var metaKey = event.originalEvent.metaKey || event.originalEvent.ctrlKey;
        multiSortMeta = this.getMultiSortMeta();

        if (multiSortMeta && multiSortMeta instanceof Array) {
          var sortMeta = multiSortMeta.find(function (sortMeta) {
            return sortMeta.field === sortField;
          });
          sortOrder = sortMeta ? this.getCalculatedSortOrder(sortMeta.order) : sortOrder;
        }

        var newMetaData = {
          field: sortField,
          order: sortOrder
        };

        if (sortOrder) {
          if (!multiSortMeta || !metaKey) {
            multiSortMeta = [];
          }

          this.addSortMeta(newMetaData, multiSortMeta);
        } else if (this.props.removableSort && multiSortMeta) {
          this.removeSortMeta(newMetaData, multiSortMeta);
        }

        eventMeta = {
          multiSortMeta: multiSortMeta
        };
      } else {
        sortOrder = this.getSortField() === sortField ? this.getCalculatedSortOrder(this.getSortOrder()) : sortOrder;

        if (this.props.removableSort) {
          sortField = sortOrder ? sortField : null;
        }

        eventMeta = {
          sortField: sortField,
          sortOrder: sortOrder
        };
      }

      if (this.props.onSort) {
        this.props.onSort(eventMeta);
      } else {
        eventMeta.first = 0;
        this.setState(eventMeta);
      }
    }
  }, {
    key: "getCalculatedSortOrder",
    value: function getCalculatedSortOrder(currentOrder) {
      return this.props.removableSort ? this.props.defaultSortOrder === currentOrder ? currentOrder * -1 : 0 : currentOrder * -1;
    }
  }, {
    key: "addSortMeta",
    value: function addSortMeta(meta, multiSortMeta) {
      var index = -1;

      for (var i = 0; i < multiSortMeta.length; i++) {
        if (multiSortMeta[i].field === meta.field) {
          index = i;
          break;
        }
      }

      if (index >= 0) multiSortMeta[index] = meta;else multiSortMeta.push(meta);
    }
  }, {
    key: "removeSortMeta",
    value: function removeSortMeta(meta, multiSortMeta) {
      var index = -1;

      for (var i = 0; i < multiSortMeta.length; i++) {
        if (multiSortMeta[i].field === meta.field) {
          index = i;
          break;
        }
      }

      if (index >= 0) {
        multiSortMeta.splice(index, 1);
      }

      multiSortMeta = multiSortMeta.length > 0 ? multiSortMeta : null;
    }
  }, {
    key: "sortSingle",
    value: function sortSingle(data) {
      return this.sortNodes(data);
    }
  }, {
    key: "sortNodes",
    value: function sortNodes(data) {
      var _this2 = this;

      var value = _toConsumableArray(data);

      if (this.columnSortable && this.columnSortable === 'custom' && this.columnSortFunction) {
        value = this.columnSortFunction({
          field: this.getSortField(),
          order: this.getSortOrder()
        });
      } else {
        value.sort(function (node1, node2) {
          var sortField = _this2.getSortField();

          var value1 = ObjectUtils.resolveFieldData(node1.data, sortField);
          var value2 = ObjectUtils.resolveFieldData(node2.data, sortField);
          return ObjectUtils.sort(value1, value2, _this2.getSortOrder(), PrimeReact.locale);
        });

        for (var i = 0; i < value.length; i++) {
          if (value[i].children && value[i].children.length) {
            value[i].children = this.sortNodes(value[i].children);
          }
        }
      }

      return value;
    }
  }, {
    key: "sortMultiple",
    value: function sortMultiple(data) {
      var multiSortMeta = this.getMultiSortMeta();
      if (multiSortMeta) return this.sortMultipleNodes(data, multiSortMeta);else return data;
    }
  }, {
    key: "sortMultipleNodes",
    value: function sortMultipleNodes(data, multiSortMeta) {
      var _this3 = this;

      var value = _toConsumableArray(data);

      value.sort(function (node1, node2) {
        return _this3.multisortField(node1, node2, multiSortMeta, 0);
      });

      for (var i = 0; i < value.length; i++) {
        if (value[i].children && value[i].children.length) {
          value[i].children = this.sortMultipleNodes(value[i].children, multiSortMeta);
        }
      }

      return value;
    }
  }, {
    key: "multisortField",
    value: function multisortField(node1, node2, multiSortMeta, index) {
      var value1 = ObjectUtils.resolveFieldData(node1.data, multiSortMeta[index].field);
      var value2 = ObjectUtils.resolveFieldData(node2.data, multiSortMeta[index].field);
      var result = null;
      if (value1 == null && value2 != null) result = -1;else if (value1 != null && value2 == null) result = 1;else if (value1 == null && value2 == null) result = 0;else {
        if (value1 === value2) {
          return multiSortMeta.length - 1 > index ? this.multisortField(node1, node2, multiSortMeta, index + 1) : 0;
        } else {
          if ((typeof value1 === 'string' || value1 instanceof String) && (typeof value2 === 'string' || value2 instanceof String)) return multiSortMeta[index].order * value1.localeCompare(value2, PrimeReact.locale, {
            numeric: true
          });else result = value1 < value2 ? -1 : 1;
        }
      }
      return multiSortMeta[index].order * result;
    }
  }, {
    key: "filter",
    value: function filter(value, field, mode) {
      this.onFilter({
        value: value,
        field: field,
        matchMode: mode
      });
    }
  }, {
    key: "onFilter",
    value: function onFilter(event) {
      var currentFilters = this.getFilters();
      var newFilters = currentFilters ? _objectSpread$3({}, currentFilters) : {};
      if (!this.isFilterBlank(event.value)) newFilters[event.field] = {
        value: event.value,
        matchMode: event.matchMode
      };else if (newFilters[event.field]) delete newFilters[event.field];

      if (this.props.onFilter) {
        this.props.onFilter({
          filters: newFilters
        });
      } else {
        this.setState({
          first: 0,
          filters: newFilters
        });
      }
    }
  }, {
    key: "hasFilter",
    value: function hasFilter() {
      var filters = this.getFilters();
      return filters && Object.keys(filters).length > 0;
    }
  }, {
    key: "isFilterBlank",
    value: function isFilterBlank(filter) {
      if (filter !== null && filter !== undefined) {
        if (typeof filter === 'string' && filter.trim().length === 0 || filter instanceof Array && filter.length === 0) return true;else return false;
      }

      return true;
    }
  }, {
    key: "onColumnResizeStart",
    value: function onColumnResizeStart(event) {
      var containerLeft = DomHandler$1.getOffset(this.container).left;
      this.resizeColumn = event.columnEl;
      this.resizeColumnProps = event.column;
      this.columnResizing = true;
      this.lastResizerHelperX = event.originalEvent.pageX - containerLeft + this.container.scrollLeft;
      this.bindColumnResizeEvents();
    }
  }, {
    key: "onColumnResize",
    value: function onColumnResize(event) {
      var containerLeft = DomHandler$1.getOffset(this.container).left;
      DomHandler$1.addClass(this.container, 'p-unselectable-text');
      this.resizerHelper.style.height = this.container.offsetHeight + 'px';
      this.resizerHelper.style.top = 0 + 'px';
      this.resizerHelper.style.left = event.pageX - containerLeft + this.container.scrollLeft + 'px';
      this.resizerHelper.style.display = 'block';
    }
  }, {
    key: "onColumnResizeEnd",
    value: function onColumnResizeEnd(event) {
      var delta = this.resizerHelper.offsetLeft - this.lastResizerHelperX;
      var columnWidth = this.resizeColumn.offsetWidth;
      var newColumnWidth = columnWidth + delta;
      var minWidth = this.resizeColumn.style.minWidth || 15;

      if (columnWidth + delta > parseInt(minWidth, 10)) {
        if (this.props.columnResizeMode === 'fit') {
          var nextColumn = this.resizeColumn.nextElementSibling;
          var nextColumnWidth = nextColumn.offsetWidth - delta;

          if (newColumnWidth > 15 && nextColumnWidth > 15) {
            if (this.props.scrollable) {
              var scrollableView = this.findParentScrollableView(this.resizeColumn);
              var scrollableBodyTable = DomHandler$1.findSingle(scrollableView, 'table.p-treetable-scrollable-body-table');
              var scrollableHeaderTable = DomHandler$1.findSingle(scrollableView, 'table.p-treetable-scrollable-header-table');
              var scrollableFooterTable = DomHandler$1.findSingle(scrollableView, 'table.p-treetable-scrollable-footer-table');
              var resizeColumnIndex = DomHandler$1.index(this.resizeColumn);
              this.resizeColGroup(scrollableHeaderTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
              this.resizeColGroup(scrollableBodyTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
              this.resizeColGroup(scrollableFooterTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
            } else {
              this.resizeColumn.style.width = newColumnWidth + 'px';

              if (nextColumn) {
                nextColumn.style.width = nextColumnWidth + 'px';
              }
            }
          }
        } else if (this.props.columnResizeMode === 'expand') {
          if (this.props.scrollable) {
            var _scrollableView = this.findParentScrollableView(this.resizeColumn);

            var _scrollableBodyTable = DomHandler$1.findSingle(_scrollableView, 'table.p-treetable-scrollable-body-table');

            var _scrollableHeaderTable = DomHandler$1.findSingle(_scrollableView, 'table.p-treetable-scrollable-header-table');

            var _scrollableFooterTable = DomHandler$1.findSingle(_scrollableView, 'table.p-treetable-scrollable-footer-table');

            _scrollableBodyTable.style.width = _scrollableBodyTable.offsetWidth + delta + 'px';
            _scrollableHeaderTable.style.width = _scrollableHeaderTable.offsetWidth + delta + 'px';

            if (_scrollableFooterTable) {
              _scrollableFooterTable.style.width = _scrollableHeaderTable.offsetWidth + delta + 'px';
            }

            var _resizeColumnIndex = DomHandler$1.index(this.resizeColumn);

            this.resizeColGroup(_scrollableHeaderTable, _resizeColumnIndex, newColumnWidth, null);
            this.resizeColGroup(_scrollableBodyTable, _resizeColumnIndex, newColumnWidth, null);
            this.resizeColGroup(_scrollableFooterTable, _resizeColumnIndex, newColumnWidth, null);
          } else {
            this.table.style.width = this.table.offsetWidth + delta + 'px';
            this.resizeColumn.style.width = newColumnWidth + 'px';
          }
        }

        if (this.props.onColumnResizeEnd) {
          this.props.onColumnResizeEnd({
            element: this.resizeColumn,
            column: this.resizeColumnProps,
            delta: delta
          });
        }
      }

      this.resizerHelper.style.display = 'none';
      this.resizeColumn = null;
      this.resizeColumnProps = null;
      DomHandler$1.removeClass(this.container, 'p-unselectable-text');
      this.unbindColumnResizeEvents();
    }
  }, {
    key: "findParentScrollableView",
    value: function findParentScrollableView(column) {
      if (column) {
        var parent = column.parentElement;

        while (parent && !DomHandler$1.hasClass(parent, 'p-treetable-scrollable-view')) {
          parent = parent.parentElement;
        }

        return parent;
      } else {
        return null;
      }
    }
  }, {
    key: "resizeColGroup",
    value: function resizeColGroup(table, resizeColumnIndex, newColumnWidth, nextColumnWidth) {
      if (table) {
        var colGroup = table.children[0].nodeName === 'COLGROUP' ? table.children[0] : null;

        if (colGroup) {
          var col = colGroup.children[resizeColumnIndex];
          var nextCol = col.nextElementSibling;
          col.style.width = newColumnWidth + 'px';

          if (nextCol && nextColumnWidth) {
            nextCol.style.width = nextColumnWidth + 'px';
          }
        } else {
          throw new Error("Scrollable tables require a colgroup to support resizable columns");
        }
      }
    }
  }, {
    key: "bindColumnResizeEvents",
    value: function bindColumnResizeEvents() {
      var _this4 = this;

      this.documentColumnResizeListener = document.addEventListener('mousemove', function (event) {
        if (_this4.columnResizing) {
          _this4.onColumnResize(event);
        }
      });
      this.documentColumnResizeEndListener = document.addEventListener('mouseup', function (event) {
        if (_this4.columnResizing) {
          _this4.columnResizing = false;

          _this4.onColumnResizeEnd(event);
        }
      });
    }
  }, {
    key: "unbindColumnResizeEvents",
    value: function unbindColumnResizeEvents() {
      document.removeEventListener('document', this.documentColumnResizeListener);
      document.removeEventListener('document', this.documentColumnResizeEndListener);
    }
  }, {
    key: "onColumnDragStart",
    value: function onColumnDragStart(e) {
      var event = e.originalEvent,
          column = e.column;

      if (this.columnResizing) {
        event.preventDefault();
        return;
      }

      this.iconWidth = DomHandler$1.getHiddenElementOuterWidth(this.reorderIndicatorUp);
      this.iconHeight = DomHandler$1.getHiddenElementOuterHeight(this.reorderIndicatorUp);
      this.draggedColumnEl = this.findParentHeader(event.currentTarget);
      this.draggedColumn = column;
      event.dataTransfer.setData('text', 'b'); // Firefox requires this to make dragging possible
    }
  }, {
    key: "onColumnDragOver",
    value: function onColumnDragOver(e) {
      var event = e.originalEvent;
      var dropHeader = this.findParentHeader(event.currentTarget);

      if (this.props.reorderableColumns && this.draggedColumnEl && dropHeader) {
        event.preventDefault();
        var containerOffset = DomHandler$1.getOffset(this.container);
        var dropHeaderOffset = DomHandler$1.getOffset(dropHeader);

        if (this.draggedColumnEl !== dropHeader) {
          var targetLeft = dropHeaderOffset.left - containerOffset.left; //let targetTop =  containerOffset.top - dropHeaderOffset.top;

          var columnCenter = dropHeaderOffset.left + dropHeader.offsetWidth / 2;
          this.reorderIndicatorUp.style.top = dropHeaderOffset.top - containerOffset.top - (this.iconHeight - 1) + 'px';
          this.reorderIndicatorDown.style.top = dropHeaderOffset.top - containerOffset.top + dropHeader.offsetHeight + 'px';

          if (event.pageX > columnCenter) {
            this.reorderIndicatorUp.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(this.iconWidth / 2) + 'px';
            this.reorderIndicatorDown.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(this.iconWidth / 2) + 'px';
            this.dropPosition = 1;
          } else {
            this.reorderIndicatorUp.style.left = targetLeft - Math.ceil(this.iconWidth / 2) + 'px';
            this.reorderIndicatorDown.style.left = targetLeft - Math.ceil(this.iconWidth / 2) + 'px';
            this.dropPosition = -1;
          }

          this.reorderIndicatorUp.style.display = 'block';
          this.reorderIndicatorDown.style.display = 'block';
        }
      }
    }
  }, {
    key: "onColumnDragLeave",
    value: function onColumnDragLeave(e) {
      var event = e.originalEvent;

      if (this.props.reorderableColumns && this.draggedColumnEl) {
        event.preventDefault();
        this.reorderIndicatorUp.style.display = 'none';
        this.reorderIndicatorDown.style.display = 'none';
      }
    }
  }, {
    key: "onColumnDrop",
    value: function onColumnDrop(e) {
      var _this5 = this;

      var event = e.originalEvent,
          column = e.column;
      event.preventDefault();

      if (this.draggedColumnEl) {
        var dragIndex = DomHandler$1.index(this.draggedColumnEl);
        var dropIndex = DomHandler$1.index(this.findParentHeader(event.currentTarget));
        var allowDrop = dragIndex !== dropIndex;

        if (allowDrop && (dropIndex - dragIndex === 1 && this.dropPosition === -1 || dragIndex - dropIndex === 1 && this.dropPosition === 1)) {
          allowDrop = false;
        }

        if (allowDrop) {
          var columns = this.state.columnOrder ? this.getColumns() : React.Children.toArray(this.props.children);

          var isSameColumn = function isSameColumn(col1, col2) {
            return col1.props.columnKey || col2.props.columnKey ? ObjectUtils.equals(col1, col2, 'props.columnKey') : ObjectUtils.equals(col1, col2, 'props.field');
          };

          var dragColIndex = columns.findIndex(function (child) {
            return isSameColumn(child, _this5.draggedColumn);
          });
          var dropColIndex = columns.findIndex(function (child) {
            return isSameColumn(child, column);
          });

          if (dropColIndex < dragColIndex && this.dropPosition === 1) {
            dropColIndex++;
          }

          if (dropColIndex > dragColIndex && this.dropPosition === -1) {
            dropColIndex--;
          }

          ObjectUtils.reorderArray(columns, dragColIndex, dropColIndex);
          var columnOrder = [];

          var _iterator = _createForOfIteratorHelper(columns),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _column = _step.value;
              columnOrder.push(_column.props.columnKey || _column.props.field);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          this.setState({
            columnOrder: columnOrder
          });

          if (this.props.onColReorder) {
            this.props.onColReorder({
              dragIndex: dragColIndex,
              dropIndex: dropColIndex,
              columns: columns
            });
          }
        }

        this.reorderIndicatorUp.style.display = 'none';
        this.reorderIndicatorDown.style.display = 'none';
        this.draggedColumnEl.draggable = false;
        this.draggedColumnEl = null;
        this.dropPosition = null;
      }
    }
  }, {
    key: "findParentHeader",
    value: function findParentHeader(element) {
      if (element.nodeName === 'TH') {
        return element;
      } else {
        var parent = element.parentElement;

        while (parent.nodeName !== 'TH') {
          parent = parent.parentElement;
          if (!parent) break;
        }

        return parent;
      }
    }
  }, {
    key: "getExpandedKeys",
    value: function getExpandedKeys() {
      return this.props.onToggle ? this.props.expandedKeys : this.state.expandedKeys;
    }
  }, {
    key: "getFirst",
    value: function getFirst() {
      return this.props.onPage ? this.props.first : this.state.first;
    }
  }, {
    key: "getRows",
    value: function getRows() {
      return this.props.onPage ? this.props.rows : this.state.rows;
    }
  }, {
    key: "getSortField",
    value: function getSortField() {
      return this.props.onSort ? this.props.sortField : this.state.sortField;
    }
  }, {
    key: "getSortOrder",
    value: function getSortOrder() {
      return this.props.onSort ? this.props.sortOrder : this.state.sortOrder;
    }
  }, {
    key: "getMultiSortMeta",
    value: function getMultiSortMeta() {
      return this.props.onSort ? this.props.multiSortMeta : this.state.multiSortMeta;
    }
  }, {
    key: "getFilters",
    value: function getFilters() {
      return this.props.onFilter ? this.props.filters : this.state.filters;
    }
  }, {
    key: "findColumnByKey",
    value: function findColumnByKey(columns, key) {
      if (columns && columns.length) {
        for (var i = 0; i < columns.length; i++) {
          var child = columns[i];

          if (child.props.columnKey === key || child.props.field === key) {
            return child;
          }
        }
      }

      return null;
    }
  }, {
    key: "getColumns",
    value: function getColumns() {
      var columns = React.Children.toArray(this.props.children);

      if (columns && columns.length) {
        if (this.props.reorderableColumns && this.state.columnOrder) {
          var orderedColumns = [];

          var _iterator2 = _createForOfIteratorHelper(this.state.columnOrder),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var columnKey = _step2.value;
              var column = this.findColumnByKey(columns, columnKey);

              if (column) {
                orderedColumns.push(column);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          return [].concat(orderedColumns, _toConsumableArray(columns.filter(function (item) {
            return orderedColumns.indexOf(item) < 0;
          })));
        } else {
          return columns;
        }
      }

      return null;
    }
  }, {
    key: "getTotalRecords",
    value: function getTotalRecords(data) {
      return this.props.lazy ? this.props.totalRecords : data ? data.length : 0;
    }
  }, {
    key: "isSingleSelectionMode",
    value: function isSingleSelectionMode() {
      return this.props.selectionMode && this.props.selectionMode === 'single';
    }
  }, {
    key: "isMultipleSelectionMode",
    value: function isMultipleSelectionMode() {
      return this.props.selectionMode && this.props.selectionMode === 'multiple';
    }
  }, {
    key: "isRowSelectionMode",
    value: function isRowSelectionMode() {
      return this.isSingleSelectionMode() || this.isMultipleSelectionMode();
    }
  }, {
    key: "getFrozenColumns",
    value: function getFrozenColumns(columns) {
      var frozenColumns = null;

      var _iterator3 = _createForOfIteratorHelper(columns),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var col = _step3.value;

          if (col.props.frozen) {
            frozenColumns = frozenColumns || [];
            frozenColumns.push(col);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return frozenColumns;
    }
  }, {
    key: "getScrollableColumns",
    value: function getScrollableColumns(columns) {
      var scrollableColumns = null;

      var _iterator4 = _createForOfIteratorHelper(columns),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var col = _step4.value;

          if (!col.props.frozen) {
            scrollableColumns = scrollableColumns || [];
            scrollableColumns.push(col);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return scrollableColumns;
    }
  }, {
    key: "filterLocal",
    value: function filterLocal(value) {
      var filteredNodes = [];
      var filters = this.getFilters();
      var columns = React.Children.toArray(this.props.children);
      var isStrictMode = this.props.filterMode === 'strict';

      var _iterator5 = _createForOfIteratorHelper(value),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var node = _step5.value;

          var copyNode = _objectSpread$3({}, node);

          var localMatch = true;
          var globalMatch = false;

          for (var j = 0; j < columns.length; j++) {
            var col = columns[j];
            var filterMeta = filters ? filters[col.props.field] : null;
            var filterField = col.props.field;
            var filterValue = void 0,
                filterConstraint = void 0,
                paramsWithoutNode = void 0,
                options = void 0; //local

            if (filterMeta) {
              var filterMatchMode = filterMeta.matchMode || col.props.filterMatchMode || 'startsWith';
              filterValue = filterMeta.value;
              filterConstraint = filterMatchMode === 'custom' ? col.props.filterFunction : FilterService.filters[filterMatchMode];
              options = {
                rowData: node,
                filters: filters,
                props: this.props,
                column: {
                  filterMeta: filterMeta,
                  filterField: filterField,
                  props: col.props
                }
              };
              paramsWithoutNode = {
                filterField: filterField,
                filterValue: filterValue,
                filterConstraint: filterConstraint,
                isStrictMode: isStrictMode,
                options: options
              };

              if (isStrictMode && !(this.findFilteredNodes(copyNode, paramsWithoutNode) || this.isFilterMatched(copyNode, paramsWithoutNode)) || !isStrictMode && !(this.isFilterMatched(copyNode, paramsWithoutNode) || this.findFilteredNodes(copyNode, paramsWithoutNode))) {
                localMatch = false;
              }

              if (!localMatch) {
                break;
              }
            } //global


            if (this.props.globalFilter && !globalMatch) {
              var copyNodeForGlobal = _objectSpread$3({}, copyNode);

              filterValue = this.props.globalFilter;
              filterConstraint = FilterService.filters['contains'];
              paramsWithoutNode = {
                filterField: filterField,
                filterValue: filterValue,
                filterConstraint: filterConstraint,
                isStrictMode: isStrictMode
              };

              if (isStrictMode && (this.findFilteredNodes(copyNodeForGlobal, paramsWithoutNode) || this.isFilterMatched(copyNodeForGlobal, paramsWithoutNode)) || !isStrictMode && (this.isFilterMatched(copyNodeForGlobal, paramsWithoutNode) || this.findFilteredNodes(copyNodeForGlobal, paramsWithoutNode))) {
                globalMatch = true;
                copyNode = copyNodeForGlobal;
              }
            }
          }

          var matches = localMatch;

          if (this.props.globalFilter) {
            matches = localMatch && globalMatch;
          }

          if (matches) {
            filteredNodes.push(copyNode);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return filteredNodes;
    }
  }, {
    key: "findFilteredNodes",
    value: function findFilteredNodes(node, paramsWithoutNode) {
      if (node) {
        var matched = false;

        if (node.children) {
          var childNodes = _toConsumableArray(node.children);

          node.children = [];

          var _iterator6 = _createForOfIteratorHelper(childNodes),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var childNode = _step6.value;

              var copyChildNode = _objectSpread$3({}, childNode);

              if (this.isFilterMatched(copyChildNode, paramsWithoutNode)) {
                matched = true;
                node.children.push(copyChildNode);
              }
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        }

        if (matched) {
          return true;
        }
      }
    }
  }, {
    key: "isFilterMatched",
    value: function isFilterMatched(node, _ref) {
      var filterField = _ref.filterField,
          filterValue = _ref.filterValue,
          filterConstraint = _ref.filterConstraint,
          isStrictMode = _ref.isStrictMode,
          options = _ref.options;
      var matched = false;
      var dataFieldValue = ObjectUtils.resolveFieldData(node.data, filterField);

      if (filterConstraint(dataFieldValue, filterValue, this.props.filterLocale, options)) {
        matched = true;
      }

      if (!matched || isStrictMode && !this.isNodeLeaf(node)) {
        matched = this.findFilteredNodes(node, {
          filterField: filterField,
          filterValue: filterValue,
          filterConstraint: filterConstraint,
          isStrictMode: isStrictMode
        }) || matched;
      }

      return matched;
    }
  }, {
    key: "isNodeLeaf",
    value: function isNodeLeaf(node) {
      return node.leaf === false ? false : !(node.children && node.children.length);
    }
  }, {
    key: "processValue",
    value: function processValue() {
      var data = this.props.value;

      if (!this.props.lazy) {
        if (data && data.length) {
          if (this.getSortField() || this.getMultiSortMeta()) {
            if (this.props.sortMode === 'single') data = this.sortSingle(data);else if (this.props.sortMode === 'multiple') data = this.sortMultiple(data);
          }

          var localFilters = this.getFilters();

          if (localFilters || this.props.globalFilter) {
            data = this.filterLocal(data, localFilters);
          }
        }
      }

      return data;
    }
  }, {
    key: "createTableHeader",
    value: function createTableHeader(columns, columnGroup) {
      return /*#__PURE__*/React.createElement(TreeTableHeader, {
        columns: columns,
        columnGroup: columnGroup,
        tabIndex: this.props.tabIndex,
        onSort: this.onSort,
        sortField: this.getSortField(),
        sortOrder: this.getSortOrder(),
        multiSortMeta: this.getMultiSortMeta(),
        resizableColumns: this.props.resizableColumns,
        onResizeStart: this.onColumnResizeStart,
        reorderableColumns: this.props.reorderableColumns,
        onDragStart: this.onColumnDragStart,
        onDragOver: this.onColumnDragOver,
        onDragLeave: this.onColumnDragLeave,
        onDrop: this.onColumnDrop,
        onFilter: this.onFilter,
        filters: this.getFilters(),
        filterDelay: this.props.filterDelay
      });
    }
  }, {
    key: "createTableFooter",
    value: function createTableFooter(columns, columnGroup) {
      return /*#__PURE__*/React.createElement(TreeTableFooter, {
        columns: columns,
        columnGroup: columnGroup
      });
    }
  }, {
    key: "createTableBody",
    value: function createTableBody(value, columns) {
      return /*#__PURE__*/React.createElement(TreeTableBody, {
        value: value,
        columns: columns,
        expandedKeys: this.getExpandedKeys(),
        selectOnEdit: this.props.selectOnEdit,
        onToggle: this.onToggle,
        onExpand: this.props.onExpand,
        onCollapse: this.props.onCollapse,
        paginator: this.props.paginator,
        first: this.getFirst(),
        rows: this.getRows(),
        selectionMode: this.props.selectionMode,
        selectionKeys: this.props.selectionKeys,
        onSelectionChange: this.props.onSelectionChange,
        metaKeySelection: this.props.metaKeySelection,
        onRowClick: this.props.onRowClick,
        onSelect: this.props.onSelect,
        onUnselect: this.props.onUnselect,
        propagateSelectionUp: this.props.propagateSelectionUp,
        propagateSelectionDown: this.props.propagateSelectionDown,
        lazy: this.props.lazy,
        rowClassName: this.props.rowClassName,
        emptyMessage: this.props.emptyMessage,
        loading: this.props.loading,
        contextMenuSelectionKey: this.props.contextMenuSelectionKey,
        onContextMenuSelectionChange: this.props.onContextMenuSelectionChange,
        onContextMenu: this.props.onContextMenu
      });
    }
  }, {
    key: "createPaginator",
    value: function createPaginator(position, totalRecords) {
      var className = classNames('p-paginator-' + position, this.props.paginatorClassName);
      return /*#__PURE__*/React.createElement(Paginator, {
        first: this.getFirst(),
        rows: this.getRows(),
        pageLinkSize: this.props.pageLinkSize,
        className: className,
        onPageChange: this.onPageChange,
        template: this.props.paginatorTemplate,
        totalRecords: totalRecords,
        rowsPerPageOptions: this.props.rowsPerPageOptions,
        currentPageReportTemplate: this.props.currentPageReportTemplate,
        leftContent: this.props.paginatorLeft,
        rightContent: this.props.paginatorRight,
        alwaysShow: this.props.alwaysShowPaginator,
        dropdownAppendTo: this.props.paginatorDropdownAppendTo
      });
    }
  }, {
    key: "createScrollableView",
    value: function createScrollableView(value, columns, frozen, headerColumnGroup, footerColumnGroup) {
      var header = this.createTableHeader(columns, headerColumnGroup);
      var footer = this.createTableFooter(columns, footerColumnGroup);
      var body = this.createTableBody(value, columns);
      return /*#__PURE__*/React.createElement(TreeTableScrollableView, {
        columns: columns,
        header: header,
        body: body,
        footer: footer,
        scrollHeight: this.props.scrollHeight,
        frozen: frozen,
        frozenWidth: this.props.frozenWidth
      });
    }
  }, {
    key: "renderScrollableTable",
    value: function renderScrollableTable(value) {
      var columns = this.getColumns();
      var frozenColumns = this.getFrozenColumns(columns);
      var scrollableColumns = frozenColumns ? this.getScrollableColumns(columns) : columns;
      var frozenView, scrollableView;

      if (frozenColumns) {
        frozenView = this.createScrollableView(value, frozenColumns, true, this.props.frozenHeaderColumnGroup, this.props.frozenFooterColumnGroup);
      }

      scrollableView = this.createScrollableView(value, scrollableColumns, false, this.props.headerColumnGroup, this.props.footerColumnGroup);
      return /*#__PURE__*/React.createElement("div", {
        className: "p-treetable-scrollable-wrapper"
      }, frozenView, scrollableView);
    }
  }, {
    key: "renderRegularTable",
    value: function renderRegularTable(value) {
      var _this6 = this;

      var columns = this.getColumns();
      var header = this.createTableHeader(columns, this.props.headerColumnGroup);
      var footer = this.createTableFooter(columns, this.props.footerColumnGroup);
      var body = this.createTableBody(value, columns);
      return /*#__PURE__*/React.createElement("div", {
        className: "p-treetable-wrapper"
      }, /*#__PURE__*/React.createElement("table", {
        style: this.props.tableStyle,
        className: this.props.tableClassName,
        ref: function ref(el) {
          return _this6.table = el;
        }
      }, header, footer, body));
    }
  }, {
    key: "renderTable",
    value: function renderTable(value) {
      if (this.props.scrollable) return this.renderScrollableTable(value);else return this.renderRegularTable(value);
    }
  }, {
    key: "renderLoader",
    value: function renderLoader() {
      if (this.props.loading) {
        var iconClassName = classNames('p-treetable-loading-icon pi-spin', this.props.loadingIcon);
        return /*#__PURE__*/React.createElement("div", {
          className: "p-treetable-loading"
        }, /*#__PURE__*/React.createElement("div", {
          className: "p-treetable-loading-overlay p-component-overlay"
        }, /*#__PURE__*/React.createElement("i", {
          className: iconClassName
        })));
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var _this7 = this;

      var value = this.processValue();
      var className = classNames('p-treetable p-component', {
        'p-treetable-hoverable-rows': this.props.rowHover,
        'p-treetable-selectable': this.isRowSelectionMode(),
        'p-treetable-resizable': this.props.resizableColumns,
        'p-treetable-resizable-fit': this.props.resizableColumns && this.props.columnResizeMode === 'fit',
        'p-treetable-auto-layout': this.props.autoLayout,
        'p-treetable-striped': this.props.stripedRows,
        'p-treetable-gridlines': this.props.showGridlines
      }, this.props.className);
      var table = this.renderTable(value);
      var totalRecords = this.getTotalRecords(value);
      var headerFacet = this.props.header && /*#__PURE__*/React.createElement("div", {
        className: "p-treetable-header"
      }, this.props.header);
      var footerFacet = this.props.footer && /*#__PURE__*/React.createElement("div", {
        className: "p-treetable-footer"
      }, this.props.footer);
      var paginatorTop = this.props.paginator && this.props.paginatorPosition !== 'bottom' && this.createPaginator('top', totalRecords);
      var paginatorBottom = this.props.paginator && this.props.paginatorPosition !== 'top' && this.createPaginator('bottom', totalRecords);
      var loader = this.renderLoader();
      var resizeHelper = this.props.resizableColumns && /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          _this7.resizerHelper = el;
        },
        className: "p-column-resizer-helper",
        style: {
          display: 'none'
        }
      });
      var reorderIndicatorUp = this.props.reorderableColumns && /*#__PURE__*/React.createElement("span", {
        ref: function ref(el) {
          return _this7.reorderIndicatorUp = el;
        },
        className: "pi pi-arrow-down p-datatable-reorder-indicator-up",
        style: {
          position: 'absolute',
          display: 'none'
        }
      });
      var reorderIndicatorDown = this.props.reorderableColumns && /*#__PURE__*/React.createElement("span", {
        ref: function ref(el) {
          return _this7.reorderIndicatorDown = el;
        },
        className: "pi pi-arrow-up p-datatable-reorder-indicator-down",
        style: {
          position: 'absolute',
          display: 'none'
        }
      });
      return /*#__PURE__*/React.createElement("div", {
        id: this.props.id,
        className: className,
        style: this.props.style,
        ref: function ref(el) {
          return _this7.container = el;
        },
        "data-scrollselectors": ".p-treetable-scrollable-body"
      }, loader, headerFacet, paginatorTop, table, paginatorBottom, footerFacet, resizeHelper, reorderIndicatorUp, reorderIndicatorDown);
    }
  }]);

  return TreeTable;
}(Component);

_defineProperty$1(TreeTable$1, "defaultProps", {
  id: null,
  value: null,
  header: null,
  footer: null,
  style: null,
  className: null,
  tableStyle: null,
  tableClassName: null,
  expandedKeys: null,
  paginator: false,
  paginatorPosition: 'bottom',
  alwaysShowPaginator: true,
  paginatorClassName: null,
  paginatorTemplate: 'FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown',
  paginatorLeft: null,
  paginatorRight: null,
  paginatorDropdownAppendTo: null,
  pageLinkSize: 5,
  rowsPerPageOptions: null,
  currentPageReportTemplate: '({currentPage} of {totalPages})',
  first: null,
  rows: null,
  totalRecords: null,
  lazy: false,
  sortField: null,
  sortOrder: null,
  multiSortMeta: null,
  sortMode: 'single',
  defaultSortOrder: 1,
  removableSort: false,
  selectionMode: null,
  selectionKeys: null,
  contextMenuSelectionKey: null,
  metaKeySelection: true,
  selectOnEdit: true,
  propagateSelectionUp: true,
  propagateSelectionDown: true,
  autoLayout: false,
  rowClassName: null,
  loading: false,
  loadingIcon: 'pi pi-spinner',
  tabIndex: 0,
  scrollable: false,
  scrollHeight: null,
  reorderableColumns: false,
  headerColumnGroup: null,
  footerColumnGroup: null,
  frozenHeaderColumnGroup: null,
  frozenFooterColumnGroup: null,
  frozenWidth: null,
  resizableColumns: false,
  columnResizeMode: 'fit',
  emptyMessage: null,
  filters: null,
  globalFilter: null,
  filterMode: 'lenient',
  filterDelay: 300,
  filterLocale: undefined,
  rowHover: false,
  showGridlines: false,
  stripedRows: false,
  onFilter: null,
  onExpand: null,
  onCollapse: null,
  onToggle: null,
  onPage: null,
  onSort: null,
  onSelect: null,
  onUnselect: null,
  onRowClick: null,
  onSelectionChange: null,
  onContextMenuSelectionChange: null,
  onColumnResizeEnd: null,
  onColReorder: null,
  onContextMenu: null
});

var TreeTable = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      header = _ref.header,
      footer = _ref.footer,
      style = _ref.style,
      className = _ref.className,
      tableStyle = _ref.tableStyle,
      tableClassName = _ref.tableClassName,
      expandedKeys = _ref.expandedKeys,
      first = _ref.first,
      _ref$lazy = _ref.lazy,
      lazy = _ref$lazy === void 0 ? false : _ref$lazy,
      sortField = _ref.sortField,
      sortOrder = _ref.sortOrder,
      multiSortMeta = _ref.multiSortMeta,
      _ref$sortMode = _ref.sortMode,
      sortMode = _ref$sortMode === void 0 ? "single" : _ref$sortMode,
      _ref$defaultSortOrder = _ref.defaultSortOrder,
      defaultSortOrder = _ref$defaultSortOrder === void 0 ? 1 : _ref$defaultSortOrder,
      _ref$removableSort = _ref.removableSort,
      removableSort = _ref$removableSort === void 0 ? false : _ref$removableSort,
      _ref$selectionMode = _ref.selectionMode,
      selectionMode = _ref$selectionMode === void 0 ? false : _ref$selectionMode,
      selectionKeys = _ref.selectionKeys,
      _ref$metaKeySelection = _ref.metaKeySelection,
      metaKeySelection = _ref$metaKeySelection === void 0 ? true : _ref$metaKeySelection,
      _ref$selectOnEdit = _ref.selectOnEdit,
      selectOnEdit = _ref$selectOnEdit === void 0 ? true : _ref$selectOnEdit,
      _ref$propagateSelecti = _ref.propagateSelectionUp,
      propagateSelectionUp = _ref$propagateSelecti === void 0 ? true : _ref$propagateSelecti,
      _ref$propagateSelecti2 = _ref.propagateSelectionDown,
      propagateSelectionDown = _ref$propagateSelecti2 === void 0 ? true : _ref$propagateSelecti2,
      _ref$autoLayout = _ref.autoLayout,
      autoLayout = _ref$autoLayout === void 0 ? false : _ref$autoLayout,
      rowClassName = _ref.rowClassName,
      _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? false : _ref$loading,
      _ref$tabIndex = _ref.tabIndex,
      tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
      _ref$scrollable = _ref.scrollable,
      scrollable = _ref$scrollable === void 0 ? false : _ref$scrollable,
      scrollHeight = _ref.scrollHeight,
      headerColumnGroup = _ref.headerColumnGroup,
      footerColumnGroup = _ref.footerColumnGroup,
      frozenHeaderColumnGroup = _ref.frozenHeaderColumnGroup,
      frozenFooterColumnGroup = _ref.frozenFooterColumnGroup,
      frozenWidth = _ref.frozenWidth,
      emptyMessage = _ref.emptyMessage,
      _ref$showGridlines = _ref.showGridlines,
      showGridlines = _ref$showGridlines === void 0 ? false : _ref$showGridlines,
      onExpand = _ref.onExpand,
      onCollapse = _ref.onCollapse,
      onToggle = _ref.onToggle,
      onSelect = _ref.onSelect,
      onUnselect = _ref.onUnselect,
      onSelectionChange = _ref.onSelectionChange,
      children = _ref.children;
  return /*#__PURE__*/React.createElement(TreeTable$1, {
    ref: ref,
    id: id,
    value: value,
    header: header,
    footer: footer,
    style: style,
    className: className,
    tableStyle: tableStyle,
    tableClassName: tableClassName,
    expandedKeys: expandedKeys,
    first: first,
    lazy: lazy,
    sortField: sortField,
    sortOrder: sortOrder,
    multiSortMeta: multiSortMeta,
    sortMode: sortMode,
    defaultSortOrder: defaultSortOrder,
    removableSort: removableSort,
    selectionMode: selectionMode ? "checkbox" : null,
    selectionKeys: selectionKeys,
    metaKeySelection: metaKeySelection,
    selectOnEdit: selectOnEdit,
    propagateSelectionUp: propagateSelectionUp,
    propagateSelectionDown: propagateSelectionDown,
    autoLayout: autoLayout,
    rowClassName: rowClassName,
    loading: loading,
    tabIndex: tabIndex,
    scrollable: scrollable,
    scrollHeight: scrollHeight,
    headerColumnGroup: headerColumnGroup,
    footerColumnGroup: footerColumnGroup,
    frozenHeaderColumnGroup: frozenHeaderColumnGroup,
    frozenFooterColumnGroup: frozenFooterColumnGroup,
    frozenWidth: frozenWidth,
    emptyMessage: emptyMessage,
    showGridlines: showGridlines,
    onExpand: onExpand,
    onCollapse: onCollapse,
    onToggle: onToggle,
    onSelect: onSelect,
    onUnselect: onUnselect,
    onSelectionChange: onSelectionChange,
    alwaysShowPaginator: false
  }, children);
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var TriStateCheckbox$1 = /*#__PURE__*/function (_Component) {
  _inherits(TriStateCheckbox, _Component);

  var _super = _createSuper(TriStateCheckbox);

  function TriStateCheckbox(props) {
    var _this;

    _classCallCheck(this, TriStateCheckbox);

    _this = _super.call(this, props);
    _this.state = {
      focused: false
    };
    _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized(_this));
    _this.inputRef = /*#__PURE__*/createRef(_this.props.inputRef);
    return _this;
  }

  _createClass(TriStateCheckbox, [{
    key: "onClick",
    value: function onClick(event) {
      if (!this.props.disabled) {
        this.toggle(event);
        this.inputRef.current.focus();
      }
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      var newValue;
      if (this.props.value === null || this.props.value === undefined) newValue = true;else if (this.props.value === true) newValue = false;else if (this.props.value === false) newValue = null;

      if (this.props.onChange) {
        this.props.onChange({
          originalEvent: event,
          value: newValue,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: this.props.name,
            id: this.props.id,
            value: newValue
          }
        });
      }
    }
  }, {
    key: "onFocus",
    value: function onFocus() {
      this.setState({
        focused: true
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        focused: false
      });
    }
  }, {
    key: "updateInputRef",
    value: function updateInputRef() {
      var ref = this.props.inputRef;

      if (ref) {
        if (typeof ref === 'function') {
          ref(this.inputRef.current);
        } else {
          ref.current = this.inputRef.current;
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateInputRef();

      if (this.props.tooltip && !this.props.disabled) {
        this.renderTooltip();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.tooltip !== this.props.tooltip || prevProps.tooltipOptions !== this.props.tooltipOptions) {
        if (this.tooltip) this.tooltip.update(_objectSpread({
          content: this.props.tooltip
        }, this.props.tooltipOptions || {}));else this.renderTooltip();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.tooltip) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      this.tooltip = tip({
        target: this.element,
        content: this.props.tooltip,
        options: this.props.tooltipOptions
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var containerClass = classNames('p-tristatecheckbox p-checkbox p-component', this.props.className);
      var boxClass = classNames('p-checkbox-box', {
        'p-highlight': (this.props.value || !this.props.value) && this.props.value !== null,
        'p-disabled': this.props.disabled,
        'p-focus': this.state.focused
      });
      var iconClass = classNames('p-checkbox-icon p-c', {
        'pi pi-check': this.props.value === true,
        'pi pi-times': this.props.value === false
      });
      return /*#__PURE__*/React.createElement("div", {
        ref: function ref(el) {
          return _this2.element = el;
        },
        id: this.props.id,
        className: containerClass,
        style: this.props.style,
        onClick: this.onClick
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-hidden-accessible"
      }, /*#__PURE__*/React.createElement("input", {
        ref: this.inputRef,
        type: "checkbox",
        "aria-labelledby": this.props.ariaLabelledBy,
        id: this.props.inputId,
        name: this.props.name,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        disabled: this.props.disabled,
        defaultChecked: this.props.value
      })), /*#__PURE__*/React.createElement("div", {
        className: boxClass,
        ref: function ref(el) {
          return _this2.box = el;
        },
        role: "checkbox",
        "aria-checked": this.props.value === true
      }, /*#__PURE__*/React.createElement("span", {
        className: iconClass
      })));
    }
  }]);

  return TriStateCheckbox;
}(Component);

_defineProperty(TriStateCheckbox$1, "defaultProps", {
  id: null,
  inputRef: null,
  inputId: null,
  value: null,
  name: null,
  style: null,
  className: null,
  disabled: false,
  tooltip: null,
  tooltipOptions: null,
  ariaLabelledBy: null,
  onChange: null
});

var TriStateCheckbox = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      inputRef = _ref.inputRef,
      inputId = _ref.inputId,
      value = _ref.value,
      name = _ref.name,
      style = _ref.style,
      className = _ref.className,
      disabled = _ref.disabled,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onChange = _ref.onChange;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React.createElement(TriStateCheckbox$1, {
    ref: ref,
    id: id,
    inputRef: inputRef,
    inputId: inputId,
    value: value,
    name: name,
    style: style,
    className: className,
    disabled: disabled,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onChange: onChange
  });
});

var translations = {
  ru: {
    accept: "",
    reject: "",
    choose: "",
    upload: "",
    cancel: "",
    weekHeader: "",
    weak: "",
    firstDayOfWeek: 1,
    dayNames: ["", "", "", "", "", "", ""],
    dayNamesShort: ["", "", "", "", "", "", ""],
    dayNamesMin: ["", "", "", "", "", "", ""],
    monthNames: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthNamesShort: ["", "", "", "", "", "", "", "", "", "", "", ""],
    today: "",
    clear: "",
    dateFormat: "dd.mm.yy"
  }
};

var initLocales = function initLocales() {
  addLocale("ru", translations.ru);
};

var changeLocale = function changeLocale(language) {
  locale(language);
};

export { Accordion, AccordionTab, Avatar, Badge, BlockUI, BreadCrumb, Button, Card, Checkbox$1 as Checkbox, Chip, Chips, Column, ColumnGroup, ConnectedOverlayScrollHandler, Dash, DataTable, DatePicker, DateTimePicker, Dialog, Divider, DomHandler$1 as DomHandler, Dropdown, EventBus, FileUpload, FilterMatchMode, FilterOperator, FilterService, IconUtils, Image, InputMask, InputNumber, InputSwitch, InputText, InputTextarea, Message, MessageSeverity, Money, MultiSelect, Number$1 as Number, ObjectUtils, Pagination, PanelMenu, PrimeIcons, ProgressBar, RadioButton, Row, ScrollTop, SelectButton, Skeleton, Spinner, TabPanel, TabView, Tag, TieredMenu, TimePicker, Toast, Tooltip, Tree, TreeTable, TriStateCheckbox, UniqueComponentId, ZIndexUtils, addLocale, changeLocale, classNames, confirmDialog, confirmPopup, initLocales, locale, localeOption, localeOptions, mask, updateLocaleOption, updateLocaleOptions };
