import * as React from 'react';
import React__default, { Children, isValidElement, cloneElement, useState, useMemo, Fragment, useRef } from 'react';
import ReactDOM from 'react-dom';

function _arrayWithHoles$x(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$x(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$1$6(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$1$6(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$6(o, minLen);
}

function _nonIterableRest$x() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$x(arr, i) {
  return _arrayWithHoles$x(arr) || _iterableToArrayLimit$x(arr, i) || _unsupportedIterableToArray$1$6(arr, i) || _nonIterableRest$x();
}

function _typeof$4(obj) {
  "@babel/helpers - typeof";

  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$4(obj);
}

function classNames() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args) {
    var classes = [];

    for (var i = 0; i < args.length; i++) {
      var className = args[i];
      if (!className) continue;

      var type = _typeof$4(className);

      if (type === 'string' || type === 'number') {
        classes.push(className);
      } else if (type === 'object') {
        var _classes = Array.isArray(className) ? className : Object.entries(className).map(function (_ref) {
          var _ref2 = _slicedToArray$x(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];

          return !!value ? key : null;
        });

        classes = _classes.length ? classes.concat(_classes.filter(function (c) {
          return !!c;
        })) : classes;
      }
    }

    return classes.join(' ');
  }

  return undefined;
}

function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty$l(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createForOfIteratorHelper$a(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$D(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$D(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$D(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$D(o, minLen);
}

function _arrayLikeToArray$D(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var DomHandler = /*#__PURE__*/function () {
  function DomHandler() {
    _classCallCheck$3(this, DomHandler);
  }

  _createClass$3(DomHandler, null, [{
    key: "innerWidth",
    value:
    /**
     * All data- properties like data-test-id
     */

    /**
     * All ARIA properties like aria-label and focus-target for https://www.npmjs.com/package/@q42/floating-focus-a11y
     */
    function innerWidth(el) {
      if (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
      }

      return 0;
    }
  }, {
    key: "width",
    value: function width(el) {
      if (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
      }

      return 0;
    }
  }, {
    key: "getBrowserLanguage",
    value: function getBrowserLanguage() {
      return navigator.userLanguage || navigator.languages && navigator.languages.length && navigator.languages[0] || navigator.language || navigator.browserLanguage || navigator.systemLanguage || 'en';
    }
  }, {
    key: "getWindowScrollTop",
    value: function getWindowScrollTop() {
      var doc = document.documentElement;
      return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    }
  }, {
    key: "getWindowScrollLeft",
    value: function getWindowScrollLeft() {
      var doc = document.documentElement;
      return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    }
  }, {
    key: "getOuterWidth",
    value: function getOuterWidth(el, margin) {
      if (el) {
        var width = el.offsetWidth || el.getBoundingClientRect().width;

        if (margin) {
          var style = getComputedStyle(el);
          width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }

        return width;
      }

      return 0;
    }
  }, {
    key: "getOuterHeight",
    value: function getOuterHeight(el, margin) {
      if (el) {
        var height = el.offsetHeight || el.getBoundingClientRect().height;

        if (margin) {
          var style = getComputedStyle(el);
          height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }

        return height;
      }

      return 0;
    }
  }, {
    key: "getClientHeight",
    value: function getClientHeight(el, margin) {
      if (el) {
        var height = el.clientHeight;

        if (margin) {
          var style = getComputedStyle(el);
          height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }

        return height;
      }

      return 0;
    }
  }, {
    key: "getClientWidth",
    value: function getClientWidth(el, margin) {
      if (el) {
        var width = el.clientWidth;

        if (margin) {
          var style = getComputedStyle(el);
          width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }

        return width;
      }

      return 0;
    }
  }, {
    key: "getViewport",
    value: function getViewport() {
      var win = window,
          d = document,
          e = d.documentElement,
          g = d.getElementsByTagName('body')[0],
          w = win.innerWidth || e.clientWidth || g.clientWidth,
          h = win.innerHeight || e.clientHeight || g.clientHeight;
      return {
        width: w,
        height: h
      };
    }
  }, {
    key: "getOffset",
    value: function getOffset(el) {
      if (el) {
        var rect = el.getBoundingClientRect();
        return {
          top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
          left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0)
        };
      }

      return {
        top: 'auto',
        left: 'auto'
      };
    }
  }, {
    key: "index",
    value: function index(element) {
      if (element) {
        var children = element.parentNode.childNodes;
        var num = 0;

        for (var i = 0; i < children.length; i++) {
          if (children[i] === element) return num;
          if (children[i].nodeType === 1) num++;
        }
      }

      return -1;
    }
  }, {
    key: "addMultipleClasses",
    value: function addMultipleClasses(element, className) {
      if (element && className) {
        if (element.classList) {
          var styles = className.split(' ');

          for (var i = 0; i < styles.length; i++) {
            element.classList.add(styles[i]);
          }
        } else {
          var _styles = className.split(' ');

          for (var _i = 0; _i < _styles.length; _i++) {
            element.className += ' ' + _styles[_i];
          }
        }
      }
    }
  }, {
    key: "removeMultipleClasses",
    value: function removeMultipleClasses(element, className) {
      if (element && className) {
        if (element.classList) {
          var styles = className.split(' ');

          for (var i = 0; i < styles.length; i++) {
            element.classList.remove(styles[i]);
          }
        } else {
          var _styles2 = className.split(' ');

          for (var _i2 = 0; _i2 < _styles2.length; _i2++) {
            element.className = element.className.replace(new RegExp('(^|\\b)' + _styles2[_i2].split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
          }
        }
      }
    }
  }, {
    key: "addClass",
    value: function addClass(element, className) {
      if (element && className) {
        if (element.classList) element.classList.add(className);else element.className += ' ' + className;
      }
    }
  }, {
    key: "removeClass",
    value: function removeClass(element, className) {
      if (element && className) {
        if (element.classList) element.classList.remove(className);else element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
      }
    }
  }, {
    key: "hasClass",
    value: function hasClass(element, className) {
      if (element) {
        if (element.classList) return element.classList.contains(className);else return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);
      }

      return false;
    }
  }, {
    key: "find",
    value: function find(element, selector) {
      return element ? Array.from(element.querySelectorAll(selector)) : [];
    }
  }, {
    key: "findSingle",
    value: function findSingle(element, selector) {
      if (element) {
        return element.querySelector(selector);
      }

      return null;
    }
  }, {
    key: "getHeight",
    value: function getHeight(el) {
      if (el) {
        var height = el.offsetHeight;
        var style = getComputedStyle(el);
        height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
        return height;
      }

      return 0;
    }
  }, {
    key: "getWidth",
    value: function getWidth(el) {
      if (el) {
        var width = el.offsetWidth;
        var style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
        return width;
      }

      return 0;
    }
  }, {
    key: "alignOverlay",
    value: function alignOverlay(overlay, target, appendTo) {
      var calculateMinWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (overlay && target) {
        if (appendTo === 'self') {
          this.relativePosition(overlay, target);
        } else {
          calculateMinWidth && (overlay.style.minWidth = DomHandler.getOuterWidth(target) + 'px');
          this.absolutePosition(overlay, target);
        }
      }
    }
  }, {
    key: "absolutePosition",
    value: function absolutePosition(element, target) {
      if (element) {
        var elementDimensions = element.offsetParent ? {
          width: element.offsetWidth,
          height: element.offsetHeight
        } : this.getHiddenElementDimensions(element);
        var elementOuterHeight = elementDimensions.height;
        var elementOuterWidth = elementDimensions.width;
        var targetOuterHeight = target.offsetHeight;
        var targetOuterWidth = target.offsetWidth;
        var targetOffset = target.getBoundingClientRect();
        var windowScrollTop = this.getWindowScrollTop();
        var windowScrollLeft = this.getWindowScrollLeft();
        var viewport = this.getViewport();
        var top, left;

        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
          top = targetOffset.top + windowScrollTop - elementOuterHeight;

          if (top < 0) {
            top = windowScrollTop;
          }

          element.style.transformOrigin = 'bottom';
        } else {
          top = targetOuterHeight + targetOffset.top + windowScrollTop;
          element.style.transformOrigin = 'top';
        }

        if (targetOffset.left + targetOuterWidth + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);else left = targetOffset.left + windowScrollLeft;
        element.style.top = top + 'px';
        element.style.left = left + 'px';
      }
    }
  }, {
    key: "relativePosition",
    value: function relativePosition(element, target) {
      if (element) {
        var elementDimensions = element.offsetParent ? {
          width: element.offsetWidth,
          height: element.offsetHeight
        } : this.getHiddenElementDimensions(element);
        var targetHeight = target.offsetHeight;
        var targetOffset = target.getBoundingClientRect();
        var viewport = this.getViewport();
        var top, left;

        if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {
          top = -1 * elementDimensions.height;

          if (targetOffset.top + top < 0) {
            top = -1 * targetOffset.top;
          }

          element.style.transformOrigin = 'bottom';
        } else {
          top = targetHeight;
          element.style.transformOrigin = 'top';
        }

        if (elementDimensions.width > viewport.width) {
          // element wider then viewport and cannot fit on screen (align at left side of viewport)
          left = targetOffset.left * -1;
        } else if (targetOffset.left + elementDimensions.width > viewport.width) {
          // element wider then viewport but can be fit on screen (align at right side of viewport)
          left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;
        } else {
          // element fits on screen (align with target)
          left = 0;
        }

        element.style.top = top + 'px';
        element.style.left = left + 'px';
      }
    }
  }, {
    key: "flipfitCollision",
    value: function flipfitCollision(element, target) {
      var _this = this;

      var my = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'left top';
      var at = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'left bottom';
      var callback = arguments.length > 4 ? arguments[4] : undefined;

      if (element && target) {
        var targetOffset = target.getBoundingClientRect();
        var viewport = this.getViewport();
        var myArr = my.split(' ');
        var atArr = at.split(' ');

        var getPositionValue = function getPositionValue(arr, isOffset) {
          return isOffset ? +arr.substring(arr.search(/(\+|-)/g)) || 0 : arr.substring(0, arr.search(/(\+|-)/g)) || arr;
        };

        var position = {
          my: {
            x: getPositionValue(myArr[0]),
            y: getPositionValue(myArr[1] || myArr[0]),
            offsetX: getPositionValue(myArr[0], true),
            offsetY: getPositionValue(myArr[1] || myArr[0], true)
          },
          at: {
            x: getPositionValue(atArr[0]),
            y: getPositionValue(atArr[1] || atArr[0]),
            offsetX: getPositionValue(atArr[0], true),
            offsetY: getPositionValue(atArr[1] || atArr[0], true)
          }
        };
        var myOffset = {
          left: function left() {
            var totalOffset = position.my.offsetX + position.at.offsetX;
            return totalOffset + targetOffset.left + (position.my.x === 'left' ? 0 : -1 * (position.my.x === 'center' ? _this.getOuterWidth(element) / 2 : _this.getOuterWidth(element)));
          },
          top: function top() {
            var totalOffset = position.my.offsetY + position.at.offsetY;
            return totalOffset + targetOffset.top + (position.my.y === 'top' ? 0 : -1 * (position.my.y === 'center' ? _this.getOuterHeight(element) / 2 : _this.getOuterHeight(element)));
          }
        };
        var alignWithAt = {
          count: {
            x: 0,
            y: 0
          },
          left: function left() {
            var left = myOffset.left();
            var scrollLeft = DomHandler.getWindowScrollLeft();
            element.style.left = left + scrollLeft + 'px';

            if (this.count.x === 2) {
              element.style.left = scrollLeft + 'px';
              this.count.x = 0;
            } else if (left < 0) {
              this.count.x++;
              position.my.x = 'left';
              position.at.x = 'right';
              position.my.offsetX *= -1;
              position.at.offsetX *= -1;
              this.right();
            }
          },
          right: function right() {
            var left = myOffset.left() + DomHandler.getOuterWidth(target);
            var scrollLeft = DomHandler.getWindowScrollLeft();
            element.style.left = left + scrollLeft + 'px';

            if (this.count.x === 2) {
              element.style.left = viewport.width - DomHandler.getOuterWidth(element) + scrollLeft + 'px';
              this.count.x = 0;
            } else if (left + DomHandler.getOuterWidth(element) > viewport.width) {
              this.count.x++;
              position.my.x = 'right';
              position.at.x = 'left';
              position.my.offsetX *= -1;
              position.at.offsetX *= -1;
              this.left();
            }
          },
          top: function top() {
            var top = myOffset.top();
            var scrollTop = DomHandler.getWindowScrollTop();
            element.style.top = top + scrollTop + 'px';

            if (this.count.y === 2) {
              element.style.left = scrollTop + 'px';
              this.count.y = 0;
            } else if (top < 0) {
              this.count.y++;
              position.my.y = 'top';
              position.at.y = 'bottom';
              position.my.offsetY *= -1;
              position.at.offsetY *= -1;
              this.bottom();
            }
          },
          bottom: function bottom() {
            var top = myOffset.top() + DomHandler.getOuterHeight(target);
            var scrollTop = DomHandler.getWindowScrollTop();
            element.style.top = top + scrollTop + 'px';

            if (this.count.y === 2) {
              element.style.left = viewport.height - DomHandler.getOuterHeight(element) + scrollTop + 'px';
              this.count.y = 0;
            } else if (top + DomHandler.getOuterHeight(target) > viewport.height) {
              this.count.y++;
              position.my.y = 'bottom';
              position.at.y = 'top';
              position.my.offsetY *= -1;
              position.at.offsetY *= -1;
              this.top();
            }
          },
          center: function center(axis) {
            if (axis === 'y') {
              var top = myOffset.top() + DomHandler.getOuterHeight(target) / 2;
              element.style.top = top + DomHandler.getWindowScrollTop() + 'px';

              if (top < 0) {
                this.bottom();
              } else if (top + DomHandler.getOuterHeight(target) > viewport.height) {
                this.top();
              }
            } else {
              var left = myOffset.left() + DomHandler.getOuterWidth(target) / 2;
              element.style.left = left + DomHandler.getWindowScrollLeft() + 'px';

              if (left < 0) {
                this.left();
              } else if (left + DomHandler.getOuterWidth(element) > viewport.width) {
                this.right();
              }
            }
          }
        };
        alignWithAt[position.at.x]('x');
        alignWithAt[position.at.y]('y');

        if (this.isFunction(callback)) {
          callback(position);
        }
      }
    }
  }, {
    key: "findCollisionPosition",
    value: function findCollisionPosition(position) {
      if (position) {
        var isAxisY = position === 'top' || position === 'bottom';
        var myXPosition = position === 'left' ? 'right' : 'left';
        var myYPosition = position === 'top' ? 'bottom' : 'top';

        if (isAxisY) {
          return {
            axis: 'y',
            my: "center ".concat(myYPosition),
            at: "center ".concat(position)
          };
        }

        return {
          axis: 'x',
          my: "".concat(myXPosition, " center"),
          at: "".concat(position, " center")
        };
      }
    }
  }, {
    key: "getParents",
    value: function getParents(element) {
      var parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return element['parentNode'] === null ? parents : this.getParents(element.parentNode, parents.concat([element.parentNode]));
    }
  }, {
    key: "getScrollableParents",
    value: function getScrollableParents(element) {
      var scrollableParents = [];

      if (element) {
        var parents = this.getParents(element);
        var overflowRegex = /(auto|scroll)/;

        var overflowCheck = function overflowCheck(node) {
          var styleDeclaration = node ? getComputedStyle(node) : null;
          return styleDeclaration && (overflowRegex.test(styleDeclaration.getPropertyValue('overflow')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowX')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowY')));
        };

        var _iterator = _createForOfIteratorHelper$a(parents),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var parent = _step.value;
            var scrollSelectors = parent.nodeType === 1 && parent.dataset['scrollselectors'];

            if (scrollSelectors) {
              var selectors = scrollSelectors.split(',');

              var _iterator2 = _createForOfIteratorHelper$a(selectors),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var selector = _step2.value;
                  var el = this.findSingle(parent, selector);

                  if (el && overflowCheck(el)) {
                    scrollableParents.push(el);
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }

            if (parent.nodeType !== 9 && overflowCheck(parent)) {
              scrollableParents.push(parent);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return scrollableParents;
    }
  }, {
    key: "getHiddenElementOuterHeight",
    value: function getHiddenElementOuterHeight(element) {
      if (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        var elementHeight = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementHeight;
      }

      return 0;
    }
  }, {
    key: "getHiddenElementOuterWidth",
    value: function getHiddenElementOuterWidth(element) {
      if (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        var elementWidth = element.offsetWidth;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementWidth;
      }

      return 0;
    }
  }, {
    key: "getHiddenElementDimensions",
    value: function getHiddenElementDimensions(element) {
      var dimensions = {};

      if (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        dimensions.width = element.offsetWidth;
        dimensions.height = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
      }

      return dimensions;
    }
  }, {
    key: "fadeIn",
    value: function fadeIn(element, duration) {
      if (element) {
        element.style.opacity = 0;
        var last = +new Date();
        var opacity = 0;

        var tick = function tick() {
          opacity = +element.style.opacity + (new Date().getTime() - last) / duration;
          element.style.opacity = opacity;
          last = +new Date();

          if (+opacity < 1) {
            window.requestAnimationFrame && requestAnimationFrame(tick) || setTimeout(tick, 16);
          }
        };

        tick();
      }
    }
  }, {
    key: "fadeOut",
    value: function fadeOut(element, duration) {
      if (element) {
        var opacity = 1,
            interval = 50,
            gap = interval / duration;
        var fading = setInterval(function () {
          opacity -= gap;

          if (opacity <= 0) {
            opacity = 0;
            clearInterval(fading);
          }

          element.style.opacity = opacity;
        }, interval);
      }
    }
  }, {
    key: "getUserAgent",
    value: function getUserAgent() {
      return navigator.userAgent;
    }
  }, {
    key: "isIOS",
    value: function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window['MSStream'];
    }
  }, {
    key: "isAndroid",
    value: function isAndroid() {
      return /(android)/i.test(navigator.userAgent);
    }
  }, {
    key: "isTouchDevice",
    value: function isTouchDevice() {
      return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    }
  }, {
    key: "isFunction",
    value: function isFunction(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
    }
  }, {
    key: "appendChild",
    value: function appendChild(element, target) {
      if (this.isElement(target)) target.appendChild(element);else if (target.el && target.el.nativeElement) target.el.nativeElement.appendChild(element);else throw new Error('Cannot append ' + target + ' to ' + element);
    }
  }, {
    key: "removeChild",
    value: function removeChild(element, target) {
      if (this.isElement(target)) target.removeChild(element);else if (target.el && target.el.nativeElement) target.el.nativeElement.removeChild(element);else throw new Error('Cannot remove ' + element + ' from ' + target);
    }
  }, {
    key: "isElement",
    value: function isElement(obj) {
      return (typeof HTMLElement === "undefined" ? "undefined" : _typeof$4(HTMLElement)) === 'object' ? obj instanceof HTMLElement : obj && _typeof$4(obj) === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string';
    }
  }, {
    key: "scrollInView",
    value: function scrollInView(container, item) {
      var borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');
      var borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
      var paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');
      var paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
      var containerRect = container.getBoundingClientRect();
      var itemRect = item.getBoundingClientRect();
      var offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
      var scroll = container.scrollTop;
      var elementHeight = container.clientHeight;
      var itemHeight = this.getOuterHeight(item);

      if (offset < 0) {
        container.scrollTop = scroll + offset;
      } else if (offset + itemHeight > elementHeight) {
        container.scrollTop = scroll + offset - elementHeight + itemHeight;
      }
    }
  }, {
    key: "clearSelection",
    value: function clearSelection() {
      if (window.getSelection) {
        if (window.getSelection().empty) {
          window.getSelection().empty();
        } else if (window.getSelection().removeAllRanges && window.getSelection().rangeCount > 0 && window.getSelection().getRangeAt(0).getClientRects().length > 0) {
          window.getSelection().removeAllRanges();
        }
      } else if (document['selection'] && document['selection'].empty) {
        try {
          document['selection'].empty();
        } catch (error) {//ignore IE bug
        }
      }
    }
  }, {
    key: "calculateScrollbarWidth",
    value: function calculateScrollbarWidth(el) {
      if (el) {
        var style = getComputedStyle(el);
        return el.offsetWidth - el.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);
      } else {
        if (this.calculatedScrollbarWidth != null) return this.calculatedScrollbarWidth;
        var scrollDiv = document.createElement('div');
        scrollDiv.className = 'p-scrollbar-measure';
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        this.calculatedScrollbarWidth = scrollbarWidth;
        return scrollbarWidth;
      }
    }
  }, {
    key: "getBrowser",
    value: function getBrowser() {
      if (!this.browser) {
        var matched = this.resolveUserAgent();
        this.browser = {};

        if (matched.browser) {
          this.browser[matched.browser] = true;
          this.browser['version'] = matched.version;
        }

        if (this.browser['chrome']) {
          this.browser['webkit'] = true;
        } else if (this.browser['webkit']) {
          this.browser['safari'] = true;
        }
      }

      return this.browser;
    }
  }, {
    key: "resolveUserAgent",
    value: function resolveUserAgent() {
      var ua = navigator.userAgent.toLowerCase();
      var match = /(chrome)[ ]([\w.]+)/.exec(ua) || /(webkit)[ ]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
      return {
        browser: match[1] || '',
        version: match[2] || '0'
      };
    }
  }, {
    key: "isVisible",
    value: function isVisible(element) {
      // https://stackoverflow.com/a/59096915/502366 (in future use IntersectionObserver)
      return element && (element.clientHeight !== 0 || element.getClientRects().length !== 0 || getComputedStyle(element).display !== 'none');
    }
  }, {
    key: "isExist",
    value: function isExist(element) {
      return element !== null && typeof element !== 'undefined' && element.nodeName && element.parentNode;
    }
  }, {
    key: "hasDOM",
    value: function hasDOM() {
      return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
    }
  }, {
    key: "getFocusableElements",
    value: function getFocusableElements(element) {
      var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var focusableElements = DomHandler.find(element, "button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])".concat(selector, ",\n                [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector, ",\n                [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])").concat(selector));
      var visibleFocusableElements = [];

      var _iterator3 = _createForOfIteratorHelper$a(focusableElements),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var focusableElement = _step3.value;
          if (getComputedStyle(focusableElement).display !== 'none' && getComputedStyle(focusableElement).visibility !== 'hidden') visibleFocusableElements.push(focusableElement);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return visibleFocusableElements;
    }
  }, {
    key: "getFirstFocusableElement",
    value: function getFirstFocusableElement(element, selector) {
      var focusableElements = DomHandler.getFocusableElements(element, selector);
      return focusableElements.length > 0 ? focusableElements[0] : null;
    }
  }, {
    key: "getLastFocusableElement",
    value: function getLastFocusableElement(element, selector) {
      var focusableElements = DomHandler.getFocusableElements(element, selector);
      return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
    }
    /**
     * Focus an input element if it does not already have focus.
     *
     * @param {HTMLElement} el a HTML element
     * @param {boolean} scrollTo flag to control whether to scroll to the element, false by default
     */

  }, {
    key: "focus",
    value: function focus(el, scrollTo) {
      var preventScroll = scrollTo === undefined ? true : !scrollTo;
      el && document.activeElement !== el && el.focus({
        preventScroll: preventScroll
      });
    }
  }, {
    key: "getCursorOffset",
    value: function getCursorOffset(el, prevText, nextText, currentText) {
      if (el) {
        var style = getComputedStyle(el);
        var ghostDiv = document.createElement('div');
        ghostDiv.style.position = 'absolute';
        ghostDiv.style.top = '0px';
        ghostDiv.style.left = '0px';
        ghostDiv.style.visibility = 'hidden';
        ghostDiv.style.pointerEvents = 'none';
        ghostDiv.style.overflow = style.overflow;
        ghostDiv.style.width = style.width;
        ghostDiv.style.height = style.height;
        ghostDiv.style.padding = style.padding;
        ghostDiv.style.border = style.border;
        ghostDiv.style.overflowWrap = style.overflowWrap;
        ghostDiv.style.whiteSpace = style.whiteSpace;
        ghostDiv.style.lineHeight = style.lineHeight;
        ghostDiv.innerHTML = prevText.replace(/\r\n|\r|\n/g, '<br />');
        var ghostSpan = document.createElement('span');
        ghostSpan.textContent = currentText;
        ghostDiv.appendChild(ghostSpan);
        var text = document.createTextNode(nextText);
        ghostDiv.appendChild(text);
        document.body.appendChild(ghostDiv);
        var offsetLeft = ghostSpan.offsetLeft,
            offsetTop = ghostSpan.offsetTop,
            clientHeight = ghostSpan.clientHeight;
        document.body.removeChild(ghostDiv);
        return {
          left: Math.abs(offsetLeft - el.scrollLeft),
          top: Math.abs(offsetTop - el.scrollTop) + clientHeight
        };
      }

      return {
        top: 'auto',
        left: 'auto'
      };
    }
  }, {
    key: "invokeElementMethod",
    value: function invokeElementMethod(element, methodName, args) {
      element[methodName].apply(element, args);
    }
  }, {
    key: "isClickable",
    value: function isClickable(element) {
      var targetNode = element.nodeName;
      var parentNode = element.parentElement && element.parentElement.nodeName;
      return targetNode === 'INPUT' || targetNode === 'TEXTAREA' || targetNode === 'BUTTON' || targetNode === 'A' || parentNode === 'INPUT' || parentNode === 'TEXTAREA' || parentNode === 'BUTTON' || parentNode === 'A' || this.hasClass(element, 'p-button') || this.hasClass(element.parentElement, 'p-button') || this.hasClass(element.parentElement, 'p-checkbox') || this.hasClass(element.parentElement, 'p-radiobutton');
    }
  }, {
    key: "applyStyle",
    value: function applyStyle(element, style) {
      if (typeof style === 'string') {
        element.style.cssText = this.style;
      } else {
        for (var prop in this.style) {
          element.style[prop] = style[prop];
        }
      }
    }
  }, {
    key: "exportCSV",
    value: function exportCSV(csv, filename) {
      var blob = new Blob([csv], {
        type: 'application/csv;charset=utf-8;'
      });

      if (window.navigator.msSaveOrOpenBlob) {
        navigator.msSaveOrOpenBlob(blob, filename + '.csv');
      } else {
        var isDownloaded = DomHandler.saveAs({
          name: filename + '.csv',
          src: URL.createObjectURL(blob)
        });

        if (!isDownloaded) {
          csv = 'data:text/csv;charset=utf-8,' + csv;
          window.open(encodeURI(csv));
        }
      }
    }
  }, {
    key: "saveAs",
    value: function saveAs(file) {
      if (file) {
        var link = document.createElement('a');

        if (link.download !== undefined) {
          var name = file.name,
              src = file.src;
          link.setAttribute('href', src);
          link.setAttribute('download', name);
          link.style.display = 'none';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          return true;
        }
      }

      return false;
    }
  }, {
    key: "createInlineStyle",
    value: function createInlineStyle(nonce) {
      var styleElement = document.createElement('style');

      try {
        if (!nonce) {
          nonce = process.env.REACT_APP_CSS_NONCE;
        }
      } catch (error) {// NOOP
      }

      nonce && styleElement.setAttribute('nonce', nonce);
      document.head.appendChild(styleElement);
      return styleElement;
    }
  }, {
    key: "removeInlineStyle",
    value: function removeInlineStyle(styleElement) {
      if (this.isExist(styleElement)) {
        try {
          document.head.removeChild(styleElement);
        } catch (error) {// style element may have already been removed in a fast refresh
        }

        styleElement = null;
      }

      return styleElement;
    }
  }, {
    key: "getTargetElement",
    value: function getTargetElement(target) {
      if (!target) return null;

      if (target === 'document') {
        return document;
      } else if (target === 'window') {
        return window;
      } else if (_typeof$4(target) === 'object' && target.hasOwnProperty('current')) {
        return this.isExist(target.current) ? target.current : null;
      } else {
        var isFunction = function isFunction(obj) {
          return !!(obj && obj.constructor && obj.call && obj.apply);
        };

        var element = isFunction(target) ? target() : target;
        return element && element.nodeType === 9 || this.isExist(element) ? element : null;
      }
    }
    /**
     * Get the attribute names for an element and sorts them alpha for comparison
     */

  }, {
    key: "getAttributeNames",
    value: function getAttributeNames(node) {
      var index, rv, attrs;
      rv = [];
      attrs = node.attributes;

      for (index = 0; index < attrs.length; ++index) {
        rv.push(attrs[index].nodeName);
      }

      rv.sort();
      return rv;
    }
    /**
     * Compare two elements for equality.  Even will compare if the style element
     * is out of order for example:
     *
     * elem1 = style="color: red; font-size: 28px"
     * elem2 = style="font-size: 28px; color: red"
     */

  }, {
    key: "isEqualElement",
    value: function isEqualElement(elm1, elm2) {
      var attrs1, attrs2, name, node1, node2; // Compare attributes without order sensitivity

      attrs1 = DomHandler.getAttributeNames(elm1);
      attrs2 = DomHandler.getAttributeNames(elm2);

      if (attrs1.join(',') !== attrs2.join(',')) {
        // console.log("Found nodes with different sets of attributes; not equiv");
        return false;
      } // ...and values
      // unless you want to compare DOM0 event handlers
      // (onclick="...")


      for (var index = 0; index < attrs1.length; ++index) {
        name = attrs1[index];

        if (name === 'style') {
          var astyle = elm1.style;
          var bstyle = elm2.style;
          var rexDigitsOnly = /^\d+$/;

          for (var _i3 = 0, _Object$keys = Object.keys(astyle); _i3 < _Object$keys.length; _i3++) {
            var key = _Object$keys[_i3];

            if (!rexDigitsOnly.test(key) && astyle[key] !== bstyle[key]) {
              // Not equivalent, stop
              //console.log("Found nodes with mis-matched values for attribute '" + name + "'; not equiv");
              return false;
            }
          }
        } else {
          if (elm1.getAttribute(name) !== elm2.getAttribute(name)) {
            // console.log("Found nodes with mis-matched values for attribute '" + name + "'; not equiv");
            return false;
          }
        }
      } // Walk the children


      for (node1 = elm1.firstChild, node2 = elm2.firstChild; node1 && node2; node1 = node1.nextSibling, node2 = node2.nextSibling) {
        if (node1.nodeType !== node2.nodeType) {
          // display("Found nodes of different types; not equiv");
          return false;
        }

        if (node1.nodeType === 1) {
          // Element
          if (!DomHandler.isEqualElement(node1, node2)) {
            return false;
          }
        } else if (node1.nodeValue !== node2.nodeValue) {
          // console.log("Found nodes with mis-matched nodeValues; not equiv");
          return false;
        }
      }

      if (node1 || node2) {
        // One of the elements had more nodes than the other
        // console.log("Found more children of one element than the other; not equivalent");
        return false;
      } // Seem the same


      return true;
    }
  }]);

  return DomHandler;
}();

_defineProperty$l(DomHandler, "DATA_PROPS", ['data-']);

_defineProperty$l(DomHandler, "ARIA_PROPS", ['aria', 'focus-target']);

var ConnectedOverlayScrollHandler = /*#__PURE__*/function () {
  function ConnectedOverlayScrollHandler(element) {
    var listener = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

    _classCallCheck$3(this, ConnectedOverlayScrollHandler);

    this.element = element;
    this.listener = listener;
  }

  _createClass$3(ConnectedOverlayScrollHandler, [{
    key: "bindScrollListener",
    value: function bindScrollListener() {
      this.scrollableParents = DomHandler.getScrollableParents(this.element);

      for (var i = 0; i < this.scrollableParents.length; i++) {
        this.scrollableParents[i].addEventListener('scroll', this.listener);
      }
    }
  }, {
    key: "unbindScrollListener",
    value: function unbindScrollListener() {
      if (this.scrollableParents) {
        for (var i = 0; i < this.scrollableParents.length; i++) {
          this.scrollableParents[i].removeEventListener('scroll', this.listener);
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.unbindScrollListener();
      this.element = null;
      this.listener = null;
      this.scrollableParents = null;
    }
  }]);

  return ConnectedOverlayScrollHandler;
}();

function EventBus() {
  var allHandlers = new Map();
  return {
    on: function on(type, handler) {
      var handlers = allHandlers.get(type);
      if (!handlers) handlers = [handler];else handlers.push(handler);
      allHandlers.set(type, handlers);
    },
    off: function off(type, handler) {
      var handlers = allHandlers.get(type);
      handlers && handlers.splice(handlers.indexOf(handler) >>> 0, 1);
    },
    emit: function emit(type, evt) {
      var handlers = allHandlers.get(type);
      handlers && handlers.slice().forEach(function (handler) {
        return handler(evt);
      });
    }
  };
}

function ownKeys$1$5(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1$5(Object(source), !0).forEach(function (key) {
      _defineProperty$l(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$5(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function mask(el, options) {
  var defaultOptions = {
    mask: null,
    slotChar: '_',
    autoClear: true,
    unmask: false,
    readOnly: false,
    onComplete: null,
    onChange: null,
    onFocus: null,
    onBlur: null
  };
  options = _objectSpread$1$5(_objectSpread$1$5({}, defaultOptions), options);
  var tests, partialPosition, len, firstNonMaskPos, defs, androidChrome, lastRequiredNonMaskPos, oldVal, focusText, caretTimeoutId, buffer, defaultBuffer;

  var caret = function caret(first, last) {
    var range, begin, end;

    if (!el.offsetParent || el !== document.activeElement) {
      return;
    }

    if (typeof first === 'number') {
      begin = first;
      end = typeof last === 'number' ? last : begin;

      if (el.setSelectionRange) {
        el.setSelectionRange(begin, end);
      } else if (el['createTextRange']) {
        range = el['createTextRange']();
        range.collapse(true);
        range.moveEnd('character', end);
        range.moveStart('character', begin);
        range.select();
      }
    } else {
      if (el.setSelectionRange) {
        begin = el.selectionStart;
        end = el.selectionEnd;
      } else if (document['selection'] && document['selection'].createRange) {
        range = document['selection'].createRange();
        begin = 0 - range.duplicate().moveStart('character', -100000);
        end = begin + range.text.length;
      }

      return {
        begin: begin,
        end: end
      };
    }
  };

  var isCompleted = function isCompleted() {
    for (var i = firstNonMaskPos; i <= lastRequiredNonMaskPos; i++) {
      if (tests[i] && buffer[i] === getPlaceholder(i)) {
        return false;
      }
    }

    return true;
  };

  var getPlaceholder = function getPlaceholder(i) {
    if (i < options.slotChar.length) {
      return options.slotChar.charAt(i);
    }

    return options.slotChar.charAt(0);
  };

  var getValue = function getValue() {
    return options.unmask ? getUnmaskedValue() : el && el.value;
  };

  var seekNext = function seekNext(pos) {
    while (++pos < len && !tests[pos]) {}

    return pos;
  };

  var seekPrev = function seekPrev(pos) {
    while (--pos >= 0 && !tests[pos]) {}

    return pos;
  };

  var shiftL = function shiftL(begin, end) {
    var i, j;

    if (begin < 0) {
      return;
    }

    for (i = begin, j = seekNext(end); i < len; i++) {
      if (tests[i]) {
        if (j < len && tests[i].test(buffer[j])) {
          buffer[i] = buffer[j];
          buffer[j] = getPlaceholder(j);
        } else {
          break;
        }

        j = seekNext(j);
      }
    }

    writeBuffer();
    caret(Math.max(firstNonMaskPos, begin));
  };

  var shiftR = function shiftR(pos) {
    var i, c, j, t;

    for (i = pos, c = getPlaceholder(pos); i < len; i++) {
      if (tests[i]) {
        j = seekNext(i);
        t = buffer[i];
        buffer[i] = c;

        if (j < len && tests[j].test(t)) {
          c = t;
        } else {
          break;
        }
      }
    }
  };

  var handleAndroidInput = function handleAndroidInput(e) {
    var curVal = el.value;
    var pos = caret();

    if (oldVal && oldVal.length && oldVal.length > curVal.length) {
      // a deletion or backspace happened
      checkVal(true);

      while (pos.begin > 0 && !tests[pos.begin - 1]) {
        pos.begin--;
      }

      if (pos.begin === 0) {
        while (pos.begin < firstNonMaskPos && !tests[pos.begin]) {
          pos.begin++;
        }
      }

      caret(pos.begin, pos.begin);
    } else {
      checkVal(true);

      while (pos.begin < len && !tests[pos.begin]) {
        pos.begin++;
      }

      caret(pos.begin, pos.begin);
    }

    if (options.onComplete && isCompleted()) {
      options.onComplete({
        originalEvent: e,
        value: getValue()
      });
    }
  };

  var onBlur = function onBlur(e) {
    checkVal();
    options.onBlur && options.onBlur(e);
    updateModel(e);

    if (el.value !== focusText) {
      var event = document.createEvent('HTMLEvents');
      event.initEvent('change', true, false);
      el.dispatchEvent(event);
    }
  };

  var onKeyDown = function onKeyDown(e) {
    if (options.readOnly) {
      return;
    }

    var k = e.which || e.keyCode,
        pos,
        begin,
        end;
    var iPhone = /iphone/i.test(DomHandler.getUserAgent());
    oldVal = el.value; //backspace, delete, and escape get special treatment

    if (k === 8 || k === 46 || iPhone && k === 127) {
      pos = caret();
      begin = pos.begin;
      end = pos.end;

      if (end - begin === 0) {
        begin = k !== 46 ? seekPrev(begin) : end = seekNext(begin - 1);
        end = k === 46 ? seekNext(end) : end;
      }

      clearBuffer(begin, end);
      shiftL(begin, end - 1);
      updateModel(e);
      e.preventDefault();
    } else if (k === 13) {
      // enter
      onBlur(e);
      updateModel(e);
    } else if (k === 27) {
      // escape
      el.value = focusText;
      caret(0, checkVal());
      updateModel(e);
      e.preventDefault();
    }
  };

  var onKeyPress = function onKeyPress(e) {
    if (options.readOnly) {
      return;
    }

    var k = e.which || e.keyCode,
        pos = caret(),
        p,
        c,
        next,
        completed;

    if (e.ctrlKey || e.altKey || e.metaKey || k < 32) {
      //Ignore
      return;
    } else if (k && k !== 13) {
      if (pos.end - pos.begin !== 0) {
        clearBuffer(pos.begin, pos.end);
        shiftL(pos.begin, pos.end - 1);
      }

      p = seekNext(pos.begin - 1);

      if (p < len) {
        c = String.fromCharCode(k);

        if (tests[p].test(c)) {
          shiftR(p);
          buffer[p] = c;
          writeBuffer();
          next = seekNext(p);

          if (/android/i.test(DomHandler.getUserAgent())) {
            //Path for CSP Violation on FireFox OS 1.1
            var proxy = function proxy() {
              caret(next);
            };

            setTimeout(proxy, 0);
          } else {
            caret(next);
          }

          if (pos.begin <= lastRequiredNonMaskPos) {
            completed = isCompleted();
          }
        }
      }

      e.preventDefault();
    }

    updateModel(e);

    if (options.onComplete && completed) {
      options.onComplete({
        originalEvent: e,
        value: getValue()
      });
    }
  };

  var clearBuffer = function clearBuffer(start, end) {
    var i;

    for (i = start; i < end && i < len; i++) {
      if (tests[i]) {
        buffer[i] = getPlaceholder(i);
      }
    }
  };

  var writeBuffer = function writeBuffer() {
    el.value = buffer.join('');
  };

  var checkVal = function checkVal(allow) {
    //try to place characters where they belong
    var test = el.value,
        lastMatch = -1,
        i,
        c,
        pos;

    for (i = 0, pos = 0; i < len; i++) {
      if (tests[i]) {
        buffer[i] = getPlaceholder(i);

        while (pos++ < test.length) {
          c = test.charAt(pos - 1);

          if (tests[i].test(c)) {
            buffer[i] = c;
            lastMatch = i;
            break;
          }
        }

        if (pos > test.length) {
          clearBuffer(i + 1, len);
          break;
        }
      } else {
        if (buffer[i] === test.charAt(pos)) {
          pos++;
        }

        if (i < partialPosition) {
          lastMatch = i;
        }
      }
    }

    if (allow) {
      writeBuffer();
    } else if (lastMatch + 1 < partialPosition) {
      if (options.autoClear || buffer.join('') === defaultBuffer) {
        // Invalid value. Remove it and replace it with the
        // mask, which is the default behavior.
        if (el.value) el.value = '';
        clearBuffer(0, len);
      } else {
        // Invalid value, but we opt to show the value to the
        // user and allow them to correct their mistake.
        writeBuffer();
      }
    } else {
      writeBuffer();
      el.value = el.value.substring(0, lastMatch + 1);
    }

    return partialPosition ? i : firstNonMaskPos;
  };

  var onFocus = function onFocus(e) {
    if (options.readOnly) {
      return;
    }

    clearTimeout(caretTimeoutId);
    var pos;
    focusText = el.value;
    pos = checkVal();
    caretTimeoutId = setTimeout(function () {
      if (el !== document.activeElement) {
        return;
      }

      writeBuffer();

      if (pos === options.mask.replace('?', '').length) {
        caret(0, pos);
      } else {
        caret(pos);
      }
    }, 10);

    if (options.onFocus) {
      options.onFocus(e);
    }
  };

  var onInput = function onInput(event) {
    if (androidChrome) handleAndroidInput(event);else handleInputChange(event);
  };

  var handleInputChange = function handleInputChange(e) {
    if (options.readOnly) {
      return;
    }

    var pos = checkVal(true);
    caret(pos);
    updateModel(e);

    if (options.onComplete && isCompleted()) {
      options.onComplete({
        originalEvent: e,
        value: getValue()
      });
    }
  };

  var getUnmaskedValue = function getUnmaskedValue() {
    var unmaskedBuffer = [];

    for (var i = 0; i < buffer.length; i++) {
      var c = buffer[i];

      if (tests[i] && c !== getPlaceholder(i)) {
        unmaskedBuffer.push(c);
      }
    }

    return unmaskedBuffer.join('');
  };

  var updateModel = function updateModel(e) {
    if (options.onChange) {
      var val = getValue().replace(options.slotChar, '');
      options.onChange({
        originalEvent: e,
        value: defaultBuffer !== val ? val : ''
      });
    }
  };

  var bindEvents = function bindEvents() {
    el.addEventListener('focus', onFocus);
    el.addEventListener('blur', onBlur);
    el.addEventListener('keydown', onKeyDown);
    el.addEventListener('keypress', onKeyPress);
    el.addEventListener('input', onInput);
    el.addEventListener('paste', handleInputChange);
  };

  var unbindEvents = function unbindEvents() {
    el.removeEventListener('focus', onFocus);
    el.removeEventListener('blur', onBlur);
    el.removeEventListener('keydown', onKeyDown);
    el.removeEventListener('keypress', onKeyPress);
    el.removeEventListener('input', onInput);
    el.removeEventListener('paste', handleInputChange);
  };

  var init = function init() {
    tests = [];
    partialPosition = options.mask.length;
    len = options.mask.length;
    firstNonMaskPos = null;
    defs = {
      9: '[0-9]',
      a: '[A-Za-z]',
      '*': '[A-Za-z0-9]'
    };
    var ua = DomHandler.getUserAgent();
    androidChrome = /chrome/i.test(ua) && /android/i.test(ua);
    var maskTokens = options.mask.split('');

    for (var i = 0; i < maskTokens.length; i++) {
      var c = maskTokens[i];

      if (c === '?') {
        len--;
        partialPosition = i;
      } else if (defs[c]) {
        tests.push(new RegExp(defs[c]));

        if (firstNonMaskPos === null) {
          firstNonMaskPos = tests.length - 1;
        }

        if (i < partialPosition) {
          lastRequiredNonMaskPos = tests.length - 1;
        }
      } else {
        tests.push(null);
      }
    }

    buffer = [];

    for (var _i = 0; _i < maskTokens.length; _i++) {
      var _c = maskTokens[_i];

      if (_c !== '?') {
        if (defs[_c]) buffer.push(getPlaceholder(_i));else buffer.push(_c);
      }
    }

    defaultBuffer = buffer.join('');
  };

  if (el && options.mask) {
    init();
    bindEvents();
  }

  return {
    init: init,
    bindEvents: bindEvents,
    unbindEvents: unbindEvents,
    updateModel: updateModel,
    getValue: getValue
  };
}

function _arrayWithoutHoles$h(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1$6(arr);
}

function _iterableToArray$h(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _nonIterableSpread$h() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$h(arr) {
  return _arrayWithoutHoles$h(arr) || _iterableToArray$h(arr) || _unsupportedIterableToArray$1$6(arr) || _nonIterableSpread$h();
}

var ObjectUtils = /*#__PURE__*/function () {
  function ObjectUtils() {
    _classCallCheck$3(this, ObjectUtils);
  }

  _createClass$3(ObjectUtils, null, [{
    key: "equals",
    value: function equals(obj1, obj2, field) {
      if (field && obj1 && _typeof$4(obj1) === 'object' && obj2 && _typeof$4(obj2) === 'object') return this.resolveFieldData(obj1, field) === this.resolveFieldData(obj2, field);else return this.deepEquals(obj1, obj2);
    }
  }, {
    key: "deepEquals",
    value: function deepEquals(a, b) {
      if (a === b) return true;

      if (a && b && _typeof$4(a) == 'object' && _typeof$4(b) == 'object') {
        var arrA = Array.isArray(a),
            arrB = Array.isArray(b),
            i,
            length,
            key;

        if (arrA && arrB) {
          length = a.length;
          if (length !== b.length) return false;

          for (i = length; i-- !== 0;) {
            if (!this.deepEquals(a[i], b[i])) return false;
          }

          return true;
        }

        if (arrA !== arrB) return false;
        var dateA = a instanceof Date,
            dateB = b instanceof Date;
        if (dateA !== dateB) return false;
        if (dateA && dateB) return a.getTime() === b.getTime();
        var regexpA = a instanceof RegExp,
            regexpB = b instanceof RegExp;
        if (regexpA !== regexpB) return false;
        if (regexpA && regexpB) return a.toString() === b.toString();
        var keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;

        for (i = length; i-- !== 0;) {
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        }

        for (i = length; i-- !== 0;) {
          key = keys[i];
          if (!this.deepEquals(a[key], b[key])) return false;
        }

        return true;
      }
      /*eslint no-self-compare: "off"*/


      return a !== a && b !== b;
    }
  }, {
    key: "resolveFieldData",
    value: function resolveFieldData(data, field) {
      if (data && Object.keys(data).length && field) {
        if (this.isFunction(field)) {
          return field(data);
        } else if (field.indexOf('.') === -1) {
          return data[field];
        } else {
          var fields = field.split('.');
          var value = data;

          for (var i = 0, len = fields.length; i < len; ++i) {
            if (value == null) {
              return null;
            }

            value = value[fields[i]];
          }

          return value;
        }
      } else {
        return null;
      }
    }
  }, {
    key: "isFunction",
    value: function isFunction(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
    }
  }, {
    key: "findDiffKeys",
    value: function findDiffKeys(obj1, obj2) {
      if (!obj1 || !obj2) {
        return {};
      }

      return Object.keys(obj1).filter(function (key) {
        return !obj2.hasOwnProperty(key);
      }).reduce(function (result, current) {
        result[current] = obj1[current];
        return result;
      }, {});
    }
    /**
     * Removes keys from a JSON object that start with a string such as "data" to get all "data-id" type properties.
     *
     * @param {any} obj the JSON object to reduce
     * @param {string[]} startsWiths the string(s) to check if the property starts with this key
     * @returns the JSON object containing only the key/values that match the startsWith string
     */

  }, {
    key: "reduceKeys",
    value: function reduceKeys(obj, startsWiths) {
      var result = {};

      if (!obj || !startsWiths || startsWiths.length === 0) {
        return result;
      }

      Object.keys(obj).filter(function (key) {
        return startsWiths.some(function (value) {
          return key.startsWith(value);
        });
      }).forEach(function (key) {
        result[key] = obj[key];
        delete obj[key];
      });
      return result;
    }
  }, {
    key: "reorderArray",
    value: function reorderArray(value, from, to) {
      var target;

      if (value && from !== to) {
        if (to >= value.length) {
          target = to - value.length;

          while (target-- + 1) {
            value.push(undefined);
          }
        }

        value.splice(to, 0, value.splice(from, 1)[0]);
      }
    }
  }, {
    key: "findIndexInList",
    value: function findIndexInList(value, list, dataKey) {
      var _this = this;

      if (list) {
        return dataKey ? list.findIndex(function (item) {
          return _this.equals(item, value, dataKey);
        }) : list.findIndex(function (item) {
          return item === value;
        });
      }

      return -1;
    }
  }, {
    key: "getJSXElement",
    value: function getJSXElement(obj) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }

      return this.isFunction(obj) ? obj.apply(void 0, params) : obj;
    }
  }, {
    key: "getPropValue",
    value: function getPropValue(obj) {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }

      var methodParams = params;

      if (params && params.length === 1) {
        methodParams = params[0];
      }

      return this.isFunction(obj) ? obj.apply(void 0, _toConsumableArray$h(methodParams)) : obj;
    }
  }, {
    key: "getRefElement",
    value: function getRefElement(ref) {
      if (ref) {
        return _typeof$4(ref) === 'object' && ref.hasOwnProperty('current') ? ref.current : ref;
      }

      return null;
    }
  }, {
    key: "combinedRefs",
    value: function combinedRefs(innerRef, forwardRef) {
      if (innerRef && forwardRef) {
        if (typeof forwardRef === 'function') {
          forwardRef(innerRef.current);
        } else {
          forwardRef.current = innerRef.current;
        }
      }
    }
  }, {
    key: "removeAccents",
    value: function removeAccents(str) {
      if (str && str.search(/[\xC0-\xFF]/g) > -1) {
        str = str.replace(/[\xC0-\xC5]/g, 'A').replace(/[\xC6]/g, 'AE').replace(/[\xC7]/g, 'C').replace(/[\xC8-\xCB]/g, 'E').replace(/[\xCC-\xCF]/g, 'I').replace(/[\xD0]/g, 'D').replace(/[\xD1]/g, 'N').replace(/[\xD2-\xD6\xD8]/g, 'O').replace(/[\xD9-\xDC]/g, 'U').replace(/[\xDD]/g, 'Y').replace(/[\xDE]/g, 'P').replace(/[\xE0-\xE5]/g, 'a').replace(/[\xE6]/g, 'ae').replace(/[\xE7]/g, 'c').replace(/[\xE8-\xEB]/g, 'e').replace(/[\xEC-\xEF]/g, 'i').replace(/[\xF1]/g, 'n').replace(/[\xF2-\xF6\xF8]/g, 'o').replace(/[\xF9-\xFC]/g, 'u').replace(/[\xFE]/g, 'p').replace(/[\xFD\xFF]/g, 'y');
      }

      return str;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty(value) {
      return value === null || value === undefined || value === '' || Array.isArray(value) && value.length === 0 || !(value instanceof Date) && _typeof$4(value) === 'object' && Object.keys(value).length === 0;
    }
  }, {
    key: "isNotEmpty",
    value: function isNotEmpty(value) {
      return !this.isEmpty(value);
    }
  }, {
    key: "sort",
    value: function sort(value1, value2) {
      var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var locale = arguments.length > 3 ? arguments[3] : undefined;
      var nullSortOrder = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      var result = ObjectUtils.compare(value1, value2, locale, order); // nullSortOrder == 1 means Excel like sort nulls at bottom

      var finalSortOrder = nullSortOrder === 1 ? order : nullSortOrder;
      return finalSortOrder * result;
    }
  }, {
    key: "compare",
    value: function compare(value1, value2, locale) {
      var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var result = -1;
      var emptyValue1 = this.isEmpty(value1);
      var emptyValue2 = this.isEmpty(value2);
      if (emptyValue1 && emptyValue2) result = 0;else if (emptyValue1) result = order;else if (emptyValue2) result = -order;else if (typeof value1 === 'string' && typeof value2 === 'string') result = value1.localeCompare(value2, locale, {
        numeric: true
      });else result = value1 < value2 ? -1 : value1 > value2 ? 1 : 0;
      return result;
    }
  }]);

  return ObjectUtils;
}();

function _extends$K() {
  _extends$K = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$K.apply(this, arguments);
}

function ownKeys$i(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$i(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$i(Object(source), !0).forEach(function (key) {
      _defineProperty$l(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$i(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var IconUtils = /*#__PURE__*/function () {
  function IconUtils() {
    _classCallCheck$3(this, IconUtils);
  }

  _createClass$3(IconUtils, null, [{
    key: "getJSXIcon",
    value: function getJSXIcon(icon) {
      var iconProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var content = null;

      if (icon !== null) {
        var iconType = _typeof$4(icon);

        var className = classNames(iconProps.className, iconType === 'string' && icon);
        content = /*#__PURE__*/React.createElement("span", _extends$K({}, iconProps, {
          className: className
        }));

        if (iconType !== 'string') {
          var defaultContentOptions = _objectSpread$i({
            iconProps: iconProps,
            element: content
          }, options);

          return ObjectUtils.getJSXElement(icon, defaultContentOptions);
        }
      }

      return content;
    }
  }]);

  return IconUtils;
}();

var lastId = 0;

function UniqueComponentId() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'pr_id_';
  lastId++;
  return "".concat(prefix).concat(lastId);
}

function handler() {
  var zIndexes = [];

  var generateZIndex = function generateZIndex(key, autoZIndex) {
    var baseZIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 999;
    var lastZIndex = getLastZIndex(key, autoZIndex, baseZIndex);
    var newZIndex = lastZIndex.value + (lastZIndex.key === key ? 0 : baseZIndex) + 1;
    zIndexes.push({
      key: key,
      value: newZIndex
    });
    return newZIndex;
  };

  var revertZIndex = function revertZIndex(zIndex) {
    zIndexes = zIndexes.filter(function (obj) {
      return obj.value !== zIndex;
    });
  };

  var getCurrentZIndex = function getCurrentZIndex(key, autoZIndex) {
    return getLastZIndex(key, autoZIndex).value;
  };

  var getLastZIndex = function getLastZIndex(key, autoZIndex) {
    var baseZIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return _toConsumableArray$h(zIndexes).reverse().find(function (obj) {
      return autoZIndex ? true : obj.key === key;
    }) || {
      key: key,
      value: baseZIndex
    };
  };

  var getZIndex = function getZIndex(el) {
    return el ? parseInt(el.style.zIndex, 10) || 0 : 0;
  };

  return {
    get: getZIndex,
    set: function set(key, el, autoZIndex, baseZIndex) {
      if (el) {
        el.style.zIndex = String(generateZIndex(key, autoZIndex, baseZIndex));
      }
    },
    clear: function clear(el) {
      if (el) {
        revertZIndex(ZIndexUtils.get(el));
        el.style.zIndex = '';
      }
    },
    getCurrent: function getCurrent(key, autoZIndex) {
      return getCurrentZIndex(key, autoZIndex);
    }
  };
}

var ZIndexUtils = handler();

var FilterMatchMode$1 = Object.freeze({
  STARTS_WITH: 'startsWith',
  CONTAINS: 'contains',
  NOT_CONTAINS: 'notContains',
  ENDS_WITH: 'endsWith',
  EQUALS: 'equals',
  NOT_EQUALS: 'notEquals',
  IN: 'in',
  LESS_THAN: 'lt',
  LESS_THAN_OR_EQUAL_TO: 'lte',
  GREATER_THAN: 'gt',
  GREATER_THAN_OR_EQUAL_TO: 'gte',
  BETWEEN: 'between',
  DATE_IS: 'dateIs',
  DATE_IS_NOT: 'dateIsNot',
  DATE_BEFORE: 'dateBefore',
  DATE_AFTER: 'dateAfter',
  CUSTOM: 'custom'
});
var FilterOperator = Object.freeze({
  AND: 'and',
  OR: 'or'
});

function _createForOfIteratorHelper$9(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$C(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$C(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$C(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$C(o, minLen);
}

function _arrayLikeToArray$C(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var FilterService = {
  filter: function filter(value, fields, filterValue, filterMatchMode, filterLocale) {
    var filteredItems = [];

    if (value) {
      var _iterator = _createForOfIteratorHelper$9(value),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;

          var _iterator2 = _createForOfIteratorHelper$9(fields),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var field = _step2.value;
              var fieldValue = ObjectUtils.resolveFieldData(item, field);

              if (this.filters[filterMatchMode](fieldValue, filterValue, filterLocale)) {
                filteredItems.push(item);
                break;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    return filteredItems;
  },
  filters: {
    startsWith: function startsWith(value, filter, filterLocale) {
      if (filter === undefined || filter === null || filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      var filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.slice(0, filterValue.length) === filterValue;
    },
    contains: function contains(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      var filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) !== -1;
    },
    notContains: function notContains(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      var filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) === -1;
    },
    endsWith: function endsWith(value, filter, filterLocale) {
      if (filter === undefined || filter === null || filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      var filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue, stringValue.length - filterValue.length) !== -1;
    },
    equals: function equals(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() === filter.getTime();else return ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale) === ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
    },
    notEquals: function notEquals(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return false;
      }

      if (value === undefined || value === null) {
        return true;
      }

      if (value.getTime && filter.getTime) return value.getTime() !== filter.getTime();else return ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale) !== ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
    },
    "in": function _in(value, filter) {
      if (filter === undefined || filter === null || filter.length === 0) {
        return true;
      }

      for (var i = 0; i < filter.length; i++) {
        if (ObjectUtils.equals(value, filter[i])) {
          return true;
        }
      }

      return false;
    },
    between: function between(value, filter) {
      if (filter == null || filter[0] == null || filter[1] == null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime) return filter[0].getTime() <= value.getTime() && value.getTime() <= filter[1].getTime();else return filter[0] <= value && value <= filter[1];
    },
    lt: function lt(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() < filter.getTime();else return value < filter;
    },
    lte: function lte(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() <= filter.getTime();else return value <= filter;
    },
    gt: function gt(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() > filter.getTime();else return value > filter;
    },
    gte: function gte(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() >= filter.getTime();else return value >= filter;
    },
    dateIs: function dateIs(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.toDateString() === filter.toDateString();
    },
    dateIsNot: function dateIsNot(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.toDateString() !== filter.toDateString();
    },
    dateBefore: function dateBefore(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.getTime() < filter.getTime();
    },
    dateAfter: function dateAfter(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.getTime() > filter.getTime();
    }
  },
  register: function register(rule, fn) {
    this.filters[rule] = fn;
  }
};

function _defineProperty$k(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var PrimeReact$1 = /*#__PURE__*/_createClass$2(function PrimeReact() {
  _classCallCheck$2(this, PrimeReact);
});

_defineProperty$k(PrimeReact$1, "ripple", false);

_defineProperty$k(PrimeReact$1, "inputStyle", 'outlined');

_defineProperty$k(PrimeReact$1, "locale", 'en');

_defineProperty$k(PrimeReact$1, "appendTo", null);

_defineProperty$k(PrimeReact$1, "cssTransition", true);

_defineProperty$k(PrimeReact$1, "autoZIndex", true);

_defineProperty$k(PrimeReact$1, "nonce", null);

_defineProperty$k(PrimeReact$1, "nullSortOrder", 1);

_defineProperty$k(PrimeReact$1, "zIndex", {
  modal: 1100,
  overlay: 1000,
  menu: 1000,
  tooltip: 1100,
  toast: 1200
});

_defineProperty$k(PrimeReact$1, "filterMatchModeOptions", {
  text: [FilterMatchMode$1.STARTS_WITH, FilterMatchMode$1.CONTAINS, FilterMatchMode$1.NOT_CONTAINS, FilterMatchMode$1.ENDS_WITH, FilterMatchMode$1.EQUALS, FilterMatchMode$1.NOT_EQUALS],
  numeric: [FilterMatchMode$1.EQUALS, FilterMatchMode$1.NOT_EQUALS, FilterMatchMode$1.LESS_THAN, FilterMatchMode$1.LESS_THAN_OR_EQUAL_TO, FilterMatchMode$1.GREATER_THAN, FilterMatchMode$1.GREATER_THAN_OR_EQUAL_TO],
  date: [FilterMatchMode$1.DATE_IS, FilterMatchMode$1.DATE_IS_NOT, FilterMatchMode$1.DATE_BEFORE, FilterMatchMode$1.DATE_AFTER]
});

function ownKeys$h(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$h(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$h(Object(source), !0).forEach(function (key) {
      _defineProperty$k(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var locales$1 = {
  en: {
    startsWith: 'Starts with',
    contains: 'Contains',
    notContains: 'Not contains',
    endsWith: 'Ends with',
    equals: 'Equals',
    notEquals: 'Not equals',
    noFilter: 'No Filter',
    filter: 'Filter',
    lt: 'Less than',
    lte: 'Less than or equal to',
    gt: 'Greater than',
    gte: 'Greater than or equal to',
    dateIs: 'Date is',
    dateIsNot: 'Date is not',
    dateBefore: 'Date is before',
    dateAfter: 'Date is after',
    custom: 'Custom',
    clear: 'Clear',
    close: 'Close',
    apply: 'Apply',
    matchAll: 'Match All',
    matchAny: 'Match Any',
    addRule: 'Add Rule',
    removeRule: 'Remove Rule',
    accept: 'Yes',
    reject: 'No',
    choose: 'Choose',
    upload: 'Upload',
    cancel: 'Cancel',
    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    today: 'Today',
    weekHeader: 'Wk',
    firstDayOfWeek: 0,
    dateFormat: 'mm/dd/yy',
    weak: 'Weak',
    medium: 'Medium',
    strong: 'Strong',
    passwordPrompt: 'Enter a password',
    emptyFilterMessage: 'No available options',
    emptyMessage: 'No results found',
    aria: {
      trueLabel: 'True',
      falseLabel: 'False',
      nullLabel: 'Not Selected',
      pageLabel: 'Page',
      firstPageLabel: 'First Page',
      lastPageLabel: 'Last Page',
      nextPageLabel: 'Next Page',
      previousPageLabel: 'Previous Page',
      selectLabel: 'Select',
      unselectLabel: 'Unselect',
      expandLabel: 'Expand',
      collapseLabel: 'Collapse'
    }
  }
};

function locale(locale) {
  locale && (PrimeReact$1.locale = locale);
  return {
    locale: PrimeReact$1.locale,
    options: locales$1[PrimeReact$1.locale]
  };
}

function addLocale(locale, options) {
  locales$1[locale] = _objectSpread$h(_objectSpread$h({}, locales$1['en']), options);
}

function updateLocaleOption(key, value, locale) {
  localeOptions$1(locale)[key] = value;
}

function updateLocaleOptions(options, locale) {
  var _locale = locale || PrimeReact$1.locale;

  locales$1[_locale] = _objectSpread$h(_objectSpread$h({}, locales$1[_locale]), options);
}

function localeOption$1(key, locale) {
  var _locale = locale || PrimeReact$1.locale;

  try {
    return localeOptions$1(_locale)[key];
  } catch (error) {
    throw new Error("The ".concat(key, " option is not found in the current locale('").concat(_locale, "')."));
  }
}

function ariaLabel(key) {
  var _locale = PrimeReact$1.locale;

  try {
    return localeOptions$1(_locale)['aria'][key];
  } catch (error) {
    throw new Error("The ".concat(key, " option is not found in the current locale('").concat(_locale, "')."));
  }
}

function localeOptions$1(locale) {
  var _locale = locale || PrimeReact$1.locale;

  return locales$1[_locale];
}

var MessageSeverity = Object.freeze({
  SUCCESS: 'success',
  INFO: 'info',
  WARN: 'warn',
  ERROR: 'error'
});
var PrimeIcons = Object.freeze({
  ALIGN_CENTER: 'pi pi-align-center',
  ALIGN_JUSTIFY: 'pi pi-align-justify',
  ALIGN_LEFT: 'pi pi-align-left',
  ALIGN_RIGHT: 'pi pi-align-right',
  AMAZON: 'pi pi-amazon',
  ANDROID: 'pi pi-android',
  ANGLE_DOUBLE_DOWN: 'pi pi-angle-double-down',
  ANGLE_DOUBLE_LEFT: 'pi pi-angle-double-left',
  ANGLE_DOUBLE_RIGHT: 'pi pi-angle-double-right',
  ANGLE_DOUBLE_UP: 'pi pi-angle-double-up',
  ANGLE_DOWN: 'pi pi-angle-down',
  ANGLE_LEFT: 'pi pi-angle-left',
  ANGLE_RIGHT: 'pi pi-angle-right',
  ANGLE_UP: 'pi pi-angle-up',
  APPLE: 'pi pi-apple',
  ARROW_CIRCLE_DOWN: 'pi pi-arrow-circle-down',
  ARROW_CIRCLE_LEFT: 'pi pi-arrow-circle-left',
  ARROW_CIRCLE_RIGHT: 'pi pi-arrow-circle-right',
  ARROW_CIRCLE_UP: 'pi pi-arrow-circle-up',
  ARROW_DOWN: 'pi pi-arrow-down',
  ARROW_DOWN_LEFT: 'pi pi-arrow-down-left',
  ARROW_DOWN_RIGHT: 'pi pi-arrow-down-right',
  ARROW_LEFT: 'pi pi-arrow-left',
  ARROW_RIGHT: 'pi pi-arrow-right',
  ARROW_UP: 'pi pi-arrow-up',
  ARROW_UP_LEFT: 'pi pi-arrow-up-left',
  ARROW_UP_RIGHT: 'pi pi-arrow-up-right',
  ARROWS_H: 'pi pi-arrows-h',
  ARROWS_V: 'pi pi-arrows-v',
  AT: 'pi pi-at',
  BACKWARD: 'pi pi-backward',
  BAN: 'pi pi-ban',
  BARS: 'pi pi-bars',
  BELL: 'pi pi-bell',
  BOLT: 'pi pi-bolt',
  BOOK: 'pi pi-book',
  BOOKMARK: 'pi pi-bookmark',
  BOOKMARK_FILL: 'pi pi-bookmark-fill',
  BOX: 'pi pi-box',
  BRIEFCASE: 'pi pi-briefcase',
  BUILDING: 'pi pi-building',
  CALENDAR: 'pi pi-calendar',
  CALENDAR_MINUS: 'pi pi-calendar-minus',
  CALENDAR_PLUS: 'pi pi-calendar-plus',
  CALENDAR_TIMES: 'pi pi-calendar-times',
  CAMERA: 'pi pi-camera',
  CAR: 'pi pi-car',
  CARET_DOWN: 'pi pi-caret-down',
  CARET_LEFT: 'pi pi-caret-left',
  CARET_RIGHT: 'pi pi-caret-right',
  CARET_UP: 'pi pi-caret-up',
  CHART_BAR: 'pi pi-chart-bar',
  CHART_LINE: 'pi pi-chart-line',
  CHART_PIE: 'pi pi-chart-pie',
  CHECK: 'pi pi-check',
  CHECK_CIRCLE: 'pi pi-check-circle',
  CHECK_SQUARE: 'pi pi-check-square',
  CHEVRON_CIRCLE_DOWN: 'pi pi-chevron-circle-down',
  CHEVRON_CIRCLE_LEFT: 'pi pi-chevron-circle-left',
  CHEVRON_CIRCLE_RIGHT: 'pi pi-chevron-circle-right',
  CHEVRON_CIRCLE_UP: 'pi pi-chevron-circle-up',
  CHEVRON_DOWN: 'pi pi-chevron-down',
  CHEVRON_LEFT: 'pi pi-chevron-left',
  CHEVRON_RIGHT: 'pi pi-chevron-right',
  CHEVRON_UP: 'pi pi-chevron-up',
  CIRCLE: 'pi pi-circle',
  CIRCLE_FILL: 'pi pi-circle-fill',
  CLOCK: 'pi pi-clock',
  CLONE: 'pi pi-clone',
  CLOUD: 'pi pi-cloud',
  CLOUD_DOWNLOAD: 'pi pi-cloud-download',
  CLOUD_UPLOAD: 'pi pi-cloud-upload',
  CODE: 'pi pi-code',
  COG: 'pi pi-cog',
  COMMENT: 'pi pi-comment',
  COMMENTS: 'pi pi-comments',
  COMPASS: 'pi pi-compass',
  COPY: 'pi pi-copy',
  CREDIT_CARD: 'pi pi-credit-card',
  DATABASE: 'pi pi-database',
  DESKTOP: 'pi pi-desktop',
  DIRECTIONS: 'pi pi-directions',
  DIRECTIONS_ALT: 'pi pi-directions-alt',
  DISCORD: 'pi pi-discord',
  DOLLAR: 'pi pi-dollar',
  DOWNLOAD: 'pi pi-download',
  EJECT: 'pi pi-eject',
  ELLIPSIS_H: 'pi pi-ellipsis-h',
  ELLIPSIS_V: 'pi pi-ellipsis-v',
  ENVELOPE: 'pi pi-envelope',
  EURO: 'pi pi-euro',
  EXCLAMATION_CIRCLE: 'pi pi-exclamation-circle',
  EXCLAMATION_TRIANGLE: 'pi pi-exclamation-triangle',
  EXTERNAL_LINK: 'pi pi-external-link',
  EYE: 'pi pi-eye',
  EYE_SLASH: 'pi pi-eye-slash',
  FACEBOOK: 'pi pi-facebook',
  FAST_BACKWARD: 'pi pi-fast-backward',
  FAST_FORWARD: 'pi pi-fast-forward',
  FILE: 'pi pi-file',
  FILE_EXCEL: 'pi pi-file-excel',
  FILE_PDF: 'pi pi-file-pdf',
  FILTER: 'pi pi-filter',
  FILTER_FILL: 'pi pi-filter-fill',
  FILTER_SLASH: 'pi pi-filter-slash',
  FLAG: 'pi pi-flag',
  FLAG_FILL: 'pi pi-flag-fill',
  FOLDER: 'pi pi-folder',
  FOLDER_OPEN: 'pi pi-folder-open',
  FORWARD: 'pi pi-forward',
  GITHUB: 'pi pi-github',
  GLOBE: 'pi pi-globe',
  GOOGLE: 'pi pi-google',
  HASHTAG: 'pi pi-hashtag',
  HEART: 'pi pi-heart',
  HEART_FILL: 'pi pi-heart-fill',
  HISTORY: 'pi pi-history',
  HOME: 'pi pi-home',
  ID_CARD: 'pi pi-id-card',
  IMAGE: 'pi pi-image',
  IMAGES: 'pi pi-images',
  INBOX: 'pi pi-inbox',
  INFO: 'pi pi-info',
  INFO_CIRCLE: 'pi pi-info-circle',
  INSTAGRAM: 'pi pi-instagram',
  KEY: 'pi pi-key',
  LINK: 'pi pi-link',
  LINKEDIN: 'pi pi-linkedin',
  LIST: 'pi pi-list',
  LOCK: 'pi pi-lock',
  LOCK_OPEN: 'pi pi-lock-open',
  MAP: 'pi pi-map',
  MAP_MARKER: 'pi pi-map-marker',
  MICROSOFT: 'pi pi-microsoft',
  MINUS: 'pi pi-minus',
  MINUS_CIRCLE: 'pi pi-minus-circle',
  MOBILE: 'pi pi-mobile',
  MONEY_BILL: 'pi pi-money-bill',
  MOON: 'pi pi-moon',
  PALETTE: 'pi pi-palette',
  PAPERCLIP: 'pi pi-paperclip',
  PAUSE: 'pi pi-pause',
  PAYPAL: 'pi pi-paypal',
  PENCIL: 'pi pi-pencil',
  PERCENTAGE: 'pi pi-percentage',
  PHONE: 'pi pi-phone',
  PLAY: 'pi pi-play',
  PLUS: 'pi pi-plus',
  PLUS_CIRCLE: 'pi pi-plus-circle',
  POUND: 'pi pi-pound',
  POWER_OFF: 'pi pi-power-off',
  PRIME: 'pi pi-prime',
  PRINT: 'pi pi-print',
  QRCODE: 'pi pi-qrcode',
  QUESTION: 'pi pi-question',
  QUESTION_CIRCLE: 'pi pi-question-circle',
  REDDIT: 'pi pi-reddit',
  REFRESH: 'pi pi-refresh',
  REPLAY: 'pi pi-replay',
  REPLY: 'pi pi-reply',
  SAVE: 'pi pi-save',
  SEARCH: 'pi pi-search',
  SEARCH_MINUS: 'pi pi-search-minus',
  SEARCH_PLUS: 'pi pi-search-plus',
  SEND: 'pi pi-send',
  SERVER: 'pi pi-server',
  SHARE_ALT: 'pi pi-share-alt',
  SHIELD: 'pi pi-shield',
  SHOPPING_BAG: 'pi pi-shopping-bag',
  SHOPPING_CART: 'pi pi-shopping-cart',
  SIGN_IN: 'pi pi-sign-in',
  SIGN_OUT: 'pi pi-sign-out',
  SITEMAP: 'pi pi-sitemap',
  SLACK: 'pi pi-slack',
  SLIDERS_H: 'pi pi-sliders-h',
  SLIDERS_V: 'pi pi-sliders-v',
  SORT: 'pi pi-sort',
  SORT_ALPHA_DOWN: 'pi pi-sort-alpha-down',
  SORT_ALPHA_ALT_DOWN: 'pi pi-sort-alpha-alt-down',
  SORT_ALPHA_UP: 'pi pi-sort-alpha-up',
  SORT_ALPHA_ALT_UP: 'pi pi-sort-alpha-alt-up',
  SORT_ALT: 'pi pi-sort-alt',
  SORT_ALT_SLASH: 'pi pi-sort-slash',
  SORT_AMOUNT_DOWN: 'pi pi-sort-amount-down',
  SORT_AMOUNT_DOWN_ALT: 'pi pi-sort-amount-down-alt',
  SORT_AMOUNT_UP: 'pi pi-sort-amount-up',
  SORT_AMOUNT_UP_ALT: 'pi pi-sort-amount-up-alt',
  SORT_DOWN: 'pi pi-sort-down',
  SORT_NUMERIC_DOWN: 'pi pi-sort-numeric-down',
  SORT_NUMERIC_ALT_DOWN: 'pi pi-sort-numeric-alt-down',
  SORT_NUMERIC_UP: 'pi pi-sort-numeric-up',
  SORT_NUMERIC_ALT_UP: 'pi pi-sort-numeric-alt-up',
  SORT_UP: 'pi pi-sort-up',
  SPINNER: 'pi pi-spinner',
  STAR: 'pi pi-star',
  STAR_FILL: 'pi pi-star-fill',
  STEP_BACKWARD: 'pi pi-step-backward',
  STEP_BACKWARD_ALT: 'pi pi-step-backward-alt',
  STEP_FORWARD: 'pi pi-step-forward',
  STEP_FORWARD_ALT: 'pi pi-step-forward-alt',
  STOP: 'pi pi-stop',
  STOP_CIRCLE: 'pi pi-stop-circle',
  SUN: 'pi pi-sun',
  SYNC: 'pi pi-sync',
  TABLE: 'pi pi-table',
  TABLET: 'pi pi-tablet',
  TAG: 'pi pi-tag',
  TAGS: 'pi pi-tags',
  TELEGRAM: 'pi pi-telegram',
  TH_LARGE: 'pi pi-th-large',
  THUMBS_DOWN: 'pi pi-thumbs-down',
  THUMBS_UP: 'pi pi-thumbs-up',
  TICKET: 'pi pi-ticket',
  TIMES: 'pi pi-times',
  TIMES_CIRCLE: 'pi pi-times-circle',
  TRASH: 'pi pi-trash',
  TWITTER: 'pi pi-twitter',
  UNDO: 'pi pi-undo',
  UNLOCK: 'pi pi-unlock',
  UPLOAD: 'pi pi-upload',
  USER: 'pi pi-user',
  USER_EDIT: 'pi pi-user-edit',
  USER_MINUS: 'pi pi-user-minus',
  USER_PLUS: 'pi pi-user-plus',
  USERS: 'pi pi-users',
  VIDEO: 'pi pi-video',
  VIMEO: 'pi pi-vimeo',
  VOLUME_DOWN: 'pi pi-volume-down',
  VOLUME_OFF: 'pi pi-volume-off',
  VOLUME_UP: 'pi pi-volume-up',
  WALLET: 'pi pi-wallet',
  WHATSAPP: 'pi pi-whatsapp',
  WIFI: 'pi pi-wifi',
  WINDOW_MAXIMIZE: 'pi pi-window-maximize',
  WINDOW_MINIMIZE: 'pi pi-window-minimize',
  YOUTUBE: 'pi pi-youtube'
});
var SortOrder = Object.freeze({
  DESC: -1,
  UNSORTED: 0,
  ASC: 1
});

function _extends$J() {
  _extends$J = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$J.apply(this, arguments);
}

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

var propTypes = {exports: {}};

var reactIs = {exports: {}};

var reactIs_production_min = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b = "function" === typeof Symbol && Symbol.for,
    c = b ? Symbol.for("react.element") : 60103,
    d = b ? Symbol.for("react.portal") : 60106,
    e = b ? Symbol.for("react.fragment") : 60107,
    f = b ? Symbol.for("react.strict_mode") : 60108,
    g = b ? Symbol.for("react.profiler") : 60114,
    h = b ? Symbol.for("react.provider") : 60109,
    k = b ? Symbol.for("react.context") : 60110,
    l = b ? Symbol.for("react.async_mode") : 60111,
    m = b ? Symbol.for("react.concurrent_mode") : 60111,
    n = b ? Symbol.for("react.forward_ref") : 60112,
    p = b ? Symbol.for("react.suspense") : 60113,
    q = b ? Symbol.for("react.suspense_list") : 60120,
    r = b ? Symbol.for("react.memo") : 60115,
    t = b ? Symbol.for("react.lazy") : 60116,
    v = b ? Symbol.for("react.block") : 60121,
    w = b ? Symbol.for("react.fundamental") : 60117,
    x = b ? Symbol.for("react.responder") : 60118,
    y = b ? Symbol.for("react.scope") : 60119;

function z(a) {
  if ("object" === typeof a && null !== a) {
    var u = a.$$typeof;

    switch (u) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;

          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;

              default:
                return u;
            }

        }

      case d:
        return u;
    }
  }
}

function A(a) {
  return z(a) === m;
}

reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;

reactIs_production_min.isAsyncMode = function (a) {
  return A(a) || z(a) === l;
};

reactIs_production_min.isConcurrentMode = A;

reactIs_production_min.isContextConsumer = function (a) {
  return z(a) === k;
};

reactIs_production_min.isContextProvider = function (a) {
  return z(a) === h;
};

reactIs_production_min.isElement = function (a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};

reactIs_production_min.isForwardRef = function (a) {
  return z(a) === n;
};

reactIs_production_min.isFragment = function (a) {
  return z(a) === e;
};

reactIs_production_min.isLazy = function (a) {
  return z(a) === t;
};

reactIs_production_min.isMemo = function (a) {
  return z(a) === r;
};

reactIs_production_min.isPortal = function (a) {
  return z(a) === d;
};

reactIs_production_min.isProfiler = function (a) {
  return z(a) === g;
};

reactIs_production_min.isStrictMode = function (a) {
  return z(a) === f;
};

reactIs_production_min.isSuspense = function (a) {
  return z(a) === p;
};

reactIs_production_min.isValidElementType = function (a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};

reactIs_production_min.typeOf = z;

var reactIs_development = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== "production") {
  (function () {
    // nor polyfill, then a plain number is used for performance.

    var hasSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
    // (unstable) APIs that have been removed. Can we remove the symbols?

    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
    var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
    var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
    var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
    var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
    var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

    function isValidElementType(type) {
      return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
    }

    function typeOf(object) {
      if (typeof object === 'object' && object !== null) {
        var $$typeof = object.$$typeof;

        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type = object.type;

            switch (type) {
              case REACT_ASYNC_MODE_TYPE:
              case REACT_CONCURRENT_MODE_TYPE:
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
                return type;

              default:
                var $$typeofType = type && type.$$typeof;

                switch ($$typeofType) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;

                  default:
                    return $$typeof;
                }

            }

          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }

      return undefined;
    } // AsyncMode is deprecated along with isAsyncMode


    var AsyncMode = REACT_ASYNC_MODE_TYPE;
    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
    var ContextConsumer = REACT_CONTEXT_TYPE;
    var ContextProvider = REACT_PROVIDER_TYPE;
    var Element = REACT_ELEMENT_TYPE;
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Fragment = REACT_FRAGMENT_TYPE;
    var Lazy = REACT_LAZY_TYPE;
    var Memo = REACT_MEMO_TYPE;
    var Portal = REACT_PORTAL_TYPE;
    var Profiler = REACT_PROFILER_TYPE;
    var StrictMode = REACT_STRICT_MODE_TYPE;
    var Suspense = REACT_SUSPENSE_TYPE;
    var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

    function isAsyncMode(object) {
      {
        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
          hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

          console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
        }
      }
      return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    }

    function isConcurrentMode(object) {
      return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    }

    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }

    function isContextProvider(object) {
      return typeOf(object) === REACT_PROVIDER_TYPE;
    }

    function isElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    function isForwardRef(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }

    function isFragment(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    }

    function isLazy(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    }

    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }

    function isPortal(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    }

    function isProfiler(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    }

    function isStrictMode(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }

    function isSuspense(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    }

    reactIs_development.AsyncMode = AsyncMode;
    reactIs_development.ConcurrentMode = ConcurrentMode;
    reactIs_development.ContextConsumer = ContextConsumer;
    reactIs_development.ContextProvider = ContextProvider;
    reactIs_development.Element = Element;
    reactIs_development.ForwardRef = ForwardRef;
    reactIs_development.Fragment = Fragment;
    reactIs_development.Lazy = Lazy;
    reactIs_development.Memo = Memo;
    reactIs_development.Portal = Portal;
    reactIs_development.Profiler = Profiler;
    reactIs_development.StrictMode = StrictMode;
    reactIs_development.Suspense = Suspense;
    reactIs_development.isAsyncMode = isAsyncMode;
    reactIs_development.isConcurrentMode = isConcurrentMode;
    reactIs_development.isContextConsumer = isContextConsumer;
    reactIs_development.isContextProvider = isContextProvider;
    reactIs_development.isElement = isElement;
    reactIs_development.isForwardRef = isForwardRef;
    reactIs_development.isFragment = isFragment;
    reactIs_development.isLazy = isLazy;
    reactIs_development.isMemo = isMemo;
    reactIs_development.isPortal = isPortal;
    reactIs_development.isProfiler = isProfiler;
    reactIs_development.isStrictMode = isStrictMode;
    reactIs_development.isSuspense = isSuspense;
    reactIs_development.isValidElementType = isValidElementType;
    reactIs_development.typeOf = typeOf;
  })();
}

if (process.env.NODE_ENV === 'production') {
  reactIs.exports = reactIs_production_min;
} else {
  reactIs.exports = reactIs_development;
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret$3 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
var ReactPropTypesSecret_1 = ReactPropTypesSecret$3;

var has$2 = Function.call.bind(Object.prototype.hasOwnProperty);

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var printWarning$1 = function () {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret$2 = ReactPropTypesSecret_1;

  var loggedTypeFailures = {};

  var has$1 = has$2;

  printWarning$1 = function (text) {
    var message = 'Warning: ' + text;

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {
      /**/
    }
  };
}
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */


function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (has$1(typeSpecs, typeSpecName)) {
        var error; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$2);
        } catch (ex) {
          error = ex;
        }

        if (error && !(error instanceof Error)) {
          printWarning$1((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
        }

        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;
          var stack = getStack ? getStack() : '';
          printWarning$1('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
        }
      }
    }
  }
}
/**
 * Resets warning cache when testing.
 *
 * @private
 */


checkPropTypes$1.resetWarningCache = function () {
  if (process.env.NODE_ENV !== 'production') {
    loggedTypeFailures = {};
  }
};

var checkPropTypes_1 = checkPropTypes$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactIs$1 = reactIs.exports;

var assign = objectAssign;

var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;

var has = has$2;

var checkPropTypes = checkPropTypes_1;

var printWarning = function () {};

if (process.env.NODE_ENV !== 'production') {
  printWarning = function (text) {
    var message = 'Warning: ' + text;

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

var factoryWithTypeCheckers = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */

  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);

    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }
  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */


  var ANONYMOUS = '<<anonymous>>'; // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.

  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bigint: createPrimitiveTypeChecker('bigint'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),
    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };
  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */

  /*eslint-disable no-self-compare*/

  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */


  function PropTypeError(message, data) {
    this.message = message;
    this.data = data && typeof data === 'object' ? data : {};
    this.stack = '';
  } // Make `instanceof Error` still work for returned errors.


  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }

    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret$1) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;

          if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }

      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }

          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }

        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'), {
          expectedType: expectedType
        });
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }

      var propValue = props[propName];

      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }

      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret$1);

        if (error instanceof Error) {
          return error;
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];

      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];

      if (!ReactIs$1.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (process.env.NODE_ENV !== 'production') {
        if (arguments.length > 1) {
          printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }

      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];

      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);

        if (type === 'symbol') {
          return String(value);
        }

        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }

    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }

      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }

      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$1);

          if (error instanceof Error) {
            return error;
          }
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];

      if (typeof checker !== 'function') {
        printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      var expectedTypes = [];

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret$1);

        if (checkerResult == null) {
          return null;
        }

        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
          expectedTypes.push(checkerResult.data.expectedType);
        }
      }

      var expectedTypesMessage = expectedTypes.length > 0 ? ', expected one of type [' + expectedTypes.join(', ') + ']' : '';
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
    }

    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function invalidValidatorError(componentName, location, propFullName, key, type) {
    return new PropTypeError((componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + type + '`.');
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }

      for (var key in shapeTypes) {
        var checker = shapeTypes[key];

        if (typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }

        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$1);

        if (error) {
          return error;
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      } // We need to check all keys in case some are required but missing from props.


      var allKeys = assign({}, props[propName], shapeTypes);

      for (var key in allKeys) {
        var checker = shapeTypes[key];

        if (has(shapeTypes, key) && typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }

        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }

        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$1);

        if (error) {
          return error;
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;

      case 'boolean':
        return !propValue;

      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }

        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);

        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;

          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;

              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;

      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    } // falsy value can't be a Symbol


    if (!propValue) {
      return false;
    } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'


    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    } // Fallback for non-spec compliant Symbols which are polyfilled.


    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  } // Equivalent of `typeof` but with special handling for array and regexp.


  function getPropType(propValue) {
    var propType = typeof propValue;

    if (Array.isArray(propValue)) {
      return 'array';
    }

    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }

    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }

    return propType;
  } // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.


  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }

    var propType = getPropType(propValue);

    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }

    return propType;
  } // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"


  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);

    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;

      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;

      default:
        return type;
    }
  } // Returns class name of the object, if any.


  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }

    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret = ReactPropTypesSecret_1;

function emptyFunction() {}

function emptyFunctionWithReset() {}

emptyFunctionWithReset.resetWarningCache = emptyFunction;

var factoryWithThrowingShims = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }

    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  }
  shim.isRequired = shim;

  function getShim() {
    return shim;
  }
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var ReactIs = reactIs.exports; // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod


  var throwOnDirectAccess = true;
  propTypes.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  propTypes.exports = factoryWithThrowingShims();
}

var PropTypes = propTypes.exports;

/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}

function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}

var config = {
  disabled: false
};

var timeoutsShape = process.env.NODE_ENV !== 'production' ? PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
  enter: PropTypes.number,
  exit: PropTypes.number,
  appear: PropTypes.number
}).isRequired]) : null;
var classNamesShape = process.env.NODE_ENV !== 'production' ? PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
  enter: PropTypes.string,
  exit: PropTypes.string,
  active: PropTypes.string
}), PropTypes.shape({
  enter: PropTypes.string,
  enterDone: PropTypes.string,
  enterActive: PropTypes.string,
  exit: PropTypes.string,
  exitDone: PropTypes.string,
  exitActive: PropTypes.string
})]) : null;

var TransitionGroupContext = React__default.createContext(null);

var forceReflow = function forceReflow(node) {
  return node.scrollTop;
};

var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

var Transition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  } // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }
  ;

  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this); // https://github.com/reactjs/react-transition-group/pull/749
          // With unmountOnExit or mountOnEnter, the enter animation should happen at the transition between `exited` and `entering`.
          // To make the animation happen,  we have to separate each rendering and avoid being processed as batched.

          if (node) forceReflow(node);
        }

        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;

    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing],
        maybeNode = _ref2[0],
        maybeAppearing = _ref2[1];

    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }

    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(maybeNode, maybeAppearing);

      _this2.onTransitionEnd(enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };

  _proto.performExit = function performExit() {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? undefined : ReactDOM.findDOMNode(this); // no exit animation skip right to EXITED

    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(maybeNode);
      });
      return;
    }

    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(maybeNode);

      _this3.onTransitionEnd(timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
          maybeNode = _ref3[0],
          maybeNextCallback = _ref3[1];

      this.props.addEndListener(maybeNode, maybeNextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

    return (
      /*#__PURE__*/
      // allows for nested Transitions
      React__default.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === 'function' ? children(status, childProps) : React__default.cloneElement(React__default.Children.only(children), childProps))
    );
  };

  return Transition;
}(React__default.Component);

Transition.contextType = TransitionGroupContext;
Transition.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: PropTypes.shape({
    current: typeof Element === 'undefined' ? PropTypes.any : function (propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return PropTypes.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),

  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,

  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,

  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,

  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,

  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: PropTypes.bool,

  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,

  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,

  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener) pt = pt.isRequired;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return pt.apply(void 0, [props].concat(args));
  },

  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,

  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,

  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,

  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,

  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,

  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func
} : {}; // Name the function so it is clearer in the documentation

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition$1 = Transition;

var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return addClass(node, c);
  });
};

var removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return removeClass$1(node, c);
  });
};
/**
 * A transition component inspired by the excellent
 * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
 * use it if you're using CSS transitions or animations. It's built upon the
 * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
 * component, so it inherits all of its props.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` states of the transition. The first class is applied and then a
 * second `*-active` class in order to activate the CSS transition. After the
 * transition, matching `*-done` class names are applied to persist the
 * transition state.
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
 *         <div>
 *           {"I'll receive my-node-* classes"}
 *         </div>
 *       </CSSTransition>
 *       <button type="button" onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the `in` prop is set to `true`, the child component will first receive
 * the class `example-enter`, then the `example-enter-active` will be added in
 * the next tick. `CSSTransition` [forces a
 * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * between before adding the `example-enter-active`. This is an important trick
 * because it allows us to transition between `example-enter` and
 * `example-enter-active` even though they were added immediately one after
 * another. Most notably, this is what makes it possible for us to animate
 * _appearance_.
 *
 * ```css
 * .my-node-enter {
 *   opacity: 0;
 * }
 * .my-node-enter-active {
 *   opacity: 1;
 *   transition: opacity 200ms;
 * }
 * .my-node-exit {
 *   opacity: 1;
 * }
 * .my-node-exit-active {
 *   opacity: 0;
 *   transition: opacity 200ms;
 * }
 * ```
 *
 * `*-active` classes represent which styles you want to animate **to**, so it's
 * important to add `transition` declaration only to them, otherwise transitions
 * might not behave as intended! This might not be obvious when the transitions
 * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
 * the example above (minus `transition`), but it becomes apparent in more
 * complex transitions.
 *
 * **Note**: If you're using the
 * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
 * prop, make sure to define styles for `.appear-*` classes as well.
 */


var CSSTransition$1 = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };

    _this.onEnter = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument[0],
          appearing = _this$resolveArgument[1];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };

    _this.onEntering = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument2[0],
          appearing = _this$resolveArgument2[1];

      var type = appearing ? 'appear' : 'enter';

      _this.addClass(node, type, 'active');

      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };

    _this.onEntered = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument3[0],
          appearing = _this$resolveArgument3[1];

      var type = appearing ? 'appear' : 'enter';

      _this.removeClasses(node, type);

      _this.addClass(node, type, 'done');

      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };

    _this.onExit = function (maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument4[0];

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      _this.addClass(node, 'exit', 'base');

      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };

    _this.onExiting = function (maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument5[0];

      _this.addClass(node, 'exit', 'active');

      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };

    _this.onExited = function (maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument6[0];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, 'exit', 'done');

      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };

    _this.resolveArguments = function (maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
      : [maybeNode, maybeAppearing];
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === 'string';
      var prefix = isStringClassNames && classNames ? classNames + "-" : '';
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName: baseClassName,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.addClass = function addClass(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];

    var _this$getClassNames = this.getClassNames('enter'),
        doneClassName = _this$getClassNames.doneClassName;

    if (type === 'appear' && phase === 'done' && doneClassName) {
      className += " " + doneClassName;
    } // This is to force a repaint,
    // which is necessary in order to transition styles when adding a class name.


    if (phase === 'active') {
      if (node) forceReflow(node);
    }

    if (className) {
      this.appliedClasses[type][phase] = className;

      _addClass(node, className);
    }
  };

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type],
        baseClassName = _this$appliedClasses$.base,
        activeClassName = _this$appliedClasses$.active,
        doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};

    if (baseClassName) {
      removeClass(node, baseClassName);
    }

    if (activeClassName) {
      removeClass(node, activeClassName);
    }

    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props;
        _this$props.classNames;
        var props = _objectWithoutPropertiesLoose$1(_this$props, ["classNames"]);

    return /*#__PURE__*/React__default.createElement(Transition$1, _extends$J({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(React__default.Component);

CSSTransition$1.defaultProps = {
  classNames: ''
};
CSSTransition$1.propTypes = process.env.NODE_ENV !== "production" ? _extends$J({}, Transition$1.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: PropTypes.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: PropTypes.func
}) : {};
var CSSTransition$1$1 = CSSTransition$1;

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */

function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && isValidElement(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) Children.map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!isValidElement(child)) return;
    var hasPrev = (key in prevChildMapping);
    var hasNext = (key in nextChildMapping);
    var prevChild = prevChildMapping[key];
    var isLeaving = isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && isValidElement(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}

var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
};
/**
 * The `<TransitionGroup>` component manages a set of transition components
 * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
 * components, `<TransitionGroup>` is a state machine for managing the mounting
 * and unmounting of components over time.
 *
 * Consider the example below. As items are removed or added to the TodoList the
 * `in` prop is toggled automatically by the `<TransitionGroup>`.
 *
 * Note that `<TransitionGroup>`  does not define any animation behavior!
 * Exactly _how_ a list item animates is up to the individual transition
 * component. This means you can mix and match animations across different list
 * items.
 */

var TransitionGroup = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this)); // Initial children should all be entering, dependent on appear


    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  } // node is `undefined` when user provided `nodeRef` prop
  ;

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = _extends$J({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);

    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return /*#__PURE__*/React__default.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }

    return /*#__PURE__*/React__default.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /*#__PURE__*/React__default.createElement(Component, props, children));
  };

  return TransitionGroup;
}(React__default.Component);

TransitionGroup.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: PropTypes.any,

  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: PropTypes.node,

  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: PropTypes.bool,

  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: PropTypes.bool,

  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: PropTypes.bool,

  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: PropTypes.func
} : {};
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup$1 = TransitionGroup;

var usePrevious = function usePrevious(newValue) {
  var ref = React.useRef(undefined);
  React.useEffect(function () {
    ref.current = newValue;
  });
  return ref.current;
};
/* eslint-disable */


var useMountEffect = function useMountEffect(fn) {
  return React.useEffect(fn, []);
};
/* eslint-enable */

/* eslint-disable */


var useUpdateEffect = function useUpdateEffect(fn, deps) {
  var mounted = React.useRef(false);
  return React.useEffect(function () {
    if (!mounted.current) {
      mounted.current = true;
      return;
    }

    return fn && fn();
  }, deps);
};
/* eslint-enable */

/* eslint-disable */


var useUnmountEffect = function useUnmountEffect(fn) {
  return React.useEffect(function () {
    return fn;
  }, []);
};
/* eslint-enable */

/* eslint-disable */


var useEventListener = function useEventListener(_ref) {
  var _ref$target = _ref.target,
      target = _ref$target === void 0 ? 'document' : _ref$target,
      type = _ref.type,
      listener = _ref.listener,
      options = _ref.options,
      _ref$when = _ref.when,
      when = _ref$when === void 0 ? true : _ref$when;
  var targetRef = React.useRef(null);
  var listenerRef = React.useRef(null);
  var prevOptions = usePrevious(options);

  var bind = function bind() {
    var bindOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (ObjectUtils.isNotEmpty(bindOptions.target)) {
      unbind();
      (bindOptions.when || when) && (targetRef.current = DomHandler.getTargetElement(bindOptions.target));
    }

    if (!listenerRef.current && targetRef.current) {
      listenerRef.current = function (event) {
        return listener && listener(event);
      };

      targetRef.current.addEventListener(type, listenerRef.current, options);
    }
  };

  var unbind = function unbind() {
    if (listenerRef.current) {
      targetRef.current.removeEventListener(type, listenerRef.current, options);
      listenerRef.current = null;
    }
  };

  React.useEffect(function () {
    if (when) {
      targetRef.current = DomHandler.getTargetElement(target);
    } else {
      unbind();
      targetRef.current = null;
    }
  }, [target, when]);
  React.useEffect(function () {
    if (listenerRef.current && (listenerRef.current !== listener || prevOptions !== options)) {
      unbind();
      when && bind();
    }
  }, [listener, options]);
  useUnmountEffect(function () {
    unbind();
  });
  return [bind, unbind];
};
/* eslint-enable */


function _arrayWithHoles$w(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$w(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$B(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$B(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$B(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$B(o, minLen);
}

function _nonIterableRest$w() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$w(arr, i) {
  return _arrayWithHoles$w(arr) || _iterableToArrayLimit$w(arr, i) || _unsupportedIterableToArray$B(arr, i) || _nonIterableRest$w();
}
/* eslint-disable */


var useOverlayScrollListener = function useOverlayScrollListener(_ref) {
  var target = _ref.target,
      listener = _ref.listener,
      options = _ref.options,
      _ref$when = _ref.when,
      when = _ref$when === void 0 ? true : _ref$when;
  var targetRef = React.useRef(null);
  var listenerRef = React.useRef(null);
  var scrollableParents = React.useRef([]);
  var prevOptions = usePrevious(options);

  var bind = function bind() {
    var bindOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (ObjectUtils.isNotEmpty(bindOptions.target)) {
      unbind();
      (bindOptions.when || when) && (targetRef.current = DomHandler.getTargetElement(bindOptions.target));
    }

    if (!listenerRef.current && targetRef.current) {
      var nodes = scrollableParents.current = DomHandler.getScrollableParents(targetRef.current);

      listenerRef.current = function (event) {
        return listener && listener(event);
      };

      nodes.forEach(function (node) {
        return node.addEventListener('scroll', listenerRef.current, options);
      });
    }
  };

  var unbind = function unbind() {
    if (listenerRef.current) {
      var nodes = scrollableParents.current;
      nodes.forEach(function (node) {
        return node.removeEventListener('scroll', listenerRef.current, options);
      });
      listenerRef.current = null;
    }
  };

  React.useEffect(function () {
    if (when) {
      targetRef.current = DomHandler.getTargetElement(target);
    } else {
      unbind();
      targetRef.current = null;
    }
  }, [target, when]);
  React.useEffect(function () {
    if (listenerRef.current && (listenerRef.current !== listener || prevOptions !== options)) {
      unbind();
      when && bind();
    }
  }, [listener, options]);
  useUnmountEffect(function () {
    unbind();
  });
  return [bind, unbind];
};
/* eslint-enable */


var useResizeListener = function useResizeListener(_ref) {
  var listener = _ref.listener;
  return useEventListener({
    target: 'window',
    type: 'resize',
    listener: listener
  });
};

var useOverlayListener = function useOverlayListener(_ref) {
  var target = _ref.target,
      overlay = _ref.overlay,
      _listener = _ref.listener,
      _ref$when = _ref.when,
      when = _ref$when === void 0 ? true : _ref$when;
  var targetRef = React.useRef(null);
  var overlayRef = React.useRef(null);
  /**
   * The parameters of the 'listener' method in the following event handlers;
   * @param {Event} event A click event of the document.
   * @param {string} options.type The custom type to detect event.
   * @param {boolean} options.valid It is controlled by PrimeReact. It is determined whether it is valid or not according to some custom validation.
   */

  var _useEventListener = useEventListener({
    type: 'click',
    listener: function listener(event) {
      _listener && _listener(event, {
        type: 'outside',
        valid: event.which !== 3 && isOutsideClicked(event)
      });
    }
  }),
      _useEventListener2 = _slicedToArray$w(_useEventListener, 2),
      bindDocumentClickListener = _useEventListener2[0],
      unbindDocumentClickListener = _useEventListener2[1];

  var _useResizeListener = useResizeListener({
    listener: function listener(event) {
      _listener && _listener(event, {
        type: 'resize',
        valid: !DomHandler.isTouchDevice()
      });
    }
  }),
      _useResizeListener2 = _slicedToArray$w(_useResizeListener, 2),
      bindWindowResizeListener = _useResizeListener2[0],
      unbindWindowResizeListener = _useResizeListener2[1];

  var _useOverlayScrollList = useOverlayScrollListener({
    target: targetRef,
    listener: function listener(event) {
      _listener && _listener(event, {
        type: 'scroll',
        valid: true
      });
    }
  }),
      _useOverlayScrollList2 = _slicedToArray$w(_useOverlayScrollList, 2),
      bindOverlayScrollListener = _useOverlayScrollList2[0],
      unbindOverlayScrollListener = _useOverlayScrollList2[1];

  var isOutsideClicked = function isOutsideClicked(event) {
    return targetRef.current && !(targetRef.current.isSameNode(event.target) || targetRef.current.contains(event.target) || overlayRef.current && overlayRef.current.contains(event.target));
  };

  var bind = function bind() {
    bindDocumentClickListener();
    bindWindowResizeListener();
    bindOverlayScrollListener();
  };

  var unbind = function unbind() {
    unbindDocumentClickListener();
    unbindWindowResizeListener();
    unbindOverlayScrollListener();
  };

  React.useEffect(function () {
    if (when) {
      targetRef.current = DomHandler.getTargetElement(target);
      overlayRef.current = DomHandler.getTargetElement(overlay);
    } else {
      unbind();
      targetRef.current = overlayRef.current = null;
    }
  }, [target, overlay, when]);
  React.useEffect(function () {
    unbind(); // when && bind();
  }, [when]);
  useUnmountEffect(function () {
    unbind();
  });
  return [bind, unbind];
};
/* eslint-enable */

/* eslint-disable */


var useTimeout = function useTimeout(fn) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var when = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var timeout = React.useRef(null);
  var savedCallback = React.useRef(null);
  var clear = React.useCallback(function () {
    return clearTimeout(timeout.current);
  }, [timeout.current]);
  React.useEffect(function () {
    savedCallback.current = fn;
  });
  React.useEffect(function () {
    function callback() {
      savedCallback.current();
    }

    if (when) {
      timeout.current = setTimeout(callback, delay);
      return clear;
    } else {
      clear();
    }
  }, [delay, when]);
  useUnmountEffect(function () {
    clear();
  });
  return [clear];
};

function _defineProperty$j(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$g(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$g(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$g(Object(source), !0).forEach(function (key) {
      _defineProperty$j(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$g(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var CSSTransition = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var disabled = props.disabled || props.options && props.options.disabled || !PrimeReact$1.cssTransition;

  var onEnter = function onEnter(node, isAppearing) {
    props.onEnter && props.onEnter(node, isAppearing); // component

    props.options && props.options.onEnter && props.options.onEnter(node, isAppearing); // user option
  };

  var onEntering = function onEntering(node, isAppearing) {
    props.onEntering && props.onEntering(node, isAppearing); // component

    props.options && props.options.onEntering && props.options.onEntering(node, isAppearing); // user option
  };

  var onEntered = function onEntered(node, isAppearing) {
    props.onEntered && props.onEntered(node, isAppearing); // component

    props.options && props.options.onEntered && props.options.onEntered(node, isAppearing); // user option
  };

  var onExit = function onExit(node) {
    props.onExit && props.onExit(node); // component

    props.options && props.options.onExit && props.options.onExit(node); // user option
  };

  var onExiting = function onExiting(node) {
    props.onExiting && props.onExiting(node); // component

    props.options && props.options.onExiting && props.options.onExiting(node); // user option
  };

  var onExited = function onExited(node) {
    props.onExited && props.onExited(node); // component

    props.options && props.options.onExited && props.options.onExited(node); // user option
  };

  useUpdateEffect(function () {
    if (disabled) {
      // no animation
      var node = ObjectUtils.getRefElement(props.nodeRef);

      if (props["in"]) {
        onEnter(node, true);
        onEntering(node, true);
        onEntered(node, true);
      } else {
        onExit(node);
        onExiting(node);
        onExited(node);
      }
    }
  }, [props["in"]]);

  if (disabled) {
    return props["in"] ? props.children : null;
  } else {
    var immutableProps = {
      nodeRef: props.nodeRef,
      "in": props["in"],
      onEnter: onEnter,
      onEntering: onEntering,
      onEntered: onEntered,
      onExit: onExit,
      onExiting: onExiting,
      onExited: onExited
    };
    var mutableProps = {
      classNames: props.classNames,
      timeout: props.timeout,
      unmountOnExit: props.unmountOnExit
    };

    var mergedProps = _objectSpread$g(_objectSpread$g(_objectSpread$g({}, mutableProps), props.options || {}), immutableProps);

    return /*#__PURE__*/React.createElement(CSSTransition$1$1, mergedProps, props.children);
  }
});
CSSTransition.displayName = 'CSSTransition';
CSSTransition.defaultProps = {
  __TYPE: 'CSSTransition'
};

function _extends$I() {
  _extends$I = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$I.apply(this, arguments);
}

function _defineProperty$i(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _arrayLikeToArray$A(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$g(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$A(arr);
}

function _iterableToArray$g(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$A(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$A(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$A(o, minLen);
}

function _nonIterableSpread$g() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$g(arr) {
  return _arrayWithoutHoles$g(arr) || _iterableToArray$g(arr) || _unsupportedIterableToArray$A(arr) || _nonIterableSpread$g();
}

function _arrayWithHoles$v(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$v(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$v() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$v(arr, i) {
  return _arrayWithHoles$v(arr) || _iterableToArrayLimit$v(arr, i) || _unsupportedIterableToArray$A(arr, i) || _nonIterableRest$v();
}

function ownKeys$f(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$f(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$f(Object(source), !0).forEach(function (key) {
      _defineProperty$i(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var AccordionTab = function AccordionTab() {};

var shouldUseTab = function shouldUseTab(tab) {
  return tab && tab.props.__TYPE === 'AccordionTab';
};

var Accordion$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(props.id),
      _React$useState2 = _slicedToArray$v(_React$useState, 2),
      idState = _React$useState2[0],
      setIdState = _React$useState2[1];

  var _React$useState3 = React.useState(props.activeIndex),
      _React$useState4 = _slicedToArray$v(_React$useState3, 2),
      activeIndexState = _React$useState4[0],
      setActiveIndexState = _React$useState4[1];

  var elementRef = React.useRef(null);
  var activeIndex = props.onTabChange ? props.activeIndex : activeIndexState;

  var onTabHeaderClick = function onTabHeaderClick(event, tab, index) {
    if (!tab.props.disabled) {
      var selected = isSelected(index);
      var newActiveIndex = null;

      if (props.multiple) {
        var indexes = activeIndex || [];
        newActiveIndex = selected ? indexes.filter(function (i) {
          return i !== index;
        }) : [].concat(_toConsumableArray$g(indexes), [index]);
      } else {
        newActiveIndex = selected ? null : index;
      }

      var callback = selected ? props.onTabClose : props.onTabOpen;
      callback && callback({
        originalEvent: event,
        index: index
      });

      if (props.onTabChange) {
        props.onTabChange({
          originalEvent: event,
          index: newActiveIndex
        });
      } else {
        setActiveIndexState(newActiveIndex);
      }
    }

    event.preventDefault();
  };

  var isSelected = function isSelected(index) {
    return props.multiple ? activeIndex && activeIndex.some(function (i) {
      return i === index;
    }) : activeIndex === index;
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  useMountEffect(function () {
    if (!idState) {
      setIdState(UniqueComponentId());
    }
  });

  if (!idState) {
    return null;
  }

  var createTabHeader = function createTabHeader(tab, selected, index) {
    var style = _objectSpread$f(_objectSpread$f({}, tab.props.style || {}), tab.props.headerStyle || {});

    var className = classNames('p-accordion-header', {
      'p-highlight': selected,
      'p-disabled': tab.props.disabled
    }, tab.props.headerClassName, tab.props.className);
    var headerId = idState + '_header_' + index;
    var ariaControls = idState + '_content_' + index;
    var tabIndex = tab.props.disabled ? -1 : null;
    var header = tab.props.headerTemplate ? ObjectUtils.getJSXElement(tab.props.headerTemplate, tab.props) : /*#__PURE__*/React.createElement("span", {
      className: "p-accordion-header-text"
    }, tab.props.header);
    var icon = IconUtils.getJSXIcon(selected ? props.collapseIcon : props.expandIcon, {
      className: 'p-accordion-toggle-icon'
    }, {
      props: props,
      selected: selected
    });
    var label = selected ? ariaLabel('collapseLabel') : ariaLabel('expandLabel');
    return /*#__PURE__*/React.createElement("div", {
      className: className,
      style: style
    }, /*#__PURE__*/React.createElement("a", {
      href: '#' + ariaControls,
      id: headerId,
      className: "p-accordion-header-link",
      "aria-controls": ariaControls,
      role: "tab",
      "aria-expanded": selected,
      onClick: function onClick(e) {
        return onTabHeaderClick(e, tab, index);
      },
      tabIndex: tabIndex,
      "aria-label": label
    }, icon, header));
  };

  var createTabContent = function createTabContent(tab, selected, index) {
    var style = _objectSpread$f(_objectSpread$f({}, tab.props.style || {}), tab.props.contentStyle || {});

    var className = classNames('p-toggleable-content', tab.props.contentClassName, tab.props.className);
    var contentId = idState + '_content_' + index;
    var ariaLabelledby = idState + '_header_' + index;
    var contentRef = /*#__PURE__*/React.createRef();
    return /*#__PURE__*/React.createElement(CSSTransition, {
      nodeRef: contentRef,
      classNames: "p-toggleable-content",
      timeout: {
        enter: 1000,
        exit: 450
      },
      "in": selected,
      unmountOnExit: true,
      options: props.transitionOptions
    }, /*#__PURE__*/React.createElement("div", {
      ref: contentRef,
      id: contentId,
      className: className,
      style: style,
      role: "region",
      "aria-labelledby": ariaLabelledby
    }, /*#__PURE__*/React.createElement("div", {
      className: "p-accordion-content"
    }, tab.props.children)));
  };

  var createTab = function createTab(tab, index) {
    if (shouldUseTab(tab)) {
      var key = idState + '_' + index;
      var selected = isSelected(index);

      var _otherProps = ObjectUtils.findDiffKeys(tab.props, AccordionTab.defaultProps);

      var tabHeader = createTabHeader(tab, selected, index);
      var tabContent = createTabContent(tab, selected, index);
      var tabClassName = classNames('p-accordion-tab', {
        'p-accordion-tab-active': selected
      });
      return /*#__PURE__*/React.createElement("div", _extends$I({
        key: key,
        className: tabClassName
      }, _otherProps), tabHeader, tabContent);
    }

    return null;
  };

  var createTabs = function createTabs() {
    return React.Children.map(props.children, createTab);
  };

  var otherProps = ObjectUtils.findDiffKeys(props, Accordion$1.defaultProps);
  var className = classNames('p-accordion p-component', props.className);
  var tabs = createTabs();
  return /*#__PURE__*/React.createElement("div", _extends$I({
    id: idState,
    ref: elementRef,
    className: className,
    style: props.style
  }, otherProps), tabs);
});
AccordionTab.displayName = 'AccordionTab';
AccordionTab.defaultProps = {
  __TYPE: 'AccordionTab',
  header: null,
  disabled: false,
  style: null,
  className: null,
  headerStyle: null,
  headerClassName: null,
  headerTemplate: null,
  contentStyle: null,
  contentClassName: null
};
Accordion$1.displayName = 'Accordion';
Accordion$1.defaultProps = {
  __TYPE: 'Accordion',
  id: null,
  activeIndex: null,
  className: null,
  style: null,
  multiple: false,
  expandIcon: 'pi pi-chevron-right',
  collapseIcon: 'pi pi-chevron-down',
  transitionOptions: null,
  onTabOpen: null,
  onTabClose: null,
  onTabChange: null
};

var Accordion = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      activeIndex = _ref.activeIndex,
      onTabChange = _ref.onTabChange,
      onTabOpen = _ref.onTabOpen,
      onTabClose = _ref.onTabClose,
      style = _ref.style,
      className = _ref.className,
      multiple = _ref.multiple,
      children = _ref.children;
  return /*#__PURE__*/React__default.createElement(Accordion$1, {
    ref: ref,
    id: id,
    activeIndex: activeIndex,
    onTabChange: onTabChange,
    onTabOpen: onTabOpen,
    onTabClose: onTabClose,
    style: style,
    className: className,
    multiple: multiple
  }, children);
});

function _extends$H() {
  _extends$H = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$H.apply(this, arguments);
}

var Avatar$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(null);

  var createContent = function createContent() {
    if (props.image) {
      return /*#__PURE__*/React.createElement("img", {
        src: props.image,
        alt: props.imageAlt,
        onError: props.onImageError
      });
    } else if (props.label) {
      return /*#__PURE__*/React.createElement("span", {
        className: "p-avatar-text"
      }, props.label);
    } else if (props.icon) {
      return IconUtils.getJSXIcon(props.icon, {
        className: 'p-avatar-icon'
      }, {
        props: props
      });
    }

    return null;
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  var otherProps = ObjectUtils.findDiffKeys(props, Avatar$1.defaultProps);
  var containerClassName = classNames('p-avatar p-component', {
    'p-avatar-image': props.image != null,
    'p-avatar-circle': props.shape === 'circle',
    'p-avatar-lg': props.size === 'large',
    'p-avatar-xl': props.size === 'xlarge',
    'p-avatar-clickable': !!props.onClick
  }, props.className);
  var content = props.template ? ObjectUtils.getJSXElement(props.template, props) : createContent();
  return /*#__PURE__*/React.createElement("div", _extends$H({
    ref: elementRef,
    className: containerClassName,
    style: props.style
  }, otherProps), content, props.children);
});
Avatar$1.displayName = 'Avatar';
Avatar$1.defaultProps = {
  __TYPE: 'Avatar',
  label: null,
  icon: null,
  image: null,
  size: 'normal',
  shape: 'square',
  style: null,
  className: null,
  template: null,
  imageAlt: 'avatar',
  onImageError: null
};

var Avatar = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var label = _ref.label,
      icon = _ref.icon,
      image = _ref.image,
      size = _ref.size,
      shape = _ref.shape,
      imageAlt = _ref.imageAlt,
      style = _ref.style,
      className = _ref.className,
      onImageError = _ref.onImageError,
      onClick = _ref.onClick,
      children = _ref.children;
  var avatarClassName = classNames(className, {
    "p-avatar-sm": size === "small"
  });
  return /*#__PURE__*/React__default.createElement(Avatar$1, {
    style: style,
    ref: ref,
    className: avatarClassName,
    label: label,
    icon: icon,
    image: image,
    size: size,
    shape: shape,
    imageAlt: imageAlt,
    onImageError: onImageError,
    onClick: onClick
  }, children);
});

function _extends$G() {
  _extends$G = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$G.apply(this, arguments);
}

function _defineProperty$h(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var Badge$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(null);
  var otherProps = ObjectUtils.findDiffKeys(props, Badge$1.defaultProps);
  var className = classNames('p-badge p-component', _defineProperty$h({
    'p-badge-no-gutter': ObjectUtils.isNotEmpty(props.value) && String(props.value).length === 1,
    'p-badge-dot': ObjectUtils.isEmpty(props.value),
    'p-badge-lg': props.size === 'large',
    'p-badge-xl': props.size === 'xlarge'
  }, "p-badge-".concat(props.severity), props.severity !== null), props.className);
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  return /*#__PURE__*/React.createElement("span", _extends$G({
    ref: elementRef,
    className: className,
    style: props.style
  }, otherProps), props.value);
}));
Badge$1.displayName = 'Badge';
Badge$1.defaultProps = {
  __TYPE: 'Badge',
  value: null,
  severity: null,
  size: null,
  style: null,
  className: null
};

var Badge = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var value = _ref.value,
      severity = _ref.severity,
      size = _ref.size,
      className = _ref.className,
      style = _ref.style;
  var badgeClassName = classNames(className, {
    "p-badge-sm": size === "small",
    "p-badge-secondary": severity === "secondary",
    "p-badge-help": severity === "help"
  });
  return /*#__PURE__*/React__default.createElement(Badge$1, {
    style: style,
    ref: ref,
    className: badgeClassName,
    value: value,
    severity: severity,
    size: size
  });
});

function _arrayWithHoles$u(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$u(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$z(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$z(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$z(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$z(o, minLen);
}

function _nonIterableRest$u() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$u(arr, i) {
  return _arrayWithHoles$u(arr) || _iterableToArrayLimit$u(arr, i) || _unsupportedIterableToArray$z(arr, i) || _nonIterableRest$u();
}

var Portal = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState(props.visible && DomHandler.hasDOM()),
      _React$useState2 = _slicedToArray$u(_React$useState, 2),
      mountedState = _React$useState2[0],
      setMountedState = _React$useState2[1];

  useMountEffect(function () {
    if (DomHandler.hasDOM() && !mountedState) {
      setMountedState(true);
      props.onMounted && props.onMounted();
    }
  });
  useUpdateEffect(function () {
    props.onMounted && props.onMounted();
  }, [mountedState]);
  useUnmountEffect(function () {
    props.onUnmounted && props.onUnmounted();
  });
  var element = props.element || props.children;

  if (element && mountedState) {
    var appendTo = props.appendTo || PrimeReact$1.appendTo || document.body;
    return appendTo === 'self' ? element : /*#__PURE__*/ReactDOM.createPortal(element, appendTo);
  }

  return null;
});
Portal.displayName = 'Portal';
Portal.defaultProps = {
  __TYPE: 'Portal',
  element: null,
  appendTo: null,
  visible: false,
  onMounted: null,
  onUnmounted: null
};

function _extends$F() {
  _extends$F = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$F.apply(this, arguments);
}

function _arrayWithHoles$t(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$t(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$y(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$y(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$y(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$y(o, minLen);
}

function _nonIterableRest$t() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$t(arr, i) {
  return _arrayWithHoles$t(arr) || _iterableToArrayLimit$t(arr, i) || _unsupportedIterableToArray$y(arr, i) || _nonIterableRest$t();
}

var BlockUI$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(props.blocked),
      _React$useState2 = _slicedToArray$t(_React$useState, 2),
      visibleState = _React$useState2[0],
      setVisibleState = _React$useState2[1];

  var elementRef = React.useRef(null);
  var maskRef = React.useRef(null);

  var block = function block() {
    setVisibleState(true);
  };

  var unblock = function unblock() {
    var callback = function callback() {
      setVisibleState(false);
      props.fullScreen && DomHandler.removeClass(document.body, 'p-overflow-hidden');
      props.onUnblocked && props.onUnblocked();
    };

    if (maskRef.current) {
      DomHandler.addClass(maskRef.current, 'p-component-overlay-leave');
      maskRef.current.addEventListener('animationend', function () {
        ZIndexUtils.clear(maskRef.current);
        callback();
      });
    } else {
      callback();
    }
  };

  var onPortalMounted = function onPortalMounted() {
    if (props.fullScreen) {
      DomHandler.addClass(document.body, 'p-overflow-hidden');
      document.activeElement.blur();
    }

    if (props.autoZIndex) {
      var key = props.fullScreen ? 'modal' : 'overlay';
      ZIndexUtils.set(key, maskRef.current, PrimeReact$1.autoZIndex, props.baseZIndex || PrimeReact$1.zIndex[key]);
    }

    props.onBlocked && props.onBlocked();
  };

  useMountEffect(function () {
    visibleState && block();
  });
  useUpdateEffect(function () {
    props.blocked ? block() : unblock();
  }, [props.blocked]);
  useUnmountEffect(function () {
    if (props.fullScreen) {
      DomHandler.removeClass(document.body, 'p-overflow-hidden');
    }

    ZIndexUtils.clear(maskRef.current);
  });
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      block: block,
      unblock: unblock,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });

  var createMask = function createMask() {
    if (visibleState) {
      var appendTo = props.fullScreen ? document.body : 'self';
      var className = classNames('p-blockui p-component-overlay p-component-overlay-enter', {
        'p-blockui-document': props.fullScreen
      }, props.className);
      var content = props.template ? ObjectUtils.getJSXElement(props.template, props) : null;

      var _mask = /*#__PURE__*/React.createElement("div", {
        ref: maskRef,
        className: className,
        style: props.style
      }, content);

      return /*#__PURE__*/React.createElement(Portal, {
        element: _mask,
        appendTo: appendTo,
        onMounted: onPortalMounted
      });
    }

    return null;
  };

  var otherProps = ObjectUtils.findDiffKeys(props, BlockUI$1.defaultProps);
  var mask = createMask();
  return /*#__PURE__*/React.createElement("div", _extends$F({
    id: props.id,
    ref: elementRef,
    className: "p-blockui-container"
  }, otherProps), props.children, mask);
});
BlockUI$1.displayName = 'BlockUI';
BlockUI$1.defaultProps = {
  __TYPE: 'BlockUI',
  id: null,
  blocked: false,
  fullScreen: false,
  baseZIndex: 0,
  autoZIndex: true,
  style: null,
  className: null,
  template: null,
  onBlocked: null,
  onUnblocked: null
};

var BlockUI = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      blocked = _ref.blocked,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 50 : _ref$baseZIndex,
      _ref$autoZIndex = _ref.autoZIndex,
      autoZIndex = _ref$autoZIndex === void 0 ? true : _ref$autoZIndex,
      className = _ref.className,
      style = _ref.style,
      children = _ref.children;
  return /*#__PURE__*/React__default.createElement(BlockUI$1, {
    ref: ref,
    id: id,
    blocked: blocked,
    baseZIndex: baseZIndex,
    autoZIndex: autoZIndex,
    className: className,
    style: style
  }, children);
});

function _extends$E() {
  _extends$E = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$E.apply(this, arguments);
}

var BreadCrumb$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(null);

  var itemClick = function itemClick(event, item) {
    if (item.disabled) {
      event.preventDefault();
      return;
    }

    if (!item.url) {
      event.preventDefault();
    }

    if (item.command) {
      item.command({
        originalEvent: event,
        item: item
      });
    }
  };

  var createHome = function createHome() {
    var home = props.home;

    if (home) {
      if (home.visible === false) {
        return null;
      }

      var _icon = home.icon,
          target = home.target,
          url = home.url,
          disabled = home.disabled,
          style = home.style,
          _className = home.className,
          template = home.template;

      var _className2 = classNames('p-breadcrumb-home', {
        'p-disabled': disabled
      }, _className);

      var icon = IconUtils.getJSXIcon(_icon, {
        className: 'p-menuitem-icon'
      }, {
        props: props
      });
      var content = /*#__PURE__*/React.createElement("a", {
        href: url || '#',
        className: "p-menuitem-link",
        "aria-disabled": disabled,
        target: target,
        onClick: function onClick(event) {
          return itemClick(event, home);
        }
      }, icon);

      if (template) {
        var defaultContentOptions = {
          onClick: function onClick(event) {
            return itemClick(event, home);
          },
          className: 'p-menuitem-link',
          labelClassName: 'p-menuitem-text',
          element: content,
          props: props
        };
        content = ObjectUtils.getJSXElement(template, home, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement("li", {
        className: _className2,
        style: style
      }, content);
    }

    return null;
  };

  var createSeparator = function createSeparator() {
    return /*#__PURE__*/React.createElement("li", {
      className: "p-breadcrumb-chevron pi pi-chevron-right"
    });
  };

  var createMenuitem = function createMenuitem(item) {
    if (item.visible === false) {
      return null;
    }

    var className = classNames(item.className, {
      'p-disabled': item.disabled
    });
    var label = item.label && /*#__PURE__*/React.createElement("span", {
      className: "p-menuitem-text"
    }, item.label);
    var content = /*#__PURE__*/React.createElement("a", {
      href: item.url || '#',
      className: "p-menuitem-link",
      target: item.target,
      onClick: function onClick(event) {
        return itemClick(event, item);
      },
      "aria-disabled": item.disabled
    }, label);

    if (item.template) {
      var defaultContentOptions = {
        onClick: function onClick(event) {
          return itemClick(event, item);
        },
        className: 'p-menuitem-link',
        labelClassName: 'p-menuitem-text',
        element: content,
        props: props
      };
      content = ObjectUtils.getJSXElement(item.template, item, defaultContentOptions);
    }

    return /*#__PURE__*/React.createElement("li", {
      className: className,
      style: item.style
    }, content);
  };

  var createMenuitems = function createMenuitems() {
    if (props.model) {
      var _items = props.model.map(function (item, index) {
        if (item.visible === false) {
          return null;
        }

        var menuitem = createMenuitem(item);
        var separator = index === props.model.length - 1 ? null : createSeparator();
        var key = item.label + '_' + index;
        return /*#__PURE__*/React.createElement(React.Fragment, {
          key: key
        }, menuitem, separator);
      });

      return _items;
    }

    return null;
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  var otherProps = ObjectUtils.findDiffKeys(props, BreadCrumb$1.defaultProps);
  var className = classNames('p-breadcrumb p-component', props.className);
  var home = createHome();
  var items = createMenuitems();
  var separator = createSeparator();
  return /*#__PURE__*/React.createElement("nav", _extends$E({
    id: props.id,
    ref: elementRef,
    className: className,
    style: props.style,
    "aria-label": "Breadcrumb"
  }, otherProps), /*#__PURE__*/React.createElement("ul", null, home, separator, items));
}));
BreadCrumb$1.displayName = 'BreadCrumb';
BreadCrumb$1.defaultProps = {
  __TYPE: 'BreadCrumb',
  id: null,
  model: null,
  home: null,
  style: null,
  className: null
};

var getPartsOfTime = function getPartsOfTime() {
  var currentMonth = new Date().getMonth();
  var currentDay = new Date().getDate();
  var currentYear = new Date().getFullYear();
  return {
    month: currentMonth,
    day: currentDay,
    year: currentYear
  };
};

function _arrayWithHoles$s(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$s(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$x(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$x(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$x(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$x(o, minLen);
}

function _nonIterableRest$s() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$s(arr, i) {
  return _arrayWithHoles$s(arr) || _iterableToArrayLimit$s(arr, i) || _unsupportedIterableToArray$x(arr, i) || _nonIterableRest$s();
}

var filterOptions = function filterOptions(options, paramsList) {
  if (!options) return null;
  var entries = Object.entries(options).filter(function (_ref) {
    var _ref2 = _slicedToArray$s(_ref, 1),
        key = _ref2[0];

    return paramsList.includes(key);
  });
  return Object.fromEntries(entries);
};

var POSSIBLE_PARAMS$1 = ["id", "disabled", "className", "style", "position", "at", "event", "showEvent", "hideEvent", "autoZIndex", "baseZIndex", "showDelay", "hideDelay", "autoHide", "showOnDisabled", "onShow", "onHide"];
var filterTooltipOptions = function filterTooltipOptions(options) {
  return filterOptions(options, POSSIBLE_PARAMS$1);
};

var POSSIBLE_PARAMS = ["label", "url", "command", "disabled", "style", "className"];
var BreadCrumb = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _home$disabled;

  var id = _ref.id,
      model = _ref.model,
      home = _ref.home,
      style = _ref.style,
      className = _ref.className;
  var breadCrumbModel = model.map(function (options) {
    return filterOptions(options, POSSIBLE_PARAMS);
  });
  var breadCrumbHome = {
    icon: home.icon || "pi pi-home",
    url: home.url,
    command: home.command,
    disabled: (_home$disabled = home.disabled) !== null && _home$disabled !== void 0 ? _home$disabled : false,
    style: home.style,
    className: home.className
  };
  return /*#__PURE__*/React__default.createElement(BreadCrumb$1, {
    ref: ref,
    id: id,
    model: breadCrumbModel,
    home: breadCrumbHome,
    style: style,
    className: className
  });
});

function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var Ripple = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function () {
  var inkRef = React.useRef(null);
  var targetRef = React.useRef(null);

  var getTarget = function getTarget() {
    return inkRef.current && inkRef.current.parentElement;
  };

  var bindEvents = function bindEvents() {
    if (targetRef.current) {
      targetRef.current.addEventListener('mousedown', onMouseDown);
    }
  };

  var unbindEvents = function unbindEvents() {
    if (targetRef.current) {
      targetRef.current.removeEventListener('mousedown', onMouseDown);
    }
  };

  var onMouseDown = function onMouseDown(event) {
    if (!inkRef.current || getComputedStyle(inkRef.current, null).display === 'none') {
      return;
    }

    DomHandler.removeClass(inkRef.current, 'p-ink-active');

    if (!DomHandler.getHeight(inkRef.current) && !DomHandler.getWidth(inkRef.current)) {
      var d = Math.max(DomHandler.getOuterWidth(targetRef.current), DomHandler.getOuterHeight(targetRef.current));
      inkRef.current.style.height = d + 'px';
      inkRef.current.style.width = d + 'px';
    }

    var offset = DomHandler.getOffset(targetRef.current);
    var x = event.pageX - offset.left + document.body.scrollTop - DomHandler.getWidth(inkRef.current) / 2;
    var y = event.pageY - offset.top + document.body.scrollLeft - DomHandler.getHeight(inkRef.current) / 2;
    inkRef.current.style.top = y + 'px';
    inkRef.current.style.left = x + 'px';
    DomHandler.addClass(inkRef.current, 'p-ink-active');
  };

  var onAnimationEnd = function onAnimationEnd(event) {
    DomHandler.removeClass(event.currentTarget, 'p-ink-active');
  };

  useMountEffect(function () {
    if (inkRef.current) {
      targetRef.current = getTarget();
      bindEvents();
    }
  });
  useUpdateEffect(function () {
    if (inkRef.current && !targetRef.current) {
      targetRef.current = getTarget();
      bindEvents();
    }
  });
  useUnmountEffect(function () {
    if (inkRef.current) {
      targetRef.current = null;
      unbindEvents();
    }
  });
  return PrimeReact$1.ripple ? /*#__PURE__*/React.createElement("span", {
    role: "presentation",
    ref: inkRef,
    className: "p-ink",
    onAnimationEnd: onAnimationEnd
  }) : null;
}));
Ripple.displayName = 'Ripple';
Ripple.defaultProps = {
  __TYPE: 'Ripple'
};

function _extends$D() {
  _extends$D = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$D.apply(this, arguments);
}

function _defineProperty$g(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _arrayLikeToArray$w(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$f(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$w(arr);
}

function _iterableToArray$f(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$w(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$w(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$w(o, minLen);
}

function _nonIterableSpread$f() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$f(arr) {
  return _arrayWithoutHoles$f(arr) || _iterableToArray$f(arr) || _unsupportedIterableToArray$w(arr) || _nonIterableSpread$f();
}

function _arrayWithHoles$r(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$r(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$r() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$r(arr, i) {
  return _arrayWithHoles$r(arr) || _iterableToArrayLimit$r(arr, i) || _unsupportedIterableToArray$w(arr, i) || _nonIterableRest$r();
}

var Tooltip$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$r(_React$useState, 2),
      visibleState = _React$useState2[0],
      setVisibleState = _React$useState2[1];

  var _React$useState3 = React.useState(props.position),
      _React$useState4 = _slicedToArray$r(_React$useState3, 2),
      positionState = _React$useState4[0],
      setPositionState = _React$useState4[1];

  var _React$useState5 = React.useState(''),
      _React$useState6 = _slicedToArray$r(_React$useState5, 2),
      classNameState = _React$useState6[0],
      setClassNameState = _React$useState6[1];

  var elementRef = React.useRef(null);
  var textRef = React.useRef(null);
  var currentTargetRef = React.useRef(null);
  var containerSize = React.useRef(null);
  var allowHide = React.useRef(true);
  var timeouts = React.useRef({});
  var currentMouseEvent = React.useRef(null);

  var _useResizeListener = useResizeListener({
    listener: function listener(event) {
      !DomHandler.isTouchDevice() && hide(event);
    }
  }),
      _useResizeListener2 = _slicedToArray$r(_useResizeListener, 2),
      bindWindowResizeListener = _useResizeListener2[0],
      unbindWindowResizeListener = _useResizeListener2[1];

  var _useOverlayScrollList = useOverlayScrollListener({
    target: currentTargetRef.current,
    listener: function listener(event) {
      hide(event);
    },
    when: visibleState
  }),
      _useOverlayScrollList2 = _slicedToArray$r(_useOverlayScrollList, 2),
      bindOverlayScrollListener = _useOverlayScrollList2[0],
      unbindOverlayScrollListener = _useOverlayScrollList2[1];

  var isTargetContentEmpty = function isTargetContentEmpty(target) {
    return !(props.content || getTargetOption(target, 'tooltip'));
  };

  var isContentEmpty = function isContentEmpty(target) {
    return !(props.content || getTargetOption(target, 'tooltip') || props.children);
  };

  var isMouseTrack = function isMouseTrack(target) {
    return getTargetOption(target, 'mousetrack') || props.mouseTrack;
  };

  var isDisabled = function isDisabled(target) {
    return getTargetOption(target, 'disabled') === 'true' || hasTargetOption(target, 'disabled') || props.disabled;
  };

  var isShowOnDisabled = function isShowOnDisabled(target) {
    return getTargetOption(target, 'showondisabled') || props.showOnDisabled;
  };

  var isAutoHide = function isAutoHide() {
    return getTargetOption(currentTargetRef.current, 'autohide') || props.autoHide;
  };

  var getTargetOption = function getTargetOption(target, option) {
    return hasTargetOption(target, "data-pr-".concat(option)) ? target.getAttribute("data-pr-".concat(option)) : null;
  };

  var hasTargetOption = function hasTargetOption(target, option) {
    return target && target.hasAttribute(option);
  };

  var getEvents = function getEvents(target) {
    var showEvents = [getTargetOption(target, 'showevent') || props.showEvent];
    var hideEvents = [getTargetOption(target, 'hideevent') || props.hideEvent];

    if (isMouseTrack(target)) {
      showEvents = ['mousemove'];
      hideEvents = ['mouseleave'];
    } else {
      var event = getTargetOption(target, 'event') || props.event;

      if (event === 'focus') {
        showEvents = ['focus'];
        hideEvents = ['blur'];
      }

      if (event === 'both') {
        showEvents = ['focus', 'mouseenter'];
        hideEvents = ['blur', 'mouseleave'];
      }
    }

    return {
      showEvents: showEvents,
      hideEvents: hideEvents
    };
  };

  var getPosition = function getPosition(target) {
    return getTargetOption(target, 'position') || positionState;
  };

  var getMouseTrackPosition = function getMouseTrackPosition(target) {
    var top = getTargetOption(target, 'mousetracktop') || props.mouseTrackTop;
    var left = getTargetOption(target, 'mousetrackleft') || props.mouseTrackLeft;
    return {
      top: top,
      left: left
    };
  };

  var updateText = function updateText(target, callback) {
    if (textRef.current) {
      var content = getTargetOption(target, 'tooltip') || props.content;

      if (content) {
        textRef.current.innerHTML = ''; // remove children

        textRef.current.appendChild(document.createTextNode(content));
        callback();
      } else if (props.children) {
        callback();
      }
    }
  };

  var updateTooltipState = function updateTooltipState(position) {
    updateText(currentTargetRef.current, function () {
      var _currentMouseEvent$cu = currentMouseEvent.current,
          x = _currentMouseEvent$cu.pageX,
          y = _currentMouseEvent$cu.pageY;

      if (props.autoZIndex && !ZIndexUtils.get(elementRef.current)) {
        ZIndexUtils.set('tooltip', elementRef.current, PrimeReact$1.autoZIndex, props.baseZIndex || PrimeReact$1.zIndex['tooltip']);
      }

      elementRef.current.style.left = '';
      elementRef.current.style.top = ''; // GitHub #2695 disable pointer events when autohiding

      if (isAutoHide()) {
        elementRef.current.style.pointerEvents = 'none';
      }

      if (isMouseTrack(currentTargetRef.current) && !containerSize.current) {
        containerSize.current = {
          width: DomHandler.getOuterWidth(elementRef.current),
          height: DomHandler.getOuterHeight(elementRef.current)
        };
      }

      align(currentTargetRef.current, {
        x: x,
        y: y
      }, position);
    });
  };

  var show = function show(e) {
    currentTargetRef.current = e.currentTarget;
    var disabled = isDisabled(currentTargetRef.current);
    var empty = isContentEmpty(isShowOnDisabled(currentTargetRef.current) && disabled ? currentTargetRef.current.firstChild : currentTargetRef.current);

    if (empty || disabled) {
      return;
    }

    currentMouseEvent.current = e;

    if (visibleState) {
      applyDelay('updateDelay', updateTooltipState);
    } else {
      // #2653 give the callback a chance to return false and not continue with display
      var success = sendCallback(props.onBeforeShow, {
        originalEvent: e,
        target: currentTargetRef.current
      });

      if (success) {
        applyDelay('showDelay', function () {
          setVisibleState(true);
          sendCallback(props.onShow, {
            originalEvent: e,
            target: currentTargetRef.current
          });
        });
      }
    }
  };

  var hide = function hide(e) {
    clearTimeouts();

    if (visibleState) {
      var success = sendCallback(props.onBeforeHide, {
        originalEvent: e,
        target: currentTargetRef.current
      });

      if (success) {
        applyDelay('hideDelay', function () {
          if (!isAutoHide() && allowHide.current === false) {
            return;
          }

          ZIndexUtils.clear(elementRef.current);
          DomHandler.removeClass(elementRef.current, 'p-tooltip-active');
          setVisibleState(false);
          sendCallback(props.onHide, {
            originalEvent: e,
            target: currentTargetRef.current
          });
        });
      }
    }
  };

  var align = function align(target, coordinate, position) {
    var left = 0,
        top = 0,
        currentPosition = position || positionState;

    if (isMouseTrack(target) && coordinate) {
      var _containerSize = {
        width: DomHandler.getOuterWidth(elementRef.current),
        height: DomHandler.getOuterHeight(elementRef.current)
      };
      left = coordinate.x;
      top = coordinate.y;

      var _getMouseTrackPositio = getMouseTrackPosition(target),
          mouseTrackTop = _getMouseTrackPositio.top,
          mouseTrackLeft = _getMouseTrackPositio.left;

      switch (currentPosition) {
        case 'left':
          left -= _containerSize.width + mouseTrackLeft;
          top -= _containerSize.height / 2 - mouseTrackTop;
          break;

        case 'right':
          left += mouseTrackLeft;
          top -= _containerSize.height / 2 - mouseTrackTop;
          break;

        case 'top':
          left -= _containerSize.width / 2 - mouseTrackLeft;
          top -= _containerSize.height + mouseTrackTop;
          break;

        case 'bottom':
          left -= _containerSize.width / 2 - mouseTrackLeft;
          top += mouseTrackTop;
          break;
      }

      if (left <= 0 || containerSize.current.width > _containerSize.width) {
        elementRef.current.style.left = '0px';
        elementRef.current.style.right = window.innerWidth - _containerSize.width - left + 'px';
      } else {
        elementRef.current.style.right = '';
        elementRef.current.style.left = left + 'px';
      }

      elementRef.current.style.top = top + 'px';
      DomHandler.addClass(elementRef.current, 'p-tooltip-active');
    } else {
      var pos = DomHandler.findCollisionPosition(currentPosition);
      var my = getTargetOption(target, 'my') || props.my || pos.my;
      var at = getTargetOption(target, 'at') || props.at || pos.at;
      elementRef.current.style.padding = '0px';
      DomHandler.flipfitCollision(elementRef.current, target, my, at, function (calculatedPosition) {
        var _calculatedPosition$a = calculatedPosition.at,
            atX = _calculatedPosition$a.x,
            atY = _calculatedPosition$a.y;
        var myX = calculatedPosition.my.x;
        var newPosition = props.at ? atX !== 'center' && atX !== myX ? atX : atY : calculatedPosition.at["".concat(pos.axis)];
        elementRef.current.style.padding = '';
        setPositionState(newPosition);
        updateContainerPosition(newPosition);
        DomHandler.addClass(elementRef.current, 'p-tooltip-active');
      });
    }
  };

  var updateContainerPosition = function updateContainerPosition(position) {
    if (elementRef.current) {
      var style = getComputedStyle(elementRef.current);
      if (position === 'left') elementRef.current.style.left = parseFloat(style.left) - parseFloat(style.paddingLeft) * 2 + 'px';else if (position === 'top') elementRef.current.style.top = parseFloat(style.top) - parseFloat(style.paddingTop) * 2 + 'px';
    }
  };

  var onMouseEnter = function onMouseEnter() {
    if (!isAutoHide()) {
      allowHide.current = false;
    }
  };

  var onMouseLeave = function onMouseLeave(e) {
    if (!isAutoHide()) {
      allowHide.current = true;
      hide(e);
    }
  };

  var bindTargetEvent = function bindTargetEvent(target) {
    if (target) {
      var _getEvents = getEvents(target),
          showEvents = _getEvents.showEvents,
          hideEvents = _getEvents.hideEvents;

      var currentTarget = getTarget(target);
      showEvents.forEach(function (event) {
        return currentTarget.addEventListener(event, show);
      });
      hideEvents.forEach(function (event) {
        return currentTarget.addEventListener(event, hide);
      });
    }
  };

  var unbindTargetEvent = function unbindTargetEvent(target) {
    if (target) {
      var _getEvents2 = getEvents(target),
          showEvents = _getEvents2.showEvents,
          hideEvents = _getEvents2.hideEvents;

      var currentTarget = getTarget(target);
      showEvents.forEach(function (event) {
        return currentTarget.removeEventListener(event, show);
      });
      hideEvents.forEach(function (event) {
        return currentTarget.removeEventListener(event, hide);
      });
    }
  };

  var applyDelay = function applyDelay(delayProp, callback) {
    clearTimeouts();
    var delay = getTargetOption(currentTargetRef.current, delayProp.toLowerCase()) || props[delayProp];
    !!delay ? timeouts.current["".concat(delayProp)] = setTimeout(function () {
      return callback();
    }, delay) : callback();
  };

  var sendCallback = function sendCallback(callback) {
    if (callback) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }

      var result = callback.apply(void 0, params);

      if (result === undefined) {
        result = true;
      }

      return result;
    }

    return true;
  };

  var clearTimeouts = function clearTimeouts() {
    Object.values(timeouts.current).forEach(function (t) {
      return clearTimeout(t);
    });
  };

  var getTarget = function getTarget(target) {
    if (target) {
      if (isShowOnDisabled(target)) {
        if (!target.hasWrapper) {
          var wrapper = document.createElement('span');
          target.parentNode.insertBefore(wrapper, target);
          wrapper.appendChild(target);
          target.hasWrapper = true;
          return wrapper;
        } else {
          return target.parentElement;
        }
      } else if (target.hasWrapper) {
        var _target$parentElement;

        (_target$parentElement = target.parentElement).replaceWith.apply(_target$parentElement, _toConsumableArray$f(target.parentElement.childNodes));

        delete target.hasWrapper;
      }

      return target;
    }

    return null;
  };

  var updateTargetEvents = function updateTargetEvents(target) {
    unloadTargetEvents(target);
    loadTargetEvents(target);
  };

  var loadTargetEvents = function loadTargetEvents(target) {
    setTargetEventOperations(target || props.target, bindTargetEvent);
  };

  var unloadTargetEvents = function unloadTargetEvents(target) {
    setTargetEventOperations(target || props.target, unbindTargetEvent);
  };

  var setTargetEventOperations = function setTargetEventOperations(target, operation) {
    target = ObjectUtils.getRefElement(target);

    if (target) {
      if (DomHandler.isElement(target)) {
        operation(target);
      } else {
        var setEvent = function setEvent(target) {
          var element = DomHandler.find(document, target);
          element.forEach(function (el) {
            operation(el);
          });
        };

        if (target instanceof Array) {
          target.forEach(function (t) {
            setEvent(t);
          });
        } else {
          setEvent(target);
        }
      }
    }
  };

  React.useEffect(function () {
    if (visibleState && currentTargetRef.current && isDisabled(currentTargetRef.current)) {
      hide();
    }
  });
  useMountEffect(function () {
    loadTargetEvents();
  });
  useUpdateEffect(function () {
    loadTargetEvents();
    return function () {
      unloadTargetEvents();
    };
  }, [show, hide, props.target]);
  useUpdateEffect(function () {
    if (visibleState) {
      var position = getPosition(currentTargetRef.current);
      var classname = getTargetOption(currentTargetRef.current, 'classname');
      setPositionState(position);
      setClassNameState(classname);
      updateTooltipState(position);
      bindWindowResizeListener();
      bindOverlayScrollListener();
    } else {
      setPositionState(props.position);
      setClassNameState('');
      currentTargetRef.current = null;
      containerSize.current = null;
      allowHide.current = true;
    }

    return function () {
      unbindWindowResizeListener();
      unbindOverlayScrollListener();
    };
  }, [visibleState]);
  useUpdateEffect(function () {
    if (visibleState) {
      applyDelay('updateDelay', function () {
        updateText(currentTargetRef.current, function () {
          align(currentTargetRef.current);
        });
      });
    }
  }, [props.content]);
  useUnmountEffect(function () {
    clearTimeouts();
    unloadTargetEvents();
    ZIndexUtils.clear(elementRef.current);
  });
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      updateTargetEvents: updateTargetEvents,
      loadTargetEvents: loadTargetEvents,
      unloadTargetEvents: unloadTargetEvents,
      getElement: function getElement() {
        return elementRef.current;
      },
      getTarget: function getTarget() {
        return currentTargetRef.current;
      }
    };
  });

  var createElement = function createElement() {
    var otherProps = ObjectUtils.findDiffKeys(props, Tooltip$1.defaultProps);
    var tooltipClassName = classNames('p-tooltip p-component', _defineProperty$g({}, "p-tooltip-".concat(positionState), true), props.className, classNameState);
    var empty = isTargetContentEmpty(currentTargetRef.current);
    return /*#__PURE__*/React.createElement("div", _extends$D({
      id: props.id,
      ref: elementRef,
      className: tooltipClassName,
      style: props.style,
      role: "tooltip",
      "aria-hidden": visibleState
    }, otherProps, {
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave
    }), /*#__PURE__*/React.createElement("div", {
      className: "p-tooltip-arrow"
    }), /*#__PURE__*/React.createElement("div", {
      ref: textRef,
      className: "p-tooltip-text"
    }, empty && props.children));
  };

  if (visibleState) {
    var element = createElement();
    return /*#__PURE__*/React.createElement(Portal, {
      element: element,
      appendTo: props.appendTo,
      visible: true
    });
  }

  return null;
}));
Tooltip$1.displayName = 'Tooltip';
Tooltip$1.defaultProps = {
  __TYPE: 'Tooltip',
  id: null,
  target: null,
  content: null,
  disabled: false,
  className: null,
  style: null,
  appendTo: null,
  position: 'right',
  my: null,
  at: null,
  event: null,
  showEvent: 'mouseenter',
  hideEvent: 'mouseleave',
  autoZIndex: true,
  baseZIndex: 0,
  mouseTrack: false,
  mouseTrackTop: 5,
  mouseTrackLeft: 5,
  showDelay: 0,
  updateDelay: 0,
  hideDelay: 0,
  autoHide: true,
  showOnDisabled: false,
  onBeforeShow: null,
  onBeforeHide: null,
  onShow: null,
  onHide: null
};

function _extends$C() {
  _extends$C = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$C.apply(this, arguments);
}

function _defineProperty$f(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var Button$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(ref);
  React.useEffect(function () {
    ObjectUtils.combinedRefs(elementRef, ref);
  }, [elementRef, ref]);

  if (props.visible === false) {
    return null;
  }

  var createIcon = function createIcon() {
    var icon = props.loading ? props.loadingIcon : props.icon;
    var className = classNames('p-button-icon p-c', _defineProperty$f({
      'p-button-loading-icon': props.loading
    }, "p-button-icon-".concat(props.iconPos), props.label));
    return IconUtils.getJSXIcon(icon, {
      className: className
    }, {
      props: props
    });
  };

  var createLabel = function createLabel() {
    if (props.label) {
      return /*#__PURE__*/React.createElement("span", {
        className: "p-button-label p-c"
      }, props.label);
    }

    return !props.children && !props.label && /*#__PURE__*/React.createElement("span", {
      className: "p-button-label p-c",
      dangerouslySetInnerHTML: {
        __html: '&nbsp;'
      }
    });
  };

  var createBadge = function createBadge() {
    if (props.badge) {
      var badgeClassName = classNames('p-badge', props.badgeClassName);
      return /*#__PURE__*/React.createElement("span", {
        className: badgeClassName
      }, props.badge);
    }

    return null;
  };

  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var disabled = props.disabled || props.loading;
  var otherProps = ObjectUtils.findDiffKeys(props, Button$1.defaultProps);
  var className = classNames('p-button p-component', props.className, _defineProperty$f({
    'p-button-icon-only': (props.icon || props.loading && props.loadingIcon) && !props.label,
    'p-button-vertical': (props.iconPos === 'top' || props.iconPos === 'bottom') && props.label,
    'p-disabled': disabled,
    'p-button-loading': props.loading,
    'p-button-loading-label-only': props.loading && !props.icon && props.label
  }, "p-button-loading-".concat(props.iconPos), props.loading && props.loadingIcon && props.label));
  var icon = createIcon();
  var label = createLabel();
  var badge = createBadge();
  var defaultAriaLabel = props.label ? props.label + (props.badge ? ' ' + props.badge : '') : props['aria-label'];
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("button", _extends$C({
    ref: elementRef,
    "aria-label": defaultAriaLabel
  }, otherProps, {
    className: className,
    disabled: disabled
  }), icon, label, props.children, badge, /*#__PURE__*/React.createElement(Ripple, null)), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$C({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
Button$1.displayName = 'Button';
Button$1.defaultProps = {
  __TYPE: 'Button',
  label: null,
  icon: null,
  iconPos: 'left',
  badge: null,
  badgeClassName: null,
  tooltip: null,
  tooltipOptions: null,
  disabled: false,
  loading: false,
  loadingIcon: 'pi pi-spinner pi-spin',
  visible: true
};

var _excluded$5 = ["badge", "badgeClassName", "tooltipOptions"];
var Button = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  _ref.badge;
      _ref.badgeClassName;
      var tooltipOptions = _ref.tooltipOptions,
      props = _objectWithoutProperties$1(_ref, _excluded$5);

  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(Button$1, _extends$J({}, props, {
    tooltipOptions: filteredTooltipOptions,
    ref: ref
  }));
});

function _extends$B() {
  _extends$B = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$B.apply(this, arguments);
}

var Card$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(ref);

  var createHeader = function createHeader() {
    if (props.header) {
      return /*#__PURE__*/React.createElement("div", {
        className: "p-card-header"
      }, ObjectUtils.getJSXElement(props.header, props));
    }

    return null;
  };

  var createBody = function createBody() {
    var title = props.title && /*#__PURE__*/React.createElement("div", {
      className: "p-card-title"
    }, ObjectUtils.getJSXElement(props.title, props));
    var subTitle = props.subTitle && /*#__PURE__*/React.createElement("div", {
      className: "p-card-subtitle"
    }, ObjectUtils.getJSXElement(props.subTitle, props));
    var children = props.children && /*#__PURE__*/React.createElement("div", {
      className: "p-card-content"
    }, props.children);
    var footer = props.footer && /*#__PURE__*/React.createElement("div", {
      className: "p-card-footer"
    }, ObjectUtils.getJSXElement(props.footer, props));
    return /*#__PURE__*/React.createElement("div", {
      className: "p-card-body"
    }, title, subTitle, children, footer);
  };

  React.useEffect(function () {
    ObjectUtils.combinedRefs(elementRef, ref);
  }, [elementRef, ref]);
  var otherProps = ObjectUtils.findDiffKeys(props, Card$1.defaultProps);
  var className = classNames('p-card p-component', props.className);
  var header = createHeader();
  var body = createBody();
  return /*#__PURE__*/React.createElement("div", _extends$B({
    id: props.id,
    ref: elementRef,
    className: className,
    style: props.style
  }, otherProps), header, body);
});
Card$1.displayName = 'Card';
Card$1.defaultProps = {
  __TYPE: 'Card',
  id: null,
  header: null,
  footer: null,
  title: null,
  subTitle: null,
  style: null,
  className: null
};

var Card = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      header = _ref.header,
      footer = _ref.footer,
      title = _ref.title,
      subTitle = _ref.subTitle,
      style = _ref.style,
      className = _ref.className,
      children = _ref.children;
  return /*#__PURE__*/React__default.createElement(Card$1, {
    ref: ref,
    id: id,
    header: header,
    footer: footer,
    title: title,
    subTitle: subTitle,
    style: style,
    className: className
  }, children);
});

function _extends$A() {
  _extends$A = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$A.apply(this, arguments);
}

function _arrayWithHoles$q(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$q(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$v(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$v(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$v(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$v(o, minLen);
}

function _nonIterableRest$q() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$q(arr, i) {
  return _arrayWithHoles$q(arr) || _iterableToArrayLimit$q(arr, i) || _unsupportedIterableToArray$v(arr, i) || _nonIterableRest$q();
}

var Checkbox$2 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$q(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var elementRef = React.useRef(null);
  var inputRef = React.useRef(props.inputRef);

  var onClick = function onClick(event) {
    if (!props.disabled && !props.readOnly && props.onChange) {
      var _checked = isChecked();

      var checkboxClicked = event.target instanceof HTMLDivElement || event.target instanceof HTMLSpanElement;
      var isInputToggled = event.target === inputRef.current;
      var isCheckboxToggled = checkboxClicked && event.target.checked !== _checked;

      if (isInputToggled || isCheckboxToggled) {
        var value = _checked ? props.falseValue : props.trueValue;
        props.onChange({
          originalEvent: event,
          value: props.value,
          checked: value,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            type: 'checkbox',
            name: props.name,
            id: props.id,
            value: props.value,
            checked: value
          }
        });
      }

      DomHandler.focus(inputRef.current);
      event.preventDefault();
    }
  };

  var onFocus = function onFocus() {
    setFocusedState(true);
  };

  var onBlur = function onBlur() {
    setFocusedState(false);
  };

  var onKeyDown = function onKeyDown(event) {
    if (event.code === 'Space') {
      onClick(event);
    }
  };

  var isChecked = function isChecked() {
    return props.checked === props.trueValue;
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      },
      getInput: function getInput() {
        return inputRef.current;
      }
    };
  });
  React.useEffect(function () {
    ObjectUtils.combinedRefs(inputRef, props.inputRef);
  }, [inputRef, props.inputRef]);
  useUpdateEffect(function () {
    inputRef.current.checked = isChecked();
  }, [props.checked, props.trueValue]);
  var checked = isChecked();
  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, Checkbox$2.defaultProps);
  var dataProps = ObjectUtils.reduceKeys(otherProps, DomHandler.DATA_PROPS);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var className = classNames('p-checkbox p-component', {
    'p-checkbox-checked': checked,
    'p-checkbox-disabled': props.disabled,
    'p-checkbox-focused': focusedState
  }, props.className);
  var boxClass = classNames('p-checkbox-box', {
    'p-highlight': checked,
    'p-disabled': props.disabled,
    'p-focus': focusedState
  });
  var icon = IconUtils.getJSXIcon(checked ? props.icon : '', {
    className: 'p-checkbox-icon p-c'
  }, {
    props: props,
    checked: checked
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends$A({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style
  }, otherProps, {
    onClick: onClick,
    onContextMenu: props.onContextMenu,
    onMouseDown: props.onMouseDown
  }), /*#__PURE__*/React.createElement("div", {
    className: "p-hidden-accessible"
  }, /*#__PURE__*/React.createElement("input", _extends$A({
    ref: inputRef,
    type: "checkbox",
    id: props.inputId,
    name: props.name,
    tabIndex: props.tabIndex,
    defaultChecked: checked,
    onFocus: onFocus,
    onBlur: onBlur,
    onKeyDown: onKeyDown,
    disabled: props.disabled,
    readOnly: props.readOnly,
    required: props.required
  }, ariaProps, dataProps))), /*#__PURE__*/React.createElement("div", {
    className: boxClass
  }, icon)), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$A({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
Checkbox$2.displayName = 'Checkbox';
Checkbox$2.defaultProps = {
  __TYPE: 'Checkbox',
  id: null,
  inputRef: null,
  inputId: null,
  value: null,
  name: null,
  checked: false,
  trueValue: true,
  falseValue: false,
  style: null,
  className: null,
  disabled: false,
  required: false,
  readOnly: false,
  tabIndex: null,
  icon: 'pi pi-check',
  tooltip: null,
  tooltipOptions: null,
  onChange: null,
  onMouseDown: null,
  onContextMenu: null
};

var Checkbox$1 = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      inputRef = _ref.inputRef,
      inputId = _ref.inputId,
      value = _ref.value,
      name = _ref.name,
      checked = _ref.checked,
      style = _ref.style,
      className = _ref.className,
      disabled = _ref.disabled,
      required = _ref.required,
      readOnly = _ref.readOnly,
      tabIndex = _ref.tabIndex,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onChange = _ref.onChange;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(Checkbox$2, {
    ref: ref,
    id: id,
    inputRef: inputRef,
    inputId: inputId,
    value: value,
    name: name,
    checked: checked,
    style: style,
    className: className,
    disabled: disabled,
    required: required,
    readOnly: readOnly,
    tabIndex: tabIndex,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onChange: onChange
  });
});

function _extends$z() {
  _extends$z = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$z.apply(this, arguments);
}

function _arrayWithHoles$p(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$p(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$u(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$u(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$u(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$u(o, minLen);
}

function _nonIterableRest$p() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$p(arr, i) {
  return _arrayWithHoles$p(arr) || _iterableToArrayLimit$p(arr, i) || _unsupportedIterableToArray$u(arr, i) || _nonIterableRest$p();
}

var Chip$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(null);

  var _React$useState = React.useState(true),
      _React$useState2 = _slicedToArray$p(_React$useState, 2),
      visibleState = _React$useState2[0],
      setVisibleState = _React$useState2[1];

  var onKeyDown = function onKeyDown(event) {
    if (event.keyCode === 13) {
      // enter
      close(event);
    }
  };

  var close = function close(event) {
    setVisibleState(false);

    if (props.onRemove) {
      props.onRemove(event);
    }
  };

  var createContent = function createContent() {
    var content = [];

    if (props.image) {
      content.push( /*#__PURE__*/React.createElement("img", {
        key: "image",
        src: props.image,
        alt: props.imageAlt,
        onError: props.onImageError
      }));
    } else if (props.icon) {
      content.push(IconUtils.getJSXIcon(props.icon, {
        key: 'icon',
        className: 'p-chip-icon'
      }, {
        props: props
      }));
    }

    if (props.label) {
      content.push( /*#__PURE__*/React.createElement("span", {
        key: "label",
        className: "p-chip-text"
      }, props.label));
    }

    if (props.removable) {
      content.push(IconUtils.getJSXIcon(props.removeIcon, {
        key: 'removeIcon',
        tabIndex: 0,
        className: 'p-chip-remove-icon',
        onClick: close,
        onKeyDown: onKeyDown
      }, {
        props: props
      }));
    }

    return content;
  };

  var createElement = function createElement() {
    var otherProps = ObjectUtils.findDiffKeys(props, Chip$1.defaultProps);
    var className = classNames('p-chip p-component', {
      'p-chip-image': props.image != null
    }, props.className);
    var content = props.template ? ObjectUtils.getJSXElement(props.template, props) : createContent();
    return /*#__PURE__*/React.createElement("div", _extends$z({
      ref: elementRef,
      className: className,
      style: props.style
    }, otherProps), content);
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  return visibleState && createElement();
}));
Chip$1.displayName = 'Chip';
Chip$1.defaultProps = {
  __TYPE: 'Chip',
  label: null,
  icon: null,
  image: null,
  removable: false,
  removeIcon: 'pi pi-times-circle',
  className: null,
  style: null,
  template: null,
  imageAlt: 'chip',
  onImageError: null,
  onRemove: null
};

var Chip = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var label = _ref.label,
      icon = _ref.icon,
      removable = _ref.removable,
      style = _ref.style,
      className = _ref.className,
      onRemove = _ref.onRemove;
  return /*#__PURE__*/React__default.createElement(Chip$1, {
    ref: ref,
    label: label,
    icon: icon,
    removable: removable,
    style: style,
    className: className,
    onRemove: onRemove
  });
});

function _arrayLikeToArray$t(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$e(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$t(arr);
}

function _iterableToArray$e(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$t(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$t(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$t(o, minLen);
}

function _nonIterableSpread$e() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$e(arr) {
  return _arrayWithoutHoles$e(arr) || _iterableToArray$e(arr) || _unsupportedIterableToArray$t(arr) || _nonIterableSpread$e();
}

var KeyFilter = {
  /* eslint-disable */
  DEFAULT_MASKS: {
    pint: /[\d]/,
    "int": /[\d\-]/,
    pnum: /[\d\.]/,
    money: /[\d\.\s,]/,
    num: /[\d\-\.]/,
    hex: /[0-9a-f]/i,
    email: /[a-z0-9_\.\-@]/i,
    alpha: /[a-z_]/i,
    alphanum: /[a-z0-9_]/i
  },

  /* eslint-enable */
  getRegex: function getRegex(keyfilter) {
    return KeyFilter.DEFAULT_MASKS[keyfilter] ? KeyFilter.DEFAULT_MASKS[keyfilter] : keyfilter;
  },
  onKeyPress: function onKeyPress(e, keyfilter, validateOnly) {
    if (validateOnly) {
      return;
    }

    if (e.ctrlKey || e.altKey) {
      return;
    }

    var isPrintableKey = e.key.length === 1;

    if (!isPrintableKey) {
      return;
    }

    var regex = this.getRegex(keyfilter);

    if (!regex.test(e.key)) {
      e.preventDefault();
    }
  },
  onPaste: function onPaste(e, keyfilter, validateOnly) {
    if (validateOnly) {
      return;
    }

    var regex = this.getRegex(keyfilter);
    var clipboard = e.clipboardData.getData('text'); // loop over each letter pasted and if any fail prevent the paste

    _toConsumableArray$e(clipboard).forEach(function (c) {
      if (!regex.test(c)) {
        e.preventDefault();
        return false;
      }
    });
  },
  validate: function validate(e, keyfilter) {
    var value = e.target.value,
        validatePattern = true;

    if (value && !keyfilter.test(value)) {
      validatePattern = false;
    }

    return validatePattern;
  }
};

function _extends$y() {
  _extends$y = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$y.apply(this, arguments);
}

function _arrayLikeToArray$s(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$d(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$s(arr);
}

function _iterableToArray$d(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$s(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$s(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$s(o, minLen);
}

function _nonIterableSpread$d() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$d(arr) {
  return _arrayWithoutHoles$d(arr) || _iterableToArray$d(arr) || _unsupportedIterableToArray$s(arr) || _nonIterableSpread$d();
}

function _arrayWithHoles$o(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$o(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$o() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$o(arr, i) {
  return _arrayWithHoles$o(arr) || _iterableToArrayLimit$o(arr, i) || _unsupportedIterableToArray$s(arr, i) || _nonIterableRest$o();
}

var Chips$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$o(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var elementRef = React.useRef(null);
  var listRef = React.useRef(null);
  var inputRef = React.useRef(props.inputRef);

  var removeItem = function removeItem(event, index) {
    if (props.disabled && props.readOnly) {
      return;
    }

    var values = _toConsumableArray$d(props.value);

    var removedItem = values.splice(index, 1);

    if (!isRemovable(removedItem, index)) {
      return;
    }

    if (props.onRemove) {
      props.onRemove({
        originalEvent: event,
        value: removedItem
      });
    }

    if (props.onChange) {
      props.onChange({
        originalEvent: event,
        value: values,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        target: {
          name: props.name,
          id: props.id,
          value: values
        }
      });
    }
  };

  var addItem = function addItem(event, item, preventDefault) {
    if (item && item.trim().length) {
      var values = props.value ? _toConsumableArray$d(props.value) : [];

      if (props.allowDuplicate || values.indexOf(item) === -1) {
        var allowAddition = true;

        if (props.onAdd) {
          allowAddition = props.onAdd({
            originalEvent: event,
            value: item
          });
        }

        if (allowAddition !== false) {
          values.push(item);
        }
      }

      updateInput(event, values, preventDefault);
    }
  };

  var onWrapperClick = function onWrapperClick() {
    DomHandler.focus(inputRef.current);
  };

  var onKeyDown = function onKeyDown(event) {
    var inputValue = event.target.value;
    var values = props.value || [];
    props.onKeyDown && props.onKeyDown(event); // do not continue if the user defined keydown wants to prevent

    if (event.defaultPrevented) {
      return;
    }

    switch (event.which) {
      //backspace
      case 8:
        if (inputRef.current.value.length === 0 && values.length > 0) {
          removeItem(event, values.length - 1);
        }

        break;
      //enter

      case 13:
        if (inputValue && inputValue.trim().length && (!props.max || props.max > values.length)) {
          addItem(event, inputValue, true);
        }

        break;

      default:
        if (props.keyfilter) {
          KeyFilter.onKeyPress(event, props.keyfilter);
        }

        if (isMaxedOut()) {
          event.preventDefault();
        } else if (props.separator === ',' && event.which === 188) {
          addItem(event, inputValue, true);
        }

        break;
    }
  };

  var updateInput = function updateInput(event, items, preventDefault) {
    if (props.onChange) {
      props.onChange({
        originalEvent: event,
        value: items,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        target: {
          name: props.name,
          id: props.id,
          value: items
        }
      });
    }

    inputRef.current.value = '';
    preventDefault && event.preventDefault();
  };

  var onPaste = function onPaste(event) {
    if (props.separator) {
      var pastedData = (event.clipboardData || window['clipboardData']).getData('Text');

      if (props.keyfilter) {
        KeyFilter.onPaste(event, props.keyfilter);
      }

      if (pastedData) {
        var values = props.value || [];
        var pastedValues = pastedData.split(props.separator);
        pastedValues = pastedValues.filter(function (val) {
          return (props.allowDuplicate || values.indexOf(val) === -1) && val.trim().length;
        });
        values = [].concat(_toConsumableArray$d(values), _toConsumableArray$d(pastedValues));
        updateInput(event, values, true);
      }
    }
  };

  var onFocus = function onFocus(event) {
    setFocusedState(true);
    props.onFocus && props.onFocus(event);
  };

  var onBlur = function onBlur(event) {
    if (props.addOnBlur) {
      var inputValue = event.target.value;
      var values = props.value || [];

      if (inputValue && inputValue.trim().length && (!props.max || props.max > values.length)) {
        addItem(event, inputValue, true);
      }
    }

    setFocusedState(false);
    props.onBlur && props.onBlur(event);
  };

  var isMaxedOut = function isMaxedOut() {
    return props.max && props.value && props.max === props.value.length;
  };

  var currentValue = inputRef.current && inputRef.current.value;
  var isFilled = React.useMemo(function () {
    return ObjectUtils.isNotEmpty(props.value) || ObjectUtils.isNotEmpty(currentValue);
  }, [props.value, currentValue]);

  var isRemovable = function isRemovable(value, index) {
    return ObjectUtils.getPropValue(props.removable, {
      value: value,
      index: index,
      props: props
    });
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      },
      getInput: function getInput() {
        return inputRef.current;
      }
    };
  });
  React.useEffect(function () {
    ObjectUtils.combinedRefs(inputRef, props.inputRef);
  }, [inputRef, props.inputRef]);

  var createRemoveIcon = function createRemoveIcon(value, index) {
    if (!props.disabled && !props.readOnly && isRemovable(value, index)) {
      return /*#__PURE__*/React.createElement("span", {
        className: "p-chips-token-icon pi pi-times-circle",
        onClick: function onClick(event) {
          return removeItem(event, index);
        }
      });
    }

    return null;
  };

  var createItem = function createItem(value, index) {
    var content = props.itemTemplate ? props.itemTemplate(value) : value;
    var label = /*#__PURE__*/React.createElement("span", {
      className: "p-chips-token-label"
    }, content);
    var icon = createRemoveIcon(value, index);
    return /*#__PURE__*/React.createElement("li", {
      key: index,
      className: "p-chips-token p-highlight"
    }, label, icon);
  };

  var createInput = function createInput() {
    return /*#__PURE__*/React.createElement("li", {
      className: "p-chips-input-token"
    }, /*#__PURE__*/React.createElement("input", _extends$y({
      ref: inputRef,
      id: props.inputId,
      placeholder: props.placeholder,
      type: "text",
      name: props.name,
      disabled: props.disabled || isMaxedOut(),
      onKeyDown: onKeyDown,
      onPaste: onPaste,
      onFocus: onFocus,
      onBlur: onBlur,
      readOnly: props.readOnly
    }, ariaProps)));
  };

  var createItems = function createItems() {
    return props.value ? props.value.map(createItem) : null;
  };

  var createList = function createList() {
    var className = classNames('p-inputtext p-chips-multiple-container', {
      'p-disabled': props.disabled,
      'p-focus': focusedState
    });
    var items = createItems();
    var input = createInput();
    return /*#__PURE__*/React.createElement("ul", {
      ref: listRef,
      className: className,
      onClick: onWrapperClick
    }, items, input);
  };

  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, Chips$1.defaultProps);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var className = classNames('p-chips p-component p-inputwrapper', {
    'p-inputwrapper-filled': isFilled,
    'p-inputwrapper-focus': focusedState
  }, props.className);
  var list = createList();
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends$y({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style
  }, otherProps), list), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$y({
    target: inputRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
Chips$1.displayName = 'Chips';
Chips$1.defaultProps = {
  __TYPE: 'Chips',
  id: null,
  inputRef: null,
  inputId: null,
  name: null,
  placeholder: null,
  value: null,
  max: null,
  disabled: null,
  readOnly: false,
  removable: true,
  style: null,
  className: null,
  tooltip: null,
  tooltipOptions: null,
  ariaLabelledBy: null,
  separator: null,
  allowDuplicate: true,
  itemTemplate: null,
  keyfilter: null,
  addOnBlur: null,
  onAdd: null,
  onRemove: null,
  onChange: null,
  onFocus: null,
  onBlur: null,
  onKeyDown: null
};

var SEPARATOR = ",";
var Chips = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      name = _ref.name,
      placeholder = _ref.placeholder,
      value = _ref.value,
      max = _ref.max,
      disabled = _ref.disabled,
      readOnly = _ref.readOnly,
      removable = _ref.removable,
      style = _ref.style,
      className = _ref.className,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      allowDuplicate = _ref.allowDuplicate,
      scrollable = _ref.scrollable,
      onAdd = _ref.onAdd,
      onRemove = _ref.onRemove,
      onChange = _ref.onChange,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur;
  var chipsClassName = classNames(className, {
    "p-chips_scrollable": scrollable
  });
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(Chips$1, {
    ref: ref,
    id: id,
    name: name,
    placeholder: placeholder,
    value: value,
    max: max,
    disabled: disabled,
    readOnly: readOnly,
    removable: removable,
    style: style,
    className: chipsClassName,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    separator: SEPARATOR,
    allowDuplicate: allowDuplicate,
    onAdd: onAdd,
    onRemove: onRemove,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur
  });
});

var Column = function Column() {};

Column.displayName = 'Column';
Column.defaultProps = {
  __TYPE: 'Column',
  columnKey: null,
  field: null,
  sortField: null,
  filterField: null,
  exportField: null,
  header: null,
  body: null,
  footer: null,
  sortable: false,
  sortableDisabled: false,
  sortFunction: null,
  dataType: 'text',
  filter: false,
  filterMatchMode: null,
  filterPlaceholder: null,
  filterType: 'text',
  filterMaxLength: null,
  filterElement: null,
  filterFunction: null,
  filterHeaderStyle: null,
  filterHeaderClassName: null,
  showFilterMenu: true,
  showFilterOperator: true,
  showClearButton: true,
  showApplyButton: true,
  showFilterMatchModes: true,
  showFilterMenuOptions: true,
  showAddButton: true,
  filterMatchModeOptions: null,
  maxConstraints: 2,
  filterMenuClassName: null,
  filterMenuStyle: null,
  align: null,
  alignHeader: null,
  alignFrozen: 'left',
  hidden: false,
  onFilterClear: null,
  onFilterApplyClick: null,
  onFilterMatchModeChange: null,
  onFilterOperatorChange: null,
  onFilterConstraintAdd: null,
  onFilterConstraintRemove: null,
  filterClear: null,
  filterApply: null,
  filterHeader: null,
  filterFooter: null,
  style: null,
  className: null,
  headerStyle: null,
  headerClassName: null,
  bodyStyle: null,
  bodyClassName: null,
  footerStyle: null,
  footerClassName: null,
  expander: false,
  frozen: false,
  selectionMode: null,
  colSpan: null,
  rowSpan: null,
  editor: null,
  cellEditValidator: null,
  cellEditValidatorEvent: 'click',
  onBeforeCellEditHide: null,
  onBeforeCellEditShow: null,
  onCellEditInit: null,
  onCellEditComplete: null,
  onCellEditCancel: null,
  excludeGlobalFilter: false,
  rowReorder: false,
  rowReorderIcon: 'pi pi-bars',
  rowEditor: false,
  exportable: true,
  reorderable: true,
  resizeable: true
};

var ColumnGroup = function ColumnGroup() {};

ColumnGroup.displayName = 'ColumnGroup';
ColumnGroup.defaultProps = {
  __TYPE: 'ColumnGroup'
};

function _extends$x() {
  _extends$x = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$x.apply(this, arguments);
}

function _arrayLikeToArray$r(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$c(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$r(arr);
}

function _iterableToArray$c(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$r(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$r(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$r(o, minLen);
}

function _nonIterableSpread$c() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$c(arr) {
  return _arrayWithoutHoles$c(arr) || _iterableToArray$c(arr) || _unsupportedIterableToArray$r(arr) || _nonIterableSpread$c();
}

function _arrayWithHoles$n(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$n(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$n() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$n(arr, i) {
  return _arrayWithHoles$n(arr) || _iterableToArrayLimit$n(arr, i) || _unsupportedIterableToArray$r(arr, i) || _nonIterableRest$n();
}

var Dialog$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(props.id),
      _React$useState2 = _slicedToArray$n(_React$useState, 2),
      idState = _React$useState2[0],
      setIdState = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _React$useState4 = _slicedToArray$n(_React$useState3, 2),
      maskVisibleState = _React$useState4[0],
      setMaskVisibleState = _React$useState4[1];

  var _React$useState5 = React.useState(false),
      _React$useState6 = _slicedToArray$n(_React$useState5, 2),
      visibleState = _React$useState6[0],
      setVisibleState = _React$useState6[1];

  var _React$useState7 = React.useState(props.maximized),
      _React$useState8 = _slicedToArray$n(_React$useState7, 2),
      maximizedState = _React$useState8[0],
      setMaximizedState = _React$useState8[1];

  var dialogRef = React.useRef(null);
  var maskRef = React.useRef(null);
  var contentRef = React.useRef(null);
  var headerRef = React.useRef(null);
  var footerRef = React.useRef(null);
  var closeRef = React.useRef(null);
  var dragging = React.useRef(false);
  var resizing = React.useRef(false);
  var lastPageX = React.useRef(null);
  var lastPageY = React.useRef(null);
  var styleElement = React.useRef(null);
  var attributeSelector = React.useRef('');
  var maximized = props.onMaximize ? props.maximized : maximizedState;

  var _useEventListener = useEventListener({
    type: 'keydown',
    listener: function listener(event) {
      return onKeyDown(event);
    }
  }),
      _useEventListener2 = _slicedToArray$n(_useEventListener, 2),
      bindDocumentKeyDownListener = _useEventListener2[0],
      unbindDocumentKeyDownListener = _useEventListener2[1];

  var _useEventListener3 = useEventListener({
    type: 'mousemove',
    target: function target() {
      return window.document;
    },
    listener: function listener(event) {
      return onResize(event);
    }
  }),
      _useEventListener4 = _slicedToArray$n(_useEventListener3, 2),
      bindDocumentResizeListener = _useEventListener4[0],
      unbindDocumentResizeListener = _useEventListener4[1];

  var _useEventListener5 = useEventListener({
    type: 'mouseup',
    target: function target() {
      return window.document;
    },
    listener: function listener(event) {
      return onResizeEnd(event);
    }
  }),
      _useEventListener6 = _slicedToArray$n(_useEventListener5, 2),
      bindDocumentResizeEndListener = _useEventListener6[0],
      unbindDocumentResizEndListener = _useEventListener6[1];

  var _useEventListener7 = useEventListener({
    type: 'mousemove',
    target: function target() {
      return window.document;
    },
    listener: function listener(event) {
      return onDrag(event);
    }
  }),
      _useEventListener8 = _slicedToArray$n(_useEventListener7, 2),
      bindDocumentDragListener = _useEventListener8[0],
      unbindDocumentDragListener = _useEventListener8[1];

  var _useEventListener9 = useEventListener({
    type: 'mouseup',
    target: function target() {
      return window.document;
    },
    listener: function listener(event) {
      return onDragEnd(event);
    }
  }),
      _useEventListener10 = _slicedToArray$n(_useEventListener9, 2),
      bindDocumentDragEndListener = _useEventListener10[0],
      unbindDocumentDragEndListener = _useEventListener10[1];

  var onClose = function onClose(event) {
    props.onHide();
    event.preventDefault();
  };

  var focus = function focus() {
    var activeElement = document.activeElement;
    var isActiveElementInDialog = activeElement && dialogRef.current && dialogRef.current.contains(activeElement);

    if (!isActiveElementInDialog && props.closable && props.showHeader) {
      closeRef.current.focus();
    }
  };

  var onMaskClick = function onMaskClick(event) {
    if (props.dismissableMask && props.modal && maskRef.current === event.target) {
      onClose(event);
    }

    props.onMaskClick && props.onMaskClick(event);
  };

  var toggleMaximize = function toggleMaximize(event) {
    if (props.onMaximize) {
      props.onMaximize({
        originalEvent: event,
        maximized: !maximized
      });
    } else {
      setMaximizedState(function (prevMaximized) {
        return !prevMaximized;
      });
    }

    event.preventDefault();
  };

  var onKeyDown = function onKeyDown(event) {
    var currentTarget = event.currentTarget;

    if (!currentTarget || !currentTarget.primeDialogParams) {
      return;
    }

    var params = currentTarget.primeDialogParams;
    var paramLength = params.length;
    var dialogId = params[paramLength - 1] ? params[paramLength - 1].id : undefined;

    if (dialogId !== idState) {
      return;
    }

    var dialog = document.getElementById(dialogId);

    if (props.closable && props.closeOnEscape && event.key === 'Escape') {
      onClose(event);
      event.stopImmediatePropagation();
      params.splice(paramLength - 1, 1);
    } else if (event.key === 'Tab') {
      event.preventDefault();
      var focusableElements = DomHandler.getFocusableElements(dialog);

      if (focusableElements && focusableElements.length > 0) {
        if (!document.activeElement) {
          focusableElements[0].focus();
        } else {
          var focusedIndex = focusableElements.indexOf(document.activeElement);

          if (event.shiftKey) {
            if (focusedIndex === -1 || focusedIndex === 0) focusableElements[focusableElements.length - 1].focus();else focusableElements[focusedIndex - 1].focus();
          } else {
            if (focusedIndex === -1 || focusedIndex === focusableElements.length - 1) focusableElements[0].focus();else focusableElements[focusedIndex + 1].focus();
          }
        }
      }
    }
  };

  var onDragStart = function onDragStart(event) {
    if (DomHandler.hasClass(event.target, 'p-dialog-header-icon') || DomHandler.hasClass(event.target.parentElement, 'p-dialog-header-icon')) {
      return;
    }

    if (props.draggable) {
      dragging.current = true;
      lastPageX.current = event.pageX;
      lastPageY.current = event.pageY;
      dialogRef.current.style.margin = '0';
      DomHandler.addClass(document.body, 'p-unselectable-text');
      props.onDragStart && props.onDragStart(event);
    }
  };

  var onDrag = function onDrag(event) {
    if (dragging.current) {
      var width = DomHandler.getOuterWidth(dialogRef.current);
      var height = DomHandler.getOuterHeight(dialogRef.current);
      var deltaX = event.pageX - lastPageX.current;
      var deltaY = event.pageY - lastPageY.current;
      var offset = dialogRef.current.getBoundingClientRect();
      var leftPos = offset.left + deltaX;
      var topPos = offset.top + deltaY;
      var viewport = DomHandler.getViewport();
      dialogRef.current.style.position = 'fixed';

      if (props.keepInViewport) {
        if (leftPos >= props.minX && leftPos + width < viewport.width) {
          lastPageX.current = event.pageX;
          dialogRef.current.style.left = leftPos + 'px';
        }

        if (topPos >= props.minY && topPos + height < viewport.height) {
          lastPageY.current = event.pageY;
          dialogRef.current.style.top = topPos + 'px';
        }
      } else {
        lastPageX.current = event.pageX;
        dialogRef.current.style.left = leftPos + 'px';
        lastPageY.current = event.pageY;
        dialogRef.current.style.top = topPos + 'px';
      }

      props.onDrag && props.onDrag(event);
    }
  };

  var onDragEnd = function onDragEnd(event) {
    if (dragging.current) {
      dragging.current = false;
      DomHandler.removeClass(document.body, 'p-unselectable-text');
      props.onDragEnd && props.onDragEnd(event);
    }
  };

  var onResizeStart = function onResizeStart(event) {
    if (props.resizable) {
      resizing.current = true;
      lastPageX.current = event.pageX;
      lastPageY.current = event.pageY;
      DomHandler.addClass(document.body, 'p-unselectable-text');
      props.onResizeStart && props.onResizeStart(event);
    }
  };

  var convertToPx = function convertToPx(value, property, viewport) {
    !viewport && (viewport = DomHandler.getViewport());
    var val = parseInt(value);

    if (/^(\d+|(\.\d+))(\.\d+)?%$/.test(value)) {
      return val * (viewport[property] / 100);
    }

    return val;
  };

  var onResize = function onResize(event) {
    if (resizing.current) {
      var deltaX = event.pageX - lastPageX.current;
      var deltaY = event.pageY - lastPageY.current;
      var width = DomHandler.getOuterWidth(dialogRef.current);
      var height = DomHandler.getOuterHeight(dialogRef.current);
      var offset = dialogRef.current.getBoundingClientRect();
      var viewport = DomHandler.getViewport();
      var hasBeenDragged = !parseInt(dialogRef.current.style.top) || !parseInt(dialogRef.current.style.left);
      var minWidth = convertToPx(dialogRef.current.style.minWidth, 'width', viewport);
      var minHeight = convertToPx(dialogRef.current.style.minHeight, 'height', viewport);
      var newWidth = width + deltaX;
      var newHeight = height + deltaY;

      if (hasBeenDragged) {
        newWidth += deltaX;
        newHeight += deltaY;
      }

      if ((!minWidth || newWidth > minWidth) && offset.left + newWidth < viewport.width) {
        dialogRef.current.style.width = newWidth + 'px';
      }

      if ((!minHeight || newHeight > minHeight) && offset.top + newHeight < viewport.height) {
        dialogRef.current.style.height = newHeight + 'px';
      }

      lastPageX.current = event.pageX;
      lastPageY.current = event.pageY;
      props.onResize && props.onResize(event);
    }
  };

  var onResizeEnd = function onResizeEnd(event) {
    if (resizing.current) {
      resizing.current = false;
      DomHandler.removeClass(document.body, 'p-unselectable-text');
      props.onResizeEnd && props.onResizeEnd(event);
    }
  };

  var resetPosition = function resetPosition() {
    dialogRef.current.style.position = '';
    dialogRef.current.style.left = '';
    dialogRef.current.style.top = '';
    dialogRef.current.style.margin = '';
  };

  var getPositionClass = function getPositionClass() {
    var positions = ['center', 'left', 'right', 'top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right'];
    var pos = positions.find(function (item) {
      return item === props.position || item.replace('-', '') === props.position;
    });
    return pos ? "p-dialog-".concat(pos) : '';
  };

  var onEnter = function onEnter() {
    dialogRef.current.setAttribute(attributeSelector.current, '');
  };

  var onEntered = function onEntered() {
    props.onShow && props.onShow();

    if (props.focusOnShow) {
      focus();
    }

    enableDocumentSettings();
  };

  var onExiting = function onExiting() {
    if (props.modal) {
      DomHandler.addClass(maskRef.current, 'p-component-overlay-leave');
    }

    if (props.blockScroll) {
      DomHandler.removeClass(document.body, 'p-overflow-hidden');
    }
  };

  var onExited = function onExited() {
    dragging.current = false;
    ZIndexUtils.clear(maskRef.current);
    setMaskVisibleState(false);
    disableDocumentSettings();
  };

  var enableDocumentSettings = function enableDocumentSettings() {
    bindGlobalListeners();

    if (props.blockScroll || props.maximizable && maximized) {
      DomHandler.addClass(document.body, 'p-overflow-hidden');
    }
  };

  var disableDocumentSettings = function disableDocumentSettings() {
    unbindGlobalListeners();

    if (props.modal) {
      var hasBlockScroll = document.primeDialogParams && document.primeDialogParams.some(function (param) {
        return param.hasBlockScroll;
      });

      if (hasBlockScroll) {
        DomHandler.removeClass(document.body, 'p-overflow-hidden');
      }
    } else if (props.blockScroll || props.maximizable && maximized) {
      DomHandler.removeClass(document.body, 'p-overflow-hidden');
    }
  };

  var bindGlobalListeners = function bindGlobalListeners() {
    if (props.draggable) {
      bindDocumentDragListener();
      bindDocumentDragEndListener();
    }

    if (props.resizable) {
      bindDocumentResizeListener();
      bindDocumentResizeEndListener();
    }

    bindDocumentKeyDownListener();
    var newParam = {
      id: idState,
      hasBlockScroll: props.blockScroll
    };
    document.primeDialogParams = document.primeDialogParams ? [].concat(_toConsumableArray$c(document.primeDialogParams), [newParam]) : [newParam];
  };

  var unbindGlobalListeners = function unbindGlobalListeners() {
    unbindDocumentDragListener();
    unbindDocumentDragEndListener();
    unbindDocumentResizeListener();
    unbindDocumentResizEndListener();
    unbindDocumentKeyDownListener();
    document.primeDialogParams = document.primeDialogParams && document.primeDialogParams.filter(function (param) {
      return param.id !== idState;
    });
  };

  var createStyle = function createStyle() {
    if (!styleElement.current) {
      styleElement.current = DomHandler.createInlineStyle(PrimeReact$1.nonce);
      var innerHTML = '';

      for (var breakpoint in props.breakpoints) {
        innerHTML += "\n                    @media screen and (max-width: ".concat(breakpoint, ") {\n                        .p-dialog[").concat(attributeSelector.current, "] {\n                            width: ").concat(props.breakpoints[breakpoint], " !important;\n                        }\n                    }\n                ");
      }

      styleElement.current.innerHTML = innerHTML;
    }
  };

  var changeScrollOnMaximizable = function changeScrollOnMaximizable() {
    if (!props.blockScroll) {
      var funcName = maximized ? 'addClass' : 'removeClass';
      DomHandler[funcName](document.body, 'p-overflow-hidden');
    }
  };

  useMountEffect(function () {
    var unqiueId = UniqueComponentId();

    if (!idState) {
      setIdState(unqiueId);
    }

    if (!attributeSelector.current) {
      attributeSelector.current = unqiueId;
    }

    if (props.visible) {
      setMaskVisibleState(true);
    }

    if (props.breakpoints) {
      createStyle();
    }
  });
  useUpdateEffect(function () {
    if (props.visible && !maskVisibleState) {
      setMaskVisibleState(true);
    }

    if (props.visible !== visibleState && maskVisibleState) {
      setVisibleState(props.visible);
    }
  });
  useUpdateEffect(function () {
    if (maskVisibleState) {
      ZIndexUtils.set('modal', maskRef.current, PrimeReact$1.autoZIndex, props.baseZIndex || PrimeReact$1.zIndex['modal']);
      setVisibleState(true);
    }
  }, [maskVisibleState]);
  useUpdateEffect(function () {
    changeScrollOnMaximizable();
  }, [props.maximized, maximizedState]);
  useUnmountEffect(function () {
    disableDocumentSettings();
    DomHandler.removeInlineStyle(styleElement.current);
    ZIndexUtils.clear(maskRef.current);
  });
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      resetPosition: resetPosition,
      getElement: function getElement() {
        return dialogRef.current;
      },
      getMask: function getMask() {
        return maskRef.current;
      },
      getContent: function getContent() {
        return contentRef.current;
      },
      getHeader: function getHeader() {
        return headerRef.current;
      },
      getFooter: function getFooter() {
        return footerRef.current;
      },
      getCloseButton: function getCloseButton() {
        return closeRef.current;
      }
    };
  });

  var createCloseIcon = function createCloseIcon() {
    if (props.closable) {
      var ariaLabel = props.ariaCloseIconLabel || localeOption$1('close');
      return /*#__PURE__*/React.createElement("button", {
        ref: closeRef,
        type: "button",
        className: "p-dialog-header-icon p-dialog-header-close p-link",
        "aria-label": ariaLabel,
        onClick: onClose
      }, /*#__PURE__*/React.createElement("span", {
        className: "p-dialog-header-close-icon pi pi-times",
        "aria-hidden": "true"
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }

    return null;
  };

  var createMaximizeIcon = function createMaximizeIcon() {
    var iconClassName = classNames('p-dialog-header-maximize-icon pi', {
      'pi-window-maximize': !maximized,
      'pi-window-minimize': maximized
    });

    if (props.maximizable) {
      return /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-dialog-header-icon p-dialog-header-maximize p-link",
        onClick: toggleMaximize
      }, /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }

    return null;
  };

  var createHeader = function createHeader() {
    if (props.showHeader) {
      var closeIcon = createCloseIcon();
      var maximizeIcon = createMaximizeIcon();
      var icons = ObjectUtils.getJSXElement(props.icons, props);
      var header = ObjectUtils.getJSXElement(props.header, props);
      var headerId = idState + '_header';
      var headerClassName = classNames('p-dialog-header', props.headerClassName);
      return /*#__PURE__*/React.createElement("div", {
        ref: headerRef,
        style: props.headerStyle,
        className: headerClassName,
        onMouseDown: onDragStart
      }, /*#__PURE__*/React.createElement("div", {
        id: headerId,
        className: "p-dialog-title"
      }, header), /*#__PURE__*/React.createElement("div", {
        className: "p-dialog-header-icons"
      }, icons, maximizeIcon, closeIcon));
    }

    return null;
  };

  var createContent = function createContent() {
    var className = classNames('p-dialog-content', props.contentClassName);
    var contentId = idState + '_content';
    return /*#__PURE__*/React.createElement("div", {
      id: contentId,
      ref: contentRef,
      className: className,
      style: props.contentStyle
    }, props.children);
  };

  var createFooter = function createFooter() {
    var footer = ObjectUtils.getJSXElement(props.footer, props);
    return footer && /*#__PURE__*/React.createElement("div", {
      ref: footerRef,
      className: "p-dialog-footer"
    }, footer);
  };

  var createResizer = function createResizer() {
    if (props.resizable) {
      return /*#__PURE__*/React.createElement("span", {
        className: "p-resizable-handle",
        style: {
          zIndex: 90
        },
        onMouseDown: onResizeStart
      });
    }

    return null;
  };

  var createElement = function createElement() {
    var otherProps = ObjectUtils.findDiffKeys(props, Dialog$1.defaultProps);
    var className = classNames('p-dialog p-component', props.className, {
      'p-dialog-rtl': props.rtl,
      'p-dialog-maximized': maximized
    });
    var maskClassName = classNames('p-dialog-mask', getPositionClass(), {
      'p-component-overlay p-component-overlay-enter': props.modal,
      'p-dialog-visible': maskVisibleState,
      'p-dialog-draggable': props.draggable,
      'p-dialog-resizable': props.resizable
    }, props.maskClassName);
    var header = createHeader();
    var content = createContent();
    var footer = createFooter();
    var resizer = createResizer();
    var headerId = idState + '_header';
    var contentId = idState + '_content';
    var transitionTimeout = {
      enter: props.position === 'center' ? 150 : 300,
      exit: props.position === 'center' ? 150 : 300
    };
    return /*#__PURE__*/React.createElement("div", {
      ref: maskRef,
      style: props.maskStyle,
      className: maskClassName,
      onClick: onMaskClick
    }, /*#__PURE__*/React.createElement(CSSTransition, {
      nodeRef: dialogRef,
      classNames: "p-dialog",
      timeout: transitionTimeout,
      "in": visibleState,
      options: props.transitionOptions,
      unmountOnExit: true,
      onEnter: onEnter,
      onEntered: onEntered,
      onExiting: onExiting,
      onExited: onExited
    }, /*#__PURE__*/React.createElement("div", _extends$x({
      ref: dialogRef,
      id: idState,
      className: className,
      style: props.style,
      onClick: props.onClick,
      role: "dialog"
    }, otherProps, {
      "aria-labelledby": headerId,
      "aria-describedby": contentId,
      "aria-modal": props.modal
    }), header, content, footer, resizer)));
  };

  var createDialog = function createDialog() {
    var element = createElement();
    return /*#__PURE__*/React.createElement(Portal, {
      element: element,
      appendTo: props.appendTo,
      visible: true
    });
  };

  return maskVisibleState && createDialog();
});
Dialog$1.displayName = 'Dialog';
Dialog$1.defaultProps = {
  __TYPE: 'Dialog',
  id: null,
  header: null,
  footer: null,
  visible: false,
  position: 'center',
  draggable: true,
  resizable: true,
  modal: true,
  onHide: null,
  onShow: null,
  headerStyle: null,
  headerClassName: null,
  contentStyle: null,
  contentClassName: null,
  closeOnEscape: true,
  dismissableMask: false,
  rtl: false,
  closable: true,
  style: null,
  className: null,
  maskStyle: null,
  maskClassName: null,
  showHeader: true,
  appendTo: null,
  baseZIndex: 0,
  maximizable: false,
  blockScroll: false,
  icons: null,
  ariaCloseIconLabel: null,
  focusOnShow: true,
  minX: 0,
  minY: 0,
  keepInViewport: true,
  maximized: false,
  breakpoints: null,
  transitionOptions: null,
  onMaximize: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  onResizeStart: null,
  onResize: null,
  onResizeEnd: null,
  onClick: null,
  onMaskClick: null
};

var OverlayService = EventBus();

function _extends$w() {
  _extends$w = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$w.apply(this, arguments);
}

function _arrayWithHoles$m(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$m(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$q(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$q(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$q(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$q(o, minLen);
}

function _nonIterableRest$m() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$m(arr, i) {
  return _arrayWithHoles$m(arr) || _iterableToArrayLimit$m(arr, i) || _unsupportedIterableToArray$q(arr, i) || _nonIterableRest$m();
}

function _defineProperty$e(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$e(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$e(Object(source), !0).forEach(function (key) {
      _defineProperty$e(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var confirmDialog$1 = function confirmDialog() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  props = _objectSpread$e(_objectSpread$e({}, props), {
    visible: props.visible === undefined ? true : props.visible
  });
  props.visible && OverlayService.emit('confirm-dialog', props);

  var show = function show() {
    var updatedProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    OverlayService.emit('confirm-dialog', _objectSpread$e(_objectSpread$e(_objectSpread$e({}, props), updatedProps), {
      visible: true
    }));
  };

  var hide = function hide() {
    OverlayService.emit('confirm-dialog', {
      visible: false
    });
  };

  return {
    show: show,
    hide: hide
  };
};

var ConfirmDialog = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(props.visible),
      _React$useState2 = _slicedToArray$m(_React$useState, 2),
      visibleState = _React$useState2[0],
      setVisibleState = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _React$useState4 = _slicedToArray$m(_React$useState3, 2),
      reshowState = _React$useState4[0],
      setReshowState = _React$useState4[1];

  var confirmProps = React.useRef(null);

  var getCurrentProps = function getCurrentProps() {
    return confirmProps.current || props;
  };

  var getPropValue = function getPropValue(key) {
    return (confirmProps.current || props)[key];
  };

  var callbackFromProp = function callbackFromProp(key) {
    for (var _len = arguments.length, param = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      param[_key - 1] = arguments[_key];
    }

    return ObjectUtils.getPropValue(getPropValue(key), param);
  };

  var acceptLabel = getPropValue('acceptLabel') || localeOption$1('accept');
  var rejectLabel = getPropValue('rejectLabel') || localeOption$1('reject');

  var accept = function accept() {
    callbackFromProp('accept');
    hide('accept');
  };

  var reject = function reject() {
    callbackFromProp('reject');
    hide('reject');
  };

  var show = function show() {
    setVisibleState(true);
  };

  var hide = function hide() {
    var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cancel';
    setVisibleState(false);
    callbackFromProp('onHide', result);
  };

  var confirm = function confirm(updatedProps) {
    if (updatedProps.tagKey === props.tagKey) {
      var isVisibleChanged = visibleState !== updatedProps.visible;
      var targetChanged = getPropValue('target') !== updatedProps.target;

      if (targetChanged && !props.target) {
        hide();
        confirmProps.current = updatedProps;
        setReshowState(true);
      } else if (isVisibleChanged) {
        confirmProps.current = updatedProps;
        updatedProps.visible ? show() : hide();
      }
    }
  };

  React.useEffect(function () {
    props.visible ? show() : hide(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [props.visible]);
  React.useEffect(function () {
    if (!props.target && !props.message) {
      OverlayService.on('confirm-dialog', confirm);
    }

    return function () {
      OverlayService.off('confirm-dialog', confirm);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [props.target]);
  useUpdateEffect(function () {
    reshowState && show();
  }, [reshowState]);
  useUnmountEffect(function () {
    OverlayService.off('confirm-dialog', confirm);
  });
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      confirm: confirm
    };
  });

  var createFooter = function createFooter() {
    var acceptClassName = classNames('p-confirm-dialog-accept', getPropValue('acceptClassName'));
    var rejectClassName = classNames('p-confirm-dialog-reject', {
      'p-button-text': !getPropValue('rejectClassName')
    }, getPropValue('rejectClassName'));
    var content = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Button$1, {
      label: rejectLabel,
      icon: getPropValue('rejectIcon'),
      className: rejectClassName,
      onClick: reject
    }), /*#__PURE__*/React.createElement(Button$1, {
      label: acceptLabel,
      icon: getPropValue('acceptIcon'),
      className: acceptClassName,
      onClick: accept,
      autoFocus: true
    }));

    if (getPropValue('footer')) {
      var defaultContentOptions = {
        accept: accept,
        reject: reject,
        acceptClassName: acceptClassName,
        rejectClassName: rejectClassName,
        acceptLabel: acceptLabel,
        rejectLabel: rejectLabel,
        element: content,
        props: getCurrentProps()
      };
      return ObjectUtils.getJSXElement(getPropValue('footer'), defaultContentOptions);
    }

    return content;
  };

  var createElement = function createElement() {
    var currentProps = getCurrentProps();
    var className = classNames('p-confirm-dialog', getPropValue('className'));
    var otherProps = ObjectUtils.findDiffKeys(currentProps, ConfirmDialog.defaultProps);
    var message = ObjectUtils.getJSXElement(getPropValue('message'), currentProps);
    var icon = IconUtils.getJSXIcon(getPropValue('icon'), {
      className: 'p-confirm-dialog-icon'
    }, {
      props: currentProps
    });
    var footer = createFooter();
    return /*#__PURE__*/React.createElement(Dialog$1, _extends$w({
      visible: visibleState
    }, otherProps, {
      className: className,
      footer: footer,
      onHide: hide,
      breakpoints: getPropValue('breakpoints')
    }), icon, /*#__PURE__*/React.createElement("span", {
      className: "p-confirm-dialog-message"
    }, message));
  };

  var element = createElement();
  return /*#__PURE__*/React.createElement(Portal, {
    element: element,
    appendTo: getPropValue('appendTo')
  });
}));
ConfirmDialog.displayName = 'ConfirmDialog';
ConfirmDialog.defaultProps = {
  __TYPE: 'ConfirmDialog',
  tagKey: undefined,
  visible: undefined,
  message: null,
  rejectLabel: null,
  acceptLabel: null,
  icon: null,
  rejectIcon: null,
  acceptIcon: null,
  rejectClassName: null,
  acceptClassName: null,
  className: null,
  appendTo: null,
  footer: null,
  breakpoints: null,
  onHide: null,
  accept: null,
  reject: null
};

var confirmDialog = function confirmDialog(_ref) {
  var message = _ref.message,
      acceptLabel = _ref.acceptLabel,
      rejectLabel = _ref.rejectLabel,
      icon = _ref.icon,
      acceptClassName = _ref.acceptClassName,
      rejectClassName = _ref.rejectClassName,
      accept = _ref.accept,
      reject = _ref.reject,
      id = _ref.id,
      header = _ref.header,
      footer = _ref.footer,
      visible = _ref.visible,
      onHide = _ref.onHide,
      onShow = _ref.onShow,
      contentStyle = _ref.contentStyle,
      contentClassName = _ref.contentClassName,
      style = _ref.style,
      className = _ref.className,
      showHeader = _ref.showHeader,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 100 : _ref$baseZIndex,
      breakpoints = _ref.breakpoints,
      onClick = _ref.onClick,
      onMaskClick = _ref.onMaskClick;
  var params = {
    // confirmDialog params
    message: message,
    acceptLabel: acceptLabel,
    rejectLabel: rejectLabel,
    icon: icon,
    acceptClassName: acceptClassName,
    rejectClassName: rejectClassName,
    accept: accept,
    reject: reject,
    // common dialog params
    id: id,
    header: header,
    footer: footer,
    visible: visible,
    onHide: onHide,
    onShow: onShow,
    contentStyle: contentStyle,
    contentClassName: contentClassName,
    style: style,
    className: className,
    showHeader: showHeader,
    baseZIndex: baseZIndex,
    breakpoints: breakpoints,
    onClick: onClick,
    onMaskClick: onMaskClick,
    // params below are unavailable for users
    draggable: false,
    resizable: false,
    modal: true,
    closeOnEscape: true,
    dismissableMask: true,
    rtl: false,
    closable: true,
    maximizable: false,
    blockScroll: true,
    keepInViewport: true,
    maximized: false
  };
  return confirmDialog$1(params);
};

function _extends$v() {
  _extends$v = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$v.apply(this, arguments);
}

function _arrayWithHoles$l(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$l(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$p(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$p(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$p(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$p(o, minLen);
}

function _nonIterableRest$l() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$l(arr, i) {
  return _arrayWithHoles$l(arr) || _iterableToArrayLimit$l(arr, i) || _unsupportedIterableToArray$p(arr, i) || _nonIterableRest$l();
}

function _defineProperty$d(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$d(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$d(Object(source), !0).forEach(function (key) {
      _defineProperty$d(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var confirmPopup$1 = function confirmPopup() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  props = _objectSpread$d(_objectSpread$d({}, props), {
    visible: props.visible === undefined ? true : props.visible
  });
  props.visible && OverlayService.emit('confirm-popup', props);

  var show = function show() {
    var updatedProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    OverlayService.emit('confirm-popup', _objectSpread$d(_objectSpread$d(_objectSpread$d({}, props), updatedProps), {
      visible: true
    }));
  };

  var hide = function hide() {
    OverlayService.emit('confirm-popup', {
      visible: false
    });
  };

  return {
    show: show,
    hide: hide
  };
};

var ConfirmPopup = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(props.visible),
      _React$useState2 = _slicedToArray$l(_React$useState, 2),
      visibleState = _React$useState2[0],
      setVisibleState = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _React$useState4 = _slicedToArray$l(_React$useState3, 2),
      reshowState = _React$useState4[0],
      setReshowState = _React$useState4[1];

  var overlayRef = React.useRef(null);
  var acceptBtnRef = React.useRef(null);
  var isPanelClicked = React.useRef(false);
  var overlayEventListener = React.useRef(null);
  var confirmProps = React.useRef(null);

  var getCurrentProps = function getCurrentProps() {
    return confirmProps.current || props;
  };

  var getPropValue = function getPropValue(key) {
    return (confirmProps.current || props)[key];
  };

  var callbackFromProp = function callbackFromProp(key) {
    for (var _len = arguments.length, param = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      param[_key - 1] = arguments[_key];
    }

    return ObjectUtils.getPropValue(getPropValue(key), param);
  };

  var acceptLabel = getPropValue('acceptLabel') || localeOption$1('accept');
  var rejectLabel = getPropValue('rejectLabel') || localeOption$1('reject');

  var _useOverlayListener = useOverlayListener({
    target: getPropValue('target'),
    overlay: overlayRef,
    listener: function listener(event, _ref) {
      var type = _ref.type,
          valid = _ref.valid;

      if (valid) {
        type === 'outside' ? props.dismissable && !isPanelClicked.current && hide() : hide();
      }

      isPanelClicked.current = false;
    },
    when: visibleState
  }),
      _useOverlayListener2 = _slicedToArray$l(_useOverlayListener, 2),
      bindOverlayListener = _useOverlayListener2[0],
      unbindOverlayListener = _useOverlayListener2[1];

  var onPanelClick = function onPanelClick(event) {
    isPanelClicked.current = true;
    OverlayService.emit('overlay-click', {
      originalEvent: event,
      target: getPropValue('target')
    });
  };

  var accept = function accept() {
    callbackFromProp('accept');
    hide('accept');
  };

  var reject = function reject() {
    callbackFromProp('reject');
    hide('reject');
  };

  var show = function show() {
    setVisibleState(true);
    setReshowState(false);

    overlayEventListener.current = function (e) {
      !isOutsideClicked(e.target) && (isPanelClicked.current = true);
    };

    OverlayService.on('overlay-click', overlayEventListener.current);
  };

  var hide = function hide(result) {
    setVisibleState(false);
    OverlayService.off('overlay-click', overlayEventListener.current);
    overlayEventListener.current = null;

    if (result) {
      callbackFromProp('onHide', result);
    }
  };

  var onEnter = function onEnter() {
    ZIndexUtils.set('overlay', overlayRef.current, PrimeReact$1.autoZIndex, PrimeReact$1.zIndex['overlay']);
    align();
  };

  var onEntered = function onEntered() {
    bindOverlayListener();

    if (acceptBtnRef.current) {
      acceptBtnRef.current.focus();
    }

    callbackFromProp('onShow');
  };

  var onExit = function onExit() {
    unbindOverlayListener();
  };

  var onExited = function onExited() {
    ZIndexUtils.clear(overlayRef.current);
    isPanelClicked.current = false;
  };

  var align = function align() {
    if (getPropValue('target')) {
      DomHandler.absolutePosition(overlayRef.current, getPropValue('target'));
      var containerOffset = DomHandler.getOffset(overlayRef.current);
      var targetOffset = DomHandler.getOffset(getPropValue('target'));
      var arrowLeft = 0;

      if (containerOffset.left < targetOffset.left) {
        arrowLeft = targetOffset.left - containerOffset.left;
      }

      overlayRef.current.style.setProperty('--overlayArrowLeft', "".concat(arrowLeft, "px"));

      if (containerOffset.top < targetOffset.top) {
        DomHandler.addClass(overlayRef.current, 'p-confirm-popup-flipped');
      }
    }
  };

  var isOutsideClicked = function isOutsideClicked(target) {
    return overlayRef && overlayRef.current && !(overlayRef.current.isSameNode(target) || overlayRef.current.contains(target));
  };

  var confirm = function confirm(updatedProps) {
    if (updatedProps.tagKey === props.tagKey) {
      var isVisibleChanged = visibleState !== updatedProps.visible;
      var targetChanged = getPropValue('target') !== updatedProps.target;

      if (targetChanged && !props.target) {
        hide();
        confirmProps.current = updatedProps;
        setReshowState(true);
      } else if (isVisibleChanged) {
        confirmProps.current = updatedProps;
        updatedProps.visible ? show() : hide();
      }
    }
  };

  React.useEffect(function () {
    props.visible ? show() : hide(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [props.visible]);
  React.useEffect(function () {
    if (!props.target && !props.message) {
      OverlayService.on('confirm-popup', confirm);
    }

    return function () {
      OverlayService.off('confirm-popup', confirm);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [props.target]);
  useUpdateEffect(function () {
    reshowState && show();
  }, [reshowState]);
  useUnmountEffect(function () {
    if (overlayEventListener.current) {
      OverlayService.off('overlay-click', overlayEventListener.current);
      overlayEventListener.current = null;
    }

    OverlayService.off('confirm-popup', confirm);
    ZIndexUtils.clear(overlayRef.current);
  });
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      confirm: confirm
    };
  });

  var createContent = function createContent() {
    var currentProps = getCurrentProps();
    var message = ObjectUtils.getJSXElement(getPropValue('message'), currentProps);
    var icon = IconUtils.getJSXIcon(getPropValue('icon'), {
      className: 'p-confirm-popup-icon'
    }, {
      props: currentProps
    });
    return /*#__PURE__*/React.createElement("div", {
      className: "p-confirm-popup-content"
    }, icon, /*#__PURE__*/React.createElement("span", {
      className: "p-confirm-popup-message"
    }, message));
  };

  var createFooter = function createFooter() {
    var acceptClassName = classNames('p-confirm-popup-accept p-button-sm', getPropValue('acceptClassName'));
    var rejectClassName = classNames('p-confirm-popup-reject p-button-sm', {
      'p-button-text': !getPropValue('rejectClassName')
    }, getPropValue('rejectClassName'));
    var content = /*#__PURE__*/React.createElement("div", {
      className: "p-confirm-popup-footer"
    }, /*#__PURE__*/React.createElement(Button$1, {
      label: rejectLabel,
      icon: getPropValue('rejectIcon'),
      className: rejectClassName,
      onClick: reject
    }), /*#__PURE__*/React.createElement(Button$1, {
      ref: acceptBtnRef,
      label: acceptLabel,
      icon: getPropValue('acceptIcon'),
      className: acceptClassName,
      onClick: accept
    }));

    if (getPropValue('footer')) {
      var defaultContentOptions = {
        accept: accept,
        reject: reject,
        className: 'p-confirm-popup-footer',
        acceptClassName: acceptClassName,
        rejectClassName: rejectClassName,
        acceptLabel: acceptLabel,
        rejectLabel: rejectLabel,
        element: content,
        props: getCurrentProps()
      };
      return ObjectUtils.getJSXElement(getPropValue('footer'), defaultContentOptions);
    }

    return content;
  };

  var createElement = function createElement() {
    var otherProps = ObjectUtils.findDiffKeys(props, ConfirmPopup.defaultProps);
    var className = classNames('p-confirm-popup p-component', getPropValue('className'));
    var content = createContent();
    var footer = createFooter();
    return /*#__PURE__*/React.createElement(CSSTransition, {
      nodeRef: overlayRef,
      classNames: "p-connected-overlay",
      "in": visibleState,
      timeout: {
        enter: 120,
        exit: 100
      },
      options: getPropValue('transitionOptions'),
      unmountOnExit: true,
      onEnter: onEnter,
      onEntered: onEntered,
      onExit: onExit,
      onExited: onExited
    }, /*#__PURE__*/React.createElement("div", _extends$v({
      ref: overlayRef,
      id: getPropValue('id'),
      className: className,
      style: getPropValue('style')
    }, otherProps, {
      onClick: onPanelClick
    }), content, footer));
  };

  var element = createElement();
  return /*#__PURE__*/React.createElement(Portal, {
    element: element,
    appendTo: getPropValue('appendTo'),
    visible: getPropValue('visible')
  });
}));
ConfirmPopup.displayName = 'ConfirmPopup';
ConfirmPopup.defaultProps = {
  __TYPE: 'ConfirmPopup',
  tagKey: undefined,
  target: null,
  visible: false,
  message: null,
  rejectLabel: null,
  acceptLabel: null,
  icon: null,
  rejectIcon: null,
  acceptIcon: null,
  rejectClassName: null,
  acceptClassName: null,
  className: null,
  style: null,
  appendTo: null,
  dismissable: true,
  footer: null,
  onShow: null,
  onHide: null,
  accept: null,
  reject: null,
  transitionOptions: null
};

var confirmPopup = function confirmPopup(_ref) {
  var target = _ref.target,
      message = _ref.message,
      rejectLabel = _ref.rejectLabel,
      acceptLabel = _ref.acceptLabel,
      icon = _ref.icon,
      rejectClassName = _ref.rejectClassName,
      acceptClassName = _ref.acceptClassName,
      className = _ref.className,
      style = _ref.style,
      footer = _ref.footer,
      onShow = _ref.onShow,
      onHide = _ref.onHide,
      accept = _ref.accept,
      reject = _ref.reject;
  var params = {
    target: target,
    message: message,
    rejectLabel: rejectLabel,
    acceptLabel: acceptLabel,
    icon: icon,
    rejectClassName: rejectClassName,
    acceptClassName: acceptClassName,
    className: className,
    style: style,
    footer: footer,
    onShow: onShow,
    onHide: onHide,
    accept: accept,
    reject: reject,
    dismissable: true
  };
  return confirmPopup$1(params);
};

var Dash = "";

function _extends$u() {
  _extends$u = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$u.apply(this, arguments);
}

var InputText$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(ref);

  var onKeyPress = function onKeyPress(event) {
    props.onKeyPress && props.onKeyPress(event);

    if (props.keyfilter) {
      KeyFilter.onKeyPress(event, props.keyfilter, props.validateOnly);
    }
  };

  var onInput = function onInput(event) {
    var validatePattern = true;

    if (props.keyfilter && props.validateOnly) {
      validatePattern = KeyFilter.validate(event, props.keyfilter);
    }

    props.onInput && props.onInput(event, validatePattern);

    if (!props.onChange) {
      var target = event.target;
      ObjectUtils.isNotEmpty(target.value) ? DomHandler.addClass(target, 'p-filled') : DomHandler.removeClass(target, 'p-filled');
    }
  };

  var onPaste = function onPaste(event) {
    props.onPaste && props.onPaste(event);

    if (props.keyfilter) {
      KeyFilter.onPaste(event, props.keyfilter, props.validateOnly);
    }
  };

  var currentValue = elementRef.current && elementRef.current.value;
  var isFilled = React.useMemo(function () {
    return ObjectUtils.isNotEmpty(props.value) || ObjectUtils.isNotEmpty(props.defaultValue) || ObjectUtils.isNotEmpty(currentValue);
  }, [props.value, props.defaultValue, currentValue]);
  React.useEffect(function () {
    ObjectUtils.combinedRefs(elementRef, ref);
  }, [elementRef, ref]);
  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, InputText$1.defaultProps);
  var className = classNames('p-inputtext p-component', {
    'p-disabled': props.disabled,
    'p-filled': isFilled
  }, props.className);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("input", _extends$u({
    ref: elementRef
  }, otherProps, {
    className: className,
    onInput: onInput,
    onKeyPress: onKeyPress,
    onPaste: onPaste
  })), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$u({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
InputText$1.displayName = 'InputText';
InputText$1.defaultProps = {
  __TYPE: 'InputText',
  keyfilter: null,
  validateOnly: false,
  tooltip: null,
  tooltipOptions: null,
  onInput: null,
  onKeyPress: null,
  onPaste: null
};

function _extends$t() {
  _extends$t = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$t.apply(this, arguments);
}

function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _arrayLikeToArray$o(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$b(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$o(arr);
}

function _iterableToArray$b(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$o(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$o(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$o(o, minLen);
}

function _nonIterableSpread$b() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$b(arr) {
  return _arrayWithoutHoles$b(arr) || _iterableToArray$b(arr) || _unsupportedIterableToArray$o(arr) || _nonIterableSpread$b();
}

function _arrayWithHoles$k(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$k(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$k() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$k(arr, i) {
  return _arrayWithHoles$k(arr) || _iterableToArrayLimit$k(arr, i) || _unsupportedIterableToArray$o(arr, i) || _nonIterableRest$k();
}

function ownKeys$c(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$c(Object(source), !0).forEach(function (key) {
      _defineProperty$c(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var InputNumber$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$k(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var elementRef = React.useRef(null);
  var inputRef = React.useRef(null);
  var timer = React.useRef(null);
  var lastValue = React.useRef(null);
  var numberFormat = React.useRef(null);
  var groupChar = React.useRef(null);
  var prefixChar = React.useRef(null);
  var suffixChar = React.useRef(null);
  var isSpecialChar = React.useRef(null);

  var _numeral = React.useRef(null);

  var _group = React.useRef(null);

  var _minusSign = React.useRef(null);

  var _currency = React.useRef(null);

  var _decimal = React.useRef(null);

  var _suffix = React.useRef(null);

  var _prefix = React.useRef(null);

  var _index = React.useRef(null);

  var stacked = props.showButtons && props.buttonLayout === 'stacked';
  var horizontal = props.showButtons && props.buttonLayout === 'horizontal';
  var vertical = props.showButtons && props.buttonLayout === 'vertical';
  var inputMode = props.inputMode || (props.mode === 'decimal' && !props.minFractionDigits ? 'numeric' : 'decimal');

  var getOptions = function getOptions() {
    return {
      localeMatcher: props.localeMatcher,
      style: props.mode,
      currency: props.currency,
      currencyDisplay: props.currencyDisplay,
      useGrouping: props.useGrouping,
      minimumFractionDigits: props.minFractionDigits,
      maximumFractionDigits: props.maxFractionDigits
    };
  };

  var constructParser = function constructParser() {
    numberFormat.current = new Intl.NumberFormat(props.locale, getOptions());

    var numerals = _toConsumableArray$b(new Intl.NumberFormat(props.locale, {
      useGrouping: false
    }).format(9876543210)).reverse();

    var index = new Map(numerals.map(function (d, i) {
      return [d, i];
    }));
    _numeral.current = new RegExp("[".concat(numerals.join(''), "]"), 'g');
    _group.current = getGroupingExpression();
    _minusSign.current = getMinusSignExpression();
    _currency.current = getCurrencyExpression();
    _decimal.current = getDecimalExpression();
    _suffix.current = getSuffixExpression();
    _prefix.current = getPrefixExpression();

    _index.current = function (d) {
      return index.get(d);
    };
  };

  var escapeRegExp = function escapeRegExp(text) {
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
  };

  var getDecimalExpression = function getDecimalExpression() {
    var formatter = new Intl.NumberFormat(props.locale, _objectSpread$c(_objectSpread$c({}, getOptions()), {}, {
      useGrouping: false
    }));
    return new RegExp("[".concat(formatter.format(1.1).replace(_currency.current, '').trim().replace(_numeral.current, ''), "]"), 'g');
  };

  var getGroupingExpression = function getGroupingExpression() {
    var formatter = new Intl.NumberFormat(props.locale, {
      useGrouping: true
    });
    groupChar.current = formatter.format(1000000).trim().replace(_numeral.current, '').charAt(0);
    return new RegExp("[".concat(groupChar.current, "]"), 'g');
  };

  var getMinusSignExpression = function getMinusSignExpression() {
    var formatter = new Intl.NumberFormat(props.locale, {
      useGrouping: false
    });
    return new RegExp("[".concat(formatter.format(-1).trim().replace(_numeral.current, ''), "]"), 'g');
  };

  var getCurrencyExpression = function getCurrencyExpression() {
    if (props.currency) {
      var formatter = new Intl.NumberFormat(props.locale, {
        style: 'currency',
        currency: props.currency,
        currencyDisplay: props.currencyDisplay,
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      });
      return new RegExp("[".concat(formatter.format(1).replace(/\s/g, '').replace(_numeral.current, '').replace(_group.current, ''), "]"), 'g');
    }

    return new RegExp("[]", 'g');
  };

  var getPrefixExpression = function getPrefixExpression() {
    if (props.prefix) {
      prefixChar.current = props.prefix;
    } else {
      var formatter = new Intl.NumberFormat(props.locale, {
        style: props.mode,
        currency: props.currency,
        currencyDisplay: props.currencyDisplay
      });
      prefixChar.current = formatter.format(1).split('1')[0];
    }

    return new RegExp("".concat(escapeRegExp(prefixChar.current || '')), 'g');
  };

  var getSuffixExpression = function getSuffixExpression() {
    if (props.suffix) {
      suffixChar.current = props.suffix;
    } else {
      var formatter = new Intl.NumberFormat(props.locale, {
        style: props.mode,
        currency: props.currency,
        currencyDisplay: props.currencyDisplay,
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      });
      suffixChar.current = formatter.format(1).split('1')[1];
    }

    return new RegExp("".concat(escapeRegExp(suffixChar.current || '')), 'g');
  };

  var formatValue = function formatValue(value) {
    if (value != null) {
      if (value === '-') {
        // Minus sign
        return value;
      }

      if (props.format) {
        var formatter = new Intl.NumberFormat(props.locale, getOptions());

        var _formattedValue = formatter.format(value);

        if (props.prefix) {
          _formattedValue = props.prefix + _formattedValue;
        }

        if (props.suffix) {
          _formattedValue = _formattedValue + props.suffix;
        }

        return _formattedValue;
      }

      return value.toString();
    }

    return '';
  };

  var parseValue = function parseValue(text) {
    var filteredText = text.replace(_suffix.current, '').replace(_prefix.current, '').trim().replace(/\s/g, '').replace(_currency.current, '').replace(_group.current, '').replace(_minusSign.current, '-').replace(_decimal.current, '.').replace(_numeral.current, _index.current);

    if (filteredText) {
      if (filteredText === '-') // Minus sign
        return filteredText;
      var parsedValue = +filteredText;
      return isNaN(parsedValue) ? null : parsedValue;
    }

    return null;
  };

  var repeat = function repeat(event, interval, dir) {
    var i = interval || 500;
    clearTimer();
    timer.current = setTimeout(function () {
      repeat(event, 40, dir);
    }, i);
    spin(event, dir);
  };

  var spin = function spin(event, dir) {
    if (inputRef.current) {
      var step = props.step * dir;
      var currentValue = parseValue(inputRef.current.value) || 0;
      var newValue = validateValue(currentValue + step); // touch devices trigger the keyboard to display because of setSelectionRange

      !DomHandler.isTouchDevice() && updateInput(newValue, null, 'spin');
      updateModel(event, newValue);
      handleOnChange(event, currentValue, newValue);
    }
  };

  var onUpButtonTouchStart = function onUpButtonTouchStart(event) {
    if (!props.disabled && !props.readOnly) {
      repeat(event, null, 1);
      event.preventDefault();
    }
  };

  var onUpButtonMouseDown = function onUpButtonMouseDown(event) {
    if (!props.disabled && !props.readOnly) {
      props.autoFocus && DomHandler.focus(inputRef.current, props.autoFocus);
      repeat(event, null, 1);
      event.preventDefault();
    }
  };

  var onUpButtonTouchEnd = function onUpButtonTouchEnd() {
    if (!props.disabled && !props.readOnly) {
      clearTimer();
      event.preventDefault();
    }
  };

  var onUpButtonMouseUp = function onUpButtonMouseUp() {
    if (!props.disabled && !props.readOnly) {
      clearTimer();
    }
  };

  var onUpButtonMouseLeave = function onUpButtonMouseLeave() {
    if (!props.disabled && !props.readOnly) {
      clearTimer();
    }
  };

  var onUpButtonKeyUp = function onUpButtonKeyUp() {
    if (!props.disabled && !props.readOnly) {
      clearTimer();
    }
  };

  var onUpButtonKeyDown = function onUpButtonKeyDown(event) {
    if (!props.disabled && !props.readOnly && (event.keyCode === 32 || event.keyCode === 13)) {
      repeat(event, null, 1);
    }
  };

  var onDownButtonTouchStart = function onDownButtonTouchStart(event) {
    if (!props.disabled && !props.readOnly) {
      repeat(event, null, -1);
      event.preventDefault();
    }
  };

  var onDownButtonTouchEnd = function onDownButtonTouchEnd() {
    if (!props.disabled && !props.readOnly) {
      clearTimer();
      event.preventDefault();
    }
  };

  var onDownButtonMouseDown = function onDownButtonMouseDown(event) {
    if (!props.disabled && !props.readOnly) {
      props.autoFocus && DomHandler.focus(inputRef.current, props.autoFocus);
      repeat(event, null, -1);
      event.preventDefault();
    }
  };

  var onDownButtonMouseUp = function onDownButtonMouseUp() {
    if (!props.disabled && !props.readOnly) {
      clearTimer();
    }
  };

  var onDownButtonMouseLeave = function onDownButtonMouseLeave() {
    if (!props.disabled && !props.readOnly) {
      clearTimer();
    }
  };

  var onDownButtonKeyUp = function onDownButtonKeyUp() {
    if (!props.disabled && !props.readOnly) {
      clearTimer();
    }
  };

  var onDownButtonKeyDown = function onDownButtonKeyDown(event) {
    if (!props.disabled && !props.readOnly && (event.keyCode === 32 || event.keyCode === 13)) {
      repeat(event, null, -1);
    }
  };

  var onInput = function onInput(event) {
    if (props.disabled || props.readOnly) {
      return;
    }

    if (isSpecialChar.current) {
      event.target.value = lastValue.current;
    }

    isSpecialChar.current = false;
  };

  var onInputKeyDown = function onInputKeyDown(event) {
    if (props.disabled || props.readOnly) {
      return;
    }

    lastValue.current = event.target.value;

    if (event.shiftKey || event.altKey) {
      isSpecialChar.current = true;
      return;
    }

    var selectionStart = event.target.selectionStart;
    var selectionEnd = event.target.selectionEnd;
    var inputValue = event.target.value;
    var newValueStr = null;

    if (event.altKey) {
      event.preventDefault();
    }

    switch (event.which) {
      //up
      case 38:
        spin(event, 1);
        event.preventDefault();
        break;
      //down

      case 40:
        spin(event, -1);
        event.preventDefault();
        break;
      //left

      case 37:
        if (!isNumeralChar(inputValue.charAt(selectionStart - 1))) {
          event.preventDefault();
        }

        break;
      //right

      case 39:
        if (!isNumeralChar(inputValue.charAt(selectionStart))) {
          event.preventDefault();
        }

        break;
      //enter and tab

      case 13:
      case 9:
        newValueStr = validateValue(parseValue(inputValue));
        inputRef.current.value = formatValue(newValueStr);
        inputRef.current.setAttribute('aria-valuenow', newValueStr);
        updateModel(event, newValueStr);
        break;
      //backspace

      case 8:
        event.preventDefault();

        if (selectionStart === selectionEnd) {
          var deleteChar = inputValue.charAt(selectionStart - 1);

          var _getDecimalCharIndexe = getDecimalCharIndexes(inputValue),
              decimalCharIndex = _getDecimalCharIndexe.decimalCharIndex,
              decimalCharIndexWithoutPrefix = _getDecimalCharIndexe.decimalCharIndexWithoutPrefix;

          if (isNumeralChar(deleteChar)) {
            var decimalLength = getDecimalLength(inputValue);

            if (_group.current.test(deleteChar)) {
              _group.current.lastIndex = 0;
              newValueStr = inputValue.slice(0, selectionStart - 2) + inputValue.slice(selectionStart - 1);
            } else if (_decimal.current.test(deleteChar)) {
              _decimal.current.lastIndex = 0;

              if (decimalLength) {
                inputRef.current.setSelectionRange(selectionStart - 1, selectionStart - 1);
              } else {
                newValueStr = inputValue.slice(0, selectionStart - 1) + inputValue.slice(selectionStart);
              }
            } else if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
              var insertedText = isDecimalMode() && (props.minFractionDigits || 0) < decimalLength ? '' : '0';
              newValueStr = inputValue.slice(0, selectionStart - 1) + insertedText + inputValue.slice(selectionStart);
            } else if (decimalCharIndexWithoutPrefix === 1) {
              newValueStr = inputValue.slice(0, selectionStart - 1) + '0' + inputValue.slice(selectionStart);
              newValueStr = parseValue(newValueStr) > 0 ? newValueStr : '';
            } else {
              newValueStr = inputValue.slice(0, selectionStart - 1) + inputValue.slice(selectionStart);
            }
          }

          updateValue(event, newValueStr, null, 'delete-single');
        } else {
          newValueStr = deleteRange(inputValue, selectionStart, selectionEnd);
          updateValue(event, newValueStr, null, 'delete-range');
        }

        break;
      // del

      case 46:
        event.preventDefault();

        if (selectionStart === selectionEnd) {
          var _deleteChar = inputValue.charAt(selectionStart);

          var _getDecimalCharIndexe2 = getDecimalCharIndexes(inputValue),
              _decimalCharIndex = _getDecimalCharIndexe2.decimalCharIndex,
              _decimalCharIndexWithoutPrefix = _getDecimalCharIndexe2.decimalCharIndexWithoutPrefix;

          if (isNumeralChar(_deleteChar)) {
            var _decimalLength = getDecimalLength(inputValue);

            if (_group.current.test(_deleteChar)) {
              _group.current.lastIndex = 0;
              newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 2);
            } else if (_decimal.current.test(_deleteChar)) {
              _decimal.current.lastIndex = 0;

              if (_decimalLength) {
                $refs.input.$el.setSelectionRange(selectionStart + 1, selectionStart + 1);
              } else {
                newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 1);
              }
            } else if (_decimalCharIndex > 0 && selectionStart > _decimalCharIndex) {
              var _insertedText = isDecimalMode() && (props.minFractionDigits || 0) < _decimalLength ? '' : '0';

              newValueStr = inputValue.slice(0, selectionStart) + _insertedText + inputValue.slice(selectionStart + 1);
            } else if (_decimalCharIndexWithoutPrefix === 1) {
              newValueStr = inputValue.slice(0, selectionStart) + '0' + inputValue.slice(selectionStart + 1);
              newValueStr = parseValue(newValueStr) > 0 ? newValueStr : '';
            } else {
              newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 1);
            }
          }

          updateValue(event, newValueStr, null, 'delete-back-single');
        } else {
          newValueStr = deleteRange(inputValue, selectionStart, selectionEnd);
          updateValue(event, newValueStr, null, 'delete-range');
        }

        break;
    }

    if (props.onKeyDown) {
      props.onKeyDown(event);
    }
  };

  var onInputKeyPress = function onInputKeyPress(event) {
    if (props.disabled || props.readOnly) {
      return;
    }

    var code = event.which || event.keyCode;

    if (code !== 13) {
      // to submit a form
      event.preventDefault();
    }

    var _char = String.fromCharCode(code);

    var _isDecimalSign = isDecimalSign(_char);

    var _isMinusSign = isMinusSign(_char);

    if (48 <= code && code <= 57 || _isMinusSign || _isDecimalSign) {
      insert(event, _char, {
        isDecimalSign: _isDecimalSign,
        isMinusSign: _isMinusSign
      });
    }
  };

  var onPaste = function onPaste(event) {
    event.preventDefault();

    if (props.disabled || props.readOnly) {
      return;
    }

    var data = (event.clipboardData || window['clipboardData']).getData('Text');

    if (data) {
      var filteredData = parseValue(data);

      if (filteredData != null) {
        insert(event, filteredData.toString());
      }
    }
  };

  var allowMinusSign = function allowMinusSign() {
    return props.min === null || props.min < 0;
  };

  var isMinusSign = function isMinusSign(_char2) {
    if (_minusSign.current.test(_char2) || _char2 === '-') {
      _minusSign.current.lastIndex = 0;
      return true;
    }

    return false;
  };

  var isDecimalSign = function isDecimalSign(_char3) {
    if (_decimal.current.test(_char3)) {
      _decimal.current.lastIndex = 0;
      return true;
    }

    return false;
  };

  var isDecimalMode = function isDecimalMode() {
    return props.mode === 'decimal';
  };

  var getDecimalCharIndexes = function getDecimalCharIndexes(val) {
    var decimalCharIndex = val.search(_decimal.current);
    _decimal.current.lastIndex = 0;
    var filteredVal = val.replace(_prefix.current, '').trim().replace(/\s/g, '').replace(_currency.current, '');
    var decimalCharIndexWithoutPrefix = filteredVal.search(_decimal.current);
    _decimal.current.lastIndex = 0;
    return {
      decimalCharIndex: decimalCharIndex,
      decimalCharIndexWithoutPrefix: decimalCharIndexWithoutPrefix
    };
  };

  var getCharIndexes = function getCharIndexes(val) {
    var decimalCharIndex = val.search(_decimal.current);
    _decimal.current.lastIndex = 0;
    var minusCharIndex = val.search(_minusSign.current);
    _minusSign.current.lastIndex = 0;
    var suffixCharIndex = val.search(_suffix.current);
    _suffix.current.lastIndex = 0;
    var currencyCharIndex = val.search(_currency.current);
    _currency.current.lastIndex = 0;
    return {
      decimalCharIndex: decimalCharIndex,
      minusCharIndex: minusCharIndex,
      suffixCharIndex: suffixCharIndex,
      currencyCharIndex: currencyCharIndex
    };
  };

  var insert = function insert(event, text) {
    var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      isDecimalSign: false,
      isMinusSign: false
    };
    var minusCharIndexOnText = text.search(_minusSign.current);
    _minusSign.current.lastIndex = 0;

    if (!allowMinusSign() && minusCharIndexOnText !== -1) {
      return;
    }

    var selectionStart = inputRef.current.selectionStart;
    var selectionEnd = inputRef.current.selectionEnd;
    var inputValue = inputRef.current.value.trim();

    var _getCharIndexes = getCharIndexes(inputValue),
        decimalCharIndex = _getCharIndexes.decimalCharIndex,
        minusCharIndex = _getCharIndexes.minusCharIndex,
        suffixCharIndex = _getCharIndexes.suffixCharIndex,
        currencyCharIndex = _getCharIndexes.currencyCharIndex;

    var newValueStr;

    if (sign.isMinusSign) {
      if (selectionStart === 0) {
        newValueStr = inputValue;

        if (minusCharIndex === -1 || selectionEnd !== 0) {
          newValueStr = insertText(inputValue, text, 0, selectionEnd);
        }

        updateValue(event, newValueStr, text, 'insert');
      }
    } else if (sign.isDecimalSign) {
      if (decimalCharIndex > 0 && selectionStart === decimalCharIndex) {
        updateValue(event, inputValue, text, 'insert');
      } else if (decimalCharIndex > selectionStart && decimalCharIndex < selectionEnd) {
        newValueStr = insertText(inputValue, text, selectionStart, selectionEnd);
        updateValue(event, newValueStr, text, 'insert');
      } else if (decimalCharIndex === -1 && props.maxFractionDigits) {
        newValueStr = insertText(inputValue, text, selectionStart, selectionEnd);
        updateValue(event, newValueStr, text, 'insert');
      }
    } else {
      var maxFractionDigits = numberFormat.current.resolvedOptions().maximumFractionDigits;
      var operation = selectionStart !== selectionEnd ? 'range-insert' : 'insert';

      if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
        if (selectionStart + text.length - (decimalCharIndex + 1) <= maxFractionDigits) {
          var charIndex = currencyCharIndex >= selectionStart ? currencyCharIndex - 1 : suffixCharIndex >= selectionStart ? suffixCharIndex : inputValue.length;
          newValueStr = inputValue.slice(0, selectionStart) + text + inputValue.slice(selectionStart + text.length, charIndex) + inputValue.slice(charIndex);
          updateValue(event, newValueStr, text, operation);
        }
      } else {
        newValueStr = insertText(inputValue, text, selectionStart, selectionEnd);
        updateValue(event, newValueStr, text, operation);
      }
    }
  };

  var insertText = function insertText(value, text, start, end) {
    var textSplit = text === '.' ? text : text.split('.');

    if (textSplit.length === 2) {
      var decimalCharIndex = value.slice(start, end).search(_decimal.current);
      _decimal.current.lastIndex = 0;
      return decimalCharIndex > 0 ? value.slice(0, start) + formatValue(text) + value.slice(end) : value || formatValue(text);
    } else if (end - start === value.length) {
      return formatValue(text);
    } else if (start === 0) {
      return text + value.slice(end);
    } else if (end === value.length) {
      return value.slice(0, start) + text;
    } else {
      return value.slice(0, start) + text + value.slice(end);
    }
  };

  var deleteRange = function deleteRange(value, start, end) {
    var newValueStr;
    if (end - start === value.length) newValueStr = '';else if (start === 0) newValueStr = value.slice(end);else if (end === value.length) newValueStr = value.slice(0, start);else newValueStr = value.slice(0, start) + value.slice(end);
    return newValueStr;
  };

  var initCursor = function initCursor() {
    var selectionStart = inputRef.current.selectionStart;
    var inputValue = inputRef.current.value;
    var valueLength = inputValue.length;
    var index = null; // remove prefix

    var prefixLength = (prefixChar.current || '').length;
    inputValue = inputValue.replace(_prefix.current, '');
    selectionStart = selectionStart - prefixLength;

    var _char4 = inputValue.charAt(selectionStart);

    if (isNumeralChar(_char4)) {
      return selectionStart + prefixLength;
    } //left


    var i = selectionStart - 1;

    while (i >= 0) {
      _char4 = inputValue.charAt(i);

      if (isNumeralChar(_char4)) {
        index = i + prefixLength;
        break;
      } else {
        i--;
      }
    }

    if (index !== null) {
      inputRef.current.setSelectionRange(index + 1, index + 1);
    } else {
      i = selectionStart;

      while (i < valueLength) {
        _char4 = inputValue.charAt(i);

        if (isNumeralChar(_char4)) {
          index = i + prefixLength;
          break;
        } else {
          i++;
        }
      }

      if (index !== null) {
        inputRef.current.setSelectionRange(index, index);
      }
    }

    return index || 0;
  };

  var onInputClick = function onInputClick() {
    initCursor();
  };

  var isNumeralChar = function isNumeralChar(_char5) {
    if (_char5.length === 1 && (_numeral.current.test(_char5) || _decimal.current.test(_char5) || _group.current.test(_char5) || _minusSign.current.test(_char5))) {
      resetRegex();
      return true;
    } else {
      return false;
    }
  };

  var resetRegex = function resetRegex() {
    _numeral.current.lastIndex = 0;
    _decimal.current.lastIndex = 0;
    _group.current.lastIndex = 0;
    _minusSign.current.lastIndex = 0;
  };

  var updateValue = function updateValue(event, valueStr, insertedValueStr, operation) {
    var currentValue = inputRef.current.value;
    var newValue = null;

    if (valueStr != null) {
      newValue = evaluateEmpty(parseValue(valueStr));
      updateInput(newValue, insertedValueStr, operation, valueStr);
      handleOnChange(event, currentValue, newValue);
    }
  };

  var evaluateEmpty = function evaluateEmpty(newValue) {
    return !newValue && !props.allowEmpty ? props.min || 0 : newValue;
  };

  var handleOnChange = function handleOnChange(event, currentValue, newValue) {
    if (props.onChange && isValueChanged(currentValue, newValue)) {
      props.onChange({
        originalEvent: event,
        value: newValue
      });
    }
  };

  var isValueChanged = function isValueChanged(currentValue, newValue) {
    if (newValue === null && currentValue !== null) {
      return true;
    }

    if (newValue != null) {
      var parsedCurrentValue = typeof currentValue === 'string' ? parseValue(currentValue) : currentValue;
      return newValue !== parsedCurrentValue;
    }

    return false;
  };

  var validateValue = function validateValue(value) {
    if (value === '-' || value == null) {
      return null;
    }

    if (props.min !== null && value < props.min) {
      return props.min;
    }

    if (props.max !== null && value > props.max) {
      return props.max;
    }

    return value;
  };

  var updateInput = function updateInput(value, insertedValueStr, operation, valueStr) {
    insertedValueStr = insertedValueStr || '';
    var inputEl = inputRef.current;
    var inputValue = inputEl.value;
    var newValue = formatValue(value);
    var currentLength = inputValue.length;

    if (newValue !== valueStr) {
      newValue = concatValues(newValue, valueStr);
    }

    if (currentLength === 0) {
      inputEl.value = newValue;
      inputEl.setSelectionRange(0, 0);
      var index = initCursor();
      var selectionEnd = index + insertedValueStr.length;
      inputEl.setSelectionRange(selectionEnd, selectionEnd);
    } else {
      var selectionStart = inputEl.selectionStart;
      var _selectionEnd = inputEl.selectionEnd;
      inputEl.value = newValue;
      var newLength = newValue.length;

      if (operation === 'range-insert') {
        var startValue = parseValue((inputValue || '').slice(0, selectionStart));
        var startValueStr = startValue !== null ? startValue.toString() : '';
        var startExpr = startValueStr.split('').join("(".concat(groupChar.current, ")?"));
        var sRegex = new RegExp(startExpr, 'g');
        sRegex.test(newValue);
        var tExpr = insertedValueStr.split('').join("(".concat(groupChar.current, ")?"));
        var tRegex = new RegExp(tExpr, 'g');
        tRegex.test(newValue.slice(sRegex.lastIndex));
        _selectionEnd = sRegex.lastIndex + tRegex.lastIndex;
        inputEl.setSelectionRange(_selectionEnd, _selectionEnd);
      } else if (newLength === currentLength) {
        if (operation === 'insert' || operation === 'delete-back-single') inputEl.setSelectionRange(_selectionEnd + 1, _selectionEnd + 1);else if (operation === 'delete-single') inputEl.setSelectionRange(_selectionEnd - 1, _selectionEnd - 1);else if (operation === 'delete-range' || operation === 'spin') inputEl.setSelectionRange(_selectionEnd, _selectionEnd);
      } else if (operation === 'delete-back-single') {
        var prevChar = inputValue.charAt(_selectionEnd - 1);
        var nextChar = inputValue.charAt(_selectionEnd);
        var diff = currentLength - newLength;

        var isGroupChar = _group.current.test(nextChar);

        if (isGroupChar && diff === 1) {
          _selectionEnd += 1;
        } else if (!isGroupChar && isNumeralChar(prevChar)) {
          _selectionEnd += -1 * diff + 1;
        }

        _group.current.lastIndex = 0;
        inputEl.setSelectionRange(_selectionEnd, _selectionEnd);
      } else if (inputValue === '-' && operation === 'insert') {
        inputEl.setSelectionRange(0, 0);

        var _index2 = initCursor();

        var _selectionEnd2 = _index2 + insertedValueStr.length + 1;

        inputEl.setSelectionRange(_selectionEnd2, _selectionEnd2);
      } else {
        _selectionEnd = _selectionEnd + (newLength - currentLength);
        inputEl.setSelectionRange(_selectionEnd, _selectionEnd);
      }
    }

    inputEl.setAttribute('aria-valuenow', value);
  };

  var updateInputValue = function updateInputValue(newValue) {
    newValue = evaluateEmpty(newValue);
    var inputEl = inputRef.current;
    var value = inputEl.value;

    var _formattedValue = formattedValue(newValue);

    if (value !== _formattedValue) {
      inputEl.value = _formattedValue;
      inputEl.setAttribute('aria-valuenow', newValue);
    }
  };

  var formattedValue = function formattedValue(val) {
    return formatValue(evaluateEmpty(val));
  };

  var concatValues = function concatValues(val1, val2) {
    if (val1 && val2) {
      var decimalCharIndex = val2.search(_decimal.current);
      _decimal.current.lastIndex = 0;
      return decimalCharIndex !== -1 ? val1.split(_decimal.current)[0] + val2.slice(decimalCharIndex) : val1;
    }

    return val1;
  };

  var getDecimalLength = function getDecimalLength(value) {
    if (value) {
      var valueSplit = value.split(_decimal.current);

      if (valueSplit.length === 2) {
        return valueSplit[1].replace(_suffix.current, '').trim().replace(/\s/g, '').replace(_currency.current, '').length;
      }
    }

    return 0;
  };

  var updateModel = function updateModel(event, value) {
    if (props.onValueChange) {
      props.onValueChange({
        originalEvent: event,
        value: value,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        target: {
          name: props.name,
          id: props.id,
          value: value
        }
      });
    }
  };

  var onInputFocus = function onInputFocus(event) {
    setFocusedState(true);
    props.onFocus && props.onFocus(event);
  };

  var onInputBlur = function onInputBlur(event) {
    setFocusedState(false);

    if (inputRef.current) {
      var currentValue = inputRef.current.value;

      if (isValueChanged(currentValue, props.value)) {
        var newValue = validateValue(parseValue(currentValue));
        updateInputValue(newValue);
        updateModel(event, newValue);
      }
    }

    props.onBlur && props.onBlur(event);
  };

  var clearTimer = function clearTimer() {
    if (timer.current) {
      clearInterval(timer.current);
    }
  };

  var changeValue = function changeValue() {
    var newValue = validateValue(props.value);
    updateInputValue(newValue);

    if (props.value !== null && props.value !== newValue) {
      updateModel(null, newValue);
    }
  };

  var getFormatter = function getFormatter() {
    return numberFormat.current;
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getFormatter: getFormatter,
      getElement: function getElement() {
        return elementRef.current;
      },
      getInput: function getInput() {
        return inputRef.current;
      }
    };
  });
  React.useEffect(function () {
    ObjectUtils.combinedRefs(inputRef, props.inputRef);
  }, [inputRef, props.inputRef]);
  useMountEffect(function () {
    constructParser();
    var newValue = validateValue(props.value);

    if (props.value !== null && props.value !== newValue) {
      updateModel(null, newValue);
    }
  });
  useUpdateEffect(function () {
    constructParser();
    changeValue();
  }, [props.locale, props.localeMatcher, props.mode, props.currency, props.currencyDisplay, props.useGrouping, props.minFractionDigits, props.maxFractionDigits, props.suffix, props.prefix]);
  useUpdateEffect(function () {
    changeValue();
  }, [props.value]);

  var createInputElement = function createInputElement() {
    var className = classNames('p-inputnumber-input', props.inputClassName);
    var valueToRender = formattedValue(props.value);
    return /*#__PURE__*/React.createElement(InputText$1, _extends$t({
      ref: inputRef,
      id: props.inputId,
      style: props.inputStyle,
      role: "spinbutton",
      className: className,
      defaultValue: valueToRender,
      type: props.type,
      size: props.size,
      tabIndex: props.tabIndex,
      inputMode: inputMode,
      maxLength: props.maxLength,
      disabled: props.disabled,
      required: props.required,
      pattern: props.pattern,
      placeholder: props.placeholder,
      readOnly: props.readOnly,
      name: props.name,
      autoFocus: props.autoFocus,
      onKeyDown: onInputKeyDown,
      onKeyPress: onInputKeyPress,
      onInput: onInput,
      onClick: onInputClick,
      onBlur: onInputBlur,
      onFocus: onInputFocus,
      onPaste: onPaste,
      min: props.min,
      max: props.max,
      "aria-valuemin": props.min,
      "aria-valuemax": props.max,
      "aria-valuenow": props.value
    }, ariaProps, dataProps));
  };

  var createUpButton = function createUpButton() {
    var className = classNames('p-inputnumber-button p-inputnumber-button-up p-button p-button-icon-only p-component', {
      'p-disabled': props.disabled
    }, props.incrementButtonClassName);
    var icon = classNames('p-button-icon', props.incrementButtonIcon);
    return /*#__PURE__*/React.createElement("button", {
      type: "button",
      className: className,
      onMouseLeave: onUpButtonMouseLeave,
      onMouseDown: onUpButtonMouseDown,
      onMouseUp: onUpButtonMouseUp,
      onKeyDown: onUpButtonKeyDown,
      onKeyUp: onUpButtonKeyUp,
      onTouchStart: onUpButtonTouchStart,
      onTouchEnd: onUpButtonTouchEnd,
      disabled: props.disabled,
      tabIndex: -1
    }, /*#__PURE__*/React.createElement("span", {
      className: icon
    }), /*#__PURE__*/React.createElement(Ripple, null));
  };

  var createDownButton = function createDownButton() {
    var className = classNames('p-inputnumber-button p-inputnumber-button-down p-button p-button-icon-only p-component', {
      'p-disabled': props.disabled
    }, props.decrementButtonClassName);
    var icon = classNames('p-button-icon', props.decrementButtonIcon);
    return /*#__PURE__*/React.createElement("button", {
      type: "button",
      className: className,
      onMouseLeave: onDownButtonMouseLeave,
      onMouseDown: onDownButtonMouseDown,
      onMouseUp: onDownButtonMouseUp,
      onKeyDown: onDownButtonKeyDown,
      onKeyUp: onDownButtonKeyUp,
      onTouchStart: onDownButtonTouchStart,
      onTouchEnd: onDownButtonTouchEnd,
      disabled: props.disabled,
      tabIndex: -1
    }, /*#__PURE__*/React.createElement("span", {
      className: icon
    }), /*#__PURE__*/React.createElement(Ripple, null));
  };

  var createButtonGroup = function createButtonGroup() {
    var upButton = props.showButtons && createUpButton();
    var downButton = props.showButtons && createDownButton();

    if (stacked) {
      return /*#__PURE__*/React.createElement("span", {
        className: "p-inputnumber-button-group"
      }, upButton, downButton);
    }

    return /*#__PURE__*/React.createElement(React.Fragment, null, upButton, downButton);
  };

  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, InputNumber$1.defaultProps);
  var dataProps = ObjectUtils.reduceKeys(otherProps, DomHandler.DATA_PROPS);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var className = classNames('p-inputnumber p-component p-inputwrapper', {
    'p-inputwrapper-filled': props.value != null && props.value.toString().length > 0,
    'p-inputwrapper-focus': focusedState,
    'p-inputnumber-buttons-stacked': stacked,
    'p-inputnumber-buttons-horizontal': horizontal,
    'p-inputnumber-buttons-vertical': vertical
  }, props.className);
  var inputElement = createInputElement();
  var buttonGroup = createButtonGroup();
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", _extends$t({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style
  }, otherProps), inputElement, buttonGroup), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$t({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
InputNumber$1.displayName = 'InputNumber';
InputNumber$1.defaultProps = {
  __TYPE: 'InputNumber',
  allowEmpty: true,
  ariaLabelledBy: null,
  autoFocus: false,
  buttonLayout: 'stacked',
  className: null,
  currency: undefined,
  currencyDisplay: undefined,
  decrementButtonClassName: null,
  decrementButtonIcon: 'pi pi-angle-down',
  disabled: false,
  format: true,
  id: null,
  incrementButtonClassName: null,
  incrementButtonIcon: 'pi pi-angle-up',
  inputClassName: null,
  inputId: null,
  inputMode: null,
  inputRef: null,
  inputStyle: null,
  locale: undefined,
  localeMatcher: undefined,
  max: null,
  maxFractionDigits: undefined,
  min: null,
  minFractionDigits: undefined,
  mode: 'decimal',
  name: null,
  onBlur: null,
  onChange: null,
  onFocus: null,
  onKeyDown: null,
  onValueChange: null,
  pattern: null,
  placeholder: null,
  prefix: null,
  readOnly: false,
  required: false,
  showButtons: false,
  size: null,
  step: 1,
  style: null,
  suffix: null,
  tabIndex: null,
  tooltip: null,
  tooltipOptions: null,
  type: 'text',
  useGrouping: true,
  value: null
};

function _extends$s() {
  _extends$s = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$s.apply(this, arguments);
}

function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _arrayWithHoles$j(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$j(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$n(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$n(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$n(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$n(o, minLen);
}

function _nonIterableRest$j() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$j(arr, i) {
  return _arrayWithHoles$j(arr) || _iterableToArrayLimit$j(arr, i) || _unsupportedIterableToArray$n(arr, i) || _nonIterableRest$j();
}

function ownKeys$b(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$b(Object(source), !0).forEach(function (key) {
      _defineProperty$b(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var VirtualScroller = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var vertical = props.orientation === 'vertical';
  var horizontal = props.orientation === 'horizontal';
  var both = props.orientation === 'both';

  var _React$useState = React.useState(both ? {
    rows: 0,
    cols: 0
  } : 0),
      _React$useState2 = _slicedToArray$j(_React$useState, 2),
      firstState = _React$useState2[0],
      setFirstState = _React$useState2[1];

  var _React$useState3 = React.useState(both ? {
    rows: 0,
    cols: 0
  } : 0),
      _React$useState4 = _slicedToArray$j(_React$useState3, 2),
      lastState = _React$useState4[0],
      setLastState = _React$useState4[1];

  var _React$useState5 = React.useState(both ? {
    rows: 0,
    cols: 0
  } : 0),
      _React$useState6 = _slicedToArray$j(_React$useState5, 2),
      numItemsInViewportState = _React$useState6[0],
      setNumItemsInViewportState = _React$useState6[1];

  var _React$useState7 = React.useState(props.numToleratedItems),
      _React$useState8 = _slicedToArray$j(_React$useState7, 2),
      numToleratedItemsState = _React$useState8[0],
      setNumToleratedItemsState = _React$useState8[1];

  var _React$useState9 = React.useState(props.loading || false),
      _React$useState10 = _slicedToArray$j(_React$useState9, 2),
      loadingState = _React$useState10[0],
      setLoadingState = _React$useState10[1];

  var _React$useState11 = React.useState([]),
      _React$useState12 = _slicedToArray$j(_React$useState11, 2),
      loaderArrState = _React$useState12[0],
      setLoaderArrState = _React$useState12[1];

  var elementRef = React.useRef(null);

  var _contentRef = React.useRef(null);

  var _spacerRef = React.useRef(null);

  var _stickyRef = React.useRef(null);

  var lastScrollPos = React.useRef(both ? {
    top: 0,
    left: 0
  } : 0);
  var scrollTimeout = React.useRef(null);
  var resizeTimeout = React.useRef(null);
  var defaultWidth = React.useRef(null);
  var defaultHeight = React.useRef(null);
  var prevItems = usePrevious(props.items);
  var prevLoading = usePrevious(props.loading);

  var _useResizeListener = useResizeListener({
    listener: function listener(event) {
      return onResize();
    }
  }),
      _useResizeListener2 = _slicedToArray$j(_useResizeListener, 1),
      bindWindowResizeListener = _useResizeListener2[0];

  var _useEventListener = useEventListener({
    target: 'window',
    type: 'orientationchange',
    listener: function listener(event) {
      return onResize();
    }
  }),
      _useEventListener2 = _slicedToArray$j(_useEventListener, 1),
      bindOrientationChangeListener = _useEventListener2[0];

  var getElementRef = function getElementRef() {
    return elementRef;
  };

  var scrollTo = function scrollTo(options) {
    lastScrollPos.current = both ? {
      top: 0,
      left: 0
    } : 0;
    elementRef.current && elementRef.current.scrollTo(options);
  };

  var scrollToIndex = function scrollToIndex(index) {
    var behavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';

    var _calculateNumItems = calculateNumItems(),
        numToleratedItems = _calculateNumItems.numToleratedItems;

    var calculateFirst = function calculateFirst() {
      var _index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var _numT = arguments.length > 1 ? arguments[1] : undefined;

      return _index <= _numT ? 0 : _index;
    };

    var calculateCoord = function calculateCoord(_first, _size) {
      return _first * _size;
    };

    var scrollToItem = function scrollToItem() {
      var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return scrollTo({
        left: left,
        top: top,
        behavior: behavior
      });
    };

    if (both) {
      var newFirst = {
        rows: calculateFirst(index[0], numToleratedItems[0]),
        cols: calculateFirst(index[1], numToleratedItems[1])
      };

      if (newFirst.rows !== firstState.rows || newFirst.cols !== firstState.cols) {
        scrollToItem(calculateCoord(newFirst.cols, props.itemSize[1]), calculateCoord(newFirst.rows, props.itemSize[0]));
      }
    } else {
      var _newFirst = calculateFirst(index, numToleratedItems);

      if (_newFirst !== firstState) {
        horizontal ? scrollToItem(calculateCoord(_newFirst, props.itemSize), 0) : scrollToItem(0, calculateCoord(_newFirst, props.itemSize));
      }
    }
  };

  var scrollInView = function scrollInView(index, to) {
    var behavior = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'auto';

    if (to) {
      var _getRenderedRange = getRenderedRange(),
          first = _getRenderedRange.first,
          viewport = _getRenderedRange.viewport;

      var scrollToItem = function scrollToItem() {
        var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return scrollTo({
          left: left,
          top: top,
          behavior: behavior
        });
      };

      var isToStart = to === 'to-start';
      var isToEnd = to === 'to-end';

      if (isToStart) {
        if (both) {
          if (viewport.first.rows - first.rows > index[0]) {
            scrollToItem(viewport.first.cols * props.itemSize[1], (viewport.first.rows - 1) * props.itemSize[0]);
          } else if (viewport.first.cols - first.cols > index[1]) {
            scrollToItem((viewport.first.cols - 1) * props.itemSize[1], viewport.first.rows * props.itemSize[0]);
          }
        } else {
          if (viewport.first - first > index) {
            var pos = (viewport.first - 1) * props.itemSize;
            horizontal ? scrollToItem(pos, 0) : scrollToItem(0, pos);
          }
        }
      } else if (isToEnd) {
        if (both) {
          if (viewport.last.rows - first.rows <= index[0] + 1) {
            scrollToItem(viewport.first.cols * props.itemSize[1], (viewport.first.rows + 1) * props.itemSize[0]);
          } else if (viewport.last.cols - first.cols <= index[1] + 1) {
            scrollToItem((viewport.first.cols + 1) * props.itemSize[1], viewport.first.rows * props.itemSize[0]);
          }
        } else {
          if (viewport.last - first <= index + 1) {
            var _pos2 = (viewport.first + 1) * props.itemSize;

            horizontal ? scrollToItem(_pos2, 0) : scrollToItem(0, _pos2);
          }
        }
      }
    } else {
      scrollToIndex(index, behavior);
    }
  };

  var getRows = function getRows() {
    return loadingState ? props.loaderDisabled ? loaderArrState : [] : loadedItems();
  };

  var getColumns = function getColumns() {
    if (props.columns && both || horizontal) {
      return loadingState && props.loaderDisabled ? both ? loaderArrState[0] : loaderArrState : props.columns.slice(both ? firstState.cols : firstState, both ? lastState.cols : lastState);
    }

    return props.columns;
  };

  var getRenderedRange = function getRenderedRange() {
    var calculateFirstInViewport = function calculateFirstInViewport(_pos, _size) {
      return Math.floor(_pos / (_size || _pos));
    };

    var firstInViewport = firstState;
    var lastInViewport = 0;

    if (elementRef.current) {
      var _elementRef$current = elementRef.current,
          scrollTop = _elementRef$current.scrollTop,
          scrollLeft = _elementRef$current.scrollLeft;

      if (both) {
        firstInViewport = {
          rows: calculateFirstInViewport(scrollTop, props.itemSize[0]),
          cols: calculateFirstInViewport(scrollLeft, props.itemSize[1])
        };
        lastInViewport = {
          rows: firstInViewport.rows + numItemsInViewportState.rows,
          cols: firstInViewport.cols + numItemsInViewportState.cols
        };
      } else {
        var scrollPos = horizontal ? scrollLeft : scrollTop;
        firstInViewport = calculateFirstInViewport(scrollPos, props.itemSize);
        lastInViewport = firstInViewport + numItemsInViewportState;
      }
    }

    return {
      first: firstState,
      last: lastState,
      viewport: {
        first: firstInViewport,
        last: lastInViewport
      }
    };
  };

  var calculateNumItems = function calculateNumItems() {
    var contentPos = getContentPosition();
    var contentWidth = elementRef.current ? elementRef.current.offsetWidth - contentPos.left : 0;
    var contentHeight = elementRef.current ? elementRef.current.offsetHeight - contentPos.top : 0;

    var calculateNumItemsInViewport = function calculateNumItemsInViewport(_contentSize, _itemSize) {
      return Math.ceil(_contentSize / (_itemSize || _contentSize));
    };

    var calculateNumToleratedItems = function calculateNumToleratedItems(_numItems) {
      return Math.ceil(_numItems / 2);
    };

    var numItemsInViewport = both ? {
      rows: calculateNumItemsInViewport(contentHeight, props.itemSize[0]),
      cols: calculateNumItemsInViewport(contentWidth, props.itemSize[1])
    } : calculateNumItemsInViewport(horizontal ? contentWidth : contentHeight, props.itemSize);
    var numToleratedItems = numToleratedItemsState || (both ? [calculateNumToleratedItems(numItemsInViewport.rows), calculateNumToleratedItems(numItemsInViewport.cols)] : calculateNumToleratedItems(numItemsInViewport));
    return {
      numItemsInViewport: numItemsInViewport,
      numToleratedItems: numToleratedItems
    };
  };

  var calculateOptions = function calculateOptions() {
    var _calculateNumItems2 = calculateNumItems(),
        numItemsInViewport = _calculateNumItems2.numItemsInViewport,
        numToleratedItems = _calculateNumItems2.numToleratedItems;

    var calculateLast = function calculateLast(_first, _num, _numT, _isCols) {
      return getLast(_first + _num + (_first < _numT ? 2 : 3) * _numT, _isCols);
    };

    var last = both ? {
      rows: calculateLast(firstState.rows, numItemsInViewport.rows, numToleratedItems[0]),
      cols: calculateLast(firstState.cols, numItemsInViewport.cols, numToleratedItems[1], true)
    } : calculateLast(firstState, numItemsInViewport, numToleratedItems);
    setNumItemsInViewportState(numItemsInViewport);
    setNumToleratedItemsState(numToleratedItems);
    setLastState(last);

    if (props.showLoader) {
      setLoaderArrState(both ? Array.from({
        length: numItemsInViewport.rows
      }).map(function () {
        return Array.from({
          length: numItemsInViewport.cols
        });
      }) : Array.from({
        length: numItemsInViewport
      }));
    }

    if (props.lazy) {
      props.onLazyLoad && props.onLazyLoad({
        first: firstState,
        last: last
      });
    }
  };

  var calculateAutoSize = function calculateAutoSize(loading) {
    if (props.autoSize && !loading) {
      Promise.resolve().then(function () {
        if (_contentRef.current) {
          _contentRef.current.style.minHeight = _contentRef.current.style.minWidth = 'auto';
          var _contentRef$current = _contentRef.current,
              offsetWidth = _contentRef$current.offsetWidth,
              offsetHeight = _contentRef$current.offsetHeight;
          (both || horizontal) && (elementRef.current.style.width = (offsetWidth < defaultWidth.current ? offsetWidth : defaultWidth.current) + 'px');
          (both || vertical) && (elementRef.current.style.height = (offsetHeight < defaultHeight.current ? offsetHeight : defaultHeight.current) + 'px');
          _contentRef.current.style.minHeight = _contentRef.current.style.minWidth = '';
        }
      });
    }
  };

  var getLast = function getLast() {
    var last = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var isCols = arguments.length > 1 ? arguments[1] : undefined;
    return props.items ? Math.min(isCols ? (props.columns || props.items[0]).length : props.items.length, last) : 0;
  };

  var getContentPosition = function getContentPosition() {
    if (_contentRef.current) {
      var style = getComputedStyle(_contentRef.current);
      var left = parseInt(style.paddingLeft, 10) + Math.max(parseInt(style.left, 10), 0);
      var right = parseInt(style.paddingRight, 10) + Math.max(parseInt(style.right, 10), 0);
      var top = parseInt(style.paddingTop, 10) + Math.max(parseInt(style.top, 10), 0);
      var bottom = parseInt(style.paddingBottom, 10) + Math.max(parseInt(style.bottom, 10), 0);
      return {
        left: left,
        right: right,
        top: top,
        bottom: bottom,
        x: left + right,
        y: top + bottom
      };
    }

    return {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      x: 0,
      y: 0
    };
  };

  var setSize = function setSize() {
    if (elementRef.current) {
      var parentElement = elementRef.current.parentElement;
      var width = props.scrollWidth || "".concat(elementRef.current.offsetWidth || parentElement.offsetWidth, "px");
      var height = props.scrollHeight || "".concat(elementRef.current.offsetHeight || parentElement.offsetHeight, "px");

      var setProp = function setProp(_name, _value) {
        return elementRef.current.style[_name] = _value;
      };

      if (both || horizontal) {
        setProp('height', height);
        setProp('width', width);
      } else {
        setProp('height', height);
      }
    }
  };

  var setSpacerSize = function setSpacerSize() {
    var items = props.items;

    if (_spacerRef.current && items) {
      var contentPos = getContentPosition();

      var setProp = function setProp(_name, _value, _size) {
        var _cpos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        return _spacerRef.current.style[_name] = (_value || []).length * _size + _cpos + 'px';
      };

      if (both) {
        setProp('height', items, props.itemSize[0], contentPos.y);
        setProp('width', props.columns || items[1], props.itemSize[1], contentPos.x);
      } else {
        horizontal ? setProp('width', props.columns || items, props.itemSize, contentPos.x) : setProp('height', items, props.itemSize, contentPos.y);
      }
    }
  };

  var setContentPosition = function setContentPosition(pos) {
    if (_contentRef.current) {
      var first = pos ? pos.first : firstState;

      var calculateTranslateVal = function calculateTranslateVal(_first, _size) {
        return _first * _size;
      };

      var setTransform = function setTransform() {
        var _x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        var _y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        _stickyRef.current && (_stickyRef.current.style.top = "-".concat(_y, "px"));
        _contentRef.current.style.transform = "translate3d(".concat(_x, "px, ").concat(_y, "px, 0)");
      };

      if (both) {
        setTransform(calculateTranslateVal(first.cols, props.itemSize[1]), calculateTranslateVal(first.rows, props.itemSize[0]));
      } else {
        var translateVal = calculateTranslateVal(first, props.itemSize);
        horizontal ? setTransform(translateVal, 0) : setTransform(0, translateVal);
      }
    }
  };

  var onScrollPositionChange = function onScrollPositionChange(event) {
    var target = event.target;
    var contentPos = getContentPosition();

    var calculateScrollPos = function calculateScrollPos(_pos, _cpos) {
      return _pos ? _pos > _cpos ? _pos - _cpos : _pos : 0;
    };

    var calculateCurrentIndex = function calculateCurrentIndex(_pos, _size) {
      return Math.floor(_pos / (_size || _pos));
    };

    var calculateTriggerIndex = function calculateTriggerIndex(_currentIndex, _first, _last, _num, _numT, _isScrollDownOrRight) {
      return _currentIndex <= _numT ? _numT : _isScrollDownOrRight ? _last - _num - _numT : _first + _numT - 1;
    };

    var calculateFirst = function calculateFirst(_currentIndex, _triggerIndex, _first, _last, _num, _numT, _isScrollDownOrRight) {
      if (_currentIndex <= _numT) return 0;else return Math.max(0, _isScrollDownOrRight ? _currentIndex < _triggerIndex ? _first : _currentIndex - _numT : _currentIndex > _triggerIndex ? _first : _currentIndex - 2 * _numT);
    };

    var calculateLast = function calculateLast(_currentIndex, _first, _last, _num, _numT, _isCols) {
      var lastValue = _first + _num + 2 * _numT;

      if (_currentIndex >= _numT) {
        lastValue += _numT + 1;
      }

      return getLast(lastValue, _isCols);
    };

    var scrollTop = calculateScrollPos(target.scrollTop, contentPos.top);
    var scrollLeft = calculateScrollPos(target.scrollLeft, contentPos.left);
    var newFirst = both ? {
      rows: 0,
      cols: 0
    } : 0;
    var newLast = lastState;
    var isRangeChanged = false;
    var newScrollPos = lastScrollPos.current;

    if (both) {
      var isScrollDown = lastScrollPos.current.top <= scrollTop;
      var isScrollRight = lastScrollPos.current.left <= scrollLeft;
      var currentIndex = {
        rows: calculateCurrentIndex(scrollTop, props.itemSize[0]),
        cols: calculateCurrentIndex(scrollLeft, props.itemSize[1])
      };
      var triggerIndex = {
        rows: calculateTriggerIndex(currentIndex.rows, firstState.rows, lastState.rows, numItemsInViewportState.rows, numToleratedItemsState[0], isScrollDown),
        cols: calculateTriggerIndex(currentIndex.cols, firstState.cols, lastState.cols, numItemsInViewportState.cols, numToleratedItemsState[1], isScrollRight)
      };
      newFirst = {
        rows: calculateFirst(currentIndex.rows, triggerIndex.rows, firstState.rows, lastState.rows, numItemsInViewportState.rows, numToleratedItemsState[0], isScrollDown),
        cols: calculateFirst(currentIndex.cols, triggerIndex.cols, firstState.cols, lastState.cols, numItemsInViewportState.cols, numToleratedItemsState[1], isScrollRight)
      };
      newLast = {
        rows: calculateLast(currentIndex.rows, newFirst.rows, lastState.rows, numItemsInViewportState.rows, numToleratedItemsState[0]),
        cols: calculateLast(currentIndex.cols, newFirst.cols, lastState.cols, numItemsInViewportState.cols, numToleratedItemsState[1], true)
      };
      isRangeChanged = newFirst.rows !== firstState.rows || newLast.rows !== lastState.rows || newFirst.cols !== firstState.cols || newLast.cols !== lastState.cols;
      newScrollPos = {
        top: scrollTop,
        left: scrollLeft
      };
    } else {
      var scrollPos = horizontal ? scrollLeft : scrollTop;
      var isScrollDownOrRight = lastScrollPos.current <= scrollPos;

      var _currentIndex2 = calculateCurrentIndex(scrollPos, props.itemSize);

      var _triggerIndex2 = calculateTriggerIndex(_currentIndex2, firstState, lastState, numItemsInViewportState, numToleratedItemsState, isScrollDownOrRight);

      newFirst = calculateFirst(_currentIndex2, _triggerIndex2, firstState, lastState, numItemsInViewportState, numToleratedItemsState, isScrollDownOrRight);
      newLast = calculateLast(_currentIndex2, newFirst, lastState, numItemsInViewportState, numToleratedItemsState);
      isRangeChanged = newFirst !== firstState || newLast !== lastState;
      newScrollPos = scrollPos;
    }

    return {
      first: newFirst,
      last: newLast,
      isRangeChanged: isRangeChanged,
      scrollPos: newScrollPos
    };
  };

  var onScrollChange = function onScrollChange(event) {
    var _onScrollPositionChan = onScrollPositionChange(event),
        first = _onScrollPositionChan.first,
        last = _onScrollPositionChan.last,
        isRangeChanged = _onScrollPositionChan.isRangeChanged,
        scrollPos = _onScrollPositionChan.scrollPos;

    if (isRangeChanged) {
      var newState = {
        first: first,
        last: last
      };
      setContentPosition(newState);
      setFirstState(first);
      setLastState(last);
      lastScrollPos.current = scrollPos;
      props.onScrollIndexChange && props.onScrollIndexChange(newState);

      if (props.lazy) {
        props.onLazyLoad && props.onLazyLoad(newState);
      }
    }
  };

  var onScroll = function onScroll(event) {
    props.onScroll && props.onScroll(event);

    if (props.delay) {
      if (scrollTimeout.current) {
        clearTimeout(scrollTimeout.current);
      }

      if (!loadingState && props.showLoader) {
        var _onScrollPositionChan2 = onScrollPositionChange(event),
            changed = _onScrollPositionChan2.isRangeChanged;

        changed && setLoadingState(true);
      }

      scrollTimeout.current = setTimeout(function () {
        onScrollChange(event);

        if (loadingState && props.showLoader && (!props.lazy || props.loading === undefined)) {
          setLoadingState(false);
        }
      }, props.delay);
    } else {
      onScrollChange(event);
    }
  };

  var onResize = function onResize() {
    if (resizeTimeout.current) {
      clearTimeout(resizeTimeout.current);
    }

    resizeTimeout.current = setTimeout(function () {
      if (elementRef.current) {
        var _ref = [DomHandler.getWidth(elementRef.current), DomHandler.getHeight(elementRef.current)],
            width = _ref[0],
            height = _ref[1];
        var isDiffWidth = width !== defaultWidth.current,
            isDiffHeight = height !== defaultHeight.current;
        var reinit = both ? isDiffWidth || isDiffHeight : horizontal ? isDiffWidth : vertical ? isDiffHeight : false;

        if (reinit) {
          setNumToleratedItemsState(props.numToleratedItems);
          defaultWidth.current = width;
          defaultHeight.current = height;
        }
      }
    }, props.resizeDelay);
  };

  var getOptions = function getOptions(renderedIndex) {
    var count = (props.items || []).length;
    var index = both ? firstState.rows + renderedIndex : firstState + renderedIndex;
    return {
      index: index,
      count: count,
      first: index === 0,
      last: index === count - 1,
      even: index % 2 === 0,
      odd: index % 2 !== 0,
      props: props
    };
  };

  var loaderOptions = function loaderOptions(index, extOptions) {
    var count = loaderArrState.length;
    return _objectSpread$b({
      index: index,
      count: count,
      first: index === 0,
      last: index === count - 1,
      even: index % 2 === 0,
      odd: index % 2 !== 0,
      props: props
    }, extOptions);
  };

  var loadedItems = function loadedItems() {
    var items = props.items;

    if (items && !loadingState) {
      if (both) return items.slice(firstState.rows, lastState.rows).map(function (item) {
        return props.columns ? item : item.slice(firstState.cols, lastState.cols);
      });else if (horizontal && props.columns) return items;else return items.slice(firstState, lastState);
    }

    return [];
  };

  var init = function init() {
    if (!props.disabled) {
      setSize();
      calculateOptions();
      setSpacerSize();
    }
  };

  useMountEffect(function () {
    if (!props.disabled) {
      init();
      bindWindowResizeListener();
      bindOrientationChangeListener();
      defaultWidth.current = DomHandler.getWidth(elementRef.current);
      defaultHeight.current = DomHandler.getHeight(elementRef.current);
    }
  });
  useUpdateEffect(function () {
    init();
  }, [props.itemSize, props.scrollHeight]);
  useUpdateEffect(function () {
    if (props.numToleratedItems !== numToleratedItemsState) {
      setNumToleratedItemsState(props.numToleratedItems);
    }
  }, [props.numToleratedItems]);
  useUpdateEffect(function () {
    if (props.numToleratedItems === numToleratedItemsState) {
      init(); // reinit after resizing
    }
  }, [numToleratedItemsState]);
  useUpdateEffect(function () {
    if (!prevItems || prevItems.length !== (props.items || []).length) {
      init();
    }

    var loading = loadingState;

    if (props.lazy && prevLoading !== props.loading && props.loading !== loadingState) {
      setLoadingState(props.loading);
      loading = props.loading;
    }

    calculateAutoSize(loading);
  });
  useUpdateEffect(function () {
    lastScrollPos.current = both ? {
      top: 0,
      left: 0
    } : 0;
  }, [props.orientation]);
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElementRef: getElementRef,
      scrollTo: scrollTo,
      scrollToIndex: scrollToIndex,
      scrollInView: scrollInView,
      getRenderedRange: getRenderedRange
    };
  });

  var createLoaderItem = function createLoaderItem(index) {
    var extOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var options = loaderOptions(index, extOptions);
    var content = ObjectUtils.getJSXElement(props.loadingTemplate, options);
    return /*#__PURE__*/React.createElement(React.Fragment, {
      key: index
    }, content);
  };

  var createLoader = function createLoader() {
    if (!props.loaderDisabled && props.showLoader && loadingState) {
      var className = classNames('p-virtualscroller-loader', {
        'p-component-overlay': !props.loadingTemplate
      });
      var content = /*#__PURE__*/React.createElement("i", {
        className: "p-virtualscroller-loading-icon pi pi-spinner pi-spin"
      });

      if (props.loadingTemplate) {
        content = loaderArrState.map(function (_, index) {
          return createLoaderItem(index, both && {
            numCols: numItemsInViewportState.cols
          });
        });
      } else if (props.loaderIconTemplate) {
        var defaultContentOptions = {
          className: 'p-virtualscroller-loading-icon',
          element: content,
          props: props
        };
        content = ObjectUtils.getJSXElement(props.loaderIconTemplate, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement("div", {
        className: className
      }, content);
    }

    return null;
  };

  var createSpacer = function createSpacer() {
    if (props.showSpacer) {
      return /*#__PURE__*/React.createElement("div", {
        ref: _spacerRef,
        className: "p-virtualscroller-spacer"
      });
    }

    return null;
  };

  var createItem = function createItem(item, index) {
    var options = getOptions(index);
    var content = ObjectUtils.getJSXElement(props.itemTemplate, item, options);
    return /*#__PURE__*/React.createElement(React.Fragment, {
      key: options.index
    }, content);
  };

  var createItems = function createItems() {
    var items = loadedItems();
    return items.map(createItem);
  };

  var createContent = function createContent() {
    var items = createItems();
    var className = classNames('p-virtualscroller-content', {
      'p-virtualscroller-loading': loadingState
    });
    var content = /*#__PURE__*/React.createElement("div", {
      ref: _contentRef,
      className: className
    }, items);

    if (props.contentTemplate) {
      var defaultOptions = {
        className: className,
        contentRef: function contentRef(el) {
          return _contentRef.current = ObjectUtils.getRefElement(el);
        },
        spacerRef: function spacerRef(el) {
          return _spacerRef.current = ObjectUtils.getRefElement(el);
        },
        stickyRef: function stickyRef(el) {
          return _stickyRef.current = ObjectUtils.getRefElement(el);
        },
        items: loadedItems(),
        getItemOptions: function getItemOptions(index) {
          return getOptions(index);
        },
        children: items,
        element: content,
        props: props,
        loading: loadingState,
        getLoaderOptions: function getLoaderOptions(index, ext) {
          return loaderOptions(index, ext);
        },
        loadingTemplate: props.loadingTemplate,
        itemSize: props.itemSize,
        rows: getRows(),
        columns: getColumns(),
        vertical: vertical,
        horizontal: horizontal,
        both: both
      };
      return ObjectUtils.getJSXElement(props.contentTemplate, defaultOptions);
    }

    return content;
  };

  if (props.disabled) {
    var content = ObjectUtils.getJSXElement(props.contentTemplate, {
      items: props.items,
      rows: props.items,
      columns: props.columns
    });
    return /*#__PURE__*/React.createElement(React.Fragment, null, props.children, content);
  } else {
    var otherProps = ObjectUtils.findDiffKeys(props, VirtualScroller.defaultProps);
    var className = classNames('p-virtualscroller', {
      'p-both-scroll': both,
      'p-horizontal-scroll': horizontal
    }, props.className);
    var loader = createLoader();

    var _content = createContent();

    var spacer = createSpacer();
    return /*#__PURE__*/React.createElement("div", _extends$s({
      ref: elementRef,
      className: className,
      tabIndex: 0,
      style: props.style
    }, otherProps, {
      onScroll: onScroll
    }), _content, spacer, loader);
  }
}));
VirtualScroller.displayName = 'VirtualScroller';
VirtualScroller.defaultProps = {
  __TYPE: 'VirtualScroller',
  id: null,
  style: null,
  className: null,
  items: null,
  itemSize: 0,
  scrollHeight: null,
  scrollWidth: null,
  orientation: 'vertical',
  numToleratedItems: null,
  delay: 0,
  resizeDelay: 10,
  lazy: false,
  disabled: false,
  loaderDisabled: false,
  columns: null,
  loading: undefined,
  autoSize: false,
  showSpacer: true,
  showLoader: false,
  loadingTemplate: null,
  loaderIconTemplate: null,
  itemTemplate: null,
  contentTemplate: null,
  onScroll: null,
  onScrollIndexChange: null,
  onLazyLoad: null
};

function _extends$r() {
  _extends$r = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$r.apply(this, arguments);
}

function _typeof$3(obj) {
  "@babel/helpers - typeof";

  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$3(obj);
}

function _defineProperty$a(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _arrayWithHoles$i(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$i(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$1$5(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$1$5(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$5(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$5(o, minLen);
}

function _nonIterableRest$i() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$i(arr, i) {
  return _arrayWithHoles$i(arr) || _iterableToArrayLimit$i(arr, i) || _unsupportedIterableToArray$1$5(arr, i) || _nonIterableRest$i();
}

var DropdownItem = /*#__PURE__*/React.memo(function (props) {
  var onClick = function onClick(event) {
    if (props.onClick) {
      props.onClick({
        originalEvent: event,
        option: props.option
      });
    }
  };

  var className = classNames('p-dropdown-item', {
    'p-highlight': props.selected,
    'p-disabled': props.disabled,
    'p-dropdown-item-empty': !props.label || props.label.length === 0
  }, props.option && props.option.className);
  var content = props.template ? ObjectUtils.getJSXElement(props.template, props.option) : props.label;
  return /*#__PURE__*/React.createElement("li", {
    className: className,
    style: props.style,
    onClick: onClick,
    "aria-label": props.label,
    key: props.label,
    role: "option",
    "aria-selected": props.selected
  }, content, /*#__PURE__*/React.createElement(Ripple, null));
});
DropdownItem.displayName = 'DropdownItem';

function ownKeys$1$4(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1$4(Object(source), !0).forEach(function (key) {
      _defineProperty$a(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$4(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var DropdownPanel = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var virtualScrollerRef = React.useRef(null);
  var filterInputRef = React.useRef(null);
  var isEmptyFilter = !(props.visibleOptions && props.visibleOptions.length) && props.hasFilter;
  var filterOptions = {
    filter: function filter(e) {
      return onFilterInputChange(e);
    },
    reset: function reset() {
      return props.resetFilter();
    }
  };

  var onEnter = function onEnter() {
    props.onEnter(function () {
      if (virtualScrollerRef.current) {
        var selectedIndex = props.getSelectedOptionIndex();

        if (selectedIndex !== -1) {
          setTimeout(function () {
            return virtualScrollerRef.current.scrollToIndex(selectedIndex);
          }, 0);
        }
      }
    });
  };

  var onEntered = function onEntered() {
    props.onEntered(function () {
      if (props.filter && props.filterInputAutoFocus) {
        DomHandler.focus(filterInputRef.current, false);
      }
    });
  };

  var onFilterInputChange = function onFilterInputChange(event) {
    virtualScrollerRef.current && virtualScrollerRef.current.scrollToIndex(0);
    props.onFilterInputChange && props.onFilterInputChange(event);
  };

  var createGroupChildren = function createGroupChildren(optionGroup, style) {
    var groupChildren = props.getOptionGroupChildren(optionGroup);
    return groupChildren.map(function (option, j) {
      var optionLabel = props.getOptionLabel(option);
      var optionKey = j + '_' + props.getOptionRenderKey(option);
      var disabled = props.isOptionDisabled(option);
      return /*#__PURE__*/React.createElement(DropdownItem, {
        key: optionKey,
        label: optionLabel,
        option: option,
        style: style,
        template: props.itemTemplate,
        selected: props.isSelected(option),
        disabled: disabled,
        onClick: props.onOptionClick
      });
    });
  };

  var createEmptyMessage = function createEmptyMessage(emptyMessage, isFilter) {
    var message = ObjectUtils.getJSXElement(emptyMessage, props) || localeOption$1(isFilter ? 'emptyFilterMessage' : 'emptyMessage');
    return /*#__PURE__*/React.createElement("li", {
      className: "p-dropdown-empty-message"
    }, message);
  };

  var createItem = function createItem(option, index) {
    var scrollerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var style = {
      height: scrollerOptions.props ? scrollerOptions.props.itemSize : undefined
    };

    if (props.optionGroupLabel) {
      var groupContent = props.optionGroupTemplate ? ObjectUtils.getJSXElement(props.optionGroupTemplate, option, index) : props.getOptionGroupLabel(option);
      var groupChildrenContent = createGroupChildren(option, style);
      var key = index + '_' + props.getOptionGroupRenderKey(option);
      return /*#__PURE__*/React.createElement(React.Fragment, {
        key: key
      }, /*#__PURE__*/React.createElement("li", {
        className: "p-dropdown-item-group",
        style: style
      }, groupContent), groupChildrenContent);
    } else {
      var optionLabel = props.getOptionLabel(option);
      var optionKey = index + '_' + props.getOptionRenderKey(option);
      var disabled = props.isOptionDisabled(option);
      return /*#__PURE__*/React.createElement(DropdownItem, {
        key: optionKey,
        label: optionLabel,
        option: option,
        style: style,
        template: props.itemTemplate,
        selected: props.isSelected(option),
        disabled: disabled,
        onClick: props.onOptionClick
      });
    }
  };

  var createItems = function createItems() {
    if (ObjectUtils.isNotEmpty(props.visibleOptions)) {
      return props.visibleOptions.map(createItem);
    } else if (props.hasFilter) {
      return createEmptyMessage(props.emptyFilterMessage, true);
    }

    return createEmptyMessage(props.emptyMessage);
  };

  var createFilterClearIcon = function createFilterClearIcon() {
    if (props.showFilterClear && props.filterValue) {
      var ariaLabel = localeOption$1('clear');
      return /*#__PURE__*/React.createElement("i", {
        className: "p-dropdown-filter-clear-icon pi pi-times",
        "aria-label": ariaLabel,
        onClick: function onClick() {
          return props.onFilterClearIconClick(function () {
            return DomHandler.focus(filterInputRef.current);
          });
        }
      });
    }

    return null;
  };

  var createFilter = function createFilter() {
    if (props.filter) {
      var clearIcon = createFilterClearIcon();
      var containerClassName = classNames('p-dropdown-filter-container', {
        'p-dropdown-clearable-filter': !!clearIcon
      });
      var content = /*#__PURE__*/React.createElement("div", {
        className: containerClassName
      }, /*#__PURE__*/React.createElement("input", {
        ref: filterInputRef,
        type: "text",
        autoComplete: "off",
        className: "p-dropdown-filter p-inputtext p-component",
        placeholder: props.filterPlaceholder,
        onKeyDown: props.onFilterInputKeyDown,
        onChange: onFilterInputChange,
        value: props.filterValue
      }), clearIcon, /*#__PURE__*/React.createElement("i", {
        className: "p-dropdown-filter-icon pi pi-search"
      }));

      if (props.filterTemplate) {
        var defaultContentOptions = {
          className: containerClassName,
          element: content,
          filterOptions: filterOptions,
          filterInputKeyDown: props.onFilterInputKeyDown,
          filterInputChange: onFilterInputChange,
          filterIconClassName: 'p-dropdown-filter-icon pi pi-search',
          clearIcon: clearIcon,
          props: props
        };
        content = ObjectUtils.getJSXElement(props.filterTemplate, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement("div", {
        className: "p-dropdown-header"
      }, content);
    }

    return null;
  };

  var createContent = function createContent() {
    if (props.virtualScrollerOptions) {
      var virtualScrollerProps = _objectSpread$1$4(_objectSpread$1$4({}, props.virtualScrollerOptions), {
        style: _objectSpread$1$4(_objectSpread$1$4({}, props.virtualScrollerOptions.style), {
          height: props.scrollHeight
        }),
        className: classNames('p-dropdown-items-wrapper', props.virtualScrollerOptions.className),
        items: props.visibleOptions,
        autoSize: true,
        onLazyLoad: function onLazyLoad(event) {
          return props.virtualScrollerOptions.onLazyLoad(_objectSpread$1$4(_objectSpread$1$4({}, event), {
            filter: props.filterValue
          }));
        },
        itemTemplate: function itemTemplate(item, options) {
          return item && createItem(item, options.index, options);
        },
        contentTemplate: function contentTemplate(options) {
          var className = classNames('p-dropdown-items', options.className);
          var content = isEmptyFilter ? createEmptyMessage() : options.children;
          return /*#__PURE__*/React.createElement("ul", {
            ref: options.contentRef,
            className: className,
            role: "listbox"
          }, content);
        }
      });

      return /*#__PURE__*/React.createElement(VirtualScroller, _extends$r({
        ref: virtualScrollerRef
      }, virtualScrollerProps));
    } else {
      var items = createItems();
      return /*#__PURE__*/React.createElement("div", {
        className: "p-dropdown-items-wrapper",
        style: {
          maxHeight: props.scrollHeight || 'auto'
        }
      }, /*#__PURE__*/React.createElement("ul", {
        className: "p-dropdown-items",
        role: "listbox"
      }, items));
    }
  };

  var createElement = function createElement() {
    var className = classNames('p-dropdown-panel p-component', props.panelClassName);
    var filter = createFilter();
    var content = createContent();
    return /*#__PURE__*/React.createElement(CSSTransition, {
      nodeRef: ref,
      classNames: "p-connected-overlay",
      "in": props["in"],
      timeout: {
        enter: 120,
        exit: 100
      },
      options: props.transitionOptions,
      unmountOnExit: true,
      onEnter: onEnter,
      onEntering: props.onEntering,
      onEntered: onEntered,
      onExit: props.onExit,
      onExited: props.onExited
    }, /*#__PURE__*/React.createElement("div", {
      ref: ref,
      className: className,
      style: props.panelStyle,
      onClick: props.onClick
    }, filter, content));
  };

  var element = createElement();
  return /*#__PURE__*/React.createElement(Portal, {
    element: element,
    appendTo: props.appendTo
  });
}));
DropdownPanel.displayName = 'DropdownPanel';

function ownKeys$a(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$a(Object(source), !0).forEach(function (key) {
      _defineProperty$a(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createForOfIteratorHelper$8(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$m(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$m(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$m(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$m(o, minLen);
}

function _arrayLikeToArray$m(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var Dropdown$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(''),
      _React$useState2 = _slicedToArray$i(_React$useState, 2),
      filterState = _React$useState2[0],
      setFilterState = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _React$useState4 = _slicedToArray$i(_React$useState3, 2),
      focusedState = _React$useState4[0],
      setFocusedState = _React$useState4[1];

  var _React$useState5 = React.useState(false),
      _React$useState6 = _slicedToArray$i(_React$useState5, 2),
      overlayVisibleState = _React$useState6[0],
      setOverlayVisibleState = _React$useState6[1];

  var elementRef = React.useRef(null);
  var overlayRef = React.useRef(null);
  var inputRef = React.useRef(props.inputRef);
  var focusInputRef = React.useRef(null);
  var searchTimeout = React.useRef(null);
  var searchValue = React.useRef(null);
  var currentSearchChar = React.useRef(null);
  var isLazy = props.virtualScrollerOptions && props.virtualScrollerOptions.lazy;
  var hasFilter = ObjectUtils.isNotEmpty(filterState);
  var appendTo = props.appendTo || PrimeReact$1.appendTo;

  var _useOverlayListener = useOverlayListener({
    target: elementRef,
    overlay: overlayRef,
    listener: function listener(event, _ref) {
      var type = _ref.type,
          valid = _ref.valid;

      if (valid) {
        type === 'outside' ? !isClearClicked(event) && hide() : hide();
      }
    },
    when: overlayVisibleState
  }),
      _useOverlayListener2 = _slicedToArray$i(_useOverlayListener, 2),
      bindOverlayListener = _useOverlayListener2[0],
      unbindOverlayListener = _useOverlayListener2[1];

  var getVisibleOptions = function getVisibleOptions() {
    if (hasFilter && !isLazy) {
      var filterValue = filterState.trim().toLocaleLowerCase(props.filterLocale);
      var searchFields = props.filterBy ? props.filterBy.split(',') : [props.optionLabel || 'label'];

      if (props.optionGroupLabel) {
        var filteredGroups = [];

        var _iterator = _createForOfIteratorHelper$8(props.options),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var optgroup = _step.value;
            var filteredSubOptions = FilterService.filter(getOptionGroupChildren(optgroup), searchFields, filterValue, props.filterMatchMode, props.filterLocale);

            if (filteredSubOptions && filteredSubOptions.length) {
              filteredGroups.push(_objectSpread$a(_objectSpread$a({}, optgroup), {
                items: filteredSubOptions
              }));
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return filteredGroups;
      } else {
        return FilterService.filter(props.options, searchFields, filterValue, props.filterMatchMode, props.filterLocale);
      }
    } else {
      return props.options;
    }
  };

  var isClearClicked = function isClearClicked(event) {
    return DomHandler.hasClass(event.target, 'p-dropdown-clear-icon') || DomHandler.hasClass(event.target, 'p-dropdown-filter-clear-icon');
  };

  var onClick = function onClick(event) {
    if (props.disabled) {
      return;
    }

    if (DomHandler.hasClass(event.target, 'p-dropdown-clear-icon') || event.target.tagName === 'INPUT') {
      return;
    } else if (!overlayRef.current || !(overlayRef.current && overlayRef.current.contains(event.target))) {
      DomHandler.focus(focusInputRef.current);
      overlayVisibleState ? hide() : show();
    }
  };

  var onInputFocus = function onInputFocus(event) {
    if (props.showOnFocus && !overlayVisibleState) {
      show();
    }

    setFocusedState(true);
    props.onFocus && props.onFocus(event);
  };

  var onInputBlur = function onInputBlur(event) {
    setFocusedState(false);

    if (props.onBlur) {
      setTimeout(function () {
        var currentValue = inputRef.current ? inputRef.current.value : undefined;
        props.onBlur({
          originalEvent: event.originalEvent,
          value: currentValue,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: props.name,
            id: props.id,
            value: currentValue
          }
        });
      }, 200);
    }
  };

  var onPanelClick = function onPanelClick(event) {
    OverlayService.emit('overlay-click', {
      originalEvent: event,
      target: elementRef.current
    });
  };

  var onInputKeyDown = function onInputKeyDown(event) {
    switch (event.which) {
      //down
      case 40:
        onDownKey(event);
        break;
      //up

      case 38:
        onUpKey(event);
        break;
      //space and enter

      case 32:
      case 13:
        overlayVisibleState ? hide() : show();
        event.preventDefault();
        break;
      //escape and tab

      case 27:
      case 9:
        hide();
        break;

      default:
        search(event);
        break;
    }
  };

  var onFilterInputKeyDown = function onFilterInputKeyDown(event) {
    switch (event.which) {
      //down
      case 40:
        onDownKey(event);
        break;
      //up

      case 38:
        onUpKey(event);
        break;
      //enter and escape

      case 13:
      case 27:
        hide();
        event.preventDefault();
        break;
    }
  };

  var onUpKey = function onUpKey(event) {
    if (visibleOptions) {
      var prevOption = findPrevOption(getSelectedOptionIndex());

      if (prevOption) {
        selectItem({
          originalEvent: event,
          option: prevOption
        });
      }
    }

    event.preventDefault();
  };

  var onDownKey = function onDownKey(event) {
    if (visibleOptions) {
      if (!overlayVisibleState && event.altKey) {
        show();
      } else {
        var nextOption = findNextOption(getSelectedOptionIndex());

        if (nextOption) {
          selectItem({
            originalEvent: event,
            option: nextOption
          });
        }
      }
    }

    event.preventDefault();
  };

  var findNextOption = function findNextOption(index) {
    if (props.optionGroupLabel) {
      var groupIndex = index === -1 ? 0 : index.group;
      var optionIndex = index === -1 ? -1 : index.option;
      var option = findNextOptionInList(getOptionGroupChildren(visibleOptions[groupIndex]), optionIndex);
      if (option) return option;else if (groupIndex + 1 !== visibleOptions.length) return findNextOption({
        group: groupIndex + 1,
        option: -1
      });else return null;
    }

    return findNextOptionInList(visibleOptions, index);
  };

  var findNextOptionInList = function findNextOptionInList(list, index) {
    var i = index + 1;

    if (i === list.length) {
      return null;
    }

    var option = list[i];
    return isOptionDisabled(option) ? findNextOptionInList(i) : option;
  };

  var findPrevOption = function findPrevOption(index) {
    if (index === -1) {
      return null;
    }

    if (props.optionGroupLabel) {
      var groupIndex = index.group;
      var optionIndex = index.option;
      var option = findPrevOptionInList(getOptionGroupChildren(visibleOptions[groupIndex]), optionIndex);
      if (option) return option;else if (groupIndex > 0) return findPrevOption({
        group: groupIndex - 1,
        option: getOptionGroupChildren(visibleOptions[groupIndex - 1]).length
      });else return null;
    }

    return findPrevOptionInList(visibleOptions, index);
  };

  var findPrevOptionInList = function findPrevOptionInList(list, index) {
    var i = index - 1;

    if (i < 0) {
      return null;
    }

    var option = list[i];
    return isOptionDisabled(option) ? findPrevOption(i) : option;
  };

  var search = function search(event) {
    if (searchTimeout.current) {
      clearTimeout(searchTimeout.current);
    }

    var _char = event.key;

    if (_char === 'Shift' || _char === 'Control' || _char === 'Alt') {
      return;
    }

    if (currentSearchChar.current === _char) searchValue.current = _char;else searchValue.current = searchValue.current ? searchValue.current + _char : _char;
    currentSearchChar.current = _char;

    if (searchValue.current) {
      var searchIndex = getSelectedOptionIndex();
      var newOption = props.optionGroupLabel ? searchOptionInGroup(searchIndex) : searchOption(searchIndex + 1);

      if (newOption) {
        selectItem({
          originalEvent: event,
          option: newOption
        });
      }
    }

    searchTimeout.current = setTimeout(function () {
      searchValue.current = null;
    }, 250);
  };

  var searchOption = function searchOption(index) {
    if (searchValue.current) {
      return searchOptionInRange(index, visibleOptions.length) || searchOptionInRange(0, index);
    }

    return null;
  };

  var searchOptionInRange = function searchOptionInRange(start, end) {
    for (var i = start; i < end; i++) {
      var opt = visibleOptions[i];

      if (matchesSearchValue(opt)) {
        return opt;
      }
    }

    return null;
  };

  var searchOptionInGroup = function searchOptionInGroup(index) {
    var searchIndex = index === -1 ? {
      group: 0,
      option: -1
    } : index;

    for (var i = searchIndex.group; i < visibleOptions.length; i++) {
      var groupOptions = getOptionGroupChildren(visibleOptions[i]);

      for (var j = searchIndex.group === i ? searchIndex.option + 1 : 0; j < groupOptions.length; j++) {
        if (matchesSearchValue(groupOptions[j])) {
          return groupOptions[j];
        }
      }
    }

    for (var _i = 0; _i <= searchIndex.group; _i++) {
      var _groupOptions = getOptionGroupChildren(visibleOptions[_i]);

      for (var _j = 0; _j < (searchIndex.group === _i ? searchIndex.option : _groupOptions.length); _j++) {
        if (matchesSearchValue(_groupOptions[_j])) {
          return _groupOptions[_j];
        }
      }
    }

    return null;
  };

  var matchesSearchValue = function matchesSearchValue(option) {
    var label = getOptionLabel(option);

    if (!label) {
      return false;
    }

    label = label.toLocaleLowerCase(props.filterLocale);
    return label.startsWith(searchValue.current.toLocaleLowerCase(props.filterLocale));
  };

  var onEditableInputChange = function onEditableInputChange(event) {
    if (props.onChange) {
      props.onChange({
        originalEvent: event.originalEvent,
        value: event.target.value,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        target: {
          name: props.name,
          id: props.id,
          value: event.target.value
        }
      });
    }
  };

  var onEditableInputFocus = function onEditableInputFocus(event) {
    setFocusedState(true);
    hide();
    props.onFocus && props.onFocus(event);
  };

  var onOptionClick = function onOptionClick(event) {
    var option = event.option;

    if (!option.disabled) {
      selectItem(event);
      DomHandler.focus(focusInputRef.current);
    }

    hide();
  };

  var onFilterInputChange = function onFilterInputChange(event) {
    var filter = event.target.value;
    setFilterState(filter);

    if (props.onFilter) {
      props.onFilter({
        originalEvent: event,
        filter: filter
      });
    }
  };

  var onFilterClearIconClick = function onFilterClearIconClick(callback) {
    resetFilter(callback);
  };

  var resetFilter = function resetFilter(callback) {
    setFilterState('');
    props.onFilter && props.onFilter({
      filter: ''
    });
    callback && callback();
  };

  var clear = function clear(event) {
    if (props.onChange) {
      props.onChange({
        originalEvent: event,
        value: undefined,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        target: {
          name: props.name,
          id: props.id,
          value: undefined
        }
      });
    }

    updateEditableLabel();
  };

  var selectItem = function selectItem(event) {
    if (selectedOption !== event.option) {
      updateEditableLabel(event.option);
      var optionValue = getOptionValue(event.option);

      if (props.onChange) {
        props.onChange({
          originalEvent: event.originalEvent,
          value: optionValue,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            name: props.name,
            id: props.id,
            value: optionValue
          }
        });
      }
    }
  };

  var getSelectedOptionIndex = function getSelectedOptionIndex(options) {
    options = options || visibleOptions;

    if (props.value != null && options) {
      if (props.optionGroupLabel) {
        for (var i = 0; i < options.length; i++) {
          var selectedOptionIndex = findOptionIndexInList(props.value, getOptionGroupChildren(options[i]));

          if (selectedOptionIndex !== -1) {
            return {
              group: i,
              option: selectedOptionIndex
            };
          }
        }
      } else {
        return findOptionIndexInList(props.value, options);
      }
    }

    return -1;
  };

  var equalityKey = function equalityKey() {
    return props.optionValue ? null : props.dataKey;
  };

  var findOptionIndexInList = function findOptionIndexInList(value, list) {
    var key = equalityKey();
    return list.findIndex(function (item) {
      return ObjectUtils.equals(value, getOptionValue(item), key);
    });
  };

  var isSelected = function isSelected(option) {
    return ObjectUtils.equals(props.value, getOptionValue(option), equalityKey());
  };

  var show = function show() {
    setOverlayVisibleState(true);
  };

  var hide = function hide() {
    setOverlayVisibleState(false);
  };

  var onOverlayEnter = function onOverlayEnter(callback) {
    ZIndexUtils.set('overlay', overlayRef.current, PrimeReact$1.autoZIndex, PrimeReact$1.zIndex['overlay']);
    alignOverlay();
    callback && callback();
  };

  var onOverlayEntered = function onOverlayEntered(callback) {
    callback && callback();
    bindOverlayListener();
    props.onShow && props.onShow();
  };

  var onOverlayExit = function onOverlayExit() {
    unbindOverlayListener();
  };

  var onOverlayExited = function onOverlayExited() {
    if (props.filter && props.resetFilterOnHide) {
      resetFilter();
    }

    ZIndexUtils.clear(overlayRef.current);
    props.onHide && props.onHide();
  };

  var alignOverlay = function alignOverlay() {
    DomHandler.alignOverlay(overlayRef.current, inputRef.current.parentElement, props.appendTo || PrimeReact$1.appendTo);
  };

  var scrollInView = function scrollInView() {
    var highlightItem = DomHandler.findSingle(overlayRef.current, 'li.p-highlight');

    if (highlightItem && highlightItem.scrollIntoView) {
      highlightItem.scrollIntoView({
        block: 'nearest',
        inline: 'nearest'
      });
    }
  };

  var updateEditableLabel = function updateEditableLabel(option) {
    if (inputRef.current) {
      inputRef.current.value = option ? getOptionLabel(option) : props.value || '';
    }
  };

  var getOptionLabel = function getOptionLabel(option) {
    return props.optionLabel ? ObjectUtils.resolveFieldData(option, props.optionLabel) : option && option['label'] !== undefined ? option['label'] : option;
  };

  var getOptionValue = function getOptionValue(option) {
    return props.optionValue ? ObjectUtils.resolveFieldData(option, props.optionValue) : option && option['value'] !== undefined ? option['value'] : option;
  };

  var getOptionRenderKey = function getOptionRenderKey(option) {
    return props.dataKey ? ObjectUtils.resolveFieldData(option, props.dataKey) : getOptionLabel(option);
  };

  var isOptionDisabled = function isOptionDisabled(option) {
    if (props.optionDisabled) {
      return ObjectUtils.isFunction(props.optionDisabled) ? props.optionDisabled(option) : ObjectUtils.resolveFieldData(option, props.optionDisabled);
    }

    return option && option['disabled'] !== undefined ? option['disabled'] : false;
  };

  var getOptionGroupRenderKey = function getOptionGroupRenderKey(optionGroup) {
    return ObjectUtils.resolveFieldData(optionGroup, props.optionGroupLabel);
  };

  var getOptionGroupLabel = function getOptionGroupLabel(optionGroup) {
    return ObjectUtils.resolveFieldData(optionGroup, props.optionGroupLabel);
  };

  var getOptionGroupChildren = function getOptionGroupChildren(optionGroup) {
    return ObjectUtils.resolveFieldData(optionGroup, props.optionGroupChildren);
  };

  var updateInputField = function updateInputField() {
    if (props.editable && inputRef.current) {
      var label = selectedOption ? getOptionLabel(selectedOption) : null;
      var value = label || props.value || '';
      inputRef.current.value = value;
    }
  };

  var getSelectedOption = function getSelectedOption() {
    var index = getSelectedOptionIndex(props.options);
    return index !== -1 ? props.optionGroupLabel ? getOptionGroupChildren(props.options[index.group])[index.option] : props.options[index] : null;
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      show: show,
      hide: hide,
      getElement: function getElement() {
        return elementRef.current;
      },
      getOverlay: function getOverlay() {
        return overlayRef.current;
      },
      getInput: function getInput() {
        return inputRef.current;
      },
      getFocusInput: function getFocusInput() {
        return focusInputRef.current;
      }
    };
  });
  React.useEffect(function () {
    ObjectUtils.combinedRefs(inputRef, props.inputRef);
  }, [inputRef, props.inputRef]);
  useMountEffect(function () {
    if (props.autoFocus) {
      DomHandler.focus(focusInputRef.current, props.autoFocus);
    }
  });
  useUpdateEffect(function () {
    if (overlayVisibleState && props.value) {
      scrollInView();
    }
  }, [overlayVisibleState, props.value]);
  useUpdateEffect(function () {
    if (overlayVisibleState && props.filter) {
      alignOverlay();
    }
  }, [overlayVisibleState, props.filter]);
  useUpdateEffect(function () {
    if (filterState && (!props.options || props.options.length === 0)) {
      setFilterState('');
    }

    updateInputField();

    if (inputRef.current) {
      inputRef.current.selectedIndex = 1;
    }
  });
  useUnmountEffect(function () {
    ZIndexUtils.clear(overlayRef.current);
  });

  var createHiddenSelect = function createHiddenSelect() {
    var option = {
      value: '',
      label: props.placeholder
    };

    if (selectedOption) {
      var optionValue = getOptionValue(selectedOption);
      option = {
        value: _typeof$3(optionValue) === 'object' ? props.options.findIndex(function (o) {
          return o === optionValue;
        }) : optionValue,
        label: getOptionLabel(selectedOption)
      };
    }

    return /*#__PURE__*/React.createElement("div", {
      className: "p-hidden-accessible p-dropdown-hidden-select"
    }, /*#__PURE__*/React.createElement("select", _extends$r({
      ref: inputRef,
      required: props.required,
      defaultValue: option.value,
      name: props.name,
      tabIndex: -1,
      "aria-hidden": "true"
    }, dataProps), /*#__PURE__*/React.createElement("option", {
      value: option.value
    }, option.label)));
  };

  var createKeyboardHelper = function createKeyboardHelper() {
    return /*#__PURE__*/React.createElement("div", {
      className: "p-hidden-accessible"
    }, /*#__PURE__*/React.createElement("input", _extends$r({
      ref: focusInputRef,
      id: props.inputId,
      type: "text",
      readOnly: true,
      "aria-haspopup": "listbox",
      onFocus: onInputFocus,
      onBlur: onInputBlur,
      onKeyDown: onInputKeyDown,
      disabled: props.disabled,
      tabIndex: props.tabIndex
    }, ariaProps)));
  };

  var createLabel = function createLabel() {
    var label = ObjectUtils.isNotEmpty(selectedOption) ? getOptionLabel(selectedOption) : null;

    if (props.editable) {
      var value = label || props.value || '';
      return /*#__PURE__*/React.createElement("input", _extends$r({
        ref: inputRef,
        type: "text",
        defaultValue: value,
        className: "p-dropdown-label p-inputtext",
        disabled: props.disabled,
        placeholder: props.placeholder,
        maxLength: props.maxLength,
        onInput: onEditableInputChange,
        onFocus: onEditableInputFocus,
        onBlur: onInputBlur,
        "aria-haspopup": "listbox"
      }, ariaProps));
    } else {
      var _className = classNames('p-dropdown-label p-inputtext', {
        'p-placeholder': label === null && props.placeholder,
        'p-dropdown-label-empty': label === null && !props.placeholder
      });

      var content = props.valueTemplate ? ObjectUtils.getJSXElement(props.valueTemplate, selectedOption, props) : label || props.placeholder || 'empty';
      return /*#__PURE__*/React.createElement("span", {
        ref: inputRef,
        className: _className
      }, content);
    }
  };

  var createClearIcon = function createClearIcon() {
    if (props.value != null && props.showClear && !props.disabled) {
      return /*#__PURE__*/React.createElement("i", {
        className: "p-dropdown-clear-icon pi pi-times",
        onClick: clear
      });
    }

    return null;
  };

  var createDropdownIcon = function createDropdownIcon() {
    var iconClassName = classNames('p-dropdown-trigger-icon p-clickable', props.dropdownIcon);
    var ariaLabel = props.placeholder || props.ariaLabel;
    return /*#__PURE__*/React.createElement("div", {
      className: "p-dropdown-trigger",
      role: "button",
      "aria-haspopup": "listbox",
      "aria-expanded": overlayVisibleState,
      "aria-label": ariaLabel
    }, /*#__PURE__*/React.createElement("span", {
      className: iconClassName
    }));
  };

  var visibleOptions = getVisibleOptions();
  var selectedOption = getSelectedOption();
  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, Dropdown$1.defaultProps);
  var dataProps = ObjectUtils.reduceKeys(otherProps, DomHandler.DATA_PROPS);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var className = classNames('p-dropdown p-component p-inputwrapper', {
    'p-disabled': props.disabled,
    'p-focus': focusedState,
    'p-dropdown-clearable': props.showClear && !props.disabled,
    'p-inputwrapper-filled': ObjectUtils.isNotEmpty(props.value),
    'p-inputwrapper-focus': focusedState || overlayVisibleState
  }, props.className);
  var hiddenSelect = createHiddenSelect();
  var keyboardHelper = createKeyboardHelper();
  var labelElement = createLabel();
  var dropdownIcon = createDropdownIcon();
  var clearIcon = createClearIcon();
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends$r({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style
  }, otherProps, {
    onClick: onClick,
    onMouseDown: props.onMouseDown,
    onContextMenu: props.onContextMenu
  }), keyboardHelper, hiddenSelect, labelElement, clearIcon, dropdownIcon, /*#__PURE__*/React.createElement(DropdownPanel, _extends$r({
    ref: overlayRef,
    visibleOptions: visibleOptions
  }, props, {
    appendTo: appendTo,
    onClick: onPanelClick,
    onOptionClick: onOptionClick,
    filterValue: filterState,
    hasFilter: hasFilter,
    onFilterClearIconClick: onFilterClearIconClick,
    resetFilter: resetFilter,
    onFilterInputKeyDown: onFilterInputKeyDown,
    onFilterInputChange: onFilterInputChange,
    getOptionLabel: getOptionLabel,
    getOptionRenderKey: getOptionRenderKey,
    isOptionDisabled: isOptionDisabled,
    getOptionGroupChildren: getOptionGroupChildren,
    getOptionGroupLabel: getOptionGroupLabel,
    getOptionGroupRenderKey: getOptionGroupRenderKey,
    isSelected: isSelected,
    getSelectedOptionIndex: getSelectedOptionIndex,
    "in": overlayVisibleState,
    onEnter: onOverlayEnter,
    onEntered: onOverlayEntered,
    onExit: onOverlayExit,
    onExited: onOverlayExited
  }))), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$r({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
Dropdown$1.displayName = 'Dropdown';
Dropdown$1.defaultProps = {
  __TYPE: 'Dropdown',
  appendTo: null,
  ariaLabel: null,
  ariaLabelledBy: null,
  autoFocus: false,
  className: null,
  dataKey: null,
  disabled: false,
  dropdownIcon: 'pi pi-chevron-down',
  editable: false,
  emptyFilterMessage: null,
  emptyMessage: null,
  filter: false,
  filterBy: null,
  filterInputAutoFocus: true,
  filterLocale: undefined,
  filterMatchMode: 'contains',
  filterPlaceholder: null,
  filterTemplate: null,
  id: null,
  inputId: null,
  inputRef: null,
  itemTemplate: null,
  maxLength: null,
  name: null,
  onBlur: null,
  onChange: null,
  onContextMenu: null,
  onFilter: null,
  onFocus: null,
  onHide: null,
  onMouseDown: null,
  onShow: null,
  optionDisabled: null,
  optionGroupChildren: null,
  optionGroupLabel: null,
  optionGroupTemplate: null,
  optionLabel: null,
  optionValue: null,
  options: null,
  panelClassName: null,
  panelStyle: null,
  placeholder: null,
  required: false,
  resetFilterOnHide: false,
  scrollHeight: '200px',
  showClear: false,
  showFilterClear: false,
  showOnFocus: false,
  style: null,
  tabIndex: null,
  tooltip: null,
  tooltipOptions: null,
  transitionOptions: null,
  value: null,
  valueTemplate: null,
  virtualScrollerOptions: null
};

function _extends$q() {
  _extends$q = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$q.apply(this, arguments);
}

function _arrayWithHoles$h(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$h(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$l(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$l(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$l(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$l(o, minLen);
}

function _nonIterableRest$h() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$h(arr, i) {
  return _arrayWithHoles$h(arr) || _iterableToArrayLimit$h(arr, i) || _unsupportedIterableToArray$l(arr, i) || _nonIterableRest$h();
}

function _typeof$2(obj) {
  "@babel/helpers - typeof";

  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$2(obj);
}

function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$9(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$9(Object(source), !0).forEach(function (key) {
      _defineProperty$9(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var CurrentPageReport = /*#__PURE__*/React.memo(function (props) {
  var report = {
    currentPage: props.page + 1,
    totalPages: props.pageCount,
    first: Math.min(props.first + 1, props.totalRecords),
    last: Math.min(props.first + props.rows, props.totalRecords),
    rows: props.rows,
    totalRecords: props.totalRecords
  };
  var text = props.reportTemplate.replace('{currentPage}', report.currentPage).replace('{totalPages}', report.totalPages).replace('{first}', report.first).replace('{last}', report.last).replace('{rows}', report.rows).replace('{totalRecords}', report.totalRecords);
  var element = /*#__PURE__*/React.createElement("span", {
    className: "p-paginator-current"
  }, text);

  if (props.template) {
    var defaultOptions = _objectSpread$9(_objectSpread$9({}, report), {
      className: 'p-paginator-current',
      element: element,
      props: props
    });

    return ObjectUtils.getJSXElement(props.template, defaultOptions);
  }

  return element;
});
CurrentPageReport.displayName = 'CurrentPageReport';
CurrentPageReport.defaultProps = {
  __TYPE: 'CurrentPageReport',
  pageCount: null,
  page: null,
  first: null,
  rows: null,
  totalRecords: null,
  reportTemplate: '({currentPage} of {totalPages})',
  template: null
};
var FirstPageLink = /*#__PURE__*/React.memo(function (props) {
  var className = classNames('p-paginator-first p-paginator-element p-link', {
    'p-disabled': props.disabled
  });
  var iconClassName = 'p-paginator-icon pi pi-angle-double-left';
  var element = /*#__PURE__*/React.createElement("button", {
    type: "button",
    className: className,
    onClick: props.onClick,
    disabled: props.disabled,
    "aria-label": ariaLabel('firstPageLabel')
  }, /*#__PURE__*/React.createElement("span", {
    className: iconClassName
  }), /*#__PURE__*/React.createElement(Ripple, null));

  if (props.template) {
    var defaultOptions = {
      onClick: props.onClick,
      className: className,
      iconClassName: iconClassName,
      disabled: props.disabled,
      element: element,
      props: props
    };
    return ObjectUtils.getJSXElement(props.template, defaultOptions);
  }

  return element;
});
FirstPageLink.displayName = 'FirstPageLink';
FirstPageLink.defaultProps = {
  __TYPE: 'FirstPageLink',
  disabled: false,
  onClick: null,
  template: null
};
var JumpToPageInput = /*#__PURE__*/React.memo(function (props) {
  var onChange = function onChange(event) {
    if (props.onChange) {
      props.onChange(props.rows * (event.value - 1), props.rows);
    }
  };

  var value = props.pageCount > 0 ? props.page + 1 : 0;
  var element = /*#__PURE__*/React.createElement(InputNumber$1, {
    value: value,
    onChange: onChange,
    className: "p-paginator-page-input",
    disabled: props.disabled
  });

  if (props.template) {
    var defaultOptions = {
      value: value,
      onChange: onChange,
      disabled: props.disabled,
      className: 'p-paginator-page-input',
      element: element,
      props: props
    };
    return ObjectUtils.getJSXElement(props.template, defaultOptions);
  }

  return element;
});
JumpToPageInput.displayName = 'JumpToPageInput';
JumpToPageInput.defaultProps = {
  __TYPE: 'JumbToPageInput',
  page: null,
  rows: null,
  pageCount: null,
  disabled: false,
  template: null,
  onChange: null
};
var LastPageLink = /*#__PURE__*/React.memo(function (props) {
  var className = classNames('p-paginator-last p-paginator-element p-link', {
    'p-disabled': props.disabled
  });
  var iconClassName = 'p-paginator-icon pi pi-angle-double-right';
  var element = /*#__PURE__*/React.createElement("button", {
    type: "button",
    className: className,
    onClick: props.onClick,
    disabled: props.disabled,
    "aria-label": ariaLabel('lastPageLabel')
  }, /*#__PURE__*/React.createElement("span", {
    className: iconClassName
  }), /*#__PURE__*/React.createElement(Ripple, null));

  if (props.template) {
    var defaultOptions = {
      onClick: props.onClick,
      className: className,
      iconClassName: iconClassName,
      disabled: props.disabled,
      element: element,
      props: props
    };
    return ObjectUtils.getJSXElement(props.template, defaultOptions);
  }

  return element;
});
LastPageLink.displayName = 'LastPageLink';
LastPageLink.defaultProps = {
  __TYPE: 'LastPageLink',
  disabled: false,
  onClick: null,
  template: null
};
var NextPageLink = /*#__PURE__*/React.memo(function (props) {
  var className = classNames('p-paginator-next p-paginator-element p-link', {
    'p-disabled': props.disabled
  });
  var iconClassName = 'p-paginator-icon pi pi-angle-right';
  var element = /*#__PURE__*/React.createElement("button", {
    type: "button",
    className: className,
    onClick: props.onClick,
    disabled: props.disabled,
    "aria-label": ariaLabel('nextPageLabel')
  }, /*#__PURE__*/React.createElement("span", {
    className: iconClassName
  }), /*#__PURE__*/React.createElement(Ripple, null));

  if (props.template) {
    var defaultOptions = {
      onClick: props.onClick,
      className: className,
      iconClassName: iconClassName,
      disabled: props.disabled,
      element: element,
      props: props
    };
    return ObjectUtils.getJSXElement(props.template, defaultOptions);
  }

  return element;
});
NextPageLink.displayName = 'NextPageLink';
NextPageLink.defaultProps = {
  __TYPE: 'NextPageLink',
  disabled: false,
  onClick: null,
  template: null
};
var PageLinks = /*#__PURE__*/React.memo(function (props) {
  var onPageLinkClick = function onPageLinkClick(event, pageLink) {
    if (props.onClick) {
      props.onClick({
        originalEvent: event,
        value: pageLink
      });
    }

    event.preventDefault();
  };

  var elements;

  if (props.value) {
    var startPageInView = props.value[0];
    var endPageInView = props.value[props.value.length - 1];
    elements = props.value.map(function (pageLink) {
      var className = classNames('p-paginator-page p-paginator-element p-link', {
        'p-paginator-page-start': pageLink === startPageInView,
        'p-paginator-page-end': pageLink === endPageInView,
        'p-highlight': pageLink - 1 === props.page
      });
      var element = /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: className,
        onClick: function onClick(e) {
          return onPageLinkClick(e, pageLink);
        },
        "aria-label": "".concat(ariaLabel('pageLabel'), " ").concat(pageLink + 1)
      }, pageLink, /*#__PURE__*/React.createElement(Ripple, null));

      if (props.template) {
        var defaultOptions = {
          onClick: function onClick(e) {
            return onPageLinkClick(e, pageLink);
          },
          className: className,
          view: {
            startPage: startPageInView - 1,
            endPage: endPageInView - 1
          },
          page: pageLink - 1,
          currentPage: props.page,
          totalPages: props.pageCount,
          element: element,
          props: props
        };
        element = ObjectUtils.getJSXElement(props.template, defaultOptions);
      }

      return /*#__PURE__*/React.createElement(React.Fragment, {
        key: pageLink
      }, element);
    });
  }

  return /*#__PURE__*/React.createElement("span", {
    className: "p-paginator-pages"
  }, elements);
});
PageLinks.displayName = 'PageLinks';
PageLinks.defaultProps = {
  __TYPE: 'PageLinks',
  value: null,
  page: null,
  rows: null,
  pageCount: null,
  links: null,
  template: null
};
var PrevPageLink = /*#__PURE__*/React.memo(function (props) {
  var className = classNames('p-paginator-prev p-paginator-element p-link', {
    'p-disabled': props.disabled
  });
  var iconClassName = 'p-paginator-icon pi pi-angle-left';
  var element = /*#__PURE__*/React.createElement("button", {
    type: "button",
    className: className,
    onClick: props.onClick,
    disabled: props.disabled,
    "aria-label": ariaLabel('previousPageLabel')
  }, /*#__PURE__*/React.createElement("span", {
    className: iconClassName
  }), /*#__PURE__*/React.createElement(Ripple, null));

  if (props.template) {
    var defaultOptions = {
      onClick: props.onClick,
      className: className,
      iconClassName: iconClassName,
      disabled: props.disabled,
      element: element,
      props: props
    };
    return ObjectUtils.getJSXElement(props.template, defaultOptions);
  }

  return element;
});
PrevPageLink.displayName = 'PrevPageLink';
PrevPageLink.defaultProps = {
  __TYPE: 'PrevPageLink',
  disabled: false,
  onClick: null,
  template: null
};
var RowsPerPageDropdown = /*#__PURE__*/React.memo(function (props) {
  var hasOptions = props.options && props.options.length > 0;
  var options = hasOptions ? props.options.map(function (opt) {
    return {
      label: String(opt),
      value: opt
    };
  }) : [];
  var ariaLabel = localeOption$1('choose');
  var element = hasOptions ? /*#__PURE__*/React.createElement(Dropdown$1, {
    value: props.value,
    options: options,
    onChange: props.onChange,
    appendTo: props.appendTo,
    disabled: props.disabled,
    placeholder: ariaLabel,
    ariaLabel: ariaLabel
  }) : null;

  if (props.template) {
    var defaultOptions = {
      value: props.value,
      options: options,
      onChange: props.onChange,
      appendTo: props.appendTo,
      currentPage: props.page,
      totalPages: props.pageCount,
      totalRecords: props.totalRecords,
      disabled: props.disabled,
      element: element,
      props: props
    };
    return ObjectUtils.getJSXElement(props.template, defaultOptions);
  }

  return element;
});
RowsPerPageDropdown.displayName = 'RowsPerPageDropdown';
RowsPerPageDropdown.defaultProps = {
  __TYPE: 'RowsPerPageDropdown',
  options: null,
  value: null,
  page: null,
  pageCount: null,
  totalRecords: 0,
  appendTo: null,
  onChange: null,
  template: null,
  disabled: false
};
var Paginator = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(null);
  var rppChanged = React.useRef(false);
  var page = Math.floor(props.first / props.rows);
  var pageCount = Math.ceil(props.totalRecords / props.rows);
  var isFirstPage = page === 0;
  var isLastPage = page === pageCount - 1;
  var isEmpty = pageCount === 0;

  var calculatePageLinkBoundaries = function calculatePageLinkBoundaries() {
    var numberOfPages = pageCount;
    var visiblePages = Math.min(props.pageLinkSize, numberOfPages); //calculate range, keep current in middle if necessary

    var start = Math.max(0, Math.ceil(page - visiblePages / 2));
    var end = Math.min(numberOfPages - 1, start + visiblePages - 1); //check when approaching to last page

    var delta = props.pageLinkSize - (end - start + 1);
    start = Math.max(0, start - delta);
    return [start, end];
  };

  var updatePageLinks = function updatePageLinks() {
    var pageLinks = [];
    var boundaries = calculatePageLinkBoundaries();
    var start = boundaries[0];
    var end = boundaries[1];

    for (var i = start; i <= end; i++) {
      pageLinks.push(i + 1);
    }

    return pageLinks;
  };

  var changePage = function changePage(first, rows) {
    var pc = pageCount;
    var p = Math.floor(first / rows);

    if (p >= 0 && p < pc) {
      var newPageState = {
        first: first,
        rows: rows,
        page: p,
        pageCount: pc
      };

      if (props.onPageChange) {
        props.onPageChange(newPageState);
      }
    }
  };

  var changePageToFirst = function changePageToFirst(event) {
    changePage(0, props.rows);
    event.preventDefault();
  };

  var changePageToPrev = function changePageToPrev(event) {
    changePage(props.first - props.rows, props.rows);
    event.preventDefault();
  };

  var onPageLinkClick = function onPageLinkClick(event) {
    changePage((event.value - 1) * props.rows, props.rows);
  };

  var changePageToNext = function changePageToNext(event) {
    changePage(props.first + props.rows, props.rows);
    event.preventDefault();
  };

  var changePageToLast = function changePageToLast(event) {
    changePage((pageCount - 1) * props.rows, props.rows);
    event.preventDefault();
  };

  var onRowsChange = function onRowsChange(event) {
    var rows = event.value;
    rppChanged.current = rows !== props.rows;
    changePage(0, rows);
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  useUpdateEffect(function () {
    if (!rppChanged.current) {
      changePage(0, props.rows);
    }

    rppChanged.current = false;
  }, [props.rows]);
  useUpdateEffect(function () {
    if (page > 0 && props.first >= props.totalRecords) {
      changePage((pageCount - 1) * props.rows, props.rows);
    }
  }, [props.totalRecords]);

  var createElement = function createElement(key, template) {
    var element;

    switch (key) {
      case 'FirstPageLink':
        element = /*#__PURE__*/React.createElement(FirstPageLink, {
          key: key,
          onClick: changePageToFirst,
          disabled: isFirstPage || isEmpty,
          template: template
        });
        break;

      case 'PrevPageLink':
        element = /*#__PURE__*/React.createElement(PrevPageLink, {
          key: key,
          onClick: changePageToPrev,
          disabled: isFirstPage || isEmpty,
          template: template
        });
        break;

      case 'NextPageLink':
        element = /*#__PURE__*/React.createElement(NextPageLink, {
          key: key,
          onClick: changePageToNext,
          disabled: isLastPage || isEmpty,
          template: template
        });
        break;

      case 'LastPageLink':
        element = /*#__PURE__*/React.createElement(LastPageLink, {
          key: key,
          onClick: changePageToLast,
          disabled: isLastPage || isEmpty,
          template: template
        });
        break;

      case 'PageLinks':
        element = /*#__PURE__*/React.createElement(PageLinks, {
          key: key,
          value: updatePageLinks(),
          page: page,
          rows: props.rows,
          pageCount: pageCount,
          onClick: onPageLinkClick,
          template: template
        });
        break;

      case 'RowsPerPageDropdown':
        element = /*#__PURE__*/React.createElement(RowsPerPageDropdown, {
          key: key,
          value: props.rows,
          page: page,
          pageCount: pageCount,
          totalRecords: props.totalRecords,
          options: props.rowsPerPageOptions,
          onChange: onRowsChange,
          appendTo: props.dropdownAppendTo,
          template: template,
          disabled: isEmpty
        });
        break;

      case 'CurrentPageReport':
        element = /*#__PURE__*/React.createElement(CurrentPageReport, {
          reportTemplate: props.currentPageReportTemplate,
          key: key,
          page: page,
          pageCount: pageCount,
          first: props.first,
          rows: props.rows,
          totalRecords: props.totalRecords,
          template: template
        });
        break;

      case 'JumpToPageInput':
        element = /*#__PURE__*/React.createElement(JumpToPageInput, {
          key: key,
          rows: props.rows,
          page: page,
          pageCount: pageCount,
          onChange: changePage,
          disabled: isEmpty,
          template: template
        });
        break;

      default:
        element = null;
        break;
    }

    return element;
  };

  var createElements = function createElements() {
    var template = props.template;

    if (template) {
      if (_typeof$2(template) === 'object') {
        return template.layout ? template.layout.split(' ').map(function (value) {
          var key = value.trim();
          return createElement(key, template[key]);
        }) : Object.entries(template).map(function (_ref) {
          var _ref2 = _slicedToArray$h(_ref, 2),
              key = _ref2[0],
              _template = _ref2[1];

          return createElement(key, _template);
        });
      }

      return template.split(' ').map(function (value) {
        return createElement(value.trim());
      });
    }

    return null;
  };

  if (!props.alwaysShow && pageCount === 1) {
    return null;
  } else {
    var otherProps = ObjectUtils.findDiffKeys(props, Paginator.defaultProps);
    var className = classNames('p-paginator p-component', props.className);
    var leftContent = ObjectUtils.getJSXElement(props.leftContent, props);
    var rightContent = ObjectUtils.getJSXElement(props.rightContent, props);
    var elements = createElements();
    var leftElement = leftContent && /*#__PURE__*/React.createElement("div", {
      className: "p-paginator-left-content"
    }, leftContent);
    var rightElement = rightContent && /*#__PURE__*/React.createElement("div", {
      className: "p-paginator-right-content"
    }, rightContent);
    return /*#__PURE__*/React.createElement("div", _extends$q({
      ref: elementRef,
      className: className,
      style: props.style
    }, otherProps), leftElement, elements, rightElement);
  }
}));
Paginator.displayName = 'Paginator';
Paginator.defaultProps = {
  __TYPE: 'Paginator',
  totalRecords: 0,
  rows: 0,
  first: 0,
  pageLinkSize: 5,
  rowsPerPageOptions: null,
  alwaysShow: true,
  style: null,
  className: null,
  template: 'FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown',
  onPageChange: null,
  leftContent: null,
  rightContent: null,
  dropdownAppendTo: null,
  currentPageReportTemplate: '({currentPage} of {totalPages})'
};

function _extends$p() {
  _extends$p = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$p.apply(this, arguments);
}

function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _arrayLikeToArray$k(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$a(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$k(arr);
}

function _iterableToArray$a(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$k(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$k(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$k(o, minLen);
}

function _nonIterableSpread$a() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$a(arr) {
  return _arrayWithoutHoles$a(arr) || _iterableToArray$a(arr) || _unsupportedIterableToArray$k(arr) || _nonIterableSpread$a();
}

function _arrayWithHoles$g(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$g(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$g() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$g(arr, i) {
  return _arrayWithHoles$g(arr) || _iterableToArrayLimit$g(arr, i) || _unsupportedIterableToArray$k(arr, i) || _nonIterableRest$g();
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var RowCheckbox = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$g(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var onFocus = function onFocus() {
    setFocusedState(true);
  };

  var onBlur = function onBlur() {
    setFocusedState(false);
  };

  var onClick = function onClick(event) {
    if (!props.disabled) {
      setFocusedState(true);
      props.onChange(event);
    }
  };

  var onKeyDown = function onKeyDown(event) {
    if (event.code === 'Space') {
      onClick(event);
      event.preventDefault();
    }
  };

  var className = classNames('p-checkbox p-component', {
    'p-checkbox-focused': focusedState
  });
  var boxClassName = classNames('p-checkbox-box p-component', {
    'p-highlight': props.checked,
    'p-disabled': props.disabled,
    'p-focus': focusedState
  });
  var iconClassName = classNames('p-checkbox-icon', {
    'pi pi-check': props.checked
  });
  var tabIndex = props.disabled ? null : '0';
  return /*#__PURE__*/React.createElement("div", {
    className: className,
    onClick: onClick
  }, /*#__PURE__*/React.createElement("div", {
    className: boxClassName,
    role: "checkbox",
    "aria-checked": props.checked,
    tabIndex: tabIndex,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur,
    "aria-label": props.ariaLabel
  }, /*#__PURE__*/React.createElement("span", {
    className: iconClassName
  })));
});
RowCheckbox.displayName = 'RowCheckbox';
var RowRadioButton = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$g(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var inputRef = React.useRef(null);

  var onFocus = function onFocus() {
    setFocusedState(true);
  };

  var onBlur = function onBlur() {
    setFocusedState(false);
  };

  var onClick = function onClick(event) {
    if (!props.disabled) {
      props.onChange(event);
      DomHandler.focus(inputRef.current);
    }
  };

  var onKeyDown = function onKeyDown(event) {
    if (event.code === 'Space') {
      onClick(event);
      event.preventDefault();
    }
  };

  var onChange = function onChange(event) {
    onClick(event);
  };

  var className = classNames('p-radiobutton p-component', {
    'p-radiobutton-focused': focusedState
  });
  var boxClassName = classNames('p-radiobutton-box p-component', {
    'p-highlight': props.checked,
    'p-focus': focusedState,
    'p-disabled': props.disabled
  });
  var name = "".concat(props.tableSelector, "_dt_radio");
  return /*#__PURE__*/React.createElement("div", {
    className: className
  }, /*#__PURE__*/React.createElement("div", {
    className: "p-hidden-accessible"
  }, /*#__PURE__*/React.createElement("input", {
    name: name,
    ref: inputRef,
    type: "radio",
    checked: props.checked,
    onFocus: onFocus,
    onBlur: onBlur,
    onChange: onChange,
    onKeyDown: onKeyDown,
    "aria-label": props.ariaLabel
  })), /*#__PURE__*/React.createElement("div", {
    className: boxClassName,
    onClick: onClick,
    role: "radio",
    "aria-checked": props.checked
  }, /*#__PURE__*/React.createElement("div", {
    className: "p-radiobutton-icon"
  })));
});
RowRadioButton.displayName = 'RowRadioButton';

function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), !0).forEach(function (key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var BodyCell = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState(props.editing),
      _React$useState2 = _slicedToArray$g(_React$useState, 2),
      editingState = _React$useState2[0],
      setEditingState = _React$useState2[1];

  var _React$useState3 = React.useState(props.rowData),
      _React$useState4 = _slicedToArray$g(_React$useState3, 2),
      editingRowDataState = _React$useState4[0],
      setEditingRowDataState = _React$useState4[1];

  var _React$useState5 = React.useState({}),
      _React$useState6 = _slicedToArray$g(_React$useState5, 2),
      styleObjectState = _React$useState6[0],
      setStyleObjectState = _React$useState6[1];

  var elementRef = React.useRef(null);
  var keyHelperRef = React.useRef(null);
  var overlayEventListener = React.useRef(null);
  var selfClick = React.useRef(false);
  var tabindexTimeout = React.useRef(null);
  var initFocusTimeout = React.useRef(null);

  var getColumnProp = function getColumnProp(prop) {
    return props.column ? props.column.props[prop] : null;
  };

  var field = getColumnProp('field') || "field_".concat(props.index);
  var editingKey = props.dataKey ? props.rowData[props.dataKey] || props.rowIndex : props.rowIndex;

  var _useEventListener = useEventListener({
    type: 'click',
    listener: function listener(e) {
      if (!selfClick.current && isOutsideClicked(e.target)) {
        switchCellToViewMode(e, true);
      }

      selfClick.current = false;
    },
    options: true
  }),
      _useEventListener2 = _slicedToArray$g(_useEventListener, 2),
      bindDocumentClickListener = _useEventListener2[0],
      unbindDocumentClickListener = _useEventListener2[1];

  if (props.editMode === 'row' && props.editing !== editingState) {
    setEditingState(props.editing);
  }

  var isEditable = function isEditable() {
    return getColumnProp('editor');
  };

  var isSelected = function isSelected() {
    return props.selection ? props.selection instanceof Array ? findIndex(props.selection) > -1 : equals(props.selection) : false;
  };

  var equalsData = function equalsData(data) {
    return props.compareSelectionBy === 'equals' ? data === props.rowData : ObjectUtils.equals(data, props.rowData, props.dataKey);
  };

  var equals = function equals(selectedCell) {
    return (selectedCell.rowIndex === props.rowIndex || equalsData(selectedCell.rowData)) && (selectedCell.field === field || selectedCell.cellIndex === props.index);
  };

  var isOutsideClicked = function isOutsideClicked(target) {
    return elementRef.current && !(elementRef.current.isSameNode(target) || elementRef.current.contains(target));
  };

  var getVirtualScrollerOption = function getVirtualScrollerOption(option) {
    return props.virtualScrollerOptions ? props.virtualScrollerOptions[option] : null;
  };

  var getStyle = function getStyle() {
    var bodyStyle = getColumnProp('bodyStyle');
    var columnStyle = getColumnProp('style');
    return getColumnProp('frozen') ? Object.assign({}, columnStyle, bodyStyle, styleObjectState) : Object.assign({}, columnStyle, bodyStyle);
  };

  var getCellParams = function getCellParams() {
    return {
      value: resolveFieldData(),
      field: field,
      rowData: props.rowData,
      rowIndex: props.rowIndex,
      cellIndex: props.index,
      selected: isSelected(),
      column: props.column,
      props: props
    };
  };

  var getCellCallbackParams = function getCellCallbackParams(event) {
    var params = getCellParams();
    return _objectSpread$7({
      originalEvent: event
    }, params);
  };

  var resolveFieldData = function resolveFieldData(data) {
    return ObjectUtils.resolveFieldData(data || props.rowData, field);
  };

  var getEditingRowData = function getEditingRowData() {
    return props.editingMeta && props.editingMeta[editingKey] ? props.editingMeta[editingKey].data : props.rowData;
  };

  var getTabIndex = function getTabIndex(cellSelected) {
    return props.allowCellSelection ? cellSelected ? 0 : props.rowIndex === 0 && props.index === 0 ? props.tabIndex : -1 : null;
  };

  var findIndex = function findIndex(collection) {
    return (collection || []).findIndex(function (data) {
      return equals(data);
    });
  };

  var closeCell = function closeCell(event) {
    var params = getCellCallbackParams(event);
    var onBeforeCellEditHide = getColumnProp('onBeforeCellEditHide');

    if (onBeforeCellEditHide) {
      onBeforeCellEditHide(params);
    }
    /* When using the 'tab' key, the focus event of the next cell is not called in IE. */


    setTimeout(function () {
      setEditingState(false);
      unbindDocumentClickListener();
      OverlayService.off('overlay-click', overlayEventListener.current);
      overlayEventListener.current = null;
      selfClick.current = false;
    }, 1);
  };

  var switchCellToViewMode = function switchCellToViewMode(event, submit) {
    var callbackParams = getCellCallbackParams(event);
    var newRowData = editingRowDataState;
    var newValue = resolveFieldData(newRowData);

    var params = _objectSpread$7(_objectSpread$7({}, callbackParams), {}, {
      newRowData: newRowData,
      newValue: newValue
    });

    var onCellEditCancel = getColumnProp('onCellEditCancel');
    var cellEditValidator = getColumnProp('cellEditValidator');
    var onCellEditComplete = getColumnProp('onCellEditComplete');

    if (!submit && onCellEditCancel) {
      onCellEditCancel(params);
    }

    var valid = true;

    if (cellEditValidator) {
      valid = cellEditValidator(params);
    }

    if (valid) {
      if (submit && onCellEditComplete) {
        onCellEditComplete(params);
      }

      closeCell(event);
    } else {
      event.preventDefault();
    }
  };

  var findNextSelectableCell = function findNextSelectableCell(cell) {
    var nextCell = cell.nextElementSibling;
    return nextCell ? DomHandler.hasClass(nextCell, 'p-selectable-cell') ? nextCell : findNextSelectableCell(nextCell) : null;
  };

  var findPrevSelectableCell = function findPrevSelectableCell(cell) {
    var prevCell = cell.previousElementSibling;
    return prevCell ? DomHandler.hasClass(prevCell, 'p-selectable-cell') ? prevCell : findPrevSelectableCell(prevCell) : null;
  };

  var findDownSelectableCell = function findDownSelectableCell(cell) {
    var downRow = cell.parentElement.nextElementSibling;
    var downCell = downRow ? downRow.children[props.index] : null;
    return downRow && downCell ? DomHandler.hasClass(downRow, 'p-selectable-row') && DomHandler.hasClass(downCell, 'p-selectable-cell') ? downCell : findDownSelectableCell(downCell) : null;
  };

  var findUpSelectableCell = function findUpSelectableCell(cell) {
    var upRow = cell.parentElement.previousElementSibling;
    var upCell = upRow ? upRow.children[props.index] : null;
    return upRow && upCell ? DomHandler.hasClass(upRow, 'p-selectable-row') && DomHandler.hasClass(upCell, 'p-selectable-cell') ? upCell : findUpSelectableCell(upCell) : null;
  };

  var changeTabIndex = function changeTabIndex(currentCell, nextCell) {
    if (currentCell && nextCell) {
      currentCell.tabIndex = -1;
      nextCell.tabIndex = props.tabIndex;
    }
  };

  var focusOnElement = function focusOnElement() {
    clearTimeout(tabindexTimeout.current);
    tabindexTimeout.current = setTimeout(function () {
      if (editingState) {
        var focusableEl = props.editMode === 'cell' ? DomHandler.getFirstFocusableElement(elementRef.current, ':not(.p-cell-editor-key-helper)') : DomHandler.findSingle(elementRef.current, '.p-row-editor-save');
        focusableEl && focusableEl.focus();
      }

      keyHelperRef.current && (keyHelperRef.current.tabIndex = editingState ? -1 : 0);
    }, 1);
  };

  var focusOnInit = function focusOnInit() {
    clearTimeout(initFocusTimeout.current);
    initFocusTimeout.current = setTimeout(function () {
      var focusableEl = props.editMode === 'row' ? DomHandler.findSingle(elementRef.current, '.p-row-editor-init') : null;
      focusableEl && focusableEl.focus();
    }, 1);
  };

  var updateStickyPosition = function updateStickyPosition() {
    if (getColumnProp('frozen')) {
      var styleObject = _objectSpread$7({}, styleObjectState);

      var align = getColumnProp('alignFrozen');

      if (align === 'right') {
        var right = 0;
        var next = elementRef.current.nextElementSibling;

        if (next) {
          right = DomHandler.getOuterWidth(next) + parseFloat(next.style.right || 0);
        }

        styleObject['right'] = right + 'px';
      } else {
        var left = 0;
        var prev = elementRef.current.previousElementSibling;

        if (prev) {
          left = DomHandler.getOuterWidth(prev) + parseFloat(prev.style.left || 0);
        }

        styleObject['left'] = left + 'px';
      }

      var isSameStyle = styleObjectState['left'] === styleObject['left'] && styleObjectState['right'] === styleObject['right'];
      !isSameStyle && setStyleObjectState(styleObject);
    }
  };

  var editorCallback = function editorCallback(val) {
    var editingRowData = _objectSpread$7({}, editingRowDataState);

    editingRowData[field] = val;
    setEditingRowDataState(editingRowData); // update editing meta for complete methods on row mode

    props.editingMeta[editingKey].data[field] = val;
  };

  var onClick = function onClick(event) {
    var params = getCellCallbackParams(event);

    if (props.editMode !== 'row' && isEditable() && !editingState && (props.selectOnEdit || !props.selectOnEdit && props.selected)) {
      selfClick.current = true;
      var onBeforeCellEditShow = getColumnProp('onBeforeCellEditShow');
      var onCellEditInit = getColumnProp('onCellEditInit');
      var cellEditValidatorEvent = getColumnProp('cellEditValidatorEvent');

      if (onBeforeCellEditShow) {
        onBeforeCellEditShow(params);
      } // If the data is sorted using sort icon, it has been added to wait for the sort operation when any cell is wanted to be opened.


      setTimeout(function () {
        setEditingState(true);

        if (onCellEditInit) {
          onCellEditInit(params);
        }

        if (cellEditValidatorEvent === 'click') {
          bindDocumentClickListener();

          overlayEventListener.current = function (e) {
            if (!isOutsideClicked(e.target)) {
              selfClick.current = true;
            }
          };

          OverlayService.on('overlay-click', overlayEventListener.current);
        }
      }, 1);
    }

    if (props.allowCellSelection && props.onClick) {
      props.onClick(params);
    }
  };

  var onMouseDown = function onMouseDown(event) {
    var params = getCellCallbackParams(event);
    props.onMouseDown && props.onMouseDown(params);
  };

  var onMouseUp = function onMouseUp(event) {
    var params = getCellCallbackParams(event);
    props.onMouseUp && props.onMouseUp(params);
  };

  var onKeyDown = function onKeyDown(event) {
    if (props.editMode !== 'row') {
      if (event.which === 13 || event.which === 9) {
        // tab || enter
        switchCellToViewMode(event, true);
      }

      if (event.which === 27) {
        // escape
        switchCellToViewMode(event, false);
      }
    }

    if (props.allowCellSelection) {
      var target = event.target,
          cell = event.currentTarget;

      switch (event.which) {
        //left arrow
        case 37:
          var prevCell = findPrevSelectableCell(cell);

          if (prevCell) {
            changeTabIndex(cell, prevCell);
            prevCell.focus();
          }

          event.preventDefault();
          break;
        //right arrow

        case 39:
          var nextCell = findNextSelectableCell(cell);

          if (nextCell) {
            changeTabIndex(cell, nextCell);
            nextCell.focus();
          }

          event.preventDefault();
          break;
        //up arrow

        case 38:
          var upCell = findUpSelectableCell(cell);

          if (upCell) {
            changeTabIndex(cell, upCell);
            upCell.focus();
          }

          event.preventDefault();
          break;
        //down arrow

        case 40:
          var downCell = findDownSelectableCell(cell);

          if (downCell) {
            changeTabIndex(cell, downCell);
            downCell.focus();
          }

          event.preventDefault();
          break;
        //enter

        case 13:
          // @deprecated
          if (!DomHandler.isClickable(target)) {
            onClick(event);
            event.preventDefault();
          }

          break;
        //space

        case 32:
          if (!DomHandler.isClickable(target) && !target.readOnly) {
            onClick(event);
            event.preventDefault();
          }

          break;
      }
    }
  };

  var onBlur = function onBlur(event) {
    selfClick.current = false;

    if (props.editMode !== 'row' && editingState && getColumnProp('cellEditValidatorEvent') === 'blur') {
      switchCellToViewMode(event, true);
    }
  };

  var onEditorFocus = function onEditorFocus(event) {
    onClick(event);
  };

  var onRadioChange = function onRadioChange(event) {
    props.onRadioChange({
      originalEvent: event,
      data: props.rowData,
      index: props.rowIndex
    });
  };

  var onCheckboxChange = function onCheckboxChange(event) {
    props.onCheckboxChange({
      originalEvent: event,
      data: props.rowData,
      index: props.rowIndex
    });
  };

  var onRowToggle = function onRowToggle(event) {
    props.onRowToggle({
      originalEvent: event,
      data: props.rowData
    });
    event.preventDefault();
  };

  var onRowEditInit = function onRowEditInit(event) {
    props.onRowEditInit({
      originalEvent: event,
      data: props.rowData,
      newData: getEditingRowData(),
      field: field,
      index: props.rowIndex
    });
  };

  var onRowEditSave = function onRowEditSave(event) {
    props.onRowEditSave({
      originalEvent: event,
      data: props.rowData,
      newData: getEditingRowData(),
      field: field,
      index: props.rowIndex
    });
    focusOnInit();
  };

  var onRowEditCancel = function onRowEditCancel(event) {
    props.onRowEditCancel({
      originalEvent: event,
      data: props.rowData,
      newData: getEditingRowData(),
      field: field,
      index: props.rowIndex
    });
    focusOnInit();
  };

  React.useEffect(function () {
    if (getColumnProp('frozen')) {
      updateStickyPosition();
    }

    if (props.editMode === 'cell' || props.editMode === 'row') {
      focusOnElement();
    }
  });
  useUpdateEffect(function () {
    if (props.editMode === 'cell' || props.editMode === 'row') {
      setEditingRowDataState(getEditingRowData());
    }
  }, [props.editingMeta]);
  useUpdateEffect(function () {
    if (props.editMode === 'cell' || props.editMode === 'row') {
      var callbackParams = getCellCallbackParams();

      var params = _objectSpread$7(_objectSpread$7({}, callbackParams), {}, {
        editing: editingState,
        editingKey: editingKey
      });

      props.onEditingMetaChange(params);
    }
  }, [editingState]);
  useUnmountEffect(function () {
    if (overlayEventListener.current) {
      OverlayService.off('overlay-click', overlayEventListener.current);
      overlayEventListener.current = null;
    }
  });

  var createLoading = function createLoading() {
    var options = getVirtualScrollerOption('getLoaderOptions')(props.rowIndex, {
      cellIndex: props.index,
      cellFirst: props.index === 0,
      cellLast: props.index === getVirtualScrollerOption('columns').length - 1,
      cellEven: props.index % 2 === 0,
      cellOdd: props.index % 2 !== 0,
      column: props.column,
      field: field
    });
    var content = ObjectUtils.getJSXElement(getVirtualScrollerOption('loadingTemplate'), options);
    return /*#__PURE__*/React.createElement("td", null, content);
  };

  var createElement = function createElement() {
    var content, editorKeyHelper;
    var cellSelected = props.allowCellSelection && isSelected();
    var isRowEditor = props.editMode === 'row';
    var tabIndex = getTabIndex(cellSelected);
    var selectionMode = getColumnProp('selectionMode');
    var rowReorder = getColumnProp('rowReorder');
    var expander = getColumnProp('expander');
    var rowEditor = getColumnProp('rowEditor');
    var header = getColumnProp('header');
    var body = getColumnProp('body');
    var editor = getColumnProp('editor');
    var frozen = getColumnProp('frozen');
    var align = getColumnProp('align');
    var value = resolveFieldData();
    var cellClassName = ObjectUtils.getPropValue(props.cellClassName, value, {
      props: props.tableProps,
      rowData: props.rowData,
      column: props.column
    });
    var className = classNames(getColumnProp('bodyClassName'), getColumnProp('className'), cellClassName, _defineProperty$8({
      'p-selection-column': selectionMode !== null,
      'p-editable-column': editor,
      'p-cell-editing': editor && editingState,
      'p-frozen-column': frozen,
      'p-selectable-cell': props.allowCellSelection && props.isSelectable({
        data: getCellParams(),
        index: props.rowIndex
      }),
      'p-highlight': cellSelected
    }, "p-align-".concat(align), !!align));
    var style = getStyle();
    var title = props.responsiveLayout === 'stack' && /*#__PURE__*/React.createElement("span", {
      className: "p-column-title"
    }, ObjectUtils.getJSXElement(header, {
      props: props.tableProps
    }));

    if (selectionMode) {
      var showSelection = props.showSelectionElement ? props.showSelectionElement(props.rowData, {
        rowIndex: props.rowIndex,
        props: props.tableProps
      }) : true;
      var label;

      if (showSelection) {
        var ariaLabelField = props.selectionAriaLabel || props.tableProps.dataKey;
        var ariaLabelText = ObjectUtils.resolveFieldData(props.rowData, ariaLabelField);
        label = "".concat(props.selected ? ariaLabel('unselectLabel') : ariaLabel('selectLabel'), " ").concat(ariaLabelText);
      }

      content = showSelection && /*#__PURE__*/React.createElement(React.Fragment, null, selectionMode === 'single' && /*#__PURE__*/React.createElement(RowRadioButton, {
        checked: props.selected,
        onChange: onRadioChange,
        tabIndex: props.tabIndex,
        tableSelector: props.tableSelector,
        ariaLabel: label
      }), selectionMode === 'multiple' && /*#__PURE__*/React.createElement(RowCheckbox, {
        checked: props.selected,
        onChange: onCheckboxChange,
        tabIndex: props.tabIndex,
        ariaLabel: label
      }));
    } else if (rowReorder) {
      var showReorder = props.showRowReorderElement ? props.showRowReorderElement(props.rowData, {
        rowIndex: props.rowIndex,
        props: props.tableProps
      }) : true;
      content = showReorder && /*#__PURE__*/React.createElement("i", {
        className: classNames('p-datatable-reorderablerow-handle', getColumnProp('rowReorderIcon'))
      });
    } else if (expander) {
      var iconClassName = classNames('p-row-toggler-icon', props.expanded ? props.expandedRowIcon : props.collapsedRowIcon);
      var ariaControls = "".concat(props.tableSelector, "_content_").concat(props.rowIndex, "_expanded");

      var _ariaLabelField = props.selectionAriaLabel || props.tableProps.dataKey;

      var _ariaLabelText = ObjectUtils.resolveFieldData(props.rowData, _ariaLabelField);

      var _label = "".concat(props.expanded ? ariaLabel('collapseLabel') : ariaLabel('expandLabel'), " ").concat(_ariaLabelText);

      var expanderProps = {
        onClick: onRowToggle,
        className: 'p-row-toggler p-link',
        iconClassName: iconClassName
      };
      content = /*#__PURE__*/React.createElement("button", {
        className: expanderProps.className,
        onClick: expanderProps.onClick,
        type: "button",
        "aria-expanded": props.expanded,
        "aria-controls": ariaControls,
        tabIndex: props.tabIndex,
        "aria-label": _label
      }, /*#__PURE__*/React.createElement("span", {
        className: expanderProps.iconClassName,
        "aria-hidden": "true"
      }), /*#__PURE__*/React.createElement(Ripple, null));

      if (body) {
        expanderProps['element'] = content;
        content = ObjectUtils.getJSXElement(body, props.rowData, {
          column: props.column,
          field: field,
          rowIndex: props.rowIndex,
          frozenRow: props.frozenRow,
          props: props.tableProps,
          expander: expanderProps
        });
      }
    } else if (isRowEditor && rowEditor) {
      var rowEditorProps = {};

      if (editingState) {
        rowEditorProps = {
          editing: true,
          onSaveClick: onRowEditSave,
          saveClassName: 'p-row-editor-save p-link',
          saveIconClassName: 'p-row-editor-save-icon pi pi-fw pi-check',
          onCancelClick: onRowEditCancel,
          cancelClassName: 'p-row-editor-cancel p-link',
          cancelIconClassName: 'p-row-editor-cancel-icon pi pi-fw pi-times'
        };
        content = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("button", {
          type: "button",
          name: "row-save",
          onClick: rowEditorProps.onSaveClick,
          className: rowEditorProps.saveClassName,
          tabIndex: props.tabIndex
        }, /*#__PURE__*/React.createElement("span", {
          className: rowEditorProps.saveIconClassName
        }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("button", {
          type: "button",
          name: "row-cancel",
          onClick: rowEditorProps.onCancelClick,
          className: rowEditorProps.cancelClassName,
          tabIndex: props.tabIndex
        }, /*#__PURE__*/React.createElement("span", {
          className: rowEditorProps.cancelIconClassName
        }), /*#__PURE__*/React.createElement(Ripple, null)));
      } else {
        rowEditorProps = {
          editing: false,
          onInitClick: onRowEditInit,
          initClassName: 'p-row-editor-init p-link',
          initIconClassName: 'p-row-editor-init-icon pi pi-fw pi-pencil'
        };
        content = /*#__PURE__*/React.createElement("button", {
          type: "button",
          name: "row-edit",
          onClick: rowEditorProps.onInitClick,
          className: rowEditorProps.initClassName,
          tabIndex: props.tabIndex
        }, /*#__PURE__*/React.createElement("span", {
          className: rowEditorProps.initIconClassName
        }), /*#__PURE__*/React.createElement(Ripple, null));
      }

      if (body) {
        rowEditorProps['element'] = content;
        content = ObjectUtils.getJSXElement(body, props.rowData, {
          column: props.column,
          field: field,
          rowIndex: props.rowIndex,
          frozenRow: props.frozenRow,
          props: props.tableProps,
          rowEditor: rowEditorProps
        });
      }
    } else if (body && (!editingState || !editor)) {
      content = body ? ObjectUtils.getJSXElement(body, props.rowData, {
        column: props.column,
        field: field,
        rowIndex: props.rowIndex,
        frozenRow: props.frozenRow,
        props: props.tableProps
      }) : value;
    } else if (editor && editingState) {
      content = ObjectUtils.getJSXElement(editor, {
        rowData: editingRowDataState,
        value: resolveFieldData(editingRowDataState),
        column: props.column,
        field: field,
        rowIndex: props.rowIndex,
        frozenRow: props.frozenRow,
        props: props.tableProps,
        editorCallback: editorCallback
      });
    } else {
      content = value;
    }

    if (!isRowEditor && editor) {
      /* eslint-disable */
      editorKeyHelper = /*#__PURE__*/React.createElement("a", {
        tabIndex: "0",
        ref: keyHelperRef,
        className: "p-cell-editor-key-helper p-hidden-accessible",
        onFocus: onEditorFocus
      }, /*#__PURE__*/React.createElement("span", null));
      /* eslint-enable */
    }

    return /*#__PURE__*/React.createElement("td", {
      ref: elementRef,
      style: style,
      className: className,
      rowSpan: props.rowSpan,
      tabIndex: tabIndex,
      role: "cell",
      onClick: onClick,
      onKeyDown: onKeyDown,
      onBlur: onBlur,
      onMouseDown: onMouseDown,
      onMouseUp: onMouseUp
    }, editorKeyHelper, title, content);
  };

  return getVirtualScrollerOption('loading') ? createLoading() : createElement();
});
BodyCell.displayName = 'BodyCell';

function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var BodyRow = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$g(_React$useState, 2),
      editingState = _React$useState2[0],
      setEditingState = _React$useState2[1];

  var editing = props.onRowEditChange ? props.editing : editingState;

  var isFocusable = function isFocusable() {
    return props.selectionMode && props.selectionModeInColumn !== 'single' && props.selectionModeInColumn !== 'multiple';
  };

  var isGrouped = function isGrouped(column) {
    if (props.groupRowsBy && getColumnProp(column, 'field')) {
      return Array.isArray(props.groupRowsBy) ? props.groupRowsBy.indexOf(column.props.field) > -1 : props.groupRowsBy === column.props.field;
    }

    return false;
  };

  var equals = function equals(data1, data2) {
    return props.compareSelectionBy === 'equals' ? data1 === data2 : ObjectUtils.equals(data1, data2, props.dataKey);
  };

  var getColumnProp = function getColumnProp(col, prop) {
    return col ? col.props[prop] : null;
  };

  var getTabIndex = function getTabIndex() {
    return isFocusable() && !props.allowCellSelection ? props.index === 0 ? props.tabIndex : -1 : null;
  };

  var findIndex = function findIndex(collection, rowData) {
    return (collection || []).findIndex(function (data) {
      return equals(rowData, data);
    });
  };

  var changeTabIndex = function changeTabIndex(currentRow, nextRow) {
    if (currentRow && nextRow) {
      currentRow.tabIndex = -1;
      nextRow.tabIndex = props.tabIndex;
    }
  };

  var findNextSelectableRow = function findNextSelectableRow(row) {
    var nextRow = row.nextElementSibling;
    return nextRow ? DomHandler.hasClass(nextRow, 'p-selectable-row') ? nextRow : findNextSelectableRow(nextRow) : null;
  };

  var findPrevSelectableRow = function findPrevSelectableRow(row) {
    var prevRow = row.previousElementSibling;
    return prevRow ? DomHandler.hasClass(prevRow, 'p-selectable-row') ? prevRow : findPrevSelectableRow(prevRow) : null;
  };

  var shouldRenderBodyCell = function shouldRenderBodyCell(value, column, i) {
    if (getColumnProp(column, 'hidden')) {
      return false;
    } else if (props.rowGroupMode && props.rowGroupMode === 'rowspan' && isGrouped(column)) {
      var prevRowData = value[i - 1];

      if (prevRowData) {
        var currentRowFieldData = ObjectUtils.resolveFieldData(value[i], getColumnProp(column, 'field'));
        var previousRowFieldData = ObjectUtils.resolveFieldData(prevRowData, getColumnProp(column, 'field'));
        return currentRowFieldData !== previousRowFieldData;
      }
    }

    return true;
  };

  var calculateRowGroupSize = function calculateRowGroupSize(value, column, index) {
    if (isGrouped(column)) {
      var currentRowFieldData = ObjectUtils.resolveFieldData(value[index], getColumnProp(column, 'field'));
      var nextRowFieldData = currentRowFieldData;
      var groupRowSpan = 0;

      while (currentRowFieldData === nextRowFieldData) {
        groupRowSpan++;
        var nextRowData = value[++index];

        if (nextRowData) {
          nextRowFieldData = ObjectUtils.resolveFieldData(nextRowData, getColumnProp(column, 'field'));
        } else {
          break;
        }
      }

      return groupRowSpan === 1 ? null : groupRowSpan;
    } else {
      return null;
    }
  };

  var onClick = function onClick(event) {
    props.onRowClick({
      originalEvent: event,
      data: props.rowData,
      index: props.index
    });
  };

  var onDoubleClick = function onDoubleClick(event) {
    props.onRowDoubleClick({
      originalEvent: event,
      data: props.rowData,
      index: props.index
    });
  };

  var onRightClick = function onRightClick(event) {
    props.onRowRightClick({
      originalEvent: event,
      data: props.rowData,
      index: props.index
    });
  };

  var onTouchEnd = function onTouchEnd(event) {
    props.onRowTouchEnd(event);
  };

  var onKeyDown = function onKeyDown(event) {
    if (isFocusable() && !props.allowCellSelection) {
      var target = event.target,
          row = event.currentTarget;

      switch (event.which) {
        //down arrow
        case 40:
          var nextRow = findNextSelectableRow(row);

          if (nextRow) {
            changeTabIndex(row, nextRow);
            nextRow.focus();
          }

          event.preventDefault();
          break;
        //up arrow

        case 38:
          var prevRow = findPrevSelectableRow(row);

          if (prevRow) {
            changeTabIndex(row, prevRow);
            prevRow.focus();
          }

          event.preventDefault();
          break;
        //enter

        case 13:
          // @deprecated
          if (!DomHandler.isClickable(target)) {
            onClick(event);
            event.preventDefault();
          }

          break;
        //space

        case 32:
          if (!DomHandler.isClickable(target) && !target.readOnly) {
            onClick(event);
            event.preventDefault();
          }

          break;
      }
    }
  };

  var onMouseDown = function onMouseDown(event) {
    props.onRowMouseDown({
      originalEvent: event,
      data: props.rowData,
      index: props.index
    });
  };

  var onMouseUp = function onMouseUp(event) {
    props.onRowMouseUp({
      originalEvent: event,
      data: props.rowData,
      index: props.index
    });
  };

  var onDragStart = function onDragStart(event) {
    props.onRowDragStart({
      originalEvent: event,
      data: props.rowData,
      index: props.index
    });
  };

  var onDragOver = function onDragOver(event) {
    props.onRowDragOver({
      originalEvent: event,
      data: props.rowData,
      index: props.index
    });
  };

  var onDragLeave = function onDragLeave(event) {
    props.onRowDragLeave({
      originalEvent: event,
      data: props.rowData,
      index: props.index
    });
  };

  var onDragEnd = function onDragEnd(event) {
    props.onRowDragEnd({
      originalEvent: event,
      data: props.rowData,
      index: props.index
    });
  };

  var onDrop = function onDrop(event) {
    props.onRowDrop({
      originalEvent: event,
      data: props.rowData,
      index: props.index
    });
  };

  var onEditChange = function onEditChange(e, isEditing) {
    if (props.onRowEditChange) {
      var editingRows;
      var dataKey = props.dataKey;
      var originalEvent = e.originalEvent,
          data = e.data,
          index = e.index,
          newData = e.newData;

      if (dataKey) {
        var dataKeyValue = String(ObjectUtils.resolveFieldData(data, dataKey));
        editingRows = props.editingRows ? _objectSpread$6({}, props.editingRows) : {};

        if (!isEditing) {
          delete editingRows[dataKeyValue]; // if the key value was changed, stop editing for the new key value too

          var newDataKeyValue = String(ObjectUtils.resolveFieldData(newData, dataKey));
          delete editingRows[newDataKeyValue];
        } else {
          editingRows[dataKeyValue] = true;
        }
      } else {
        var editingRowIndex = findIndex(props.editingRows, data);
        editingRows = props.editingRows ? _toConsumableArray$a(props.editingRows) : [];
        if (editingRowIndex !== -1) editingRows = editingRows.filter(function (val, i) {
          return i !== editingRowIndex;
        });else editingRows.push(data);
      }

      props.onRowEditChange({
        originalEvent: originalEvent,
        data: editingRows,
        index: index
      });
    } else {
      setEditingState(isEditing);
    }
  };

  var onEditInit = function onEditInit(e) {
    var event = e.originalEvent;

    if (props.onRowEditInit) {
      props.onRowEditInit({
        originalEvent: event,
        data: props.rowData,
        index: props.index
      });
    }

    onEditChange(e, true);
    event.preventDefault();
  };

  var onEditSave = function onEditSave(e) {
    var event = e.originalEvent,
        newData = e.newData;
    var valid = props.rowEditValidator ? props.rowEditValidator(newData, {
      props: props.tableProps
    }) : true;

    if (props.onRowEditSave) {
      props.onRowEditSave({
        originalEvent: event,
        data: props.rowData,
        index: props.index,
        valid: valid
      });
    }

    if (valid) {
      if (props.onRowEditComplete) {
        props.onRowEditComplete(e);
      }

      onEditChange(e, false);
    }

    event.preventDefault();
  };

  var onEditCancel = function onEditCancel(e) {
    var event = e.originalEvent;

    if (props.onRowEditCancel) {
      props.onRowEditCancel({
        originalEvent: event,
        data: props.rowData,
        index: props.index
      });
    }

    onEditChange(e, false);
    event.preventDefault();
  };

  var createContent = function createContent() {
    return props.columns.map(function (col, i) {
      if (shouldRenderBodyCell(props.value, col, props.index)) {
        var key = "".concat(getColumnProp(col, 'columnKey') || getColumnProp(col, 'field'), "_").concat(i);
        var rowSpan = props.rowGroupMode === 'rowspan' ? calculateRowGroupSize(props.value, col, props.index) : null;
        return /*#__PURE__*/React.createElement(BodyCell, {
          key: key,
          value: props.value,
          tableProps: props.tableProps,
          tableSelector: props.tableSelector,
          column: col,
          rowData: props.rowData,
          rowIndex: props.index,
          index: i,
          rowSpan: rowSpan,
          dataKey: props.dataKey,
          editing: editing,
          editingMeta: props.editingMeta,
          editMode: props.editMode,
          onRowEditInit: onEditInit,
          onRowEditSave: onEditSave,
          onRowEditCancel: onEditCancel,
          onEditingMetaChange: props.onEditingMetaChange,
          onRowToggle: props.onRowToggle,
          selection: props.selection,
          selectionAriaLabel: props.tableProps.selectionAriaLabel,
          allowCellSelection: props.allowCellSelection,
          compareSelectionBy: props.compareSelectionBy,
          selectOnEdit: props.selectOnEdit,
          selected: props.selected,
          onClick: props.onCellClick,
          onMouseDown: props.onCellMouseDown,
          onMouseUp: props.onCellMouseUp,
          tabIndex: props.tabIndex,
          cellClassName: props.cellClassName,
          responsiveLayout: props.responsiveLayout,
          frozenRow: props.frozenRow,
          isSelectable: props.isSelectable,
          showSelectionElement: props.showSelectionElement,
          showRowReorderElement: props.showRowReorderElement,
          onRadioChange: props.onRadioChange,
          onCheckboxChange: props.onCheckboxChange,
          expanded: props.expanded,
          expandedRowIcon: props.expandedRowIcon,
          collapsedRowIcon: props.collapsedRowIcon,
          virtualScrollerOptions: props.virtualScrollerOptions
        });
      }

      return null;
    });
  };

  var rowClassName = ObjectUtils.getPropValue(props.rowClassName, props.rowData, {
    props: props.tableProps
  });
  var className = classNames(rowClassName, {
    'p-highlight': !props.allowCellSelection && props.selected,
    'p-highlight-contextmenu': props.contextMenuSelected,
    'p-selectable-row': props.allowRowSelection && props.isSelectable({
      data: props.rowData,
      index: props.index
    }),
    'p-row-odd': props.index % 2 !== 0
  });
  var style = {
    height: props.virtualScrollerOptions ? props.virtualScrollerOptions.itemSize : undefined
  };
  var content = createContent();
  var tabIndex = getTabIndex();
  return /*#__PURE__*/React.createElement("tr", {
    role: "row",
    tabIndex: tabIndex,
    className: className,
    style: style,
    onMouseDown: onMouseDown,
    onMouseUp: onMouseUp,
    onClick: onClick,
    onDoubleClick: onDoubleClick,
    onContextMenu: onRightClick,
    onTouchEnd: onTouchEnd,
    onKeyDown: onKeyDown,
    onDragStart: onDragStart,
    onDragOver: onDragOver,
    onDragLeave: onDragLeave,
    onDragEnd: onDragEnd,
    onDrop: onDrop
  }, content);
});
BodyRow.displayName = 'BodyRow';
var RowTogglerButton = /*#__PURE__*/React.memo(function (props) {
  var onClick = function onClick(event) {
    props.onClick({
      originalEvent: event,
      data: props.rowData
    });
  };

  var iconClassName = classNames('p-row-toggler-icon', props.expanded ? props.expandedRowIcon : props.collapsedRowIcon);
  var label = props.expanded ? ariaLabel('collapseLabel') : ariaLabel('expandLabel');
  return /*#__PURE__*/React.createElement("button", {
    type: "button",
    onClick: onClick,
    className: "p-row-toggler p-link",
    tabIndex: props.tabIndex,
    "aria-label": label
  }, /*#__PURE__*/React.createElement("span", {
    className: iconClassName,
    "aria-hidden": "true"
  }), /*#__PURE__*/React.createElement(Ripple, null));
});
RowTogglerButton.displayName = 'RowTogglerButton';
var _excluded$4 = ["originalEvent"];

function ownKeys$5$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$5$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5$1(Object(source), !0).forEach(function (key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var TableBody = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState({}),
      _React$useState2 = _slicedToArray$g(_React$useState, 2),
      rowGroupHeaderStyleObjectState = _React$useState2[0],
      setRowGroupHeaderStyleObjectState = _React$useState2[1];

  var elementRef = React.useRef(null);
  var refCallback = React.useCallback(function (el) {
    elementRef.current = el;
    props.virtualScrollerContentRef && props.virtualScrollerContentRef(el);
  }, [props]);
  var dragSelectionHelper = React.useRef(null);
  var initialDragPosition = React.useRef(null);
  var anchorRowIndex = React.useRef(null);
  var anchorCellIndex = React.useRef(null);
  var rangeRowIndex = React.useRef(null);
  var anchorRowFirst = React.useRef(null);
  var rowTouched = React.useRef(false);
  var rowDragging = React.useRef(false);
  var draggedRowIndex = React.useRef(null);
  var droppedRowIndex = React.useRef(null);
  var prevVirtualScrollerOptions = usePrevious(props.virtualScrollerOptions);
  var isSubheaderGrouping = props.rowGroupMode && props.rowGroupMode === 'subheader';
  var isRadioSelectionMode = props.selectionMode === 'radiobutton';
  var isCheckboxSelectionMode = props.selectionMode === 'checkbox';
  var isRadioSelectionModeInColumn = props.selectionModeInColumn === 'single';
  var isCheckboxSelectionModeInColumn = props.selectionModeInColumn === 'multiple';

  var equals = function equals(data1, data2) {
    if (allowCellSelection()) return (data1.rowIndex === data2.rowIndex || data1.rowData === data2.rowData) && (data1.field === data2.field || data1.cellIndex === data2.cellIndex);else return props.compareSelectionBy === 'equals' ? data1 === data2 : ObjectUtils.equals(data1, data2, props.dataKey);
  };

  var isSelectionEnabled = function isSelectionEnabled() {
    return props.selectionMode || props.selectionModeInColumn !== null || props.columns && props.columns.some(function (col) {
      return col && !!col.props.selectionMode;
    });
  };

  var isSingleSelection = function isSingleSelection() {
    return props.selectionMode === 'single' && !isCheckboxSelectionModeInColumn || !isRadioSelectionMode && isRadioSelectionModeInColumn;
  };

  var isMultipleSelection = function isMultipleSelection() {
    return props.selectionMode === 'multiple' && !isRadioSelectionModeInColumn || isCheckboxSelectionModeInColumn;
  };

  var isRadioOnlySelection = function isRadioOnlySelection() {
    return isRadioSelectionMode && isRadioSelectionModeInColumn;
  };

  var isCheckboxOnlySelection = function isCheckboxOnlySelection() {
    return isCheckboxSelectionMode && isCheckboxSelectionModeInColumn;
  };

  var isSelected = function isSelected(rowData) {
    if (rowData && props.selection) {
      return props.selection instanceof Array ? findIndex(props.selection, rowData) > -1 : equals(rowData, props.selection);
    }

    return false;
  };

  var isContextMenuSelected = function isContextMenuSelected(rowData) {
    if (rowData && props.contextMenuSelection) {
      return equals(rowData, props.contextMenuSelection);
    }

    return false;
  };

  var isSelectable = function isSelectable(options) {
    return props.isDataSelectable ? props.isDataSelectable(options) : true;
  };

  var isRowExpanded = function isRowExpanded(rowData) {
    if (rowData && props.expandedRows) {
      if (isSubheaderGrouping && props.expandableRowGroups) {
        return isRowGroupExpanded(rowData);
      } else {
        if (props.dataKey) return props.expandedRows ? props.expandedRows[ObjectUtils.resolveFieldData(rowData, props.dataKey)] !== undefined : false;else return findIndex(props.expandedRows, rowData) !== -1;
      }
    }

    return false;
  };

  var isRowGroupExpanded = function isRowGroupExpanded(rowData) {
    if (props.dataKey === props.groupRowsBy) return Object.keys(props.expandedRows).some(function (data) {
      return ObjectUtils.equals(data, ObjectUtils.resolveFieldData(rowData, props.dataKey));
    });else return props.expandedRows.some(function (data) {
      return ObjectUtils.equals(data, rowData, props.groupRowsBy);
    });
  };

  var isRowEditing = function isRowEditing(rowData) {
    if (props.editMode === 'row' && rowData && props.editingRows) {
      if (props.dataKey) return props.editingRows ? props.editingRows[ObjectUtils.resolveFieldData(rowData, props.dataKey)] !== undefined : false;else return findIndex(props.editingRows, rowData) !== -1;
    }

    return false;
  };

  var allowDrag = function allowDrag(event) {
    return props.dragSelection && isMultipleSelection() && !event.originalEvent.shiftKey;
  };

  var allowRowDrag = function allowRowDrag(event) {
    return !allowCellSelection() && allowDrag(event) || props.reorderableRows;
  };

  var allowCellDrag = function allowCellDrag(event) {
    return allowCellSelection() && allowDrag(event);
  };

  var allowSelection = function allowSelection(event) {
    return !DomHandler.isClickable(event.originalEvent.target);
  };

  var allowMetaKeySelection = function allowMetaKeySelection(event) {
    return !rowTouched.current && (!props.metaKeySelection || props.metaKeySelection && (event.originalEvent.metaKey || event.originalEvent.ctrlKey));
  };

  var allowRangeSelection = function allowRangeSelection(event) {
    return isMultipleSelection() && event.originalEvent.shiftKey && anchorRowIndex.current !== null;
  };

  var allowRowSelection = function allowRowSelection() {
    return (props.selectionMode || props.selectionModeInColumn) && !isRadioOnlySelection() && !isCheckboxOnlySelection();
  };

  var allowCellSelection = function allowCellSelection() {
    return props.cellSelection && !isRadioSelectionModeInColumn && !isCheckboxSelectionModeInColumn;
  };

  var getColumnsLength = function getColumnsLength() {
    return props.columns ? props.columns.length : 0;
  };

  var getVirtualScrollerOption = function getVirtualScrollerOption(option, options) {
    options = options || props.virtualScrollerOptions;
    return options ? options[option] : null;
  };

  var findIndex = function findIndex(collection, rowData) {
    return (collection || []).findIndex(function (data) {
      return equals(rowData, data);
    });
  };

  var rowGroupHeaderStyle = function rowGroupHeaderStyle() {
    if (props.scrollable) {
      return {
        top: rowGroupHeaderStyleObjectState['top']
      };
    }

    return null;
  };

  var getRowKey = function getRowKey(rowData, index) {
    return props.dataKey ? ObjectUtils.resolveFieldData(rowData, props.dataKey) + '_' + index : index;
  };

  var shouldRenderRowGroupHeader = function shouldRenderRowGroupHeader(value, rowData, i) {
    var currentRowFieldData = ObjectUtils.resolveFieldData(rowData, props.groupRowsBy);
    var prevRowData = value[i - 1];

    if (prevRowData) {
      var previousRowFieldData = ObjectUtils.resolveFieldData(prevRowData, props.groupRowsBy);
      return currentRowFieldData !== previousRowFieldData;
    } else {
      return true;
    }
  };

  var shouldRenderRowGroupFooter = function shouldRenderRowGroupFooter(value, rowData, i, expanded) {
    if (props.expandableRowGroups && !expanded) {
      return false;
    } else {
      var currentRowFieldData = ObjectUtils.resolveFieldData(rowData, props.groupRowsBy);
      var nextRowData = value[i + 1];

      if (nextRowData) {
        var nextRowFieldData = ObjectUtils.resolveFieldData(nextRowData, props.groupRowsBy);
        return currentRowFieldData !== nextRowFieldData;
      } else {
        return true;
      }
    }
  };

  var updateFrozenRowStickyPosition = function updateFrozenRowStickyPosition() {
    elementRef.current.style.top = DomHandler.getOuterHeight(elementRef.current.previousElementSibling) + 'px';
  };

  var updateFrozenRowGroupHeaderStickyPosition = function updateFrozenRowGroupHeaderStickyPosition() {
    var tableHeaderHeight = DomHandler.getOuterHeight(elementRef.current.previousElementSibling);
    var top = tableHeaderHeight + 'px';

    if (rowGroupHeaderStyleObjectState.top !== top) {
      setRowGroupHeaderStyleObjectState({
        top: top
      });
    }
  };

  var updateVirtualScrollerPosition = function updateVirtualScrollerPosition() {
    var tableHeaderHeight = DomHandler.getOuterHeight(elementRef.current.previousElementSibling);
    elementRef.current.style.top = (elementRef.current.style.top || 0) + tableHeaderHeight + 'px';
  };

  var onSingleSelection = function onSingleSelection(_ref) {
    var originalEvent = _ref.originalEvent,
        data = _ref.data,
        index = _ref.index,
        toggleable = _ref.toggleable,
        type = _ref.type;

    if (!isSelectable({
      data: data,
      index: index
    })) {
      return;
    }

    var selected = isSelected(data);
    var selection = props.selection;

    if (selected) {
      if (toggleable) {
        selection = null;
        onUnselect({
          originalEvent: originalEvent,
          data: data,
          type: type
        });
      }
    } else {
      selection = data;
      onSelect({
        originalEvent: originalEvent,
        data: data,
        type: type
      });
    }

    focusOnElement(originalEvent, true);

    if (props.onSelectionChange && selection !== props.selection) {
      props.onSelectionChange({
        originalEvent: originalEvent,
        value: selection,
        type: type
      });
    }
  };

  var onMultipleSelection = function onMultipleSelection(_ref2) {
    var originalEvent = _ref2.originalEvent,
        data = _ref2.data,
        index = _ref2.index,
        toggleable = _ref2.toggleable,
        type = _ref2.type;

    if (!isSelectable({
      data: data,
      index: index
    })) {
      return;
    }

    var selected = isSelected(data);
    var selection = props.selection || [];

    if (selected) {
      if (toggleable) {
        var selectionIndex = findIndex(selection, data);
        selection = props.selection.filter(function (val, i) {
          return i !== selectionIndex;
        });
        onUnselect({
          originalEvent: originalEvent,
          data: data,
          type: type
        });
      } else if (selection.length) {
        props.selection.forEach(function (d) {
          return onUnselect({
            originalEvent: originalEvent,
            data: d,
            type: type
          });
        });
        selection = [data];
        onSelect({
          originalEvent: originalEvent,
          data: data,
          type: type
        });
      }
    } else {
      selection = toggleable && isMultipleSelection() ? [].concat(_toConsumableArray$a(selection), [data]) : [data];
      onSelect({
        originalEvent: originalEvent,
        data: data,
        type: type
      });
    }

    focusOnElement(originalEvent, true);

    if (props.onSelectionChange && selection !== props.selection) {
      props.onSelectionChange({
        originalEvent: originalEvent,
        value: selection,
        type: type
      });
    }
  };

  var onRangeSelection = function onRangeSelection(event, type) {
    DomHandler.clearSelection();
    rangeRowIndex.current = allowCellSelection() ? event.rowIndex : event.index;
    var selectionInRange = selectRange(event);
    var selection = isMultipleSelection() ? _toConsumableArray$a(new Set([].concat(_toConsumableArray$a(props.selection || []), _toConsumableArray$a(selectionInRange)))) : selectionInRange;

    if (props.onSelectionChange && selection !== props.selection) {
      props.onSelectionChange({
        originalEvent: event.originalEvent,
        value: selection,
        type: type
      });
    }

    anchorRowIndex.current = rangeRowIndex.current;
    anchorCellIndex.current = event.cellIndex;
    focusOnElement(event.originalEvent, false);
  };

  var selectRange = function selectRange(event) {
    var rangeStart, rangeEnd;

    if (rangeRowIndex.current > anchorRowIndex.current) {
      rangeStart = anchorRowIndex.current;
      rangeEnd = rangeRowIndex.current;
    } else if (rangeRowIndex.current < anchorRowIndex.current) {
      rangeStart = rangeRowIndex.current;
      rangeEnd = anchorRowIndex.current;
    } else {
      rangeStart = rangeEnd = rangeRowIndex.current;
    }

    if (props.paginator) {
      rangeStart = Math.max(rangeStart - props.first, 0);
      rangeEnd -= props.first;
    }

    return allowCellSelection() ? selectRangeOnCell(event, rangeStart, rangeEnd) : selectRangeOnRow(event, rangeStart, rangeEnd);
  };

  var selectRangeOnRow = function selectRangeOnRow(event, rowRangeStart, rowRangeEnd) {
    var value = props.value;
    var selection = [];

    for (var i = rowRangeStart; i <= rowRangeEnd; i++) {
      var rangeRowData = value[i];

      if (!isSelectable({
        data: rangeRowData,
        index: i
      })) {
        continue;
      }

      selection.push(rangeRowData);
      onSelect({
        originalEvent: event.originalEvent,
        data: rangeRowData,
        type: 'row'
      });
    }

    return selection;
  };

  var selectRangeOnCell = function selectRangeOnCell(event, rowRangeStart, rowRangeEnd) {
    var cellRangeStart,
        cellRangeEnd,
        cellIndex = event.cellIndex;

    if (cellIndex > anchorCellIndex.current) {
      cellRangeStart = anchorCellIndex.current;
      cellRangeEnd = cellIndex;
    } else if (cellIndex < anchorCellIndex.current) {
      cellRangeStart = cellIndex;
      cellRangeEnd = anchorCellIndex.current;
    } else {
      cellRangeStart = cellRangeEnd = cellIndex;
    }

    var value = props.value;
    var selection = [];

    for (var i = rowRangeStart; i <= rowRangeEnd; i++) {
      var rowData = value[i];
      var columns = props.columns;

      for (var j = cellRangeStart; j <= cellRangeEnd; j++) {
        var field = columns[j].props.field;

        var _value = ObjectUtils.resolveFieldData(rowData, field);

        var rangeRowData = {
          value: _value,
          field: field,
          rowData: rowData,
          rowIndex: i,
          cellIndex: j,
          selected: true
        };

        if (!isSelectable({
          data: rangeRowData,
          index: i
        })) {
          continue;
        }

        selection.push(rangeRowData);
        onSelect({
          originalEvent: event.originalEvent,
          data: rangeRowData,
          type: 'cell'
        });
      }
    }

    return selection;
  };

  var onSelect = function onSelect(event) {
    if (allowCellSelection()) props.onCellSelect && props.onCellSelect(_objectSpread$5$1(_objectSpread$5$1({
      originalEvent: event.originalEvent
    }, event.data), {}, {
      type: event.type
    }));else props.onRowSelect && props.onRowSelect(event);
  };

  var onUnselect = function onUnselect(event) {
    if (allowCellSelection()) props.onCellUnselect && props.onCellUnselect(_objectSpread$5$1(_objectSpread$5$1({
      originalEvent: event.originalEvent
    }, event.data), {}, {
      type: event.type
    }));else props.onRowUnselect && props.onRowUnselect(event);
  };

  var enableDragSelection = function enableDragSelection(event) {
    if (props.dragSelection && !dragSelectionHelper.current) {
      dragSelectionHelper.current = document.createElement('div');
      DomHandler.addClass(dragSelectionHelper.current, 'p-datatable-drag-selection-helper');
      initialDragPosition.current = {
        x: event.clientX,
        y: event.clientY
      };
      dragSelectionHelper.current.style.top = "".concat(event.pageY, "px");
      dragSelectionHelper.current.style.left = "".concat(event.pageX, "px");
      bindDragSelectionEvents();
    }
  };

  var focusOnElement = function focusOnElement(event, isFocused) {
    var target = event.currentTarget;

    if (!allowCellSelection() && props.selectionAutoFocus) {
      if (isCheckboxSelectionModeInColumn) {
        var checkbox = DomHandler.findSingle(target, 'td.p-selection-column .p-checkbox-box');
        checkbox && checkbox.focus();
      } else if (isRadioSelectionModeInColumn) {
        var radio = DomHandler.findSingle(target, 'td.p-selection-column input[type="radio"]');
        radio && radio.focus();
      }
    }

    !isFocused && target && target.focus();
  };

  var changeTabIndex = function changeTabIndex(event, type) {
    var target = event.currentTarget;
    var isSelectable = DomHandler.hasClass(target, type === 'cell' ? 'p-selectable-cell' : 'p-selectable-row');

    if (isSelectable) {
      var selector = type === 'cell' ? 'tr > td' : 'tr';
      var tabbableEl = DomHandler.findSingle(elementRef.current, "".concat(selector, "[tabindex=\"").concat(props.tabIndex, "\"]"));

      if (tabbableEl && target) {
        tabbableEl.tabIndex = -1;
        target.tabIndex = props.tabIndex;
      }
    }
  };

  var onRowClick = function onRowClick(event) {
    if (allowCellSelection() || !allowSelection(event)) {
      return;
    }

    props.onRowClick && props.onRowClick(event);

    if (allowRowSelection()) {
      if (allowRangeSelection(event)) {
        onRangeSelection(event, 'row');
      } else {
        var toggleable = isRadioSelectionModeInColumn || isCheckboxSelectionModeInColumn || allowMetaKeySelection(event);
        anchorRowIndex.current = event.index;
        rangeRowIndex.current = event.index;
        anchorRowFirst.current = props.first;

        if (isSingleSelection()) {
          onSingleSelection(_objectSpread$5$1(_objectSpread$5$1({}, event), {}, {
            toggleable: toggleable,
            type: 'row'
          }));
        } else {
          onMultipleSelection(_objectSpread$5$1(_objectSpread$5$1({}, event), {}, {
            toggleable: toggleable,
            type: 'row'
          }));
        }
      }

      changeTabIndex(event.originalEvent, 'row');
    } else {
      focusOnElement(event.originalEvent);
    }

    rowTouched.current = false;
  };

  var onRowDoubleClick = function onRowDoubleClick(e) {
    var event = e.originalEvent;

    if (DomHandler.isClickable(event.target)) {
      return;
    }

    if (props.onRowDoubleClick) {
      props.onRowDoubleClick(e);
    }
  };

  var onRowRightClick = function onRowRightClick(event) {
    if (props.onContextMenu || props.onContextMenuSelectionChange) {
      DomHandler.clearSelection();

      if (props.onContextMenuSelectionChange) {
        props.onContextMenuSelectionChange({
          originalEvent: event.originalEvent,
          value: event.data
        });
      }

      if (props.onContextMenu) {
        props.onContextMenu({
          originalEvent: event.originalEvent,
          data: event.data
        });
      }

      event.originalEvent.preventDefault();
    }
  };

  var onRowTouchEnd = function onRowTouchEnd() {
    rowTouched.current = true;
  };

  var onRowMouseDown = function onRowMouseDown(e) {
    var event = e.originalEvent;
    if (DomHandler.hasClass(event.target, 'p-datatable-reorderablerow-handle')) event.currentTarget.draggable = true;else event.currentTarget.draggable = false;

    if (allowRowDrag(e)) {
      enableDragSelection(event);
      anchorRowIndex.current = e.index;
      rangeRowIndex.current = e.index;
      anchorRowFirst.current = props.first;
    }
  };

  var onRowMouseUp = function onRowMouseUp(event) {
    var isSameRow = event.index === anchorRowIndex.current;

    if (allowRowDrag(event) && !isSameRow) {
      onRangeSelection(event, 'row');
    }
  };

  var onRowToggle = function onRowToggle(event) {
    var expandedRows;
    var dataKey = props.dataKey;
    var hasDataKey = props.groupRowsBy ? dataKey === props.groupRowsBy : !!dataKey;

    if (hasDataKey) {
      var dataKeyValue = String(ObjectUtils.resolveFieldData(event.data, dataKey));
      expandedRows = props.expandedRows ? _objectSpread$5$1({}, props.expandedRows) : {};

      if (expandedRows[dataKeyValue] != null) {
        delete expandedRows[dataKeyValue];

        if (props.onRowCollapse) {
          props.onRowCollapse({
            originalEvent: event,
            data: event.data
          });
        }
      } else {
        expandedRows[dataKeyValue] = true;

        if (props.onRowExpand) {
          props.onRowExpand({
            originalEvent: event,
            data: event.data
          });
        }
      }
    } else {
      var expandedRowIndex = findIndex(props.expandedRows, event.data);
      expandedRows = props.expandedRows ? _toConsumableArray$a(props.expandedRows) : [];

      if (expandedRowIndex !== -1) {
        expandedRows = expandedRows.filter(function (_, i) {
          return i !== expandedRowIndex;
        });

        if (props.onRowCollapse) {
          props.onRowCollapse({
            originalEvent: event,
            data: event.data
          });
        }
      } else {
        expandedRows.push(event.data);

        if (props.onRowExpand) {
          props.onRowExpand({
            originalEvent: event,
            data: event.data
          });
        }
      }
    }

    if (props.onRowToggle) {
      props.onRowToggle({
        data: expandedRows
      });
    }
  };

  var onRowDragStart = function onRowDragStart(e) {
    var event = e.originalEvent,
        index = e.index;

    if (allowRowDrag(event)) {
      rowDragging.current = true;
      draggedRowIndex.current = index;
      event.dataTransfer.setData('text', 'b'); // For firefox
    }
  };

  var onRowDragOver = function onRowDragOver(e) {
    var event = e.originalEvent,
        index = e.index;

    if (rowDragging.current && draggedRowIndex.current !== index) {
      var rowElement = event.currentTarget;
      var rowY = DomHandler.getOffset(rowElement).top + DomHandler.getWindowScrollTop();
      var pageY = event.pageY + window.scrollY;
      var rowMidY = rowY + DomHandler.getOuterHeight(rowElement) / 2;
      var prevRowElement = rowElement.previousElementSibling;

      if (pageY < rowMidY) {
        DomHandler.removeClass(rowElement, 'p-datatable-dragpoint-bottom');
        droppedRowIndex.current = index;
        if (prevRowElement) DomHandler.addClass(prevRowElement, 'p-datatable-dragpoint-bottom');else DomHandler.addClass(rowElement, 'p-datatable-dragpoint-top');
      } else {
        if (prevRowElement) DomHandler.removeClass(prevRowElement, 'p-datatable-dragpoint-bottom');else DomHandler.addClass(rowElement, 'p-datatable-dragpoint-top');
        droppedRowIndex.current = index + 1;
        DomHandler.addClass(rowElement, 'p-datatable-dragpoint-bottom');
      }
    }

    event.preventDefault();
  };

  var onRowDragLeave = function onRowDragLeave(e) {
    var event = e.originalEvent;
    var rowElement = event.currentTarget;
    var prevRowElement = rowElement.previousElementSibling;

    if (prevRowElement) {
      DomHandler.removeClass(prevRowElement, 'p-datatable-dragpoint-bottom');
    }

    DomHandler.removeClass(rowElement, 'p-datatable-dragpoint-bottom');
    DomHandler.removeClass(rowElement, 'p-datatable-dragpoint-top');
  };

  var onRowDragEnd = function onRowDragEnd(e) {
    var event = e.originalEvent;
    rowDragging.current = false;
    draggedRowIndex.current = null;
    droppedRowIndex.current = null;
    event.currentTarget.draggable = false;
  };

  var onRowDrop = function onRowDrop(e) {
    var event = e.originalEvent;

    if (droppedRowIndex.current != null) {
      var dropIndex = draggedRowIndex.current > droppedRowIndex.current ? droppedRowIndex.current : droppedRowIndex.current === 0 ? 0 : droppedRowIndex.current - 1;

      var val = _toConsumableArray$a(props.value);

      ObjectUtils.reorderArray(val, draggedRowIndex.current, dropIndex);

      if (props.onRowReorder) {
        props.onRowReorder({
          originalEvent: event,
          value: val,
          dragIndex: draggedRowIndex.current,
          dropIndex: droppedRowIndex.current
        });
      }
    } //cleanup


    onRowDragLeave(e);
    onRowDragEnd(e);
    event.preventDefault();
  };

  var onRadioChange = function onRadioChange(event) {
    onSingleSelection(_objectSpread$5$1(_objectSpread$5$1({}, event), {}, {
      toggleable: true,
      type: 'radio'
    }));
  };

  var onCheckboxChange = function onCheckboxChange(event) {
    onMultipleSelection(_objectSpread$5$1(_objectSpread$5$1({}, event), {}, {
      toggleable: true,
      type: 'checkbox'
    }));
  };

  var onDragSelectionMouseMove = function onDragSelectionMouseMove(event) {
    var _initialDragPosition$ = initialDragPosition.current,
        x = _initialDragPosition$.x,
        y = _initialDragPosition$.y;
    var dx = event.clientX - x;
    var dy = event.clientY - y;
    if (dy < 0) dragSelectionHelper.current.style.top = "".concat(event.pageY + 5, "px");
    if (dx < 0) dragSelectionHelper.current.style.left = "".concat(event.pageX + 5, "px");
    dragSelectionHelper.current.style.height = "".concat(Math.abs(dy), "px");
    dragSelectionHelper.current.style.width = "".concat(Math.abs(dx), "px");
    event.preventDefault();
  };

  var onDragSelectionMouseUp = function onDragSelectionMouseUp() {
    if (dragSelectionHelper.current) {
      dragSelectionHelper.current.remove();
      dragSelectionHelper.current = null;
    }

    document.removeEventListener('mousemove', onDragSelectionMouseMove);
    document.removeEventListener('mouseup', onDragSelectionMouseUp);
  };

  var onCellClick = function onCellClick(event) {
    if (!allowSelection(event)) {
      return;
    }

    props.onCellClick && props.onCellClick(event);

    if (allowCellSelection()) {
      if (allowRangeSelection(event)) {
        onRangeSelection(event, 'cell');
      } else {
        var toggleable = allowMetaKeySelection(event);

        var originalEvent = event.originalEvent,
            data = _objectWithoutProperties(event, _excluded$4);

        anchorRowIndex.current = event.rowIndex;
        rangeRowIndex.current = event.rowIndex;
        anchorRowFirst.current = props.first;
        anchorCellIndex.current = event.cellIndex;

        if (isSingleSelection()) {
          onSingleSelection({
            originalEvent: originalEvent,
            data: data,
            index: event.rowIndex,
            toggleable: toggleable,
            type: 'cell'
          });
        } else {
          onMultipleSelection({
            originalEvent: originalEvent,
            data: data,
            index: event.rowIndex,
            toggleable: toggleable,
            type: 'cell'
          });
        }
      }

      changeTabIndex(event.originalEvent, 'cell');
    }

    rowTouched.current = false;
  };

  var onCellMouseDown = function onCellMouseDown(event) {
    if (allowCellDrag(event)) {
      enableDragSelection(event.originalEvent);
      anchorRowIndex.current = event.rowIndex;
      rangeRowIndex.current = event.rowIndex;
      anchorRowFirst.current = props.first;
      anchorCellIndex.current = event.cellIndex;
    }
  };

  var onCellMouseUp = function onCellMouseUp(event) {
    var isSameCell = event.rowIndex === anchorRowIndex.current && event.cellIndex === anchorCellIndex.current;

    if (allowCellDrag(event) && !isSameCell) {
      onRangeSelection(event, 'cell');
    }
  };

  var bindDragSelectionEvents = function bindDragSelectionEvents() {
    document.addEventListener('mousemove', onDragSelectionMouseMove);
    document.addEventListener('mouseup', onDragSelectionMouseUp);
    document.body.appendChild(dragSelectionHelper.current);
  };

  var unbindDragSelectionEvents = function unbindDragSelectionEvents() {
    onDragSelectionMouseUp();
  };

  React.useEffect(function () {
    if (props.frozenRow) {
      updateFrozenRowStickyPosition();
    }

    if (props.scrollable && props.rowGroupMode === 'subheader') {
      updateFrozenRowGroupHeaderStickyPosition();
    }
  });
  useMountEffect(function () {
    if (!props.isVirtualScrollerDisabled && getVirtualScrollerOption('vertical')) {
      updateVirtualScrollerPosition();
    }
  });
  useUpdateEffect(function () {
    if (!props.isVirtualScrollerDisabled && getVirtualScrollerOption('vertical') && getVirtualScrollerOption('itemSize', prevVirtualScrollerOptions) !== getVirtualScrollerOption('itemSize')) {
      updateVirtualScrollerPosition();
    }
  }, [props.virtualScrollerOptions]);
  useUpdateEffect(function () {
    if (props.paginator && isMultipleSelection()) {
      anchorRowIndex.current = null;
    }
  }, [props.first]);
  useUnmountEffect(function () {
    if (props.dragSelection) {
      unbindDragSelectionEvents();
    }
  });

  var createEmptyContent = function createEmptyContent() {
    if (!props.loading) {
      var colSpan = getColumnsLength();

      var _content = ObjectUtils.getJSXElement(props.emptyMessage, {
        props: props.tableProps,
        frozen: props.frozenRow
      }) || localeOption$1('emptyMessage');

      return /*#__PURE__*/React.createElement("tr", {
        className: "p-datatable-emptymessage",
        role: "row"
      }, /*#__PURE__*/React.createElement("td", {
        colSpan: colSpan,
        role: "cell"
      }, _content));
    }

    return null;
  };

  var createGroupHeader = function createGroupHeader(rowData, index, expanded, colSpan) {
    if (isSubheaderGrouping && shouldRenderRowGroupHeader(props.value, rowData, index - props.first)) {
      var style = rowGroupHeaderStyle();
      var toggler = props.expandableRowGroups && /*#__PURE__*/React.createElement(RowTogglerButton, {
        onClick: onRowToggle,
        rowData: rowData,
        expanded: expanded,
        expandedRowIcon: props.expandedRowIcon,
        collapsedRowIcon: props.collapsedRowIcon
      });

      var _content2 = ObjectUtils.getJSXElement(props.rowGroupHeaderTemplate, rowData, {
        index: index,
        props: props.tableProps
      });

      return /*#__PURE__*/React.createElement("tr", {
        className: "p-rowgroup-header",
        style: style,
        role: "row"
      }, /*#__PURE__*/React.createElement("td", {
        colSpan: colSpan
      }, toggler, /*#__PURE__*/React.createElement("span", {
        className: "p-rowgroup-header-name"
      }, _content2)));
    }

    return null;
  };

  var createRow = function createRow(rowData, index, expanded) {
    if (!props.expandableRowGroups || expanded) {
      var selected = isSelectionEnabled() ? isSelected(rowData) : false;
      var contextMenuSelected = isContextMenuSelected(rowData);

      var _allowRowSelection = allowRowSelection();

      var _allowCellSelection = allowCellSelection();

      var editing = isRowEditing(rowData);
      return /*#__PURE__*/React.createElement(BodyRow, {
        tableProps: props.tableProps,
        tableSelector: props.tableSelector,
        value: props.value,
        columns: props.columns,
        rowData: rowData,
        index: index,
        selected: selected,
        contextMenuSelected: contextMenuSelected,
        onRowClick: onRowClick,
        onRowDoubleClick: onRowDoubleClick,
        onRowRightClick: onRowRightClick,
        tabIndex: props.tabIndex,
        isSelectable: isSelectable,
        onRowTouchEnd: onRowTouchEnd,
        onRowMouseDown: onRowMouseDown,
        onRowMouseUp: onRowMouseUp,
        onRowToggle: onRowToggle,
        onRowDragStart: onRowDragStart,
        onRowDragOver: onRowDragOver,
        onRowDragLeave: onRowDragLeave,
        onRowDragEnd: onRowDragEnd,
        onRowDrop: onRowDrop,
        onRadioChange: onRadioChange,
        onCheckboxChange: onCheckboxChange,
        onCellClick: onCellClick,
        onCellMouseDown: onCellMouseDown,
        onCellMouseUp: onCellMouseUp,
        editing: editing,
        editingRows: props.editingRows,
        editingMeta: props.editingMeta,
        editMode: props.editMode,
        onRowEditChange: props.onRowEditChange,
        onEditingMetaChange: props.onEditingMetaChange,
        groupRowsBy: props.groupRowsBy,
        compareSelectionBy: props.compareSelectionBy,
        dataKey: props.dataKey,
        rowGroupMode: props.rowGroupMode,
        onRowEditInit: props.onRowEditInit,
        rowEditValidator: props.rowEditValidator,
        onRowEditSave: props.onRowEditSave,
        onRowEditComplete: props.onRowEditComplete,
        onRowEditCancel: props.onRowEditCancel,
        selection: props.selection,
        allowRowSelection: _allowRowSelection,
        allowCellSelection: _allowCellSelection,
        selectOnEdit: props.selectOnEdit,
        selectionMode: props.selectionMode,
        selectionModeInColumn: props.selectionModeInColumn,
        cellClassName: props.cellClassName,
        responsiveLayout: props.responsiveLayout,
        frozenRow: props.frozenRow,
        showSelectionElement: props.showSelectionElement,
        showRowReorderElement: props.showRowReorderElement,
        expanded: expanded,
        expandedRowIcon: props.expandedRowIcon,
        collapsedRowIcon: props.collapsedRowIcon,
        rowClassName: props.rowClassName,
        virtualScrollerOptions: props.virtualScrollerOptions
      });
    }
  };

  var createExpansion = function createExpansion(rowData, index, expanded, colSpan) {
    if (expanded && !(isSubheaderGrouping && props.expandableRowGroups)) {
      var id = "".concat(props.tableSelector, "_content_").concat(index, "_expanded");
      var options = {
        index: index,
        customRendering: false
      };

      var _content3 = ObjectUtils.getJSXElement(props.rowExpansionTemplate, rowData, options); // check if the user wants complete control of the rendering


      if (!options.customRendering) {
        _content3 = /*#__PURE__*/React.createElement("td", {
          role: "cell",
          colSpan: colSpan
        }, _content3);
      }

      return /*#__PURE__*/React.createElement("tr", {
        id: id,
        className: "p-datatable-row-expansion",
        role: "row"
      }, _content3);
    }

    return null;
  };

  var createGroupFooter = function createGroupFooter(rowData, index, expanded, colSpan) {
    if (isSubheaderGrouping && shouldRenderRowGroupFooter(props.value, rowData, index - props.first, expanded)) {
      var _content4 = ObjectUtils.getJSXElement(props.rowGroupFooterTemplate, rowData, {
        index: index,
        colSpan: colSpan,
        props: props.tableProps
      });

      return /*#__PURE__*/React.createElement("tr", {
        className: "p-rowgroup-footer",
        role: "row"
      }, _content4);
    }

    return null;
  };

  var createContent = function createContent() {
    return props.value.map(function (rowData, i) {
      var index = getVirtualScrollerOption('getItemOptions') ? getVirtualScrollerOption('getItemOptions')(i).index : props.first + i;
      var key = getRowKey(rowData, index);
      var expanded = isRowExpanded(rowData);
      var colSpan = getColumnsLength();
      var groupHeader = createGroupHeader(rowData, index, expanded, colSpan);
      var row = createRow(rowData, index, expanded);
      var expansion = createExpansion(rowData, index, expanded, colSpan);
      var groupFooter = createGroupFooter(rowData, index, expanded, colSpan);
      return /*#__PURE__*/React.createElement(React.Fragment, {
        key: key
      }, groupHeader, row, expansion, groupFooter);
    });
  };

  var className = classNames('p-datatable-tbody', props.className);
  var content = props.empty ? createEmptyContent() : createContent();
  return /*#__PURE__*/React.createElement("tbody", {
    ref: refCallback,
    className: className
  }, content);
}));
TableBody.displayName = 'TableBody';

function ownKeys$4$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$4$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4$1(Object(source), !0).forEach(function (key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var FooterCell = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState({}),
      _React$useState2 = _slicedToArray$g(_React$useState, 2),
      styleObjectState = _React$useState2[0],
      setStyleObjectState = _React$useState2[1];

  var elementRef = React.useRef(null);

  var getColumnProp = function getColumnProp(prop) {
    return props.column.props[prop];
  };

  var getStyle = function getStyle() {
    var footerStyle = getColumnProp('footerStyle');
    var columnStyle = getColumnProp('style');
    return getColumnProp('frozen') ? Object.assign({}, columnStyle, footerStyle, styleObjectState) : Object.assign({}, columnStyle, footerStyle);
  };

  var updateStickyPosition = function updateStickyPosition() {
    if (getColumnProp('frozen')) {
      var styleObject = _objectSpread$4$1({}, styleObjectState);

      var _align = getColumnProp('alignFrozen');

      if (_align === 'right') {
        var right = 0;
        var next = elementRef.current.nextElementSibling;

        if (next) {
          right = DomHandler.getOuterWidth(next) + parseFloat(next.style.right || 0);
        }

        styleObject['right'] = right + 'px';
      } else {
        var left = 0;
        var prev = elementRef.current.previousElementSibling;

        if (prev) {
          left = DomHandler.getOuterWidth(prev) + parseFloat(prev.style.left || 0);
        }

        styleObject['left'] = left + 'px';
      }

      var isSameStyle = styleObjectState['left'] === styleObject['left'] && styleObjectState['right'] === styleObject['right'];
      !isSameStyle && setStyleObjectState(styleObject);
    }
  };

  React.useEffect(function () {
    if (getColumnProp('frozen')) {
      updateStickyPosition();
    }
  });
  var style = getStyle();
  var align = getColumnProp('align');
  var colSpan = getColumnProp('colSpan');
  var rowSpan = getColumnProp('rowSpan');
  var className = classNames(getColumnProp('footerClassName'), getColumnProp('className'), _defineProperty$8({
    'p-frozen-column': getColumnProp('frozen')
  }, "p-align-".concat(align), !!align));
  var content = ObjectUtils.getJSXElement(getColumnProp('footer'), {
    props: props.tableProps
  });
  return /*#__PURE__*/React.createElement("td", {
    ref: elementRef,
    style: style,
    className: className,
    role: "cell",
    colSpan: colSpan,
    rowSpan: rowSpan
  }, content);
});
FooterCell.displayName = 'FooterCell';
var TableFooter = /*#__PURE__*/React.memo(function (props) {
  var hasFooter = function hasFooter() {
    return props.footerColumnGroup ? true : props.columns ? props.columns.some(function (col) {
      return col && col.props.footer;
    }) : false;
  };

  var createGroupFooterCells = function createGroupFooterCells(row) {
    var columns = React.Children.toArray(row.props.children);
    return createFooterCells(columns);
  };

  var createFooterCells = function createFooterCells(columns) {
    return React.Children.map(columns, function (col, i) {
      var isVisible = col ? !col.props.hidden : true;
      var key = col ? col.props.columnKey || col.props.field || i : i;
      return isVisible && /*#__PURE__*/React.createElement(FooterCell, {
        key: key,
        tableProps: props.tableProps,
        column: col
      });
    });
  };

  var createContent = function createContent() {
    if (props.footerColumnGroup) {
      var rows = React.Children.toArray(props.footerColumnGroup.props.children);
      return rows.map(function (row, i) {
        return /*#__PURE__*/React.createElement("tr", {
          key: i,
          role: "row"
        }, createGroupFooterCells(row));
      });
    }

    return /*#__PURE__*/React.createElement("tr", {
      role: "row"
    }, createFooterCells(props.columns));
  };

  if (hasFooter()) {
    var content = createContent();
    return /*#__PURE__*/React.createElement("tfoot", {
      className: "p-datatable-tfoot"
    }, content);
  }

  return null;
});
TableFooter.displayName = 'TableFooter';

function ownKeys$3$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$3$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3$1(Object(source), !0).forEach(function (key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var ColumnFilter = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$g(_React$useState, 2),
      overlayVisibleState = _React$useState2[0],
      setOverlayVisibleState = _React$useState2[1];

  var overlayRef = React.useRef(null);
  var iconRef = React.useRef(null);
  var selfClick = React.useRef(false);
  var overlayEventListener = React.useRef(null);

  var getColumnProp = function getColumnProp(prop) {
    return props.column.props[prop];
  };

  var field = getColumnProp('filterField') || getColumnProp('field');
  var filterModel = props.filters[field];
  var filterStoreModel = props.filtersStore && props.filtersStore[field];

  var _useOverlayListener = useOverlayListener({
    target: iconRef,
    overlay: overlayRef,
    listener: function listener(event, _ref) {
      var type = _ref.type,
          valid = _ref.valid;

      if (valid) {
        type === 'outside' ? !selfClick.current && !isTargetClicked(event.target) && hide() : hide();
      }

      selfClick.current = false;
    },
    when: overlayVisibleState
  }),
      _useOverlayListener2 = _slicedToArray$g(_useOverlayListener, 2),
      bindOverlayListener = _useOverlayListener2[0],
      unbindOverlayListener = _useOverlayListener2[1];

  var hasFilter = function hasFilter() {
    if (!filterStoreModel || !filterModel) return false;
    return filterStoreModel.operator ? !isFilterBlank(filterModel.constraints[0].value) && filterStoreModel.constraints[0].value !== filterModel.constraints[0].value : !isFilterBlank(filterModel.value) && filterStoreModel.value !== filterModel.value;
  };

  var hasRowFilter = function hasRowFilter() {
    return filterModel && !isFilterBlank(filterModel.value);
  };

  var isFilterBlank = function isFilterBlank(filter) {
    return ObjectUtils.isEmpty(filter);
  };

  var isRowMatchModeSelected = function isRowMatchModeSelected(matchMode) {
    return filterModel && filterModel.matchMode === matchMode;
  };

  var showMenuButton = function showMenuButton() {
    return getColumnProp('showFilterMenu') && (props.display === 'row' ? getColumnProp('dataType') !== 'boolean' : true);
  };

  var matchModes = function matchModes() {
    return getColumnProp('filterMatchModeOptions') || PrimeReact$1.filterMatchModeOptions[findDataType()].map(function (key) {
      return {
        label: localeOption$1(key),
        value: key
      };
    });
  };

  var isShowMatchModes = function isShowMatchModes() {
    return getColumnProp('dataType') !== 'boolean' && getColumnProp('showFilterMatchModes') && matchModes() && getColumnProp('showFilterMenuOptions');
  };

  var isShowOperator = function isShowOperator() {
    return getColumnProp('showFilterOperator') && filterModel && filterModel.operator && getColumnProp('showFilterMenuOptions');
  };

  var showRemoveIcon = function showRemoveIcon() {
    return fieldConstraints().length > 1;
  };

  var isShowAddConstraint = function isShowAddConstraint() {
    return getColumnProp('showAddButton') && filterModel && filterModel.operator && fieldConstraints() && fieldConstraints().length < getColumnProp('maxConstraints') && getColumnProp('showFilterMenuOptions');
  };

  var isOutsideClicked = function isOutsideClicked(target) {
    return !isTargetClicked(target) && overlayRef.current && !(overlayRef.current.isSameNode(target) || overlayRef.current.contains(target));
  };

  var isTargetClicked = function isTargetClicked(target) {
    return iconRef.current && (iconRef.current.isSameNode(target) || iconRef.current.contains(target));
  };

  var getDefaultConstraint = function getDefaultConstraint() {
    if (filterStoreModel) {
      if (filterStoreModel.operator) {
        return {
          matchMode: filterStoreModel.constraints[0].matchMode,
          operator: filterStoreModel.operator
        };
      } else {
        return {
          matchMode: filterStoreModel.matchMode
        };
      }
    }
  };

  var findDataType = function findDataType() {
    var dataType = getColumnProp('dataType');
    var matchMode = getColumnProp('filterMatchMode');

    var hasMatchMode = function hasMatchMode(key) {
      return PrimeReact$1.filterMatchModeOptions[key].some(function (mode) {
        return mode === matchMode;
      });
    };

    if (matchMode === 'custom' && !hasMatchMode(dataType)) {
      PrimeReact$1.filterMatchModeOptions[dataType].push(FilterMatchMode$1.CUSTOM);
      return dataType;
    } else if (matchMode) {
      return Object.keys(PrimeReact$1.filterMatchModeOptions).find(function (key) {
        return hasMatchMode(key);
      }) || dataType;
    }

    return dataType;
  };

  var clearFilter = function clearFilter() {
    var filterClearCallback = getColumnProp('onFilterClear');
    var defaultConstraint = getDefaultConstraint();

    var filters = _objectSpread$3$1({}, props.filters);

    if (filters[field].operator) {
      filters[field].constraints.splice(1);
      filters[field].operator = defaultConstraint.operator;
      filters[field].constraints[0] = {
        value: null,
        matchMode: defaultConstraint.matchMode
      };
    } else {
      filters[field].value = null;
      filters[field].matchMode = defaultConstraint.matchMode;
    }

    filterClearCallback && filterClearCallback();
    props.onFilterChange(filters);
    props.onFilterApply();
    hide();
  };

  var applyFilter = function applyFilter() {
    var filterApplyClickCallback = getColumnProp('onFilterApplyClick');
    filterApplyClickCallback && filterApplyClickCallback({
      field: field,
      constraints: filterModel
    });
    props.onFilterApply();
    hide();
  };

  var toggleMenu = function toggleMenu() {
    setOverlayVisibleState(function (prevVisible) {
      return !prevVisible;
    });
  };

  var onToggleButtonKeyDown = function onToggleButtonKeyDown(event) {
    switch (event.key) {
      case 'Escape':
      case 'Tab':
        hide();
        break;

      case 'ArrowDown':
        if (overlayVisibleState) {
          var focusable = DomHandler.getFirstFocusableElement(overlayRef.current);
          focusable && focusable.focus();
          event.preventDefault();
        } else if (event.altKey) {
          setOverlayVisibleState(true);
          event.preventDefault();
        }

        break;
    }
  };

  var onContentKeyDown = function onContentKeyDown(event) {
    if (event.key === 'Escape') {
      hide();
      iconRef.current && iconRef.current.focus();
    }
  };

  var onInputChange = function onInputChange(event, index) {
    var filters = _objectSpread$3$1({}, props.filters);

    var value = event.target.value;

    if (props.display === 'menu') {
      filters[field].constraints[index].value = value;
    } else {
      filters[field].value = value;
    }

    props.onFilterChange(filters);

    if (!getColumnProp('showApplyButton') || props.display === 'row') {
      props.onFilterApply();
    }
  };

  var onRowMatchModeChange = function onRowMatchModeChange(matchMode) {
    var filterMatchModeChangeCallback = getColumnProp('onFilterMatchModeChange');

    var filters = _objectSpread$3$1({}, props.filters);

    filters[field].matchMode = matchMode;
    filterMatchModeChangeCallback && filterMatchModeChangeCallback({
      field: field,
      matchMode: matchMode
    });
    props.onFilterChange(filters);
    props.onFilterApply();
    hide();
  };

  var onRowMatchModeKeyDown = function onRowMatchModeKeyDown(event, matchMode, clear) {
    var item = event.target;

    switch (event.key) {
      case 'ArrowDown':
        var nextItem = findNextItem(item);

        if (nextItem) {
          item.removeAttribute('tabindex');
          nextItem.tabIndex = 0;
          nextItem.focus();
        }

        event.preventDefault();
        break;

      case 'ArrowUp':
        var prevItem = findPrevItem(item);

        if (prevItem) {
          item.removeAttribute('tabindex');
          prevItem.tabIndex = 0;
          prevItem.focus();
        }

        event.preventDefault();
        break;

      case 'Enter':
        clear ? clearFilter() : onRowMatchModeChange(matchMode.value);
        event.preventDefault();
        break;
    }
  };

  var onOperatorChange = function onOperatorChange(e) {
    var filterOperationChangeCallback = getColumnProp('onFilterOperatorChange');
    var value = e.value;

    var filters = _objectSpread$3$1({}, props.filters);

    filters[field].operator = value;
    props.onFilterChange(filters);
    filterOperationChangeCallback && filterOperationChangeCallback({
      field: field,
      operator: value
    });

    if (!getColumnProp('showApplyButton')) {
      props.onFilterApply();
    }
  };

  var onMenuMatchModeChange = function onMenuMatchModeChange(value, index) {
    var filterMatchModeChangeCallback = getColumnProp('onFilterMatchModeChange');

    var filters = _objectSpread$3$1({}, props.filters);

    filters[field].constraints[index].matchMode = value;
    props.onFilterChange(filters);
    filterMatchModeChangeCallback && filterMatchModeChangeCallback({
      field: field,
      matchMode: value,
      index: index
    });

    if (!getColumnProp('showApplyButton')) {
      props.onFilterApply();
    }
  };

  var addConstraint = function addConstraint() {
    var filterConstraintAddCallback = getColumnProp('onFilterConstraintAdd');
    var defaultConstraint = getDefaultConstraint();

    var filters = _objectSpread$3$1({}, props.filters);

    var newConstraint = {
      value: null,
      matchMode: defaultConstraint.matchMode
    };
    filters[field].constraints.push(newConstraint);
    filterConstraintAddCallback && filterConstraintAddCallback({
      field: field,
      constraint: newConstraint
    });
    props.onFilterChange(filters);

    if (!getColumnProp('showApplyButton')) {
      props.onFilterApply();
    }
  };

  var removeConstraint = function removeConstraint(index) {
    var filterConstraintRemoveCallback = getColumnProp('onFilterConstraintRemove');

    var filters = _objectSpread$3$1({}, props.filters);

    var removedConstraint = filters[field].constraints.splice(index, 1);
    filterConstraintRemoveCallback && filterConstraintRemoveCallback({
      field: field,
      constraint: removedConstraint
    });
    props.onFilterChange(filters);

    if (!getColumnProp('showApplyButton')) {
      props.onFilterApply();
    }
  };

  var findNextItem = function findNextItem(item) {
    var nextItem = item.nextElementSibling;
    return nextItem ? DomHandler.hasClass(nextItem, 'p-column-filter-separator') ? findNextItem(nextItem) : nextItem : item.parentElement.firstElementChild;
  };

  var findPrevItem = function findPrevItem(item) {
    var prevItem = item.previousElementSibling;
    return prevItem ? DomHandler.hasClass(prevItem, 'p-column-filter-separator') ? findPrevItem(prevItem) : prevItem : item.parentElement.lastElementChild;
  };

  var hide = function hide() {
    setOverlayVisibleState(false);
  };

  var onContentClick = function onContentClick(event) {
    selfClick.current = true;
    OverlayService.emit('overlay-click', {
      originalEvent: event,
      target: overlayRef.current
    });
  };

  var onContentMouseDown = function onContentMouseDown() {
    selfClick.current = true;
  };

  var onOverlayEnter = function onOverlayEnter() {
    ZIndexUtils.set('overlay', overlayRef.current, PrimeReact$1.autoZIndex, PrimeReact$1.zIndex['overlay']);
    DomHandler.alignOverlay(overlayRef.current, iconRef.current, PrimeReact$1.appendTo, false);

    overlayEventListener.current = function (e) {
      if (!isOutsideClicked(e.target)) {
        selfClick.current = true;
      }
    };

    OverlayService.on('overlay-click', overlayEventListener.current);
  };

  var onOverlayEntered = function onOverlayEntered() {
    bindOverlayListener();
  };

  var onOverlayExit = function onOverlayExit() {
    onOverlayHide();
  };

  var onOverlayExited = function onOverlayExited() {
    ZIndexUtils.clear(overlayRef.current);
  };

  var onOverlayHide = function onOverlayHide() {
    unbindOverlayListener();
    OverlayService.off('overlay-click', overlayEventListener.current);
    overlayEventListener.current = null;
    selfClick.current = false;
  };

  var fieldConstraints = function fieldConstraints() {
    return filterModel ? filterModel.constraints || [filterModel] : [];
  };

  var operator = function operator() {
    return filterModel.operator;
  };

  var operatorOptions = function operatorOptions() {
    return [{
      label: localeOption$1('matchAll'),
      value: FilterOperator.AND
    }, {
      label: localeOption$1('matchAny'),
      value: FilterOperator.OR
    }];
  };

  var filterLabel = function filterLabel() {
    return localeOption$1('filter');
  };

  var noFilterLabel = function noFilterLabel() {
    return localeOption$1('noFilter');
  };

  var removeRuleButtonLabel = function removeRuleButtonLabel() {
    return localeOption$1('removeRule');
  };

  var addRuleButtonLabel = function addRuleButtonLabel() {
    return localeOption$1('addRule');
  };

  var clearButtonLabel = function clearButtonLabel() {
    return localeOption$1('clear');
  };

  var applyButtonLabel = function applyButtonLabel() {
    return localeOption$1('apply');
  };

  var filterCallback = function filterCallback(value) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var filters = _objectSpread$3$1({}, props.filters);

    var meta = filters[field];
    props.display === 'menu' && meta && meta.operator ? filters[field].constraints[index].value = value : filters[field].value = value;
    props.onFilterChange(filters);
  };

  var filterApplyCallback = function filterApplyCallback() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    args && filterCallback(args[0], args[1]);
    props.onFilterApply();
  };

  useUpdateEffect(function () {
    if (props.display === 'menu' && overlayVisibleState) {
      DomHandler.alignOverlay(overlayRef.current, iconRef.current, PrimeReact$1.appendTo, false);
    }
  });
  useUnmountEffect(function () {
    if (overlayEventListener.current) {
      OverlayService.off('overlay-click', overlayEventListener.current);
      overlayEventListener.current = null;
    }

    if (overlayRef.current) {
      ZIndexUtils.clear(overlayRef.current);
      onOverlayHide();
    }
  });

  var createFilterElement = function createFilterElement(model, index) {
    var value = model ? model.value : null;
    return getColumnProp('filterElement') ? ObjectUtils.getJSXElement(getColumnProp('filterElement'), {
      field: field,
      index: index,
      filterModel: model,
      value: value,
      filterApplyCallback: filterApplyCallback,
      filterCallback: filterCallback
    }) : /*#__PURE__*/React.createElement(InputText$1, {
      type: getColumnProp('filterType'),
      value: value || '',
      onChange: function onChange(e) {
        return onInputChange(e, index);
      },
      className: "p-column-filter",
      placeholder: getColumnProp('filterPlaceholder'),
      maxLength: getColumnProp('filterMaxLength')
    });
  };

  var createRowFilterElement = function createRowFilterElement() {
    if (props.display === 'row') {
      var content = createFilterElement(filterModel, 0);
      return /*#__PURE__*/React.createElement("div", {
        className: "p-fluid p-column-filter-element"
      }, content);
    }

    return null;
  };

  var createMenuFilterElement = function createMenuFilterElement(fieldConstraint, index) {
    return props.display === 'menu' ? createFilterElement(fieldConstraint, index) : null;
  };

  var createMenuButton = function createMenuButton() {
    if (showMenuButton()) {
      var _className = classNames('p-column-filter-menu-button p-link', {
        'p-column-filter-menu-button-open': overlayVisibleState,
        'p-column-filter-menu-button-active': hasFilter()
      });

      var label = filterLabel();
      return /*#__PURE__*/React.createElement("button", {
        ref: iconRef,
        type: "button",
        className: _className,
        "aria-haspopup": true,
        "aria-expanded": overlayVisibleState,
        onClick: toggleMenu,
        onKeyDown: onToggleButtonKeyDown,
        "aria-label": label
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-filter-icon pi-filter",
        "aria-hidden": "true"
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }

    return null;
  };

  var createClearButton = function createClearButton() {
    if (getColumnProp('showClearButton') && props.display === 'row') {
      var _className2 = classNames('p-column-filter-clear-button p-link', {
        'p-hidden-space': !hasRowFilter()
      });

      var clearLabel = clearButtonLabel();
      return /*#__PURE__*/React.createElement("button", {
        className: _className2,
        type: "button",
        onClick: clearFilter,
        "aria-label": clearLabel
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-filter-slash",
        "aria-hidden": "true"
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }

    return null;
  };

  var createRowItems = function createRowItems() {
    if (isShowMatchModes()) {
      var _matchModes = matchModes();

      var _noFilterLabel = noFilterLabel();

      return /*#__PURE__*/React.createElement("ul", {
        className: "p-column-filter-row-items"
      }, _matchModes.map(function (matchMode, i) {
        var value = matchMode.value,
            label = matchMode.label;
        var className = classNames('p-column-filter-row-item', {
          'p-highlight': isRowMatchModeSelected(value)
        });
        var tabIndex = i === 0 ? 0 : null;
        return /*#__PURE__*/React.createElement("li", {
          className: className,
          key: label,
          onClick: function onClick() {
            return onRowMatchModeChange(value);
          },
          onKeyDown: function onKeyDown(e) {
            return onRowMatchModeKeyDown(e, matchMode);
          },
          tabIndex: tabIndex
        }, label);
      }), /*#__PURE__*/React.createElement("li", {
        className: "p-column-filter-separator"
      }), /*#__PURE__*/React.createElement("li", {
        className: "p-column-filter-row-item",
        onClick: clearFilter,
        onKeyDown: function onKeyDown(e) {
          return onRowMatchModeKeyDown(e, null, true);
        }
      }, _noFilterLabel));
    }

    return null;
  };

  var createOperator = function createOperator() {
    if (isShowOperator()) {
      var options = operatorOptions();
      var value = operator();
      return /*#__PURE__*/React.createElement("div", {
        className: "p-column-filter-operator"
      }, /*#__PURE__*/React.createElement(Dropdown$1, {
        options: options,
        value: value,
        onChange: onOperatorChange,
        className: "p-column-filter-operator-dropdown"
      }));
    }

    return null;
  };

  var createMatchModeDropdown = function createMatchModeDropdown(constraint, index) {
    if (isShowMatchModes()) {
      var options = matchModes();
      return /*#__PURE__*/React.createElement(Dropdown$1, {
        options: options,
        value: constraint.matchMode,
        onChange: function onChange(e) {
          return onMenuMatchModeChange(e.value, index);
        },
        className: "p-column-filter-matchmode-dropdown"
      });
    }

    return null;
  };

  var createRemoveButton = function createRemoveButton(index) {
    if (showRemoveIcon()) {
      var removeRuleLabel = removeRuleButtonLabel();
      return /*#__PURE__*/React.createElement(Button$1, {
        type: "button",
        icon: "pi pi-trash",
        className: "p-column-filter-remove-button p-button-text p-button-danger p-button-sm",
        onClick: function onClick() {
          return removeConstraint(index);
        },
        label: removeRuleLabel
      });
    }

    return null;
  };

  var createConstraints = function createConstraints() {
    var _fieldConstraints = fieldConstraints();

    return /*#__PURE__*/React.createElement("div", {
      className: "p-column-filter-constraints"
    }, _fieldConstraints.map(function (fieldConstraint, i) {
      var matchModeDropdown = createMatchModeDropdown(fieldConstraint, i);
      var menuFilterElement = createMenuFilterElement(fieldConstraint, i);
      var removeButton = createRemoveButton(i);
      return /*#__PURE__*/React.createElement("div", {
        key: i,
        className: "p-column-filter-constraint"
      }, matchModeDropdown, menuFilterElement, /*#__PURE__*/React.createElement("div", null, removeButton));
    }));
  };

  var createAddRule = function createAddRule() {
    if (isShowAddConstraint()) {
      var addRuleLabel = addRuleButtonLabel();
      return /*#__PURE__*/React.createElement("div", {
        className: "p-column-filter-add-rule"
      }, /*#__PURE__*/React.createElement(Button$1, {
        type: "button",
        label: addRuleLabel,
        icon: "pi pi-plus",
        className: "p-column-filter-add-button p-button-text p-button-sm",
        onClick: addConstraint
      }));
    }

    return null;
  };

  var createFilterClearButton = function createFilterClearButton() {
    if (getColumnProp('showClearButton')) {
      if (!getColumnProp('filterClear')) {
        var clearLabel = clearButtonLabel();
        return /*#__PURE__*/React.createElement(Button$1, {
          type: "button",
          className: "p-button-outlined p-button-sm",
          onClick: clearFilter,
          label: clearLabel
        });
      }

      return ObjectUtils.getJSXElement(getColumnProp('filterClear'), {
        field: field,
        filterModel: filterModel,
        filterClearCallback: clearFilter
      });
    }

    return null;
  };

  var createFilterApplyButton = function createFilterApplyButton() {
    if (getColumnProp('showApplyButton')) {
      if (!getColumnProp('filterApply')) {
        var applyLabel = applyButtonLabel();
        return /*#__PURE__*/React.createElement(Button$1, {
          type: "button",
          className: "p-button-sm",
          onClick: applyFilter,
          label: applyLabel
        });
      }

      return ObjectUtils.getJSXElement(getColumnProp('filterApply'), {
        field: field,
        filterModel: filterModel,
        filterApplyCallback: applyFilter
      });
    }

    return null;
  };

  var createButtonBar = function createButtonBar() {
    var clearButton = createFilterClearButton();
    var applyButton = createFilterApplyButton();
    return /*#__PURE__*/React.createElement("div", {
      className: "p-column-filter-buttonbar"
    }, clearButton, applyButton);
  };

  var createItems = function createItems() {
    var operator = createOperator();
    var constraints = createConstraints();
    var addRule = createAddRule();
    var buttonBar = createButtonBar();
    return /*#__PURE__*/React.createElement(React.Fragment, null, operator, constraints, addRule, buttonBar);
  };

  var createOverlay = function createOverlay() {
    var style = getColumnProp('filterMenuStyle');
    var className = classNames('p-column-filter-overlay p-component p-fluid', getColumnProp('filterMenuClassName'), {
      'p-column-filter-overlay-menu': props.display === 'menu',
      'p-input-filled': PrimeReact$1.inputStyle === 'filled',
      'p-ripple-disabled': PrimeReact$1.ripple === false
    });
    var filterHeader = ObjectUtils.getJSXElement(getColumnProp('filterHeader'), {
      field: field,
      filterModel: filterModel,
      filterApplyCallback: filterApplyCallback
    });
    var filterFooter = ObjectUtils.getJSXElement(getColumnProp('filterFooter'), {
      field: field,
      filterModel: filterModel,
      filterApplyCallback: filterApplyCallback
    });
    var items = props.display === 'row' ? createRowItems() : createItems();
    return /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(CSSTransition, {
      nodeRef: overlayRef,
      classNames: "p-connected-overlay",
      "in": overlayVisibleState,
      timeout: {
        enter: 120,
        exit: 100
      },
      unmountOnExit: true,
      onEnter: onOverlayEnter,
      onEntered: onOverlayEntered,
      onExit: onOverlayExit,
      onExited: onOverlayExited
    }, /*#__PURE__*/React.createElement("div", {
      ref: overlayRef,
      style: style,
      className: className,
      onKeyDown: onContentKeyDown,
      onClick: onContentClick,
      onMouseDown: onContentMouseDown
    }, filterHeader, items, filterFooter)));
  };

  var className = classNames('p-column-filter p-fluid', {
    'p-column-filter-row': props.display === 'row',
    'p-column-filter-menu': props.display === 'menu'
  });
  var rowFilterElement = createRowFilterElement();
  var menuButton = createMenuButton();
  var clearButton = createClearButton();
  var overlay = createOverlay();
  return /*#__PURE__*/React.createElement("div", {
    className: className
  }, rowFilterElement, menuButton, clearButton, overlay);
});
ColumnFilter.displayName = 'ColumnFilter';
var HeaderCheckbox = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$g(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var onFocus = function onFocus() {
    setFocusedState(true);
  };

  var onBlur = function onBlur() {
    setFocusedState(false);
  };

  var onClick = function onClick(event) {
    if (!props.disabled) {
      setFocusedState(true);
      props.onChange({
        originalEvent: event,
        checked: !props.checked
      });
    }
  };

  var onKeyDown = function onKeyDown(event) {
    if (event.code === 'Space') {
      onClick(event);
      event.preventDefault();
    }
  };

  var boxClassName = classNames('p-checkbox-box p-component', {
    'p-highlight': props.checked,
    'p-disabled': props.disabled,
    'p-focus': focusedState
  });
  var iconClassName = classNames('p-checkbox-icon', {
    'pi pi-check': props.checked
  });
  var tabIndex = props.disabled ? null : 0;
  return /*#__PURE__*/React.createElement("div", {
    className: "p-checkbox p-component",
    onClick: onClick
  }, /*#__PURE__*/React.createElement("div", {
    className: boxClassName,
    role: "checkbox",
    "aria-checked": props.checked,
    tabIndex: tabIndex,
    onFocus: onFocus,
    onBlur: onBlur,
    onKeyDown: onKeyDown
  }, /*#__PURE__*/React.createElement("span", {
    className: iconClassName
  })));
});
HeaderCheckbox.displayName = 'HeaderCheckbox';

function ownKeys$2$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2$1(Object(source), !0).forEach(function (key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var HeaderCell = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState({}),
      _React$useState2 = _slicedToArray$g(_React$useState, 2),
      styleObjectState = _React$useState2[0],
      setStyleObjectState = _React$useState2[1];

  var elementRef = React.useRef(null);
  var prevColumn = usePrevious(props.column);

  var isBadgeVisible = function isBadgeVisible() {
    return props.multiSortMeta && props.multiSortMeta.length > 1;
  };

  var isSortableDisabled = function isSortableDisabled() {
    return !getColumnProp('sortable') || getColumnProp('sortable') && (props.allSortableDisabled || getColumnProp('sortableDisabled'));
  };

  var getColumnProp = function getColumnProp() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return props.column ? typeof args[0] === 'string' ? props.column.props[args[0]] : (args[0] || props.column).props[args[1]] : null;
  };

  var getStyle = function getStyle() {
    var headerStyle = getColumnProp('headerStyle');
    var columnStyle = getColumnProp('style');
    return getColumnProp('frozen') ? Object.assign({}, columnStyle, headerStyle, styleObjectState) : Object.assign({}, columnStyle, headerStyle);
  };

  var getMultiSortMetaIndex = function getMultiSortMetaIndex() {
    return props.multiSortMeta.findIndex(function (meta) {
      return meta.field === getColumnProp('field') || meta.field === getColumnProp('sortField');
    });
  };

  var getSortMeta = function getSortMeta() {
    var sorted = false;
    var sortOrder = 0;
    var metaIndex = -1;

    if (props.sortMode === 'single') {
      sorted = props.sortField && (props.sortField === getColumnProp('field') || props.sortField === getColumnProp('sortField'));
      sortOrder = sorted ? props.sortOrder : 0;
    } else if (props.sortMode === 'multiple') {
      metaIndex = getMultiSortMetaIndex();

      if (metaIndex > -1) {
        sorted = true;
        sortOrder = props.multiSortMeta[metaIndex].order;
      }
    }

    return {
      sorted: sorted,
      sortOrder: sortOrder,
      metaIndex: metaIndex
    };
  };

  var getAriaSort = function getAriaSort(_ref) {
    var sorted = _ref.sorted,
        sortOrder = _ref.sortOrder;

    if (getColumnProp('sortable')) {
      var sortIcon = sorted ? sortOrder < 0 ? 'pi-sort-amount-down' : 'pi-sort-amount-up-alt' : 'pi-sort-alt';
      if (sortIcon === 'pi-sort-amount-down') return 'descending';else if (sortIcon === 'pi-sort-amount-up-alt') return 'ascending';else return 'none';
    }

    return null;
  };

  var updateStickyPosition = function updateStickyPosition() {
    if (getColumnProp('frozen')) {
      var styleObject = _objectSpread$2$1({}, styleObjectState);

      var align = getColumnProp('alignFrozen');

      if (align === 'right') {
        var right = 0;
        var next = elementRef.current.nextElementSibling;

        if (next) {
          right = DomHandler.getOuterWidth(next) + parseFloat(next.style.right || 0);
        }

        styleObject['right'] = right + 'px';
      } else {
        var left = 0;
        var prev = elementRef.current.previousElementSibling;

        if (prev) {
          left = DomHandler.getOuterWidth(prev) + parseFloat(prev.style.left || 0);
        }

        styleObject['left'] = left + 'px';
      }

      var filterRow = elementRef.current.parentElement.nextElementSibling;

      if (filterRow) {
        var index = DomHandler.index(elementRef.current);
        filterRow.children[index].style.left = styleObject['left'];
        filterRow.children[index].style.right = styleObject['right'];
      }

      var isSameStyle = styleObjectState['left'] === styleObject['left'] && styleObjectState['right'] === styleObject['right'];
      !isSameStyle && setStyleObjectState(styleObject);
    }
  };

  var updateSortableDisabled = function updateSortableDisabled(prevColumn) {
    if (getColumnProp(prevColumn, 'sortableDisabled') !== getColumnProp('sortableDisabled') || getColumnProp(prevColumn, 'sortable') !== getColumnProp('sortable')) {
      props.onSortableChange();
    }
  };

  var onClick = function onClick(event) {
    if (!isSortableDisabled()) {
      var targetNode = event.target;

      if (DomHandler.hasClass(targetNode, 'p-sortable-column') || DomHandler.hasClass(targetNode, 'p-column-title') || DomHandler.hasClass(targetNode, 'p-column-header-content') || DomHandler.hasClass(targetNode, 'p-sortable-column-icon') || DomHandler.hasClass(targetNode.parentElement, 'p-sortable-column-icon')) {
        DomHandler.clearSelection();
        props.onSortChange({
          originalEvent: event,
          column: props.column,
          sortableDisabledFields: props.sortableDisabledFields
        });
      }
    }
  };

  var onMouseDown = function onMouseDown(event) {
    props.onColumnMouseDown({
      originalEvent: event,
      column: props.column
    });
  };

  var onKeyDown = function onKeyDown(event) {
    if (event.key === 'Enter' && event.currentTarget === elementRef.current && DomHandler.hasClass(event.currentTarget, 'p-sortable-column')) {
      onClick(event);
      event.preventDefault();
    }
  };

  var onDragStart = function onDragStart(event) {
    props.onColumnDragStart({
      originalEvent: event,
      column: props.column
    });
  };

  var onDragOver = function onDragOver(event) {
    props.onColumnDragOver({
      originalEvent: event,
      column: props.column
    });
  };

  var onDragLeave = function onDragLeave(event) {
    props.onColumnDragLeave({
      originalEvent: event,
      column: props.column
    });
  };

  var onDrop = function onDrop(event) {
    props.onColumnDrop({
      originalEvent: event,
      column: props.column
    });
  };

  var onResizerMouseDown = function onResizerMouseDown(event) {
    props.onColumnResizeStart({
      originalEvent: event,
      column: props.column
    });
  };

  var onResizerClick = function onResizerClick(event) {
    if (props.onColumnResizerClick) {
      props.onColumnResizerClick({
        originalEvent: event,
        element: event.currentTarget.parentElement,
        column: props.column
      });
      event.preventDefault();
    }
  };

  var onResizerDoubleClick = function onResizerDoubleClick(event) {
    if (props.onColumnResizerDoubleClick) {
      props.onColumnResizerDoubleClick({
        originalEvent: event,
        element: event.currentTarget.parentElement,
        column: props.column
      });
      event.preventDefault();
    }
  };

  React.useEffect(function () {
    if (getColumnProp('frozen')) {
      updateStickyPosition();
    }

    updateSortableDisabled(prevColumn);
  });

  var createResizer = function createResizer() {
    if (props.resizableColumns && !getColumnProp('frozen')) {
      return /*#__PURE__*/React.createElement("span", {
        className: "p-column-resizer",
        onMouseDown: onResizerMouseDown,
        onClick: onResizerClick,
        onDoubleClick: onResizerDoubleClick
      });
    }

    return null;
  };

  var createTitle = function createTitle() {
    var title = ObjectUtils.getJSXElement(getColumnProp('header'), {
      props: props.tableProps
    });
    return /*#__PURE__*/React.createElement("span", {
      className: "p-column-title"
    }, title);
  };

  var createSortIcon = function createSortIcon(_ref2) {
    var sorted = _ref2.sorted,
        sortOrder = _ref2.sortOrder;

    if (getColumnProp('sortable')) {
      var sortIcon = sorted ? sortOrder < 0 ? 'pi-sort-amount-down' : 'pi-sort-amount-up-alt' : 'pi-sort-alt';
      var className = classNames('p-sortable-column-icon pi pi-fw', sortIcon);
      return /*#__PURE__*/React.createElement("span", {
        className: className
      });
    }

    return null;
  };

  var createBadge = function createBadge(_ref3) {
    var metaIndex = _ref3.metaIndex;

    if (metaIndex !== -1 && isBadgeVisible()) {
      var value = props.groupRowsBy && props.groupRowsBy === props.groupRowSortField ? metaIndex : metaIndex + 1;
      return /*#__PURE__*/React.createElement("span", {
        className: "p-sortable-column-badge"
      }, value);
    }

    return null;
  };

  var createCheckbox = function createCheckbox() {
    if (props.showSelectAll && getColumnProp('selectionMode') === 'multiple' && props.filterDisplay !== 'row') {
      var allRowsSelected = props.allRowsSelected(props.value);
      return /*#__PURE__*/React.createElement(HeaderCheckbox, {
        checked: allRowsSelected,
        onChange: props.onColumnCheckboxChange,
        disabled: props.empty
      });
    }

    return null;
  };

  var createFilter = function createFilter() {
    if (props.filterDisplay === 'menu' && getColumnProp('filter')) {
      return /*#__PURE__*/React.createElement(ColumnFilter, {
        display: "menu",
        column: props.column,
        filters: props.filters,
        onFilterChange: props.onFilterChange,
        onFilterApply: props.onFilterApply,
        filtersStore: props.filtersStore
      });
    }

    return null;
  };

  var createHeader = function createHeader(sortMeta) {
    var title = createTitle();
    var sortIcon = createSortIcon(sortMeta);
    var badge = createBadge(sortMeta);
    var checkbox = createCheckbox();
    var filter = createFilter();
    return /*#__PURE__*/React.createElement("div", {
      className: "p-column-header-content"
    }, title, sortIcon, badge, checkbox, filter);
  };

  var createElement = function createElement() {
    var _isSortableDisabled = isSortableDisabled();

    var sortMeta = getSortMeta();
    var style = getStyle();
    var align = getColumnProp('alignHeader') || getColumnProp('align');
    var frozen = getColumnProp('frozen');
    var className = classNames(getColumnProp('headerClassName'), getColumnProp('className'), _defineProperty$8({
      'p-sortable-column': getColumnProp('sortable'),
      'p-resizable-column': props.resizableColumns && getColumnProp('resizeable'),
      'p-highlight': sortMeta.sorted,
      'p-frozen-column': frozen,
      'p-selection-column': getColumnProp('selectionMode'),
      'p-sortable-disabled': getColumnProp('sortable') && _isSortableDisabled,
      'p-reorderable-column': props.reorderableColumns && getColumnProp('reorderable') && !frozen
    }, "p-align-".concat(align), !!align));
    var tabIndex = getColumnProp('sortable') && !_isSortableDisabled ? props.tabIndex : null;
    var colSpan = getColumnProp('colSpan');
    var rowSpan = getColumnProp('rowSpan');
    var ariaSort = getAriaSort(sortMeta);
    var resizer = createResizer();
    var header = createHeader(sortMeta);
    return /*#__PURE__*/React.createElement("th", {
      ref: elementRef,
      style: style,
      className: className,
      tabIndex: tabIndex,
      role: "columnheader",
      onClick: onClick,
      onKeyDown: onKeyDown,
      onMouseDown: onMouseDown,
      onDragStart: onDragStart,
      onDragOver: onDragOver,
      onDragLeave: onDragLeave,
      onDrop: onDrop,
      colSpan: colSpan,
      rowSpan: rowSpan,
      "aria-sort": ariaSort
    }, resizer, header);
  };

  var element = createElement();
  return element;
});
HeaderCell.displayName = 'HeaderCell';

function ownKeys$1$3(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1$3(Object(source), !0).forEach(function (key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$3(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var TableHeader = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState([]),
      _React$useState2 = _slicedToArray$g(_React$useState, 2),
      sortableDisabledFieldsState = _React$useState2[0],
      setSortableDisabledFieldsState = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _React$useState4 = _slicedToArray$g(_React$useState3, 2),
      allSortableDisabledState = _React$useState4[0],
      setAllSortableDisabledState = _React$useState4[1];

  var isSingleSort = props.sortMode === 'single';
  var isMultipleSort = props.sortMode === 'multiple';
  var isAllSortableDisabled = isSingleSort && allSortableDisabledState;

  var isColumnSorted = function isColumnSorted(column) {
    return props.sortField !== null ? column.props.field === props.sortField || column.props.sortField === props.sortField : false;
  };

  var updateSortableDisabled = function updateSortableDisabled() {
    if (isSingleSort || isMultipleSort && props.onSortChange) {
      var sortableDisabledFields = [];
      var allSortableDisabled = false;
      props.columns.forEach(function (column) {
        if (column.props.sortableDisabled) {
          sortableDisabledFields.push(column.props.sortField || column.props.field);

          if (!allSortableDisabled && isColumnSorted(column)) {
            allSortableDisabled = true;
          }
        }
      });
      setSortableDisabledFieldsState(sortableDisabledFields);
      setAllSortableDisabledState(allSortableDisabled);
    }
  };

  var onSortableChange = function onSortableChange() {
    updateSortableDisabled();
  };

  var onCheckboxChange = function onCheckboxChange(e) {
    props.onColumnCheckboxChange(e, props.value);
  };

  useMountEffect(function () {
    updateSortableDisabled();
  });

  var createGroupHeaderCells = function createGroupHeaderCells(row) {
    var columns = React.Children.toArray(row.props.children);
    return createHeaderCells(columns);
  };

  var createHeaderCells = function createHeaderCells(columns) {
    return React.Children.map(columns, function (col, i) {
      var isVisible = col ? !col.props.hidden : true;
      var key = col ? col.props.columnKey || col.props.field || i : i;
      return isVisible && /*#__PURE__*/React.createElement(HeaderCell, {
        key: key,
        value: props.value,
        tableProps: props.tableProps,
        column: col,
        tabIndex: props.tabIndex,
        empty: props.empty,
        resizableColumns: props.resizableColumns,
        groupRowsBy: props.groupRowsBy,
        groupRowSortField: props.groupRowSortField,
        sortMode: props.sortMode,
        sortField: props.sortField,
        sortOrder: props.sortOrder,
        multiSortMeta: props.multiSortMeta,
        allSortableDisabled: isAllSortableDisabled,
        onSortableChange: onSortableChange,
        sortableDisabledFields: sortableDisabledFieldsState,
        filterDisplay: props.filterDisplay,
        filters: props.filters,
        filtersStore: props.filtersStore,
        onFilterChange: props.onFilterChange,
        onFilterApply: props.onFilterApply,
        onColumnMouseDown: props.onColumnMouseDown,
        onColumnDragStart: props.onColumnDragStart,
        onColumnDragOver: props.onColumnDragOver,
        onColumnDragLeave: props.onColumnDragLeave,
        onColumnDrop: props.onColumnDrop,
        onColumnResizeStart: props.onColumnResizeStart,
        onColumnResizerClick: props.onColumnResizerClick,
        onColumnResizerDoubleClick: props.onColumnResizerDoubleClick,
        showSelectAll: props.showSelectAll,
        allRowsSelected: props.allRowsSelected,
        onColumnCheckboxChange: onCheckboxChange,
        reorderableColumns: props.reorderableColumns,
        onSortChange: props.onSortChange
      });
    });
  };

  var createCheckbox = function createCheckbox(selectionMode) {
    if (props.showSelectAll && selectionMode === 'multiple') {
      var allRowsSelected = props.allRowsSelected(props.value);
      return /*#__PURE__*/React.createElement(HeaderCheckbox, {
        checked: allRowsSelected,
        onChange: onCheckboxChange,
        disabled: props.empty
      });
    }

    return null;
  };

  var createFilter = function createFilter(column, filter) {
    if (filter) {
      return /*#__PURE__*/React.createElement(ColumnFilter, {
        display: "row",
        column: column,
        filters: props.filters,
        filtersStore: props.filtersStore,
        onFilterChange: props.onFilterChange,
        onFilterApply: props.onFilterApply
      });
    }

    return null;
  };

  var createFilterCells = function createFilterCells() {
    return React.Children.map(props.columns, function (col, i) {
      var isVisible = !col.props.hidden;

      if (isVisible) {
        var _col$props = col.props,
            filterHeaderStyle = _col$props.filterHeaderStyle,
            style = _col$props.style,
            filterHeaderClassName = _col$props.filterHeaderClassName,
            className = _col$props.className,
            frozen = _col$props.frozen,
            columnKey = _col$props.columnKey,
            field = _col$props.field,
            selectionMode = _col$props.selectionMode,
            filter = _col$props.filter;

        var colStyle = _objectSpread$1$3(_objectSpread$1$3({}, filterHeaderStyle || {}), style || {});

        var colClassName = classNames('p-filter-column', filterHeaderClassName, className, {
          'p-frozen-column': frozen
        });
        var colKey = columnKey || field || i;
        var checkbox = createCheckbox(selectionMode);
        var filterRow = createFilter(col, filter);
        return /*#__PURE__*/React.createElement("th", {
          key: colKey,
          style: colStyle,
          className: colClassName
        }, checkbox, filterRow);
      }

      return null;
    });
  };

  var createContent = function createContent() {
    if (props.headerColumnGroup) {
      var rows = React.Children.toArray(props.headerColumnGroup.props.children);
      return rows.map(function (row, i) {
        return /*#__PURE__*/React.createElement("tr", {
          key: i,
          role: "row"
        }, createGroupHeaderCells(row));
      });
    } else {
      var headerRow = /*#__PURE__*/React.createElement("tr", {
        role: "row"
      }, createHeaderCells(props.columns));
      var filterRow = props.filterDisplay === 'row' && /*#__PURE__*/React.createElement("tr", {
        role: "row"
      }, createFilterCells());
      return /*#__PURE__*/React.createElement(React.Fragment, null, headerRow, filterRow);
    }
  };

  var content = createContent();
  return /*#__PURE__*/React.createElement("thead", {
    className: "p-datatable-thead"
  }, content);
});
TableHeader.displayName = 'TableHeader';

function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$8(Object(source), !0).forEach(function (key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var DataTable$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(props.first),
      _React$useState2 = _slicedToArray$g(_React$useState, 2),
      firstState = _React$useState2[0],
      setFirstState = _React$useState2[1];

  var _React$useState3 = React.useState(props.rows),
      _React$useState4 = _slicedToArray$g(_React$useState3, 2),
      rowsState = _React$useState4[0],
      setRowsState = _React$useState4[1];

  var _React$useState5 = React.useState(props.sortField),
      _React$useState6 = _slicedToArray$g(_React$useState5, 2),
      sortFieldState = _React$useState6[0],
      setSortFieldState = _React$useState6[1];

  var _React$useState7 = React.useState(props.sortOrder),
      _React$useState8 = _slicedToArray$g(_React$useState7, 2),
      sortOrderState = _React$useState8[0],
      setSortOrderState = _React$useState8[1];

  var _React$useState9 = React.useState(props.multiSortMeta),
      _React$useState10 = _slicedToArray$g(_React$useState9, 2),
      multiSortMetaState = _React$useState10[0],
      setMultiSortMetaState = _React$useState10[1];

  var _React$useState11 = React.useState(props.filters),
      _React$useState12 = _slicedToArray$g(_React$useState11, 2),
      filtersState = _React$useState12[0],
      setFiltersState = _React$useState12[1];

  var _React$useState13 = React.useState([]),
      _React$useState14 = _slicedToArray$g(_React$useState13, 2),
      columnOrderState = _React$useState14[0],
      setColumnOrderState = _React$useState14[1];

  var _React$useState15 = React.useState(null),
      _React$useState16 = _slicedToArray$g(_React$useState15, 2),
      groupRowsSortMetaState = _React$useState16[0],
      setGroupRowsSortMetaState = _React$useState16[1];

  var _React$useState17 = React.useState({}),
      _React$useState18 = _slicedToArray$g(_React$useState17, 2),
      editingMetaState = _React$useState18[0],
      setEditingMetaState = _React$useState18[1];

  var _React$useState19 = React.useState(null),
      _React$useState20 = _slicedToArray$g(_React$useState19, 2),
      attributeSelectorState = _React$useState20[0],
      setAttributeSelectorState = _React$useState20[1];

  var _React$useState21 = React.useState(props.rows),
      _React$useState22 = _slicedToArray$g(_React$useState21, 2),
      d_rowsState = _React$useState22[0],
      setD_rowsState = _React$useState22[1];

  var _React$useState23 = React.useState({}),
      _React$useState24 = _slicedToArray$g(_React$useState23, 2),
      d_filtersState = _React$useState24[0],
      setD_filtersState = _React$useState24[1];

  var elementRef = React.useRef(null);
  var tableRef = React.useRef(null);
  var wrapperRef = React.useRef(null);
  var bodyRef = React.useRef(null);
  var frozenBodyRef = React.useRef(null);
  var virtualScrollerRef = React.useRef(null);
  var reorderIndicatorUpRef = React.useRef(null);
  var reorderIndicatorDownRef = React.useRef(null);
  var colReorderIconWidth = React.useRef(null);
  var colReorderIconHeight = React.useRef(null);
  var resizeHelperRef = React.useRef(null);
  var draggedColumnElement = React.useRef(null);
  var draggedColumn = React.useRef(null);
  var dropPosition = React.useRef(null);
  var styleElement = React.useRef(null);
  var responsiveStyleElement = React.useRef(null);
  var columnWidthsState = React.useRef(null);
  var tableWidthState = React.useRef(null);
  var resizeColumn = React.useRef(null);
  var resizeColumnElement = React.useRef(null);
  var columnResizing = React.useRef(false);
  var lastResizeHelperX = React.useRef(null);
  var columnSortable = React.useRef(false);
  var columnSortFunction = React.useRef(null);
  var columnField = React.useRef(null);
  var filterTimeout = React.useRef(null);

  if (props.rows !== d_rowsState && !props.onPage) {
    setRowsState(props.rows);
    setD_rowsState(props.rows);
  }

  var _useEventListener = useEventListener({
    type: 'mousemove',
    listener: function listener(event) {
      if (columnResizing.current) {
        onColumnResize(event);
      }
    }
  }),
      _useEventListener2 = _slicedToArray$g(_useEventListener, 2),
      bindDocumentMouseMoveListener = _useEventListener2[0],
      unbindDocumentMouseMoveListener = _useEventListener2[1];

  var _useEventListener3 = useEventListener({
    type: 'mouseup',
    listener: function listener() {
      if (columnResizing.current) {
        columnResizing.current = false;
        onColumnResizeEnd();
      }
    }
  }),
      _useEventListener4 = _slicedToArray$g(_useEventListener3, 2),
      bindDocumentMouseUpListener = _useEventListener4[0],
      unbindDocumentMouseUpListener = _useEventListener4[1];

  var isCustomStateStorage = function isCustomStateStorage() {
    return props.stateStorage === 'custom';
  };

  var isStateful = function isStateful() {
    return props.stateKey != null || isCustomStateStorage();
  };

  var isVirtualScrollerDisabled = function isVirtualScrollerDisabled() {
    return ObjectUtils.isEmpty(props.virtualScrollerOptions) || !props.scrollable;
  };

  var isEquals = function isEquals(data1, data2) {
    return props.compareSelectionBy === 'equals' ? data1 === data2 : ObjectUtils.equals(data1, data2, props.dataKey);
  };

  var hasFilter = function hasFilter() {
    return ObjectUtils.isNotEmpty(getFilters()) || props.globalFilter;
  };

  var getFirst = function getFirst() {
    return props.onPage ? props.first : firstState;
  };

  var getRows = function getRows() {
    return props.onPage ? props.rows : rowsState;
  };

  var getSortField = function getSortField() {
    return props.onSort ? props.sortField : sortFieldState;
  };

  var getSortOrder = function getSortOrder() {
    return props.onSort ? props.sortOrder : sortOrderState;
  };

  var getMultiSortMeta = function getMultiSortMeta() {
    return (props.onSort ? props.multiSortMeta : multiSortMetaState) || [];
  };

  var getFilters = function getFilters() {
    return props.onFilter ? props.filters : filtersState;
  };

  var getColumnProp = function getColumnProp(col, prop) {
    return col.props[prop];
  };

  var getColumns = function getColumns(ignoreReorderable) {
    var columns = React.Children.toArray(props.children);

    if (!columns) {
      return null;
    }

    if (!ignoreReorderable && props.reorderableColumns && columnOrderState) {
      var orderedColumns = columnOrderState.reduce(function (arr, columnKey) {
        var column = findColumnByKey(columns, columnKey);
        column && arr.push(column);
        return arr;
      }, []);
      return [].concat(_toConsumableArray$a(orderedColumns), _toConsumableArray$a(columns.filter(function (col) {
        return orderedColumns.indexOf(col) < 0;
      })));
    }

    return columns;
  };

  var getStorage = function getStorage() {
    switch (props.stateStorage) {
      case 'local':
        return window.localStorage;

      case 'session':
        return window.sessionStorage;

      case 'custom':
        return null;

      default:
        throw new Error(props.stateStorage + ' is not a valid value for the state storage, supported values are "local", "session" and "custom".');
    }
  };

  var saveState = function saveState() {
    var state = {};

    if (props.paginator) {
      state.first = getFirst();
      state.rows = getRows();
    }

    var sortField = getSortField();

    if (sortField) {
      state.sortField = sortField;
      state.sortOrder = getSortOrder();
    }

    var multiSortMeta = getMultiSortMeta();

    if (multiSortMeta) {
      state.multiSortMeta = multiSortMeta;
    }

    if (hasFilter()) {
      state.filters = getFilters();
    }

    if (props.resizableColumns) {
      saveColumnWidths(state);
    }

    if (props.reorderableColumns) {
      state.columnOrder = columnOrderState;
    }

    if (props.expandedRows) {
      state.expandedRows = props.expandedRows;
    }

    if (props.selection && props.onSelectionChange) {
      state.selection = props.selection;
    }

    if (isCustomStateStorage()) {
      if (props.customSaveState) {
        props.customSaveState(state);
      }
    } else {
      var storage = getStorage();

      if (ObjectUtils.isNotEmpty(state)) {
        storage.setItem(props.stateKey, JSON.stringify(state));
      }
    }

    if (props.onStateSave) {
      props.onStateSave(state);
    }
  };

  var clearState = function clearState() {
    var storage = getStorage();

    if (storage && props.stateKey) {
      storage.removeItem(props.stateKey);
    }
  };

  var restoreState = function restoreState() {
    var restoredState = {};

    if (isCustomStateStorage()) {
      if (props.customRestoreState) {
        restoredState = props.customRestoreState();
      }
    } else {
      var storage = getStorage();
      var stateString = storage.getItem(props.stateKey);
      var dateFormat = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/;

      var reviver = function reviver(key, value) {
        return typeof value === 'string' && dateFormat.test(value) ? new Date(value) : value;
      };

      if (stateString) {
        restoredState = JSON.parse(stateString, reviver);
      }
    }

    _restoreState(restoredState);
  };

  var restoreTableState = function restoreTableState(restoredState) {
    _restoreState(restoredState);
  };

  var _restoreState = function _restoreState() {
    var restoredState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (ObjectUtils.isNotEmpty(restoredState)) {
      if (props.paginator) {
        if (props.onPage) {
          var getOnPageParams = function getOnPageParams(first, rows) {
            var totalRecords = getTotalRecords(processedData());
            var pageCount = Math.ceil(totalRecords / rows) || 1;
            var page = Math.floor(first / rows);
            return {
              first: first,
              rows: rows,
              page: page,
              pageCount: pageCount
            };
          };

          props.onPage(createEvent(getOnPageParams(restoredState.first, restoredState.rows)));
        } else {
          setFirstState(restoredState.first);
          setRowsState(restoredState.rows);
        }
      }

      if (restoredState.sortField) {
        if (props.onSort) {
          props.onSort(createEvent({
            sortField: restoredState.sortField,
            sortOrder: restoredState.sortOrder
          }));
        } else {
          setSortFieldState(restoredState.sortField);
          setSortOrderState(restoredState.sortOrder);
        }
      }

      if (restoredState.multiSortMeta) {
        if (props.onSort) {
          props.onSort(createEvent({
            multiSortMeta: restoredState.multiSortMeta
          }));
        } else {
          setMultiSortMetaState(restoredState.multiSortMeta);
        }
      }

      if (restoredState.filters) {
        setD_filtersState(cloneFilters(restoredState.filters));

        if (props.onFilter) {
          props.onFilter(createEvent({
            filters: restoredState.filters
          }));
        } else {
          setFiltersState(cloneFilters(restoredState.filters));
        }
      }

      if (props.resizableColumns) {
        columnWidthsState.current = restoredState.columnWidths;
        tableWidthState.current = restoredState.tableWidth;
        restoreColumnWidths();
      }

      if (props.reorderableColumns) {
        setColumnOrderState(restoredState.columnOrder);
      }

      if (restoredState.expandedRows && props.onRowToggle) {
        props.onRowToggle({
          data: restoredState.expandedRows
        });
      }

      if (restoredState.selection && props.onSelectionChange) {
        props.onSelectionChange({
          value: restoredState.selection
        });
      }

      if (props.onStateRestore) {
        props.onStateRestore(restoredState);
      }
    }
  };

  var saveColumnWidths = function saveColumnWidths(state) {
    var widths = [];
    var headers = DomHandler.find(elementRef.current, '.p-datatable-thead > tr > th');
    headers.forEach(function (header) {
      return widths.push(DomHandler.getOuterWidth(header));
    });
    state.columnWidths = widths.join(',');

    if (props.columnResizeMode === 'expand') {
      state.tableWidth = DomHandler.getOuterWidth(tableRef.current) + 'px';
    }
  };

  var restoreColumnWidths = function restoreColumnWidths() {
    if (columnWidthsState.current) {
      var widths = columnWidthsState.current.split(',');

      if (props.columnResizeMode === 'expand' && tableWidthState.current) {
        tableRef.current.style.width = tableWidthState.current;
        tableRef.current.style.minWidth = tableWidthState.current;
        elementRef.current.style.width = tableWidthState.current;
      }

      if (ObjectUtils.isNotEmpty(widths)) {
        createStyleElement();
        var innerHTML = '';
        widths.forEach(function (width, index) {
          var style = props.scrollable ? "flex: 1 1 ".concat(width, "px !important") : "width: ".concat(width, "px !important");
          innerHTML += "\n                        .p-datatable[".concat(attributeSelectorState, "] .p-datatable-thead > tr > th:nth-child(").concat(index + 1, "),\n                        .p-datatable[").concat(attributeSelectorState, "] .p-datatable-tbody > tr > td:nth-child(").concat(index + 1, "),\n                        .p-datatable[").concat(attributeSelectorState, "] .p-datatable-tfoot > tr > td:nth-child(").concat(index + 1, ") {\n                            ").concat(style, "\n                        }\n                    ");
        });
        styleElement.current.innerHTML = innerHTML;
      }
    }
  };

  var findParentHeader = function findParentHeader(element) {
    if (element.nodeName === 'TH') {
      return element;
    } else {
      var parent = element.parentElement;

      while (parent.nodeName !== 'TH') {
        parent = parent.parentElement;
        if (!parent) break;
      }

      return parent;
    }
  };

  var getGroupRowSortField = function getGroupRowSortField() {
    return props.sortMode === 'single' ? props.sortField : groupRowsSortMetaState ? groupRowsSortMetaState.field : null;
  };

  var getSelectableData = function getSelectableData(val) {
    if (props.showSelectionElement || props.isDataSelectable) {
      return val.filter(function (data, index) {
        var isSelectable = true;
        if (props.showSelectionElement) isSelectable = props.showSelectionElement({
          rowIndex: index,
          props: props
        });
        if (props.isDataSelectable && isSelectable) isSelectable = props.isDataSelectable({
          data: data,
          index: index
        });
        return isSelectable;
      });
    }

    return val;
  };

  var allRowsSelected = function allRowsSelected(processedData) {
    if (props.onSelectAllChange) {
      return props.selectAll;
    } else {
      var _data = props.selectionPageOnly ? dataToRender(processedData) : processedData;

      var val = props.frozenValue ? [].concat(_toConsumableArray$a(props.frozenValue), _toConsumableArray$a(_data)) : _data;
      var selectableVal = getSelectableData(val);
      return selectableVal && props.selection && selectableVal.every(function (sv) {
        return props.selection.some(function (s) {
          return isEquals(s, sv);
        });
      });
    }
  };

  var getSelectionModeInColumn = function getSelectionModeInColumn(columns) {
    if (columns) {
      var col = columns.find(function (c) {
        return !!c.props.selectionMode;
      });
      return col ? col.props.selectionMode : null;
    }

    return null;
  };

  var findColumnByKey = function findColumnByKey(columns, key) {
    return ObjectUtils.isNotEmpty(columns) ? columns.find(function (col) {
      return col.props.columnKey === key || col.props.field === key;
    }) : null;
  };

  var getTotalRecords = function getTotalRecords(data) {
    return props.lazy ? props.totalRecords : data ? data.length : 0;
  };

  var onEditingMetaChange = function onEditingMetaChange(e) {
    var rowData = e.rowData,
        field = e.field,
        editingKey = e.editingKey;
    e.rowIndex;
    var editing = e.editing;

    var editingMeta = _objectSpread$8({}, editingMetaState);

    var meta = editingMeta[editingKey];

    if (editing) {
      !meta && (meta = editingMeta[editingKey] = {
        data: _objectSpread$8({}, rowData),
        fields: []
      });
      meta['fields'].push(field);
    } else if (meta) {
      var fields = meta['fields'].filter(function (f) {
        return f !== field;
      });
      !fields.length ? delete editingMeta[editingKey] : meta['fields'] = fields;
    }

    setEditingMetaState(editingMeta);
  };

  var clearEditingMetaData = function clearEditingMetaData() {
    if (props.editMode && ObjectUtils.isNotEmpty(editingMetaState)) {
      setEditingMetaState({});
    }
  };

  var onColumnResizeStart = function onColumnResizeStart(e) {
    var event = e.originalEvent,
        column = e.column;
    var containerLeft = DomHandler.getOffset(elementRef.current).left;
    resizeColumn.current = column;
    resizeColumnElement.current = event.currentTarget.parentElement;
    columnResizing.current = true;
    lastResizeHelperX.current = event.pageX - containerLeft + elementRef.current.scrollLeft;
    bindColumnResizeEvents();
  };

  var onColumnResize = function onColumnResize(event) {
    var containerLeft = DomHandler.getOffset(elementRef.current).left;
    DomHandler.addClass(elementRef.current, 'p-unselectable-text');
    resizeHelperRef.current.style.height = elementRef.current.offsetHeight + 'px';
    resizeHelperRef.current.style.top = 0 + 'px';
    resizeHelperRef.current.style.left = event.pageX - containerLeft + elementRef.current.scrollLeft + 'px';
    resizeHelperRef.current.style.display = 'block';
  };

  var onColumnResizeEnd = function onColumnResizeEnd() {
    var delta = resizeHelperRef.current.offsetLeft - lastResizeHelperX.current;
    var columnWidth = resizeColumnElement.current.offsetWidth;
    var newColumnWidth = columnWidth + delta;
    var minWidth = resizeColumnElement.current.style.minWidth || 15;

    if (columnWidth + delta > parseInt(minWidth, 10)) {
      if (props.columnResizeMode === 'fit') {
        var nextColumn = resizeColumnElement.current.nextElementSibling;
        var nextColumnWidth = nextColumn.offsetWidth - delta;

        if (newColumnWidth > 15 && nextColumnWidth > 15) {
          resizeTableCells(newColumnWidth, nextColumnWidth);
        }
      } else if (props.columnResizeMode === 'expand') {
        var tableWidth = tableRef.current.offsetWidth + delta + 'px';

        var updateTableWidth = function updateTableWidth(el) {
          !!el && (el.style.width = el.style.minWidth = tableWidth);
        };

        updateTableWidth(tableRef.current);

        if (!isVirtualScrollerDisabled()) {
          updateTableWidth(bodyRef.current);
          updateTableWidth(frozenBodyRef.current);

          if (wrapperRef.current) {
            updateTableWidth(DomHandler.findSingle(wrapperRef.current, '.p-virtualscroller-content'));
          }
        }

        resizeTableCells(newColumnWidth);
      }

      if (props.onColumnResizeEnd) {
        props.onColumnResizeEnd({
          element: resizeColumnElement.current,
          column: resizeColumn.current,
          delta: delta
        });
      }

      if (isStateful()) {
        saveState();
      }
    }

    resizeHelperRef.current.style.display = 'none';
    resizeColumn.current = null;
    resizeColumnElement.current = null;
    DomHandler.removeClass(elementRef.current, 'p-unselectable-text');
    unbindColumnResizeEvents();
  };

  var resizeTableCells = function resizeTableCells(newColumnWidth, nextColumnWidth) {
    var widths = [];
    var colIndex = DomHandler.index(resizeColumnElement.current);
    var headers = DomHandler.find(tableRef.current, '.p-datatable-thead > tr > th');
    headers.forEach(function (header) {
      return widths.push(DomHandler.getOuterWidth(header));
    });
    destroyStyleElement();
    createStyleElement();
    var innerHTML = '';
    widths.forEach(function (width, index) {
      var colWidth = index === colIndex ? newColumnWidth : nextColumnWidth && index === colIndex + 1 ? nextColumnWidth : width;
      var style = props.scrollable ? "flex: 1 1 ".concat(colWidth, "px !important") : "width: ".concat(colWidth, "px !important");
      innerHTML += "\n                .p-datatable[".concat(attributeSelectorState, "] .p-datatable-thead > tr > th:nth-child(").concat(index + 1, "),\n                .p-datatable[").concat(attributeSelectorState, "] .p-datatable-tbody > tr > td:nth-child(").concat(index + 1, "),\n                .p-datatable[").concat(attributeSelectorState, "] .p-datatable-tfoot > tr > td:nth-child(").concat(index + 1, ") {\n                    ").concat(style, "\n                }\n            ");
    });
    styleElement.current.innerHTML = innerHTML;
  };

  var bindColumnResizeEvents = function bindColumnResizeEvents() {
    bindDocumentMouseMoveListener();
    bindDocumentMouseUpListener();
  };

  var unbindColumnResizeEvents = function unbindColumnResizeEvents() {
    unbindDocumentMouseMoveListener();
    unbindDocumentMouseUpListener();
  };

  var onColumnHeaderMouseDown = function onColumnHeaderMouseDown(e) {
    DomHandler.clearSelection();
    var event = e.originalEvent,
        column = e.column;

    if (props.reorderableColumns && getColumnProp(column, 'reorderable') !== false && !getColumnProp(column, 'frozen')) {
      if (event.target.nodeName === 'INPUT' || event.target.nodeName === 'TEXTAREA' || DomHandler.hasClass(event.target, 'p-column-resizer')) event.currentTarget.draggable = false;else event.currentTarget.draggable = true;
    }
  };

  var onColumnHeaderCheckboxChange = function onColumnHeaderCheckboxChange(e, processedData) {
    if (props.onSelectAllChange) {
      props.onSelectAllChange(e);
    } else {
      var originalEvent = e.originalEvent,
          checked = e.checked;

      var _data2 = props.selectionPageOnly ? dataToRender(processedData) : processedData;

      var selection = props.selectionPageOnly && props.selection ? props.selection.filter(function (s) {
        return !_data2.some(function (d) {
          return isEquals(s, d);
        });
      }) : [];

      if (checked) {
        selection = props.frozenValue ? [].concat(_toConsumableArray$a(selection), _toConsumableArray$a(props.frozenValue), _toConsumableArray$a(_data2)) : [].concat(_toConsumableArray$a(selection), _toConsumableArray$a(_data2));
        selection = getSelectableData(selection);
        props.onAllRowsSelect && props.onAllRowsSelect({
          originalEvent: originalEvent,
          data: selection,
          type: 'all'
        });
      } else {
        props.onAllRowsUnselect && props.onAllRowsUnselect({
          originalEvent: originalEvent,
          data: selection,
          type: 'all'
        });
      }

      if (props.onSelectionChange) {
        props.onSelectionChange({
          originalEvent: originalEvent,
          value: selection,
          type: 'all'
        });
      }
    }
  };

  var onColumnHeaderDragStart = function onColumnHeaderDragStart(e) {
    var event = e.originalEvent,
        column = e.column;

    if (columnResizing.current) {
      event.preventDefault();
      return;
    }

    colReorderIconWidth.current = DomHandler.getHiddenElementOuterWidth(reorderIndicatorUpRef.current);
    colReorderIconHeight.current = DomHandler.getHiddenElementOuterHeight(reorderIndicatorUpRef.current);
    draggedColumn.current = column;
    draggedColumnElement.current = findParentHeader(event.currentTarget);
    event.dataTransfer.setData('text', 'b'); // Firefox requires this to make dragging possible
  };

  var onColumnHeaderDragOver = function onColumnHeaderDragOver(e) {
    var event = e.originalEvent,
        column = e.column;
    var dropHeader = findParentHeader(event.currentTarget);

    if (props.reorderableColumns && draggedColumnElement.current && dropHeader && !getColumnProp(column, 'frozen')) {
      event.preventDefault();

      if (draggedColumnElement.current !== dropHeader) {
        var containerOffset = DomHandler.getOffset(elementRef.current);
        var dropHeaderOffset = DomHandler.getOffset(dropHeader);
        var targetLeft = dropHeaderOffset.left - containerOffset.left;
        var columnCenter = dropHeaderOffset.left + dropHeader.offsetWidth / 2;
        reorderIndicatorUpRef.current.style.top = dropHeaderOffset.top - containerOffset.top - (colReorderIconHeight.current - 1) + 'px';
        reorderIndicatorDownRef.current.style.top = dropHeaderOffset.top - containerOffset.top + dropHeader.offsetHeight + 'px';

        if (event.pageX > columnCenter) {
          reorderIndicatorUpRef.current.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(colReorderIconWidth.current / 2) + 'px';
          reorderIndicatorDownRef.current.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(colReorderIconWidth.current / 2) + 'px';
          dropPosition.current = 1;
        } else {
          reorderIndicatorUpRef.current.style.left = targetLeft - Math.ceil(colReorderIconWidth.current / 2) + 'px';
          reorderIndicatorDownRef.current.style.left = targetLeft - Math.ceil(colReorderIconWidth.current / 2) + 'px';
          dropPosition.current = -1;
        }

        reorderIndicatorUpRef.current.style.display = 'block';
        reorderIndicatorDownRef.current.style.display = 'block';
      }
    }
  };

  var onColumnHeaderDragLeave = function onColumnHeaderDragLeave(e) {
    var event = e.originalEvent;

    if (props.reorderableColumns && draggedColumnElement.current) {
      event.preventDefault();
      reorderIndicatorUpRef.current.style.display = 'none';
      reorderIndicatorDownRef.current.style.display = 'none';
    }
  };

  var onColumnHeaderDrop = function onColumnHeaderDrop(e) {
    var event = e.originalEvent,
        column = e.column;
    event.preventDefault();

    if (draggedColumnElement.current) {
      var dragIndex = DomHandler.index(draggedColumnElement.current);
      var dropIndex = DomHandler.index(findParentHeader(event.currentTarget));
      var allowDrop = dragIndex !== dropIndex;

      if (allowDrop && (dropIndex - dragIndex === 1 && dropPosition.current === -1 || dragIndex - dropIndex === 1 && dropPosition.current === 1)) {
        allowDrop = false;
      }

      if (allowDrop) {
        var _columns = getColumns();

        var isSameColumn = function isSameColumn(col1, col2) {
          return col1.props.columnKey || col2.props.columnKey ? ObjectUtils.equals(col1.props, col2.props, 'columnKey') : ObjectUtils.equals(col1.props, col2.props, 'field');
        };

        var dragColIndex = _columns.findIndex(function (child) {
          return isSameColumn(child, draggedColumn.current);
        });

        var dropColIndex = _columns.findIndex(function (child) {
          return isSameColumn(child, column);
        });

        if (dropColIndex < dragColIndex && dropPosition.current === 1) {
          dropColIndex++;
        }

        if (dropColIndex > dragColIndex && dropPosition.current === -1) {
          dropColIndex--;
        }

        ObjectUtils.reorderArray(_columns, dragColIndex, dropColIndex);

        var columnOrder = _columns.reduce(function (orders, col) {
          orders.push(col.props.columnKey || col.props.field);
          return orders;
        }, []);

        setColumnOrderState(columnOrder);

        if (props.onColReorder) {
          props.onColReorder({
            originalEvent: event,
            dragIndex: dragColIndex,
            dropIndex: dropColIndex,
            columns: _columns
          });
        }
      }

      reorderIndicatorUpRef.current.style.display = 'none';
      reorderIndicatorDownRef.current.style.display = 'none';
      draggedColumnElement.current.draggable = false;
      draggedColumnElement.current = null;
      draggedColumn.current = null;
      dropPosition.current = null;
    }
  };

  var createStyleElement = function createStyleElement() {
    styleElement.current = DomHandler.createInlineStyle(PrimeReact$1.nonce);
  };

  var createResponsiveStyle = function createResponsiveStyle() {
    if (!responsiveStyleElement.current) {
      responsiveStyleElement.current = DomHandler.createInlineStyle(PrimeReact$1.nonce);
      var innerHTML = "\n@media screen and (max-width: ".concat(props.breakpoint, ") {\n    .p-datatable[").concat(attributeSelectorState, "] .p-datatable-thead > tr > th,\n    .p-datatable[").concat(attributeSelectorState, "] .p-datatable-tfoot > tr > td {\n        display: none !important;\n    }\n\n    .p-datatable[").concat(attributeSelectorState, "] .p-datatable-tbody > tr > td {\n        display: flex;\n        width: 100% !important;\n        align-items: center;\n        justify-content: space-between;\n    }\n\n    .p-datatable[").concat(attributeSelectorState, "] .p-datatable-tbody > tr > td:not(:last-child) {\n        border: 0 none;\n    }\n\n    .p-datatable[").concat(attributeSelectorState, "].p-datatable-gridlines .p-datatable-tbody > tr > td:last-child {\n        border-top: 0;\n        border-right: 0;\n        border-left: 0;\n    }\n\n    .p-datatable[").concat(attributeSelectorState, "] .p-datatable-tbody > tr > td > .p-column-title {\n        display: block;\n    }\n}\n");
      responsiveStyleElement.current.innerHTML = innerHTML;
    }
  };

  var destroyResponsiveStyle = function destroyResponsiveStyle() {
    responsiveStyleElement.current = DomHandler.removeInlineStyle(responsiveStyleElement.current);
  };

  var destroyStyleElement = function destroyStyleElement() {
    styleElement.current = DomHandler.removeInlineStyle(styleElement.current);
  };

  var onPageChange = function onPageChange(e) {
    clearEditingMetaData();

    if (props.onPage) {
      props.onPage(createEvent(e));
    } else {
      setFirstState(e.first);
      setRowsState(e.rows);
    }

    if (props.onValueChange) {
      props.onValueChange(processedData());
    }
  };

  var onSortChange = function onSortChange(e) {
    clearEditingMetaData();
    var event = e.originalEvent,
        column = e.column,
        sortableDisabledFields = e.sortableDisabledFields;
    var sortField = column.props.sortField || column.props.field;
    var sortOrder = props.defaultSortOrder;
    var multiSortMeta;
    var eventMeta;
    columnSortable.current = column.props.sortable;
    columnSortFunction.current = column.props.sortFunction;
    columnField.current = sortField;

    if (props.sortMode === 'multiple') {
      var metaKey = event.metaKey || event.ctrlKey;
      multiSortMeta = _toConsumableArray$a(getMultiSortMeta());
      var sortMeta = multiSortMeta.find(function (sortMeta) {
        return sortMeta.field === sortField;
      });
      sortOrder = sortMeta ? getCalculatedSortOrder(sortMeta.order) : sortOrder;
      var newMetaData = {
        field: sortField,
        order: sortOrder
      };

      if (sortOrder) {
        multiSortMeta = metaKey ? multiSortMeta : multiSortMeta.filter(function (meta) {
          return sortableDisabledFields.some(function (field) {
            return field === meta.field;
          });
        });
        addSortMeta(newMetaData, multiSortMeta);
      } else if (props.removableSort) {
        removeSortMeta(newMetaData, multiSortMeta);
      }

      eventMeta = {
        multiSortMeta: multiSortMeta
      };
    } else {
      sortOrder = getSortField() === sortField ? getCalculatedSortOrder(getSortOrder()) : sortOrder;

      if (props.removableSort) {
        sortField = sortOrder ? sortField : null;
      }

      eventMeta = {
        sortField: sortField,
        sortOrder: sortOrder
      };
    }

    if (props.onSort) {
      props.onSort(createEvent(eventMeta));
    } else {
      setFirstState(0);
      setSortFieldState(eventMeta.sortField);
      setSortOrderState(eventMeta.sortOrder);
      setMultiSortMetaState(eventMeta.multiSortMeta);
    }

    if (props.onValueChange) {
      props.onValueChange(processedData({
        sortField: sortField,
        sortOrder: sortOrder,
        multiSortMeta: multiSortMeta
      }));
    }
  };

  var getCalculatedSortOrder = function getCalculatedSortOrder(currentOrder) {
    return props.removableSort ? props.defaultSortOrder === currentOrder ? currentOrder * -1 : 0 : currentOrder * -1;
  };

  var compareValuesOnSort = function compareValuesOnSort(value1, value2, order) {
    return ObjectUtils.sort(value1, value2, order, PrimeReact$1.locale, PrimeReact$1.nullSortOrder);
  };

  var addSortMeta = function addSortMeta(meta, multiSortMeta) {
    var index = multiSortMeta.findIndex(function (sortMeta) {
      return sortMeta.field === meta.field;
    });
    if (index >= 0) multiSortMeta[index] = meta;else multiSortMeta.push(meta);
  };

  var removeSortMeta = function removeSortMeta(meta, multiSortMeta) {
    var index = multiSortMeta.findIndex(function (sortMeta) {
      return sortMeta.field === meta.field;
    });

    if (index >= 0) {
      multiSortMeta.splice(index, 1);
    }

    multiSortMeta = multiSortMeta.length > 0 ? multiSortMeta : null;
  };

  var sortSingle = function sortSingle(data, field, order) {
    if (props.groupRowsBy && props.groupRowsBy === props.sortField) {
      var multiSortMeta = [{
        field: props.sortField,
        order: props.sortOrder || props.defaultSortOrder
      }];
      props.sortField !== field && multiSortMeta.push({
        field: field,
        order: order
      });
      return sortMultiple(data, multiSortMeta);
    }

    var value = _toConsumableArray$a(data);

    if (columnSortable.current && columnSortFunction.current) {
      value = columnSortFunction.current({
        data: data,
        field: field,
        order: order
      });
    } else {
      value.sort(function (data1, data2) {
        var value1 = ObjectUtils.resolveFieldData(data1, field);
        var value2 = ObjectUtils.resolveFieldData(data2, field);
        return compareValuesOnSort(value1, value2, order);
      });
    }

    return value;
  };

  var sortMultiple = function sortMultiple(data) {
    var multiSortMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (props.groupRowsBy && (groupRowsSortMetaState || multiSortMeta.length && props.groupRowsBy === multiSortMeta[0].field)) {
      var groupRowsSortMeta = groupRowsSortMetaState;
      var firstSortMeta = multiSortMeta[0];

      if (!groupRowsSortMeta) {
        groupRowsSortMeta = firstSortMeta;
        setGroupRowsSortMetaState(groupRowsSortMeta);
      }

      if (firstSortMeta.field !== groupRowsSortMeta.field) {
        multiSortMeta = [groupRowsSortMeta].concat(_toConsumableArray$a(multiSortMeta));
      }
    }

    var value = _toConsumableArray$a(data);

    if (columnSortable.current && columnSortFunction.current) {
      var meta = multiSortMeta.find(function (meta) {
        return meta.field === columnField.current;
      });
      var field = columnField.current;
      var order = meta ? meta.order : props.defaultSortOrder;
      value = columnSortFunction.current({
        data: data,
        field: field,
        order: order,
        multiSortMeta: multiSortMeta
      });
    } else {
      value.sort(function (data1, data2) {
        return multisortField(data1, data2, multiSortMeta, 0);
      });
    }

    return value;
  };

  var multisortField = function multisortField(data1, data2, multiSortMeta, index) {
    var value1 = ObjectUtils.resolveFieldData(data1, multiSortMeta[index].field);
    var value2 = ObjectUtils.resolveFieldData(data2, multiSortMeta[index].field); // check if they are equal handling dates and locales

    if (ObjectUtils.compare(value1, value2, PrimeReact$1.locale) === 0) {
      return multiSortMeta.length - 1 > index ? multisortField(data1, data2, multiSortMeta, index + 1) : 0;
    }

    return compareValuesOnSort(value1, value2, multiSortMeta[index].order);
  };

  var onFilterChange = function onFilterChange(filters) {
    clearEditingMetaData();
    setD_filtersState(filters);
  };

  var onFilterApply = function onFilterApply() {
    clearTimeout(filterTimeout.current);
    filterTimeout.current = setTimeout(function () {
      var filters = cloneFilters(d_filtersState);

      if (props.onFilter) {
        props.onFilter(createEvent({
          filters: filters
        }));
      } else {
        setFirstState(0);
        setFiltersState(filters);
      }

      if (props.onValueChange) {
        props.onValueChange(processedData({
          filters: filters
        }));
      }
    }, props.filterDelay);
  };

  var filterLocal = function filterLocal(data, filters) {
    if (!data) return;
    filters = filters || {};
    var columns = getColumns();
    var filteredValue = [];
    var isGlobalFilter = filters['global'] || props.globalFilter;
    var globalFilterFieldsArray;

    if (isGlobalFilter) {
      globalFilterFieldsArray = props.globalFilterFields || columns.filter(function (col) {
        return !col.props.excludeGlobalFilter;
      }).map(function (col) {
        return col.props.filterField || col.props.field;
      });
    }

    for (var i = 0; i < data.length; i++) {
      var localMatch = true;
      var globalMatch = false;
      var localFiltered = false;

      for (var prop in filters) {
        if (Object.prototype.hasOwnProperty.call(filters, prop) && prop !== 'global') {
          localFiltered = true;
          var filterField = prop;
          var filterMeta = filters[filterField];

          if (filterMeta.operator) {
            for (var j = 0; j < filterMeta.constraints.length; j++) {
              var filterConstraint = filterMeta.constraints[j];
              localMatch = executeLocalFilter(filterField, data[i], filterConstraint, j);

              if (filterMeta.operator === FilterOperator.OR && localMatch || filterMeta.operator === FilterOperator.AND && !localMatch) {
                break;
              }
            }
          } else {
            localMatch = executeLocalFilter(filterField, data[i], filterMeta, 0);
          }

          if (!localMatch) {
            break;
          }
        }
      }

      if (isGlobalFilter && !globalMatch && globalFilterFieldsArray) {
        for (var _j = 0; _j < globalFilterFieldsArray.length; _j++) {
          var globalFilterField = globalFilterFieldsArray[_j];
          var matchMode = filters['global'] ? filters['global'].matchMode : FilterMatchMode$1.CONTAINS;
          var value = filters['global'] ? filters['global'].value : props.globalFilter;
          globalMatch = FilterService.filters[matchMode](ObjectUtils.resolveFieldData(data[i], globalFilterField), value, props.filterLocale);

          if (globalMatch) {
            break;
          }
        }
      }

      var matches = void 0;

      if (isGlobalFilter) {
        matches = localFiltered ? localFiltered && localMatch && globalMatch : globalMatch;
      } else {
        matches = localFiltered && localMatch;
      }

      if (matches) {
        filteredValue.push(data[i]);
      }
    }

    if (filteredValue.length === props.value.length) {
      filteredValue = data;
    }

    return filteredValue;
  };

  var executeLocalFilter = function executeLocalFilter(field, rowData, filterMeta, index) {
    var filterValue = filterMeta.value;
    var filterMatchMode = filterMeta.matchMode === 'custom' ? "custom_".concat(field) : filterMeta.matchMode || FilterMatchMode$1.STARTS_WITH;
    var dataFieldValue = ObjectUtils.resolveFieldData(rowData, field);
    var filterConstraint = FilterService.filters[filterMatchMode];
    return ObjectUtils.isFunction(filterConstraint) && filterConstraint(dataFieldValue, filterValue, props.filterLocale, index);
  };

  var cloneFilters = function cloneFilters(filters) {
    filters = filters || props.filters;
    var cloned = {};

    if (filters) {
      Object.entries(filters).forEach(function (_ref) {
        var _ref2 = _slicedToArray$g(_ref, 2),
            prop = _ref2[0],
            value = _ref2[1];

        cloned[prop] = value.operator ? {
          operator: value.operator,
          constraints: value.constraints.map(function (constraint) {
            return _objectSpread$8({}, constraint);
          })
        } : _objectSpread$8({}, value);
      });
    } else {
      var _columns2 = getColumns();

      cloned = _columns2.reduce(function (filters, col) {
        var field = col.props.filterField || col.props.field;
        var filterFunction = col.props.filterFunction;
        var dataType = col.props.dataType;
        var matchMode = col.props.filterMatchMode || (PrimeReact$1.filterMatchModeOptions[dataType] ? PrimeReact$1.filterMatchModeOptions[dataType][0] : FilterMatchMode$1.STARTS_WITH);
        var constraint = {
          value: null,
          matchMode: matchMode
        };

        if (filterFunction) {
          FilterService.register("custom_".concat(field), function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return filterFunction.apply(void 0, args.concat([{
              column: col
            }]));
          });
        }

        filters[field] = props.filterDisplay === 'menu' ? {
          operator: FilterOperator.AND,
          constraints: [constraint]
        } : constraint;
        return filters;
      }, {});
    }

    return cloned;
  };

  var filter = function filter(value, field, matchMode) {
    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    var filters = _objectSpread$8({}, d_filtersState);

    var meta = filters[field];
    var constraint = meta && meta.operator ? meta.constraints[index] : meta;
    constraint = meta ? {
      value: value,
      matchMode: matchMode || constraint.matchMode
    } : {
      value: value,
      matchMode: matchMode
    };
    props.filterDisplay === 'menu' && meta && meta.operator ? filters[field].constraints[index] = constraint : filters[field] = constraint;
    setD_filtersState(filters);
    onFilterApply();
  };

  var reset = function reset() {
    setD_rowsState(props.rows);
    setD_filtersState(cloneFilters(props.filters));
    setGroupRowsSortMetaState(null);
    setEditingMetaState({});

    if (!props.onPage) {
      setFirstState(props.first);
      setRowsState(props.rows);
    }

    if (!props.onSort) {
      setSortFieldState(props.sortField);
      setSortOrderState(props.sortOrder);
      setMultiSortMetaState(props.multiSortMeta);
    }

    if (!props.onFilter) {
      setFiltersState(props.filters);
    }

    resetColumnOrder();
  };

  var resetScroll = function resetScroll() {
    if (wrapperRef.current) {
      var scrollableContainer = !isVirtualScrollerDisabled() ? DomHandler.findSingle(wrapperRef.current, '.p-virtualscroller') : wrapperRef.current;
      scrollableContainer.scrollTo(0, 0);
    }
  };

  var resetColumnOrder = function resetColumnOrder() {
    var columns = getColumns(true);
    var columnOrder = [];

    if (columns) {
      columnOrder = columns.reduce(function (orders, col) {
        orders.push(col.props.columnKey || col.props.field);
        return orders;
      }, []);
    }

    setColumnOrderState(columnOrder);
  };

  var exportCSV = function exportCSV(options) {
    var data;
    var csv = "\uFEFF";
    var columns = getColumns();

    if (options && options.selectionOnly) {
      data = props.selection || [];
    } else {
      data = [].concat(_toConsumableArray$a(props.frozenValue || []), _toConsumableArray$a(processedData() || []));
    } //headers


    columns.forEach(function (column, i) {
      var _column$props = column.props,
          field = _column$props.field,
          header = _column$props.header,
          exportable = _column$props.exportable;

      if (exportable && field) {
        csv += '"' + (header || field) + '"';

        if (i < columns.length - 1) {
          csv += props.csvSeparator;
        }
      }
    }); //body

    data.forEach(function (record) {
      csv += '\n';
      columns.forEach(function (column, i) {
        var _column$props2 = column.props,
            colField = _column$props2.field,
            exportField = _column$props2.exportField,
            exportable = _column$props2.exportable;
        var field = exportField || colField;

        if (exportable && field) {
          var cellData = ObjectUtils.resolveFieldData(record, field);

          if (cellData != null) {
            cellData = props.exportFunction ? props.exportFunction({
              data: cellData,
              field: field,
              rowData: record,
              column: column
            }) : String(cellData).replace(/"/g, '""');
          } else cellData = '';

          csv += '"' + cellData + '"';

          if (i < columns.length - 1) {
            csv += props.csvSeparator;
          }
        }
      });
    });
    DomHandler.exportCSV(csv, props.exportFilename);
  };

  var closeEditingCell = function closeEditingCell() {
    if (props.editMode !== 'row') {
      document.body.click();
    }
  };

  var createEvent = function createEvent(event) {
    return _objectSpread$8({
      first: getFirst(),
      rows: getRows(),
      sortField: getSortField(),
      sortOrder: getSortOrder(),
      multiSortMeta: getMultiSortMeta(),
      filters: getFilters()
    }, event);
  };

  var processedData = function processedData(localState) {
    var data = props.value || [];

    if (!props.lazy) {
      if (data && data.length) {
        var filters = localState && localState.filters || getFilters();
        var sortField = localState && localState.sortField || getSortField();
        var sortOrder = localState && localState.sortOrder || getSortOrder();
        var multiSortMeta = localState && localState.multiSortMeta || getMultiSortMeta();

        var _columns3 = getColumns();

        var sortColumn = _columns3.find(function (col) {
          return col.props.field === sortField;
        });

        if (sortColumn) {
          columnSortable.current = sortColumn.props.sortable;
          columnSortFunction.current = sortColumn.props.sortFunction;
        }

        if (ObjectUtils.isNotEmpty(filters) || props.globalFilter) {
          data = filterLocal(data, filters);
        }

        if (sortField || ObjectUtils.isNotEmpty(multiSortMeta)) {
          if (props.sortMode === 'single') data = sortSingle(data, sortField, sortOrder);else if (props.sortMode === 'multiple') data = sortMultiple(data, multiSortMeta);
        }
      }
    }

    return data;
  };

  var dataToRender = function dataToRender(data) {
    if (data && props.paginator) {
      var first = props.lazy ? 0 : getFirst();
      return data.slice(first, first + getRows());
    }

    return data;
  };

  useMountEffect(function () {
    setAttributeSelectorState(UniqueComponentId());
    setFiltersState(cloneFilters(props.filters));
    setD_filtersState(cloneFilters(props.filters));

    if (isStateful()) {
      restoreState();

      if (props.resizableColumns) {
        restoreColumnWidths();
      }
    }
  });
  useUpdateEffect(function () {
    elementRef.current.setAttribute(attributeSelectorState, '');

    if (props.responsiveLayout === 'stack' && !props.scrollable) {
      createResponsiveStyle();
    }
  }, [attributeSelectorState]);
  useUpdateEffect(function () {
    setFiltersState(cloneFilters(props.filters));
    setD_filtersState(cloneFilters(props.filters));
  }, [props.filters]);
  useUpdateEffect(function () {
    if (isStateful()) {
      saveState();
    }
  });
  useUpdateEffect(function () {
    destroyResponsiveStyle();

    if (props.responsiveLayout === 'stack' && !props.scrollable) {
      createResponsiveStyle();
    }
  }, [props.responsiveLayout]);
  useUpdateEffect(function () {
    if (props.globalFilter) {
      filter(props.globalFilter, 'global', 'contains');
    }
  }, [props.globalFilter]);
  useUnmountEffect(function () {
    unbindColumnResizeEvents();
    destroyStyleElement();
    destroyResponsiveStyle();
  });
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      reset: reset,
      resetScroll: resetScroll,
      exportCSV: exportCSV,
      filter: filter,
      resetColumnOrder: resetColumnOrder,
      closeEditingCell: closeEditingCell,
      restoreTableState: restoreTableState,
      clearState: clearState,
      getElement: function getElement() {
        return elementRef.current;
      },
      getTable: function getTable() {
        return tableRef.current;
      },
      getVirtualScroller: function getVirtualScroller() {
        return virtualScrollerRef.current;
      }
    };
  });

  var createLoader = function createLoader() {
    if (props.loading) {
      var iconClassName = classNames('p-datatable-loading-icon pi-spin', props.loadingIcon);
      return /*#__PURE__*/React.createElement("div", {
        className: "p-datatable-loading-overlay p-component-overlay"
      }, /*#__PURE__*/React.createElement("i", {
        className: iconClassName
      }));
    }

    return null;
  };

  var createHeader = function createHeader() {
    if (props.header) {
      var _content = ObjectUtils.getJSXElement(props.header, {
        props: props
      });

      return /*#__PURE__*/React.createElement("div", {
        className: "p-datatable-header"
      }, _content);
    }

    return null;
  };

  var createTableHeader = function createTableHeader(options, empty) {
    var sortField = getSortField();
    var sortOrder = getSortOrder();

    var multiSortMeta = _toConsumableArray$a(getMultiSortMeta());

    var groupRowSortField = getGroupRowSortField();
    var filters = d_filtersState;
    var filtersStore = !props.onFilter && props.filters || getFilters();
    var processedData = options.items,
        columns = options.columns;
    return /*#__PURE__*/React.createElement(TableHeader, {
      value: processedData,
      tableProps: props,
      columns: columns,
      tabIndex: props.tabIndex,
      empty: empty,
      headerColumnGroup: props.headerColumnGroup,
      resizableColumns: props.resizableColumns,
      onColumnResizeStart: onColumnResizeStart,
      onColumnResizerClick: props.onColumnResizerClick,
      onColumnResizerDoubleClick: props.onColumnResizerDoubleClick,
      sortMode: props.sortMode,
      sortField: sortField,
      sortOrder: sortOrder,
      multiSortMeta: multiSortMeta,
      groupRowsBy: props.groupRowsBy,
      groupRowSortField: groupRowSortField,
      onSortChange: onSortChange,
      filterDisplay: props.filterDisplay,
      filters: filters,
      filtersStore: filtersStore,
      onFilterChange: onFilterChange,
      onFilterApply: onFilterApply,
      showSelectAll: props.showSelectAll,
      allRowsSelected: allRowsSelected,
      onColumnCheckboxChange: onColumnHeaderCheckboxChange,
      onColumnMouseDown: onColumnHeaderMouseDown,
      onColumnDragStart: onColumnHeaderDragStart,
      onColumnDragOver: onColumnHeaderDragOver,
      onColumnDragLeave: onColumnHeaderDragLeave,
      onColumnDrop: onColumnHeaderDrop,
      rowGroupMode: props.rowGroupMode,
      reorderableColumns: props.reorderableColumns
    });
  };

  var createTableBody = function createTableBody(options, selectionModeInColumn, empty, isVirtualScrollerDisabled) {
    var first = getFirst();
    var rows = options.rows,
        columns = options.columns,
        contentRef = options.contentRef,
        className = options.className;
    options.itemSize;
    var frozenBody = props.frozenValue && /*#__PURE__*/React.createElement(TableBody, {
      ref: frozenBodyRef,
      value: props.frozenValue,
      className: "p-datatable-frozen-tbody",
      frozenRow: true,
      tableProps: props,
      tableSelector: attributeSelectorState,
      columns: columns,
      selectionModeInColumn: selectionModeInColumn,
      first: first,
      editingMeta: editingMetaState,
      onEditingMetaChange: onEditingMetaChange,
      tabIndex: props.tabIndex,
      onRowClick: props.onRowClick,
      onRowDoubleClick: props.onRowDoubleClick,
      onCellClick: props.onCellClick,
      selection: props.selection,
      onSelectionChange: props.onSelectionChange,
      lazy: props.lazy,
      paginator: props.paginator,
      onCellSelect: props.onCellSelect,
      onCellUnselect: props.onCellUnselect,
      onRowSelect: props.onRowSelect,
      onRowUnselect: props.onRowUnselect,
      dragSelection: props.dragSelection,
      onContextMenu: props.onContextMenu,
      onContextMenuSelectionChange: props.onContextMenuSelectionChange,
      metaKeySelection: props.metaKeySelection,
      selectionMode: props.selectionMode,
      cellSelection: props.cellSelection,
      contextMenuSelection: props.contextMenuSelection,
      dataKey: props.dataKey,
      expandedRows: props.expandedRows,
      onRowCollapse: props.onRowCollapse,
      onRowExpand: props.onRowExpand,
      onRowToggle: props.onRowToggle,
      editMode: props.editMode,
      editingRows: props.editingRows,
      onRowReorder: props.onRowReorder,
      reorderableRows: props.reorderableRows,
      scrollable: props.scrollable,
      rowGroupMode: props.rowGroupMode,
      groupRowsBy: props.groupRowsBy,
      expandableRowGroups: props.expandableRowGroups,
      loading: props.loading,
      emptyMessage: props.emptyMessage,
      rowGroupHeaderTemplate: props.rowGroupHeaderTemplate,
      rowExpansionTemplate: props.rowExpansionTemplate,
      rowGroupFooterTemplate: props.rowGroupFooterTemplate,
      onRowEditChange: props.onRowEditChange,
      compareSelectionBy: props.compareSelectionBy,
      selectOnEdit: props.selectOnEdit,
      onRowEditInit: props.onRowEditInit,
      rowEditValidator: props.rowEditValidator,
      onRowEditSave: props.onRowEditSave,
      onRowEditComplete: props.onRowEditComplete,
      onRowEditCancel: props.onRowEditCancel,
      cellClassName: props.cellClassName,
      responsiveLayout: props.responsiveLayout,
      selectionAutoFocus: props.selectionAutoFocus,
      isDataSelectable: props.isDataSelectable,
      showSelectionElement: props.showSelectionElement,
      showRowReorderElement: props.showRowReorderElement,
      expandedRowIcon: props.expandedRowIcon,
      collapsedRowIcon: props.collapsedRowIcon,
      rowClassName: props.rowClassName,
      virtualScrollerOptions: options,
      isVirtualScrollerDisabled: true
    });
    var body = /*#__PURE__*/React.createElement(TableBody, {
      ref: bodyRef,
      value: dataToRender(rows),
      className: className,
      empty: empty,
      frozenRow: false,
      tableProps: props,
      tableSelector: attributeSelectorState,
      columns: columns,
      selectionModeInColumn: selectionModeInColumn,
      first: first,
      editingMeta: editingMetaState,
      onEditingMetaChange: onEditingMetaChange,
      tabIndex: props.tabIndex,
      onRowClick: props.onRowClick,
      onRowDoubleClick: props.onRowDoubleClick,
      onCellClick: props.onCellClick,
      selection: props.selection,
      onSelectionChange: props.onSelectionChange,
      lazy: props.lazy,
      paginator: props.paginator,
      onCellSelect: props.onCellSelect,
      onCellUnselect: props.onCellUnselect,
      onRowSelect: props.onRowSelect,
      onRowUnselect: props.onRowUnselect,
      dragSelection: props.dragSelection,
      onContextMenu: props.onContextMenu,
      onContextMenuSelectionChange: props.onContextMenuSelectionChange,
      metaKeySelection: props.metaKeySelection,
      selectionMode: props.selectionMode,
      cellSelection: props.cellSelection,
      contextMenuSelection: props.contextMenuSelection,
      dataKey: props.dataKey,
      expandedRows: props.expandedRows,
      onRowCollapse: props.onRowCollapse,
      onRowExpand: props.onRowExpand,
      onRowToggle: props.onRowToggle,
      editMode: props.editMode,
      editingRows: props.editingRows,
      onRowReorder: props.onRowReorder,
      reorderableRows: props.reorderableRows,
      scrollable: props.scrollable,
      rowGroupMode: props.rowGroupMode,
      groupRowsBy: props.groupRowsBy,
      expandableRowGroups: props.expandableRowGroups,
      loading: props.loading,
      emptyMessage: props.emptyMessage,
      rowGroupHeaderTemplate: props.rowGroupHeaderTemplate,
      rowExpansionTemplate: props.rowExpansionTemplate,
      rowGroupFooterTemplate: props.rowGroupFooterTemplate,
      onRowEditChange: props.onRowEditChange,
      compareSelectionBy: props.compareSelectionBy,
      selectOnEdit: props.selectOnEdit,
      onRowEditInit: props.onRowEditInit,
      rowEditValidator: props.rowEditValidator,
      onRowEditSave: props.onRowEditSave,
      onRowEditComplete: props.onRowEditComplete,
      onRowEditCancel: props.onRowEditCancel,
      cellClassName: props.cellClassName,
      responsiveLayout: props.responsiveLayout,
      selectionAutoFocus: props.selectionAutoFocus,
      isDataSelectable: props.isDataSelectable,
      showSelectionElement: props.showSelectionElement,
      showRowReorderElement: props.showRowReorderElement,
      expandedRowIcon: props.expandedRowIcon,
      collapsedRowIcon: props.collapsedRowIcon,
      rowClassName: props.rowClassName,
      virtualScrollerContentRef: contentRef,
      virtualScrollerOptions: options,
      isVirtualScrollerDisabled: isVirtualScrollerDisabled
    });
    return /*#__PURE__*/React.createElement(React.Fragment, null, frozenBody, body);
  };

  var createTableFooter = function createTableFooter(options) {
    var columns = options.columns;
    return /*#__PURE__*/React.createElement(TableFooter, {
      tableProps: props,
      columns: columns,
      footerColumnGroup: props.footerColumnGroup
    });
  };

  var createContent = function createContent(processedData, columns, selectionModeInColumn, empty) {
    if (!columns) return;

    var _isVirtualScrollerDisabled = isVirtualScrollerDisabled();

    var virtualScrollerOptions = props.virtualScrollerOptions || {};
    return /*#__PURE__*/React.createElement("div", {
      ref: wrapperRef,
      className: "p-datatable-wrapper",
      style: {
        maxHeight: _isVirtualScrollerDisabled ? props.scrollHeight : null
      }
    }, /*#__PURE__*/React.createElement(VirtualScroller, _extends$p({
      ref: virtualScrollerRef
    }, virtualScrollerOptions, {
      items: processedData,
      columns: columns,
      style: _objectSpread$8(_objectSpread$8({}, virtualScrollerOptions.style), {
        height: props.scrollHeight !== 'flex' ? props.scrollHeight : undefined
      }),
      scrollHeight: props.scrollHeight !== 'flex' ? undefined : '100%',
      disabled: _isVirtualScrollerDisabled,
      loaderDisabled: true,
      showSpacer: false,
      contentTemplate: function contentTemplate(options) {
        var ref = function ref(el) {
          tableRef.current = el;
          options.spacerRef && options.spacerRef(el);
        };

        var tableClassName = classNames('p-datatable-table', props.tableClassName);
        var tableHeader = createTableHeader(options, empty);
        var tableBody = createTableBody(options, selectionModeInColumn, empty, _isVirtualScrollerDisabled);
        var tableFooter = createTableFooter(options);
        return /*#__PURE__*/React.createElement("table", {
          ref: ref,
          style: props.tableStyle,
          className: tableClassName,
          role: "table"
        }, tableHeader, tableBody, tableFooter);
      }
    })));
  };

  var createFooter = function createFooter() {
    if (props.footer) {
      var _content2 = ObjectUtils.getJSXElement(props.footer, {
        props: props
      });

      return /*#__PURE__*/React.createElement("div", {
        className: "p-datatable-footer"
      }, _content2);
    }

    return null;
  };

  var createPaginator = function createPaginator(position, totalRecords) {
    var className = classNames('p-paginator-' + position, props.paginatorClassName);
    return /*#__PURE__*/React.createElement(Paginator, {
      first: getFirst(),
      rows: getRows(),
      pageLinkSize: props.pageLinkSize,
      className: className,
      onPageChange: onPageChange,
      template: props.paginatorTemplate,
      totalRecords: totalRecords,
      rowsPerPageOptions: props.rowsPerPageOptions,
      currentPageReportTemplate: props.currentPageReportTemplate,
      leftContent: props.paginatorLeft,
      rightContent: props.paginatorRight,
      alwaysShow: props.alwaysShowPaginator,
      dropdownAppendTo: props.paginatorDropdownAppendTo
    });
  };

  var createPaginatorTop = function createPaginatorTop(totalRecords) {
    if (props.paginator && props.paginatorPosition !== 'bottom') {
      return createPaginator('top', totalRecords);
    }

    return null;
  };

  var createPaginatorBottom = function createPaginatorBottom(totalRecords) {
    if (props.paginator && props.paginatorPosition !== 'top') {
      return createPaginator('bottom', totalRecords);
    }

    return null;
  };

  var createResizeHelper = function createResizeHelper() {
    if (props.resizableColumns) {
      return /*#__PURE__*/React.createElement("div", {
        ref: resizeHelperRef,
        className: "p-column-resizer-helper",
        style: {
          display: 'none'
        }
      });
    }

    return null;
  };

  var createReorderIndicators = function createReorderIndicators() {
    if (props.reorderableColumns) {
      var style = {
        position: 'absolute',
        display: 'none'
      };
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
        ref: reorderIndicatorUpRef,
        className: "pi pi-arrow-down p-datatable-reorder-indicator-up",
        style: style
      }), /*#__PURE__*/React.createElement("span", {
        ref: reorderIndicatorDownRef,
        className: "pi pi-arrow-up p-datatable-reorder-indicator-down",
        style: style
      }));
    }

    return null;
  };

  var data = processedData();
  var columns = getColumns();
  var totalRecords = getTotalRecords(data);
  var empty = ObjectUtils.isEmpty(data);
  var selectionModeInColumn = getSelectionModeInColumn(columns);
  var selectable = props.selectionMode || selectionModeInColumn;
  var otherProps = ObjectUtils.findDiffKeys(props, DataTable$1.defaultProps);
  var className = classNames('p-datatable p-component', {
    'p-datatable-hoverable-rows': props.rowHover,
    'p-datatable-selectable': selectable && !props.cellSelection,
    'p-datatable-selectable-cell': selectable && props.cellSelection,
    'p-datatable-auto-layout': props.autoLayout,
    'p-datatable-resizable': props.resizableColumns,
    'p-datatable-resizable-fit': props.resizableColumns && props.columnResizeMode === 'fit',
    'p-datatable-scrollable': props.scrollable,
    'p-datatable-scrollable-vertical': props.scrollable && props.scrollDirection === 'vertical',
    'p-datatable-scrollable-horizontal': props.scrollable && props.scrollDirection === 'horizontal',
    'p-datatable-scrollable-both': props.scrollable && props.scrollDirection === 'both',
    'p-datatable-flex-scrollable': props.scrollable && props.scrollHeight === 'flex',
    'p-datatable-responsive-stack': props.responsiveLayout === 'stack',
    'p-datatable-responsive-scroll': props.responsiveLayout === 'scroll',
    'p-datatable-striped': props.stripedRows,
    'p-datatable-gridlines': props.showGridlines,
    'p-datatable-grouped-header': props.headerColumnGroup != null,
    'p-datatable-grouped-footer': props.footerColumnGroup != null,
    'p-datatable-sm': props.size === 'small',
    'p-datatable-lg': props.size === 'large'
  }, props.className);
  var loader = createLoader();
  var header = createHeader();
  var paginatorTop = createPaginatorTop(totalRecords);
  var content = createContent(data, columns, selectionModeInColumn, empty);
  var paginatorBottom = createPaginatorBottom(totalRecords);
  var footer = createFooter();
  var resizeHelper = createResizeHelper();
  var reorderIndicators = createReorderIndicators();
  return /*#__PURE__*/React.createElement("div", _extends$p({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style
  }, otherProps, {
    "data-scrollselectors": ".p-datatable-wrapper"
  }), loader, header, paginatorTop, content, paginatorBottom, footer, resizeHelper, reorderIndicators);
});
DataTable$1.displayName = 'DataTable';
DataTable$1.defaultProps = {
  __TYPE: 'DataTable',
  id: null,
  value: null,
  header: null,
  footer: null,
  style: null,
  className: null,
  tableStyle: null,
  tableClassName: null,
  paginator: false,
  paginatorPosition: 'bottom',
  alwaysShowPaginator: true,
  paginatorClassName: null,
  paginatorTemplate: 'FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown',
  paginatorLeft: null,
  paginatorRight: null,
  paginatorDropdownAppendTo: null,
  pageLinkSize: 5,
  rowsPerPageOptions: null,
  currentPageReportTemplate: '({currentPage} of {totalPages})',
  first: 0,
  rows: null,
  totalRecords: null,
  lazy: false,
  sortField: null,
  sortOrder: null,
  multiSortMeta: null,
  sortMode: 'single',
  defaultSortOrder: 1,
  removableSort: false,
  emptyMessage: null,
  selectionMode: null,
  dragSelection: false,
  cellSelection: false,
  selection: null,
  selectionAriaLabel: null,
  onSelectionChange: null,
  contextMenuSelection: null,
  onContextMenuSelectionChange: null,
  compareSelectionBy: 'deepEquals',
  dataKey: null,
  metaKeySelection: true,
  selectOnEdit: true,
  selectionPageOnly: false,
  selectionAutoFocus: true,
  showSelectAll: true,
  selectAll: false,
  onSelectAllChange: null,
  headerColumnGroup: null,
  footerColumnGroup: null,
  rowExpansionTemplate: null,
  expandedRows: null,
  onRowToggle: null,
  resizableColumns: false,
  columnResizeMode: 'fit',
  reorderableColumns: false,
  reorderableRows: false,
  filters: null,
  globalFilter: null,
  filterDelay: 300,
  filterLocale: undefined,
  scrollable: false,
  scrollHeight: null,
  scrollDirection: 'vertical',
  virtualScrollerOptions: null,
  frozenWidth: null,
  frozenValue: null,
  csvSeparator: ',',
  exportFilename: 'download',
  rowGroupMode: null,
  autoLayout: false,
  rowClassName: null,
  cellClassName: null,
  rowGroupHeaderTemplate: null,
  rowGroupFooterTemplate: null,
  loading: false,
  loadingIcon: 'pi pi-spinner',
  tabIndex: 0,
  stateKey: null,
  stateStorage: 'session',
  groupRowsBy: null,
  editMode: 'cell',
  editingRows: null,
  expandableRowGroups: false,
  rowHover: false,
  showGridlines: false,
  stripedRows: false,
  size: 'normal',
  responsiveLayout: 'stack',
  breakpoint: '960px',
  filterDisplay: 'menu',
  expandedRowIcon: 'pi pi-chevron-down',
  collapsedRowIcon: 'pi pi-chevron-right',
  onRowEditComplete: null,
  globalFilterFields: null,
  showSelectionElement: null,
  showRowReorderElement: null,
  isDataSelectable: null,
  onColumnResizeEnd: null,
  onColumnResizerClick: null,
  onColumnResizerDoubleClick: null,
  onSort: null,
  onPage: null,
  onFilter: null,
  onAllRowsSelect: null,
  onAllRowsUnselect: null,
  onRowClick: null,
  onRowDoubleClick: null,
  onRowSelect: null,
  onRowUnselect: null,
  onRowExpand: null,
  onRowCollapse: null,
  onContextMenu: null,
  onColReorder: null,
  onCellClick: null,
  onCellSelect: null,
  onCellUnselect: null,
  onRowReorder: null,
  onValueChange: null,
  rowEditValidator: null,
  onRowEditInit: null,
  onRowEditSave: null,
  onRowEditCancel: null,
  onRowEditChange: null,
  exportFunction: null,
  customSaveState: null,
  customRestoreState: null,
  onStateSave: null,
  onStateRestore: null
};

var EMPTY_MESSAGE$1 = {
  ru: "  ",
  en: "Nothing found"
};
var DataTable = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      header = _ref.header,
      footer = _ref.footer,
      style = _ref.style,
      className = _ref.className,
      tableStyle = _ref.tableStyle,
      tableClassName = _ref.tableClassName,
      _ref$paginator = _ref.paginator,
      paginator = _ref$paginator === void 0 ? false : _ref$paginator,
      paginatorClassName = _ref.paginatorClassName,
      rowsPerPageOptions = _ref.rowsPerPageOptions,
      _ref$first = _ref.first,
      first = _ref$first === void 0 ? 0 : _ref$first,
      rows = _ref.rows,
      totalRecords = _ref.totalRecords,
      _ref$lazy = _ref.lazy,
      lazy = _ref$lazy === void 0 ? false : _ref$lazy,
      sortField = _ref.sortField,
      sortOrder = _ref.sortOrder,
      multiSortMeta = _ref.multiSortMeta,
      _ref$sortMode = _ref.sortMode,
      sortMode = _ref$sortMode === void 0 ? "single" : _ref$sortMode,
      _ref$defaultSortOrder = _ref.defaultSortOrder,
      defaultSortOrder = _ref$defaultSortOrder === void 0 ? 1 : _ref$defaultSortOrder,
      _ref$removableSort = _ref.removableSort,
      removableSort = _ref$removableSort === void 0 ? false : _ref$removableSort,
      customEmptyMessage = _ref.emptyMessage,
      selection = _ref.selection,
      onSelectionChange = _ref.onSelectionChange,
      dataKey = _ref.dataKey,
      _ref$selectionPageOnl = _ref.selectionPageOnly,
      selectionPageOnly = _ref$selectionPageOnl === void 0 ? false : _ref$selectionPageOnl,
      _ref$showSelectAll = _ref.showSelectAll,
      showSelectAll = _ref$showSelectAll === void 0 ? true : _ref$showSelectAll,
      _ref$selectAll = _ref.selectAll,
      selectAll = _ref$selectAll === void 0 ? false : _ref$selectAll,
      onSelectAllChange = _ref.onSelectAllChange,
      headerColumnGroup = _ref.headerColumnGroup,
      footerColumnGroup = _ref.footerColumnGroup,
      filters = _ref.filters,
      globalFilter = _ref.globalFilter,
      filterLocale = _ref.filterLocale,
      _ref$scrollable = _ref.scrollable,
      scrollable = _ref$scrollable === void 0 ? false : _ref$scrollable,
      scrollHeight = _ref.scrollHeight,
      _ref$scrollDirection = _ref.scrollDirection,
      scrollDirection = _ref$scrollDirection === void 0 ? "vertical" : _ref$scrollDirection,
      frozenWidth = _ref.frozenWidth,
      frozenValue = _ref.frozenValue,
      _ref$csvSeparator = _ref.csvSeparator,
      csvSeparator = _ref$csvSeparator === void 0 ? "," : _ref$csvSeparator,
      _ref$exportFilename = _ref.exportFilename,
      exportFilename = _ref$exportFilename === void 0 ? "download" : _ref$exportFilename,
      _ref$autoLayout = _ref.autoLayout,
      autoLayout = _ref$autoLayout === void 0 ? false : _ref$autoLayout,
      rowClassName = _ref.rowClassName,
      cellClassName = _ref.cellClassName,
      _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? false : _ref$loading,
      _ref$tabIndex = _ref.tabIndex,
      tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
      _ref$editMode = _ref.editMode,
      editMode = _ref$editMode === void 0 ? false : _ref$editMode,
      editingRows = _ref.editingRows,
      _ref$showGridlines = _ref.showGridlines,
      showGridlines = _ref$showGridlines === void 0 ? false : _ref$showGridlines,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? "normal" : _ref$size,
      _ref$responsiveLayout = _ref.responsiveLayout,
      responsiveLayout = _ref$responsiveLayout === void 0 ? "stack" : _ref$responsiveLayout,
      _ref$breakpoint = _ref.breakpoint,
      breakpoint = _ref$breakpoint === void 0 ? "960px" : _ref$breakpoint,
      _ref$filterDisplay = _ref.filterDisplay,
      filterDisplay = _ref$filterDisplay === void 0 ? "menu" : _ref$filterDisplay,
      onRowEditComplete = _ref.onRowEditComplete,
      globalFilterFields = _ref.globalFilterFields,
      showSelectionElement = _ref.showSelectionElement,
      isDataSelectable = _ref.isDataSelectable,
      columnKey = _ref.columnKey,
      rowHover = _ref.rowHover,
      expandedRows = _ref.expandedRows,
      rowExpansionTemplate = _ref.rowExpansionTemplate,
      onRowToggle = _ref.onRowToggle,
      onRowExpand = _ref.onRowExpand,
      onRowCollapse = _ref.onRowCollapse,
      onRowClick = _ref.onRowClick,
      onSort = _ref.onSort,
      onPage = _ref.onPage,
      onFilter = _ref.onFilter,
      onAllRowsSelect = _ref.onAllRowsSelect,
      onAllRowsUnselect = _ref.onAllRowsUnselect,
      onRowSelect = _ref.onRowSelect,
      onRowUnselect = _ref.onRowUnselect,
      onValueChange = _ref.onValueChange,
      rowEditValidator = _ref.rowEditValidator,
      onRowEditInit = _ref.onRowEditInit,
      onRowEditSave = _ref.onRowEditSave,
      onRowEditCancel = _ref.onRowEditCancel,
      onRowEditChange = _ref.onRowEditChange,
      exportFunction = _ref.exportFunction,
      children = _ref.children;
  var emptyMessage = customEmptyMessage || EMPTY_MESSAGE$1[locale().locale];
  return /*#__PURE__*/React__default.createElement(DataTable$1, {
    ref: ref,
    id: id,
    value: value,
    header: header,
    footer: footer,
    style: style,
    className: className,
    tableStyle: tableStyle,
    tableClassName: tableClassName,
    paginator: paginator,
    paginatorClassName: paginatorClassName,
    rowsPerPageOptions: rowsPerPageOptions,
    alwaysShowPaginator: false,
    first: first,
    rows: rows,
    totalRecords: totalRecords,
    lazy: lazy,
    sortField: sortField,
    sortOrder: sortOrder,
    multiSortMeta: multiSortMeta,
    sortMode: sortMode,
    defaultSortOrder: defaultSortOrder,
    removableSort: removableSort,
    emptyMessage: emptyMessage,
    selection: selection,
    onSelectionChange: onSelectionChange,
    dataKey: dataKey,
    selectionPageOnly: selectionPageOnly,
    showSelectAll: showSelectAll,
    selectAll: selectAll,
    onSelectAllChange: onSelectAllChange,
    headerColumnGroup: headerColumnGroup,
    footerColumnGroup: footerColumnGroup,
    filters: filters,
    globalFilter: globalFilter,
    filterLocale: filterLocale,
    scrollable: scrollable,
    scrollHeight: scrollHeight,
    scrollDirection: scrollDirection,
    frozenWidth: frozenWidth,
    frozenValue: frozenValue,
    csvSeparator: csvSeparator,
    exportFilename: exportFilename,
    autoLayout: autoLayout,
    rowClassName: rowClassName,
    cellClassName: cellClassName,
    loading: loading,
    tabIndex: tabIndex,
    editMode: editMode ? "row" : null,
    editingRows: editingRows,
    showGridlines: showGridlines,
    size: size,
    responsiveLayout: responsiveLayout,
    breakpoint: breakpoint,
    filterDisplay: filterDisplay,
    onRowEditComplete: onRowEditComplete,
    globalFilterFields: globalFilterFields,
    showSelectionElement: showSelectionElement,
    isDataSelectable: isDataSelectable,
    columnKey: columnKey,
    rowHover: rowHover,
    expandedRows: expandedRows,
    rowExpansionTemplate: rowExpansionTemplate,
    onRowToggle: onRowToggle,
    onRowExpand: onRowExpand,
    onRowCollapse: onRowCollapse,
    onRowClick: onRowClick,
    onSort: onSort,
    onPage: onPage,
    onFilter: onFilter,
    onAllRowsSelect: onAllRowsSelect,
    onAllRowsUnselect: onAllRowsUnselect,
    onRowSelect: onRowSelect,
    onRowUnselect: onRowUnselect,
    onValueChange: onValueChange,
    rowEditValidator: rowEditValidator,
    onRowEditInit: onRowEditInit,
    onRowEditSave: onRowEditSave,
    onRowEditCancel: onRowEditCancel,
    onRowEditChange: onRowEditChange,
    exportFunction: exportFunction
  }, children);
});

function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends$o() {
  _extends$o = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$o.apply(this, arguments);
}

function _typeof$1(obj) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$1(obj);
}

function _arrayLikeToArray$1$4(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$9(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1$4(arr);
}

function _iterableToArray$9(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$1$4(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$4(o, minLen);
}

function _nonIterableSpread$9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$9(arr) {
  return _arrayWithoutHoles$9(arr) || _iterableToArray$9(arr) || _unsupportedIterableToArray$1$4(arr) || _nonIterableSpread$9();
}

function _arrayWithHoles$f(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$f(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$f() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$f(arr, i) {
  return _arrayWithHoles$f(arr) || _iterableToArrayLimit$f(arr, i) || _unsupportedIterableToArray$1$4(arr, i) || _nonIterableRest$f();
}

var CalendarPanel = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var createElement = function createElement() {
    return /*#__PURE__*/React.createElement(CSSTransition, {
      nodeRef: ref,
      classNames: "p-connected-overlay",
      "in": props["in"],
      timeout: {
        enter: 120,
        exit: 100
      },
      options: props.transitionOptions,
      unmountOnExit: true,
      onEnter: props.onEnter,
      onEntered: props.onEntered,
      onExit: props.onExit,
      onExited: props.onExited
    }, /*#__PURE__*/React.createElement("div", {
      ref: ref,
      className: props.className,
      style: props.style,
      onClick: props.onClick,
      onMouseUp: props.onMouseUp
    }, props.children));
  };

  var element = createElement();
  return props.inline ? element : /*#__PURE__*/React.createElement(Portal, {
    element: element,
    appendTo: props.appendTo
  });
});
CalendarPanel.displayName = 'CalendarPanel';

function _createForOfIteratorHelper$7(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$j(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$j(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$j(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$j(o, minLen);
}

function _arrayLikeToArray$j(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var Calendar = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _classNames;

  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$f(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _React$useState4 = _slicedToArray$f(_React$useState3, 2),
      overlayVisibleState = _React$useState4[0],
      setOverlayVisibleState = _React$useState4[1];

  var _React$useState5 = React.useState(null),
      _React$useState6 = _slicedToArray$f(_React$useState5, 2),
      viewDateState = _React$useState6[0],
      setViewDateState = _React$useState6[1];

  var elementRef = React.useRef(null);
  var overlayRef = React.useRef(null);
  var inputRef = React.useRef(props.inputRef);
  var navigation = React.useRef(null);
  var ignoreFocusFunctionality = React.useRef(false);
  var isKeydown = React.useRef(false);
  var timePickerTimer = React.useRef(null);
  var viewStateChanged = React.useRef(false);
  var touchUIMask = React.useRef(null);
  var overlayEventListener = React.useRef(null);
  var touchUIMaskClickListener = React.useRef(null);
  var isOverlayClicked = React.useRef(false);
  var ignoreMaskChange = React.useRef(false);

  var _React$useState7 = React.useState('date'),
      _React$useState8 = _slicedToArray$f(_React$useState7, 2),
      currentView = _React$useState8[0],
      setCurrentView = _React$useState8[1];

  var _React$useState9 = React.useState(null),
      _React$useState10 = _slicedToArray$f(_React$useState9, 2),
      currentMonth = _React$useState10[0],
      setCurrentMonth = _React$useState10[1];

  var _React$useState11 = React.useState(null),
      _React$useState12 = _slicedToArray$f(_React$useState11, 2),
      currentYear = _React$useState12[0],
      setCurrentYear = _React$useState12[1];

  var _React$useState13 = React.useState([]),
      _React$useState14 = _slicedToArray$f(_React$useState13, 2),
      yearOptions = _React$useState14[0],
      setYearOptions = _React$useState14[1];

  var previousValue = usePrevious(props.value);
  var visible = props.inline || (props.onVisibleChange ? props.visible : overlayVisibleState);
  var attributeSelector = UniqueComponentId();

  var _useOverlayListener = useOverlayListener({
    target: elementRef,
    overlay: overlayRef,
    listener: function listener(event, _ref) {
      var type = _ref.type,
          valid = _ref.valid;

      if (valid) {
        type === 'outside' ? !isOverlayClicked.current && !isNavIconClicked(event.target) && hide('outside') : hide();
      }

      isOverlayClicked.current = false;
    },
    when: !(props.touchUI || props.inline) && visible
  }),
      _useOverlayListener2 = _slicedToArray$f(_useOverlayListener, 2),
      bindOverlayListener = _useOverlayListener2[0],
      unbindOverlayListener = _useOverlayListener2[1];

  var getDateFormat = function getDateFormat() {
    return props.dateFormat || localeOption$1('dateFormat', props.locale);
  };

  var onInputFocus = function onInputFocus(event) {
    if (ignoreFocusFunctionality.current) {
      setFocusedState(true);
      ignoreFocusFunctionality.current = false;
    } else {
      if (props.showOnFocus && !visible) {
        show();
      }

      setFocusedState(true);
      props.onFocus && props.onFocus(event);
    }
  };

  var onInputBlur = function onInputBlur(event) {
    setFocusedState(false);
    !props.keepInvalid && updateInputfield(props.value);
    props.onBlur && props.onBlur(event);
  };

  var onInputKeyDown = function onInputKeyDown(event) {
    isKeydown.current = true;

    switch (event.which) {
      //escape
      case 27:
        {
          hide();
          break;
        }
      //tab

      case 9:
        {
          visible && trapFocus(event);
          props.touchUI && disableModality();
          break;
        }
    }
  };

  var onUserInput = function onUserInput(event) {
    // IE 11 Workaround for input placeholder
    if (!isKeydown.current) {
      return;
    }

    isKeydown.current = false;
    updateValueOnInput(event, event.target.value);
    props.onInput && props.onInput(event);
  };

  var updateValueOnInput = function updateValueOnInput(event, rawValue) {
    try {
      var value = parseValueFromString(rawValue);

      if (isValidSelection(value)) {
        updateModel(event, value);
        updateViewDate(event, value.length ? value[0] : value);
      }
    } catch (err) {
      //invalid date
      var _value = props.keepInvalid ? rawValue : null;

      updateModel(event, _value);
    }
  };

  var reFocusInputField = function reFocusInputField() {
    if (!props.inline && inputRef.current) {
      ignoreFocusFunctionality.current = true;
      DomHandler.focus(inputRef.current);
    }
  };

  var isValidSelection = function isValidSelection(value) {
    var isValid = true;

    if (isSingleSelection()) {
      if (!(isSelectable(value.getDate(), value.getMonth(), value.getFullYear(), false) && isSelectableTime(value))) {
        isValid = false;
      }
    } else if (value.every(function (v) {
      return isSelectable(v.getDate(), v.getMonth(), v.getFullYear(), false) && isSelectableTime(v);
    })) {
      if (isRangeSelection()) {
        isValid = value.length > 1 && value[1] > value[0] ? true : false;
      }
    }

    return isValid;
  };

  var onButtonClick = function onButtonClick() {
    visible ? hide() : show();
  };

  var onPrevButtonClick = function onPrevButtonClick(event) {
    navigation.current = {
      backward: true,
      button: true
    };
    navBackward(event);
  };

  var onNextButtonClick = function onNextButtonClick(event) {
    navigation.current = {
      backward: false,
      button: true
    };
    navForward(event);
  };

  var onContainerButtonKeydown = function onContainerButtonKeydown(event) {
    switch (event.which) {
      //tab
      case 9:
        trapFocus(event);
        break;
      //escape

      case 27:
        hide(null, reFocusInputField);
        event.preventDefault();
        break;
    }
  };

  var trapFocus = function trapFocus(event) {
    event.preventDefault();
    var focusableElements = DomHandler.getFocusableElements(overlayRef.current);

    if (focusableElements && focusableElements.length > 0) {
      if (!document.activeElement) {
        focusableElements[0].focus();
      } else {
        var focusedIndex = focusableElements.indexOf(document.activeElement);

        if (event.shiftKey) {
          if (focusedIndex === -1 || focusedIndex === 0) focusableElements[focusableElements.length - 1].focus();else focusableElements[focusedIndex - 1].focus();
        } else {
          if (focusedIndex === -1 || focusedIndex === focusableElements.length - 1) focusableElements[0].focus();else focusableElements[focusedIndex + 1].focus();
        }
      }
    }
  };

  var updateFocus = function updateFocus() {
    if (navigation.current) {
      if (navigation.current.button) {
        initFocusableCell();
        if (navigation.current.backward) DomHandler.findSingle(overlayRef.current, '.p-datepicker-prev').focus();else DomHandler.findSingle(overlayRef.current, '.p-datepicker-next').focus();
      } else {
        var cell;

        if (navigation.current.backward) {
          var cells = DomHandler.find(overlayRef.current, '.p-datepicker-calendar td span:not(.p-disabled)');
          cell = cells[cells.length - 1];
        } else {
          cell = DomHandler.findSingle(overlayRef.current, '.p-datepicker-calendar td span:not(.p-disabled)');
        }

        if (cell) {
          cell.tabIndex = '0';
          cell.focus();
        }
      }

      navigation.current = null;
    } else {
      initFocusableCell();
    }
  };

  var initFocusableCell = function initFocusableCell() {
    var cell;

    if (props.view === 'month') {
      var cells = DomHandler.find(overlayRef.current, '.p-monthpicker .p-monthpicker-month');
      var selectedCell = DomHandler.findSingle(overlayRef.current, '.p-monthpicker .p-monthpicker-month.p-highlight');
      cells.forEach(function (cell) {
        return cell.tabIndex = -1;
      });
      cell = selectedCell || cells[0];
    } else {
      cell = DomHandler.findSingle(overlayRef.current, 'span.p-highlight');

      if (!cell) {
        var todayCell = DomHandler.findSingle(overlayRef.current, 'td.p-datepicker-today span:not(.p-disabled)');
        cell = todayCell || DomHandler.findSingle(overlayRef.current, '.p-datepicker-calendar td span:not(.p-disabled)');
      }
    }

    if (cell) {
      cell.tabIndex = '0';
    }
  };

  var navBackward = function navBackward(event) {
    if (props.disabled) {
      event.preventDefault();
      return;
    }

    var newViewDate = new Date(getViewDate().getTime());
    newViewDate.setDate(1);

    if (currentView === 'date') {
      if (newViewDate.getMonth() === 0) {
        newViewDate.setMonth(11);
        newViewDate.setFullYear(decrementYear());
        setCurrentMonth(11);
      } else {
        newViewDate.setMonth(newViewDate.getMonth() - 1);
        setCurrentMonth(function (prevState) {
          return prevState - 1;
        });
      }
    } else if (currentView === 'month') {
      var newYear = newViewDate.getFullYear() - 1;

      if (props.yearNavigator) {
        var minYear = parseInt(props.yearRange.split(':')[0], 10);

        if (newYear < minYear) {
          newYear = minYear;
        }
      }

      newViewDate.setFullYear(newYear);
    }

    if (currentView === 'month') {
      newViewDate.setFullYear(decrementYear());
    } else if (currentView === 'year') {
      newViewDate.setFullYear(decrementDecade());
    }

    updateViewDate(event, newViewDate);
    event.preventDefault();
  };

  var navForward = function navForward(event) {
    if (props.disabled) {
      event.preventDefault();
      return;
    }

    var newViewDate = new Date(getViewDate().getTime());
    newViewDate.setDate(1);

    if (currentView === 'date') {
      if (newViewDate.getMonth() === 11) {
        newViewDate.setMonth(0);
        newViewDate.setFullYear(incrementYear());
        setCurrentMonth(0);
      } else {
        newViewDate.setMonth(newViewDate.getMonth() + 1);
        setCurrentMonth(function (prevState) {
          return prevState + 1;
        });
      }
    } else if (currentView === 'month') {
      var newYear = newViewDate.getFullYear() + 1;

      if (props.yearNavigator) {
        var maxYear = parseInt(props.yearRange.split(':')[1], 10);

        if (newYear > maxYear) {
          newYear = maxYear;
        }
      }

      newViewDate.setFullYear(newYear);
    }

    if (currentView === 'month') {
      newViewDate.setFullYear(incrementYear());
    } else if (currentView === 'year') {
      newViewDate.setFullYear(incrementDecade());
    }

    updateViewDate(event, newViewDate);
    event.preventDefault();
  };

  var populateYearOptions = function populateYearOptions(start, end) {
    var _yearOptions = [];

    for (var i = start; i <= end; i++) {
      yearOptions.push(i);
    }

    setYearOptions(_yearOptions);
  };

  var decrementYear = function decrementYear() {
    var _currentYear = currentYear - 1;

    setCurrentYear(_currentYear);

    if (props.yearNavigator && _currentYear < yearOptions[0]) {
      var difference = yearOptions[yearOptions.length - 1] - yearOptions[0];
      populateYearOptions(yearOptions[0] - difference, yearOptions[yearOptions.length - 1] - difference);
    }

    return _currentYear;
  };

  var incrementYear = function incrementYear() {
    var _currentYear = currentYear + 1;

    setCurrentYear(_currentYear);

    if (props.yearNavigator && _currentYear.current > yearOptions[yearOptions.length - 1]) {
      var difference = yearOptions[yearOptions.length - 1] - yearOptions[0];
      populateYearOptions(yearOptions[0] + difference, yearOptions[yearOptions.length - 1] + difference);
    }

    return _currentYear;
  };

  var onMonthDropdownChange = function onMonthDropdownChange(event, value) {
    var currentViewDate = getViewDate();
    var newViewDate = new Date(currentViewDate.getTime());
    newViewDate.setMonth(parseInt(value, 10));
    updateViewDate(event, newViewDate);
  };

  var onYearDropdownChange = function onYearDropdownChange(event, value) {
    var currentViewDate = getViewDate();
    var newViewDate = new Date(currentViewDate.getTime());
    newViewDate.setFullYear(parseInt(value, 10));
    updateViewDate(event, newViewDate);
  };

  var onTodayButtonClick = function onTodayButtonClick(event) {
    var today = new Date();
    var dateMeta = {
      day: today.getDate(),
      month: today.getMonth(),
      year: today.getFullYear(),
      today: true,
      selectable: true
    };
    var timeMeta = {
      hours: today.getHours(),
      minutes: today.getMinutes(),
      seconds: today.getSeconds(),
      milliseconds: today.getMilliseconds()
    };
    updateViewDate(event, today);
    onDateSelect(event, dateMeta, timeMeta);
    props.onTodayButtonClick && props.onTodayButtonClick(event);
  };

  var onClearButtonClick = function onClearButtonClick(event) {
    updateModel(event, null);
    updateInputfield(null);
    hide();
    props.onClearButtonClick && props.onClearButtonClick(event);
  };

  var onPanelClick = function onPanelClick(event) {
    if (!props.inline) {
      OverlayService.emit('overlay-click', {
        originalEvent: event,
        target: elementRef.current
      });
    }
  };

  var onPanelMouseUp = function onPanelMouseUp(event) {
    onPanelClick(event);
  };

  var onTimePickerElementMouseDown = function onTimePickerElementMouseDown(event, type, direction) {
    if (!props.disabled) {
      repeat(event, null, type, direction);
      event.preventDefault();
    }
  };

  var onTimePickerElementMouseUp = function onTimePickerElementMouseUp() {
    if (!props.disabled) {
      clearTimePickerTimer();
    }
  };

  var onTimePickerElementMouseLeave = function onTimePickerElementMouseLeave() {
    if (!props.disabled) {
      clearTimePickerTimer();
    }
  };

  var repeat = function repeat(event, interval, type, direction) {
    clearTimePickerTimer();
    timePickerTimer.current = setTimeout(function () {
      repeat(event, 100, type, direction);
    }, interval || 500);

    switch (type) {
      case 0:
        if (direction === 1) incrementHour(event);else decrementHour(event);
        break;

      case 1:
        if (direction === 1) incrementMinute(event);else decrementMinute(event);
        break;

      case 2:
        if (direction === 1) incrementSecond(event);else decrementSecond(event);
        break;

      case 3:
        if (direction === 1) incrementMilliSecond(event);else decrementMilliSecond(event);
        break;
    }
  };

  var clearTimePickerTimer = function clearTimePickerTimer() {
    if (timePickerTimer.current) {
      clearTimeout(timePickerTimer.current);
    }
  };

  var incrementHour = function incrementHour(event) {
    var currentTime = getCurrentDateTime();
    var currentHour = currentTime.getHours();
    var newHour = currentHour + props.stepHour;
    newHour = newHour >= 24 ? newHour - 24 : newHour;

    if (validateHour(newHour, currentTime)) {
      if (props.maxDate && props.maxDate.toDateString() === currentTime.toDateString() && props.maxDate.getHours() === newHour) {
        if (props.maxDate.getMinutes() < currentTime.getMinutes()) {
          if (props.maxDate.getSeconds() < currentTime.getSeconds()) {
            if (props.maxDate.getMilliseconds() < currentTime.getMilliseconds()) {
              updateTime(event, newHour, props.maxDate.getMinutes(), props.maxDate.getSeconds(), props.maxDate.getMilliseconds());
            } else {
              updateTime(event, newHour, props.maxDate.getMinutes(), props.maxDate.getSeconds(), currentTime.getMilliseconds());
            }
          } else {
            updateTime(event, newHour, props.maxDate.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
          }
        } else if (props.maxDate.getMinutes() === currentTime.getMinutes()) {
          if (props.maxDate.getSeconds() < currentTime.getSeconds()) {
            if (props.maxDate.getMilliseconds() < currentTime.getMilliseconds()) {
              updateTime(event, newHour, props.maxDate.getMinutes(), props.maxDate.getSeconds(), props.maxDate.getMilliseconds());
            } else {
              updateTime(event, newHour, props.maxDate.getMinutes(), props.maxDate.getSeconds(), currentTime.getMilliseconds());
            }
          } else {
            updateTime(event, newHour, props.maxDate.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
          }
        } else {
          updateTime(event, newHour, currentTime.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
        }
      } else {
        updateTime(event, newHour, currentTime.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
      }
    }

    event.preventDefault();
  };

  var decrementHour = function decrementHour(event) {
    var currentTime = getCurrentDateTime();
    var currentHour = currentTime.getHours();
    var newHour = currentHour - props.stepHour;
    newHour = newHour < 0 ? newHour + 24 : newHour;

    if (validateHour(newHour, currentTime)) {
      if (props.minDate && props.minDate.toDateString() === currentTime.toDateString() && props.minDate.getHours() === newHour) {
        if (props.minDate.getMinutes() > currentTime.getMinutes()) {
          if (props.minDate.getSeconds() > currentTime.getSeconds()) {
            if (props.minDate.getMilliseconds() > currentTime.getMilliseconds()) {
              updateTime(event, newHour, props.minDate.getMinutes(), props.minDate.getSeconds(), props.minDate.getMilliseconds());
            } else {
              updateTime(event, newHour, props.minDate.getMinutes(), props.minDate.getSeconds(), currentTime.getMilliseconds());
            }
          } else {
            updateTime(event, newHour, props.minDate.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
          }
        } else if (props.minDate.getMinutes() === currentTime.getMinutes()) {
          if (props.minDate.getSeconds() > currentTime.getSeconds()) {
            if (props.minDate.getMilliseconds() > currentTime.getMilliseconds()) {
              updateTime(event, newHour, props.minDate.getMinutes(), props.minDate.getSeconds(), props.minDate.getMilliseconds());
            } else {
              updateTime(event, newHour, props.minDate.getMinutes(), props.minDate.getSeconds(), currentTime.getMilliseconds());
            }
          } else {
            updateTime(event, newHour, props.minDate.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
          }
        } else {
          updateTime(event, newHour, currentTime.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
        }
      } else {
        updateTime(event, newHour, currentTime.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
      }
    }

    event.preventDefault();
  };

  var doStepMinute = function doStepMinute(currentMinute, step) {
    if (props.stepMinute <= 1) {
      return step ? currentMinute + step : currentMinute;
    }

    if (!step) {
      step = props.stepMinute;

      if (currentMinute % step === 0) {
        return currentMinute;
      }
    }

    return Math.floor((currentMinute + step) / step) * step;
  };

  var incrementMinute = function incrementMinute(event) {
    var currentTime = getCurrentDateTime();
    var currentMinute = currentTime.getMinutes();
    var newMinute = doStepMinute(currentMinute, props.stepMinute);
    newMinute = newMinute > 59 ? newMinute - 60 : newMinute;

    if (validateMinute(newMinute, currentTime)) {
      if (props.maxDate && props.maxDate.toDateString() === currentTime.toDateString() && props.maxDate.getMinutes() === newMinute) {
        if (props.maxDate.getSeconds() < currentTime.getSeconds()) {
          if (props.maxDate.getMilliseconds() < currentTime.getMilliseconds()) {
            updateTime(event, currentTime.getHours(), newMinute, props.maxDate.getSeconds(), props.maxDate.getMilliseconds());
          } else {
            updateTime(event, currentTime.getHours(), newMinute, props.maxDate.getSeconds(), currentTime.getMilliseconds());
          }
        } else {
          updateTime(event, currentTime.getHours(), newMinute, currentTime.getSeconds(), currentTime.getMilliseconds());
        }
      } else {
        updateTime(event, currentTime.getHours(), newMinute, currentTime.getSeconds(), currentTime.getMilliseconds());
      }
    }

    event.preventDefault();
  };

  var decrementMinute = function decrementMinute(event) {
    var currentTime = getCurrentDateTime();
    var currentMinute = currentTime.getMinutes();
    var newMinute = doStepMinute(currentMinute, -props.stepMinute);
    newMinute = newMinute < 0 ? newMinute + 60 : newMinute;

    if (validateMinute(newMinute, currentTime)) {
      if (props.minDate && props.minDate.toDateString() === currentTime.toDateString() && props.minDate.getMinutes() === newMinute) {
        if (props.minDate.getSeconds() > currentTime.getSeconds()) {
          if (props.minDate.getMilliseconds() > currentTime.getMilliseconds()) {
            updateTime(event, currentTime.getHours(), newMinute, props.minDate.getSeconds(), props.minDate.getMilliseconds());
          } else {
            updateTime(event, currentTime.getHours(), newMinute, props.minDate.getSeconds(), currentTime.getMilliseconds());
          }
        } else {
          updateTime(event, currentTime.getHours(), newMinute, currentTime.getSeconds(), currentTime.getMilliseconds());
        }
      } else {
        updateTime(event, currentTime.getHours(), newMinute, currentTime.getSeconds(), currentTime.getMilliseconds());
      }
    }

    event.preventDefault();
  };

  var incrementSecond = function incrementSecond(event) {
    var currentTime = getCurrentDateTime();
    var currentSecond = currentTime.getSeconds();
    var newSecond = currentSecond + props.stepSecond;
    newSecond = newSecond > 59 ? newSecond - 60 : newSecond;

    if (validateSecond(newSecond, currentTime)) {
      if (props.maxDate && props.maxDate.toDateString() === currentTime.toDateString() && props.maxDate.getSeconds() === newSecond) {
        if (props.maxDate.getMilliseconds() < currentTime.getMilliseconds()) {
          updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, props.maxDate.getMilliseconds());
        } else {
          updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, currentTime.getMilliseconds());
        }
      } else {
        updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, currentTime.getMilliseconds());
      }
    }

    event.preventDefault();
  };

  var decrementSecond = function decrementSecond(event) {
    var currentTime = getCurrentDateTime();
    var currentSecond = currentTime.getSeconds();
    var newSecond = currentSecond - props.stepSecond;
    newSecond = newSecond < 0 ? newSecond + 60 : newSecond;

    if (validateSecond(newSecond, currentTime)) {
      if (props.minDate && props.minDate.toDateString() === currentTime.toDateString() && props.minDate.getSeconds() === newSecond) {
        if (props.minDate.getMilliseconds() > currentTime.getMilliseconds()) {
          updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, props.minDate.getMilliseconds());
        } else {
          updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, currentTime.getMilliseconds());
        }
      } else {
        updateTime(event, currentTime.getHours(), currentTime.getMinutes(), newSecond, currentTime.getMilliseconds());
      }
    }

    event.preventDefault();
  };

  var incrementMilliSecond = function incrementMilliSecond(event) {
    var currentTime = getCurrentDateTime();
    var currentMillisecond = currentTime.getMilliseconds();
    var newMillisecond = currentMillisecond + props.stepMillisec;
    newMillisecond = newMillisecond > 999 ? newMillisecond - 1000 : newMillisecond;

    if (validateMillisecond(newMillisecond, currentTime)) {
      updateTime(event, currentTime.getHours(), currentTime.getMinutes(), currentTime.getSeconds(), newMillisecond);
    }

    event.preventDefault();
  };

  var decrementMilliSecond = function decrementMilliSecond(event) {
    var currentTime = getCurrentDateTime();
    var currentMillisecond = currentTime.getMilliseconds();
    var newMillisecond = currentMillisecond - props.stepMillisec;
    newMillisecond = newMillisecond < 0 ? newMillisecond + 999 : newMillisecond;

    if (validateMillisecond(newMillisecond, currentTime)) {
      updateTime(event, currentTime.getHours(), currentTime.getMinutes(), currentTime.getSeconds(), newMillisecond);
    }

    event.preventDefault();
  };

  var toggleAmPm = function toggleAmPm(event) {
    var currentTime = getCurrentDateTime();
    var currentHour = currentTime.getHours();
    var newHour = currentHour >= 12 ? currentHour - 12 : currentHour + 12;

    if (validateHour(convertTo24Hour(newHour, !(currentHour > 11)), currentTime)) {
      updateTime(event, newHour, currentTime.getMinutes(), currentTime.getSeconds(), currentTime.getMilliseconds());
    }

    event.preventDefault();
  };

  var getViewDate = function getViewDate(date) {
    var propValue = props.value;
    var viewDate = date || (props.onViewDateChange ? props.viewDate : viewDateState);

    if (Array.isArray(propValue)) {
      propValue = propValue[0];
    }

    return viewDate && isValidDate(viewDate) ? viewDate : propValue && isValidDate(propValue) ? propValue : new Date();
  };

  var getCurrentDateTime = function getCurrentDateTime() {
    if (isSingleSelection()) {
      return props.value && props.value instanceof Date ? props.value : getViewDate();
    } else if (isMultipleSelection()) {
      if (props.value && props.value.length) {
        return props.value[props.value.length - 1];
      }
    } else if (isRangeSelection()) {
      if (props.value && props.value.length) {
        var startDate = props.value[0];
        var endDate = props.value[1];
        return endDate || startDate;
      }
    }

    return new Date();
  };

  var isValidDate = function isValidDate(date) {
    return date instanceof Date && !isNaN(date);
  };

  var convertTo24Hour = function convertTo24Hour(hour, pm) {
    if (props.hourFormat == '12') {
      return hour === 12 ? pm ? 12 : 0 : pm ? hour + 12 : hour;
    }

    return hour;
  };

  var validateHour = function validateHour(hour, value) {
    var valid = true;
    var valueDateString = value ? value.toDateString() : null;

    if (props.minDate && valueDateString && props.minDate.toDateString() === valueDateString) {
      if (props.minDate.getHours() > hour) {
        valid = false;
      }
    }

    if (props.maxDate && valueDateString && props.maxDate.toDateString() === valueDateString) {
      if (props.maxDate.getHours() < hour) {
        valid = false;
      }
    }

    return valid;
  };

  var validateMinute = function validateMinute(minute, value) {
    var valid = true;
    var valueDateString = value ? value.toDateString() : null;

    if (props.minDate && valueDateString && props.minDate.toDateString() === valueDateString) {
      if (value.getHours() === props.minDate.getHours()) {
        if (props.minDate.getMinutes() > minute) {
          valid = false;
        }
      }
    }

    if (props.maxDate && valueDateString && props.maxDate.toDateString() === valueDateString) {
      if (value.getHours() === props.maxDate.getHours()) {
        if (props.maxDate.getMinutes() < minute) {
          valid = false;
        }
      }
    }

    return valid;
  };

  var validateSecond = function validateSecond(second, value) {
    var valid = true;
    var valueDateString = value ? value.toDateString() : null;

    if (props.minDate && valueDateString && props.minDate.toDateString() === valueDateString) {
      if (value.getHours() === props.minDate.getHours() && value.getMinutes() === props.minDate.getMinutes()) {
        if (props.minDate.getSeconds() > second) {
          valid = false;
        }
      }
    }

    if (props.maxDate && valueDateString && props.maxDate.toDateString() === valueDateString) {
      if (value.getHours() === props.maxDate.getHours() && value.getMinutes() === props.maxDate.getMinutes()) {
        if (props.maxDate.getSeconds() < second) {
          valid = false;
        }
      }
    }

    return valid;
  };

  var validateMillisecond = function validateMillisecond(millisecond, value) {
    var valid = true;
    var valueDateString = value ? value.toDateString() : null;

    if (props.minDate && valueDateString && props.minDate.toDateString() === valueDateString) {
      if (value.getHours() === props.minDate.getHours() && value.getSeconds() === props.minDate.getSeconds() && value.getMinutes() === props.minDate.getMinutes()) {
        if (props.minDate.getMilliseconds() > millisecond) {
          valid = false;
        }
      }
    }

    if (props.maxDate && valueDateString && props.maxDate.toDateString() === valueDateString) {
      if (value.getHours() === props.maxDate.getHours() && value.getSeconds() === props.maxDate.getSeconds() && value.getMinutes() === props.maxDate.getMinutes()) {
        if (props.maxDate.getMilliseconds() < millisecond) {
          valid = false;
        }
      }
    }

    return valid;
  };

  var validateDate = function validateDate(value) {
    if (props.yearNavigator) {
      var viewYear = value.getFullYear();
      var minRangeYear = props.yearRange ? parseInt(props.yearRange.split(':')[0], 10) : null;
      var maxRangeYear = props.yearRange ? parseInt(props.yearRange.split(':')[1], 10) : null;
      var minYear = props.minDate && minRangeYear != null ? Math.max(props.minDate.getFullYear(), minRangeYear) : props.minDate || minRangeYear;
      var maxYear = props.maxDate && maxRangeYear != null ? Math.min(props.maxDate.getFullYear(), maxRangeYear) : props.maxDate || maxRangeYear;

      if (minYear && minYear > viewYear) {
        viewYear = minYear;
      }

      if (maxYear && maxYear < viewYear) {
        viewYear = maxYear;
      }

      value.setFullYear(viewYear);
    }

    if (props.monthNavigator && props.view !== 'month') {
      var viewMonth = value.getMonth();
      var viewMonthWithMinMax = parseInt(isInMinYear(value) && Math.max(props.minDate.getMonth(), viewMonth).toString() || isInMaxYear(value) && Math.min(props.maxDate.getMonth(), viewMonth).toString() || viewMonth);
      value.setMonth(viewMonthWithMinMax);
    }
  };

  var updateTime = function updateTime(event, hour, minute, second, millisecond) {
    var newDateTime = getCurrentDateTime();
    newDateTime.setHours(hour);
    newDateTime.setMinutes(minute);
    newDateTime.setSeconds(second);
    newDateTime.setMilliseconds(millisecond);

    if (isMultipleSelection()) {
      if (props.value && props.value.length) {
        var value = _toConsumableArray$9(props.value);

        value[value.length - 1] = newDateTime;
        newDateTime = value;
      } else {
        newDateTime = [newDateTime];
      }
    } else if (isRangeSelection()) {
      if (props.value && props.value.length) {
        var startDate = props.value[0];
        var endDate = props.value[1];
        newDateTime = endDate ? [startDate, newDateTime] : [newDateTime, null];
      } else {
        newDateTime = [newDateTime, null];
      }
    }

    updateModel(event, newDateTime);

    if (props.onSelect) {
      props.onSelect({
        originalEvent: event,
        value: newDateTime
      });
    }

    updateInputfield(newDateTime);
  };

  var updateViewDate = function updateViewDate(event, value) {
    validateDate(value);

    if (props.onViewDateChange) {
      props.onViewDateChange({
        originalEvent: event,
        value: value
      });
    } else {
      viewStateChanged.current = true;
      setViewDateState(value);
    }

    setCurrentMonth(value.getMonth());
    setCurrentYear(value.getFullYear());
  };

  var setNavigationState = function setNavigationState(newViewDate) {
    if (!props.showMinMaxRange || props.view !== 'date' || !overlayRef.current) {
      return;
    }

    var navPrev = DomHandler.findSingle(overlayRef.current, '.p-datepicker-prev');
    var navNext = DomHandler.findSingle(overlayRef.current, '.p-datepicker-next');

    if (props.disabled) {
      DomHandler.addClass(navPrev, 'p-disabled');
      DomHandler.addClass(navNext, 'p-disabled');
      return;
    } // previous (check first day of month at 00:00:00)


    if (props.minDate) {
      var firstDayOfMonth = new Date(newViewDate.getTime());

      if (firstDayOfMonth.getMonth() === 0) {
        firstDayOfMonth.setMonth(11, 1);
        firstDayOfMonth.setFullYear(firstDayOfMonth.getFullYear() - 1);
      } else {
        firstDayOfMonth.setMonth(firstDayOfMonth.getMonth() - 1, 1);
      }

      firstDayOfMonth.setHours(0);
      firstDayOfMonth.setMinutes(0);
      firstDayOfMonth.setSeconds(0);

      if (props.minDate > firstDayOfMonth) {
        DomHandler.addClass(navPrev, 'p-disabled');
      } else {
        DomHandler.removeClass(navPrev, 'p-disabled');
      }
    } // next (check last day of month at 11:59:59)


    if (props.maxDate) {
      var lastDayOfMonth = new Date(newViewDate.getTime());

      if (lastDayOfMonth.getMonth() === 11) {
        lastDayOfMonth.setMonth(0, 1);
        lastDayOfMonth.setFullYear(lastDayOfMonth.getFullYear() + 1);
      } else {
        lastDayOfMonth.setMonth(lastDayOfMonth.getMonth() + 1, 1);
      }

      lastDayOfMonth.setHours(0);
      lastDayOfMonth.setMinutes(0);
      lastDayOfMonth.setSeconds(0);
      lastDayOfMonth.setSeconds(-1);

      if (props.maxDate < lastDayOfMonth) {
        DomHandler.addClass(navNext, 'p-disabled');
      } else {
        DomHandler.removeClass(navNext, 'p-disabled');
      }
    }
  };

  var onDateCellKeydown = function onDateCellKeydown(event, date, groupIndex) {
    var cellContent = event.currentTarget;
    var cell = cellContent.parentElement;

    switch (event.which) {
      //down arrow
      case 40:
        {
          cellContent.tabIndex = '-1';
          var cellIndex = DomHandler.index(cell);
          var nextRow = cell.parentElement.nextElementSibling;

          if (nextRow) {
            var focusCell = nextRow.children[cellIndex].children[0];

            if (DomHandler.hasClass(focusCell, 'p-disabled')) {
              navigation.current = {
                backward: false
              };
              navForward(event);
            } else {
              nextRow.children[cellIndex].children[0].tabIndex = '0';
              nextRow.children[cellIndex].children[0].focus();
            }
          } else {
            navigation.current = {
              backward: false
            };
            navForward(event);
          }

          event.preventDefault();
          break;
        }
      //up arrow

      case 38:
        {
          cellContent.tabIndex = '-1';

          var _cellIndex = DomHandler.index(cell);

          var prevRow = cell.parentElement.previousElementSibling;

          if (prevRow) {
            var _focusCell = prevRow.children[_cellIndex].children[0];

            if (DomHandler.hasClass(_focusCell, 'p-disabled')) {
              navigation.current = {
                backward: true
              };
              navBackward(event);
            } else {
              _focusCell.tabIndex = '0';

              _focusCell.focus();
            }
          } else {
            navigation.current = {
              backward: true
            };
            navBackward(event);
          }

          event.preventDefault();
          break;
        }
      //left arrow

      case 37:
        {
          cellContent.tabIndex = '-1';
          var prevCell = cell.previousElementSibling;

          if (prevCell) {
            var _focusCell2 = prevCell.children[0];

            if (DomHandler.hasClass(_focusCell2, 'p-disabled')) {
              navigateToMonth(true, groupIndex, event);
            } else {
              _focusCell2.tabIndex = '0';

              _focusCell2.focus();
            }
          } else {
            navigateToMonth(true, groupIndex, event);
          }

          event.preventDefault();
          break;
        }
      //right arrow

      case 39:
        {
          cellContent.tabIndex = '-1';
          var nextCell = cell.nextElementSibling;

          if (nextCell) {
            var _focusCell3 = nextCell.children[0];

            if (DomHandler.hasClass(_focusCell3, 'p-disabled')) {
              navigateToMonth(false, groupIndex, event);
            } else {
              _focusCell3.tabIndex = '0';

              _focusCell3.focus();
            }
          } else {
            navigateToMonth(false, groupIndex, event);
          }

          event.preventDefault();
          break;
        }
      //enter

      case 13:
        {
          onDateSelect(event, date);
          event.preventDefault();
          break;
        }
      //escape

      case 27:
        {
          hide(null, reFocusInputField);
          event.preventDefault();
          break;
        }
      //tab

      case 9:
        {
          trapFocus(event);
          break;
        }
    }
  };

  var navigateToMonth = function navigateToMonth(prev, groupIndex, event) {
    if (prev) {
      if (props.numberOfMonths === 1 || groupIndex === 0) {
        navigation.current = {
          backward: true
        };
        navBackward(event);
      } else {
        var prevMonthContainer = overlayRef.current.children[groupIndex - 1];
        var cells = DomHandler.find(prevMonthContainer, '.p-datepicker-calendar td span:not(.p-disabled)');
        var focusCell = cells[cells.length - 1];
        focusCell.tabIndex = '0';
        focusCell.focus();
      }
    } else {
      if (props.numberOfMonths === 1 || groupIndex === props.numberOfMonths - 1) {
        navigation.current = {
          backward: false
        };
        navForward(event);
      } else {
        var nextMonthContainer = overlayRef.current.children[groupIndex + 1];

        var _focusCell4 = DomHandler.findSingle(nextMonthContainer, '.p-datepicker-calendar td span:not(.p-disabled)');

        _focusCell4.tabIndex = '0';

        _focusCell4.focus();
      }
    }
  };

  var onDateSelect = function onDateSelect(event, dateMeta, timeMeta) {
    if (props.disabled || !dateMeta.selectable) {
      event.preventDefault();
      return;
    }

    DomHandler.find(overlayRef.current, '.p-datepicker-calendar td span:not(.p-disabled)').forEach(function (cell) {
      return cell.tabIndex = -1;
    });
    event.currentTarget.focus();

    if (isMultipleSelection()) {
      if (isSelected(dateMeta)) {
        var value = props.value.filter(function (date, i) {
          return !isDateEquals(date, dateMeta);
        });
        updateModel(event, value);
        updateInputfield(value);
      } else if (!props.maxDateCount || !props.value || props.maxDateCount > props.value.length) {
        selectDate(event, dateMeta, timeMeta);
      }
    } else {
      selectDate(event, dateMeta, timeMeta);
    }

    if (!props.inline && isSingleSelection() && (!props.showTime || props.hideOnDateTimeSelect)) {
      setTimeout(function () {
        hide('dateselect');
      }, 100);

      if (touchUIMask.current) {
        disableModality();
      }
    }

    event.preventDefault();
  };

  var selectTime = function selectTime(date, timeMeta) {
    if (props.showTime) {
      var hours, minutes, seconds, milliseconds;

      if (timeMeta) {
        hours = timeMeta.hours;
        minutes = timeMeta.minutes;
        seconds = timeMeta.seconds;
        milliseconds = timeMeta.milliseconds;
      } else {
        var time = getCurrentDateTime();
        var _ref2 = [time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()];
        hours = _ref2[0];
        minutes = _ref2[1];
        seconds = _ref2[2];
        milliseconds = _ref2[3];
      }

      date.setHours(hours);
      date.setMinutes(minutes);
      date.setSeconds(seconds);
      date.setMilliseconds(milliseconds);
    }
  };

  var selectDate = function selectDate(event, dateMeta, timeMeta) {
    var date = new Date(dateMeta.year, dateMeta.month, dateMeta.day);
    selectTime(date, timeMeta);

    if (props.minDate && props.minDate > date) {
      date = props.minDate;
    }

    if (props.maxDate && props.maxDate < date) {
      date = props.maxDate;
    }

    var selectedValues = date;

    if (isSingleSelection()) {
      updateModel(event, date);
    } else if (isMultipleSelection()) {
      selectedValues = props.value ? [].concat(_toConsumableArray$9(props.value), [date]) : [date];
      updateModel(event, selectedValues);
    } else if (isRangeSelection()) {
      if (props.value && props.value.length) {
        var startDate = props.value[0];
        var endDate = props.value[1];

        if (!endDate) {
          if (date.getTime() >= startDate.getTime()) {
            endDate = date;
          } else {
            endDate = startDate;
            startDate = date;
          }
        } else {
          startDate = date;
          endDate = null;
        }

        selectedValues = [startDate, endDate];
        updateModel(event, selectedValues);
      } else {
        selectedValues = [date, null];
        updateModel(event, selectedValues);
      }
    }

    if (props.onSelect) {
      props.onSelect({
        originalEvent: event,
        value: date
      });
    }

    updateInputfield(selectedValues);
  };

  var decrementDecade = function decrementDecade() {
    var _currentYear = currentYear - 10;

    setCurrentYear(_currentYear);
    return _currentYear;
  };

  var incrementDecade = function incrementDecade() {
    var _currentYear = currentYear + 10;

    setCurrentYear(_currentYear);
    return _currentYear;
  };

  var switchToMonthView = function switchToMonthView(event) {
    setCurrentView('month');
    event.preventDefault();
  };

  var switchToYearView = function switchToYearView(event) {
    setCurrentView('year');
    event.preventDefault();
  };

  var onMonthSelect = function onMonthSelect(event, month) {
    if (props.view === 'month') {
      onDateSelect(event, {
        year: currentYear,
        month: month,
        day: 1,
        selectable: true
      });
      event.preventDefault();
    } else {
      setCurrentMonth(month);
      createMonthsMeta(month, currentYear);
      var currentDate = new Date(getCurrentDateTime().getTime());
      currentDate.setDate(1); // #2948 always set to 1st of month

      currentDate.setMonth(month);
      currentDate.setYear(currentYear);
      setViewDateState(currentDate);
      setCurrentView('date');
      props.onMonthChange && props.onMonthChange({
        month: month + 1,
        year: currentYear
      });
    }
  };

  var onYearSelect = function onYearSelect(event, year) {
    if (props.view === 'year') {
      onDateSelect(event, {
        year: year,
        month: 0,
        day: 1,
        selectable: true
      });
    } else {
      setCurrentYear(year);
      setCurrentView('month');
      props.onMonthChange && props.onMonthChange({
        month: currentMonth + 1,
        year: year
      });
    }
  };

  var updateModel = function updateModel(event, value) {
    if (props.onChange) {
      var newValue = value && value instanceof Date ? new Date(value.getTime()) : value;
      viewStateChanged.current = true;
      props.onChange({
        originalEvent: event,
        value: newValue,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        target: {
          name: props.name,
          id: props.id,
          value: newValue
        }
      });
    }
  };

  var show = function show(type) {
    if (props.onVisibleChange) {
      props.onVisibleChange({
        visible: true,
        type: type
      });
    } else {
      setOverlayVisibleState(true);

      overlayEventListener.current = function (e) {
        if (!isOutsideClicked(e)) {
          isOverlayClicked.current = true;
        }
      };

      OverlayService.on('overlay-click', overlayEventListener.current);
    }
  };

  var hide = function hide(type, callback) {
    var _hideCallback = function _hideCallback() {
      viewStateChanged.current = false;
      ignoreFocusFunctionality.current = false;
      isOverlayClicked.current = false;
      callback && callback();
      OverlayService.off('overlay-click', overlayEventListener.current);
      overlayEventListener.current = null;
    };

    props.touchUI && disableModality();

    if (props.onVisibleChange) {
      props.onVisibleChange({
        visible: false,
        type: type,
        callback: _hideCallback
      });
    } else {
      setOverlayVisibleState(false);

      _hideCallback();
    }
  };

  var onOverlayEnter = function onOverlayEnter() {
    if (props.autoZIndex) {
      var key = props.touchUI ? 'modal' : 'overlay';
      ZIndexUtils.set(key, overlayRef.current, PrimeReact$1.autoZIndex, props.baseZIndex || PrimeReact$1.zIndex[key]);
    }

    alignOverlay();
  };

  var onOverlayEntered = function onOverlayEntered() {
    bindOverlayListener();
    props.onShow && props.onShow();
  };

  var onOverlayExit = function onOverlayExit() {
    unbindOverlayListener();
  };

  var onOverlayExited = function onOverlayExited() {
    ZIndexUtils.clear(overlayRef.current);
    props.onHide && props.onHide();
  };

  var appendDisabled = function appendDisabled() {
    return props.appendTo === 'self' || props.inline;
  };

  var alignOverlay = function alignOverlay() {
    if (props.touchUI) {
      enableModality();
    } else if (overlayRef && overlayRef.current && inputRef && inputRef.current) {
      DomHandler.alignOverlay(overlayRef.current, inputRef.current, props.appendTo || PrimeReact$1.appendTo);

      if (appendDisabled()) {
        DomHandler.relativePosition(overlayRef.current, inputRef.current);
      } else {
        if (currentView === 'date') {
          overlayRef.current.style.width = DomHandler.getOuterWidth(overlayRef.current) + 'px';
          overlayRef.current.style.minWidth = DomHandler.getOuterWidth(inputRef.current) + 'px';
        } else {
          overlayRef.current.style.width = DomHandler.getOuterWidth(inputRef.current) + 'px';
        }

        DomHandler.absolutePosition(overlayRef.current, inputRef.current);
      }
    }
  };

  var enableModality = function enableModality() {
    if (!touchUIMask.current) {
      touchUIMask.current = document.createElement('div');
      touchUIMask.current.style.zIndex = String(ZIndexUtils.get(overlayRef.current) - 1);
      DomHandler.addMultipleClasses(touchUIMask.current, 'p-component-overlay p-datepicker-mask p-datepicker-mask-scrollblocker p-component-overlay-enter');

      touchUIMaskClickListener.current = function () {
        disableModality();
        hide();
      };

      touchUIMask.current.addEventListener('click', touchUIMaskClickListener.current);
      document.body.appendChild(touchUIMask.current);
      DomHandler.addClass(document.body, 'p-overflow-hidden');
    }
  };

  var disableModality = function disableModality() {
    if (touchUIMask.current) {
      DomHandler.addClass(touchUIMask.current, 'p-component-overlay-leave');
      touchUIMask.current.addEventListener('animationend', function () {
        destroyMask();
      });
    }
  };

  var destroyMask = function destroyMask() {
    if (touchUIMask.current) {
      touchUIMask.current.removeEventListener('click', touchUIMaskClickListener.current);
      touchUIMaskClickListener.current = null;
      document.body.removeChild(touchUIMask.current);
      touchUIMask.current = null;
    }

    var bodyChildren = document.body.children;
    var hasBlockerMasks;

    for (var i = 0; i < bodyChildren.length; i++) {
      var bodyChild = bodyChildren[i];

      if (DomHandler.hasClass(bodyChild, 'p-datepicker-mask-scrollblocker')) {
        hasBlockerMasks = true;
        break;
      }
    }

    if (!hasBlockerMasks) {
      DomHandler.removeClass(document.body, 'p-overflow-hidden');
    }
  };

  var isOutsideClicked = function isOutsideClicked(event) {
    return elementRef.current && !(elementRef.current.isSameNode(event.target) || isNavIconClicked(event.target) || elementRef.current.contains(event.target) || overlayRef.current && overlayRef.current.contains(event.target));
  };

  var isNavIconClicked = function isNavIconClicked(target) {
    return DomHandler.hasClass(target, 'p-datepicker-prev') || DomHandler.hasClass(target, 'p-datepicker-prev-icon') || DomHandler.hasClass(target, 'p-datepicker-next') || DomHandler.hasClass(target, 'p-datepicker-next-icon');
  };

  var getFirstDayOfMonthIndex = function getFirstDayOfMonthIndex(month, year) {
    var day = new Date();
    day.setDate(1);
    day.setMonth(month);
    day.setFullYear(year);
    var dayIndex = day.getDay() + getSundayIndex();
    return dayIndex >= 7 ? dayIndex - 7 : dayIndex;
  };

  var getDaysCountInMonth = function getDaysCountInMonth(month, year) {
    return 32 - daylightSavingAdjust(new Date(year, month, 32)).getDate();
  };

  var getDaysCountInPrevMonth = function getDaysCountInPrevMonth(month, year) {
    var prev = getPreviousMonthAndYear(month, year);
    return getDaysCountInMonth(prev.month, prev.year);
  };

  var daylightSavingAdjust = function daylightSavingAdjust(date) {
    if (!date) {
      return null;
    }

    date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
    return date;
  };

  var getPreviousMonthAndYear = function getPreviousMonthAndYear(month, year) {
    var m, y;

    if (month === 0) {
      m = 11;
      y = year - 1;
    } else {
      m = month - 1;
      y = year;
    }

    return {
      month: m,
      year: y
    };
  };

  var getNextMonthAndYear = function getNextMonthAndYear(month, year) {
    var m, y;

    if (month === 11) {
      m = 0;
      y = year + 1;
    } else {
      m = month + 1;
      y = year;
    }

    return {
      month: m,
      year: y
    };
  };

  var getSundayIndex = function getSundayIndex() {
    var firstDayOfWeek = localeOption$1('firstDayOfWeek', props.locale);
    return firstDayOfWeek > 0 ? 7 - firstDayOfWeek : 0;
  };

  var createWeekDaysMeta = function createWeekDaysMeta() {
    var weekDays = [];

    var _localeOptions = localeOptions$1(props.locale),
        dayIndex = _localeOptions.firstDayOfWeek,
        dayNamesMin = _localeOptions.dayNamesMin;

    for (var i = 0; i < 7; i++) {
      weekDays.push(dayNamesMin[dayIndex]);
      dayIndex = dayIndex === 6 ? 0 : ++dayIndex;
    }

    return weekDays;
  };

  var createMonthsMeta = function createMonthsMeta(month, year) {
    var months = [];

    for (var i = 0; i < props.numberOfMonths; i++) {
      var m = month + i;
      var y = year;

      if (m > 11) {
        m = m % 11 - 1;
        y = year + 1;
      }

      months.push(createMonthMeta(m, y));
    }

    return months;
  };

  var createMonthMeta = function createMonthMeta(month, year) {
    var dates = [];
    var firstDay = getFirstDayOfMonthIndex(month, year);
    var daysLength = getDaysCountInMonth(month, year);
    var prevMonthDaysLength = getDaysCountInPrevMonth(month, year);
    var dayNo = 1;
    var today = new Date();
    var weekNumbers = [];
    var monthRows = Math.ceil((daysLength + firstDay) / 7);

    for (var i = 0; i < monthRows; i++) {
      var week = [];

      if (i === 0) {
        for (var j = prevMonthDaysLength - firstDay + 1; j <= prevMonthDaysLength; j++) {
          var prev = getPreviousMonthAndYear(month, year);
          week.push({
            day: j,
            month: prev.month,
            year: prev.year,
            otherMonth: true,
            today: isToday(today, j, prev.month, prev.year),
            selectable: isSelectable(j, prev.month, prev.year, true)
          });
        }

        var remainingDaysLength = 7 - week.length;

        for (var _j = 0; _j < remainingDaysLength; _j++) {
          week.push({
            day: dayNo,
            month: month,
            year: year,
            today: isToday(today, dayNo, month, year),
            selectable: isSelectable(dayNo, month, year, false)
          });
          dayNo++;
        }
      } else {
        for (var _j2 = 0; _j2 < 7; _j2++) {
          if (dayNo > daysLength) {
            var next = getNextMonthAndYear(month, year);
            week.push({
              day: dayNo - daysLength,
              month: next.month,
              year: next.year,
              otherMonth: true,
              today: isToday(today, dayNo - daysLength, next.month, next.year),
              selectable: isSelectable(dayNo - daysLength, next.month, next.year, true)
            });
          } else {
            week.push({
              day: dayNo,
              month: month,
              year: year,
              today: isToday(today, dayNo, month, year),
              selectable: isSelectable(dayNo, month, year, false)
            });
          }

          dayNo++;
        }
      }

      if (props.showWeek) {
        weekNumbers.push(getWeekNumber(new Date(week[0].year, week[0].month, week[0].day)));
      }

      dates.push(week);
    }

    return {
      month: month,
      year: year,
      dates: dates,
      weekNumbers: weekNumbers
    };
  };

  var getWeekNumber = function getWeekNumber(date) {
    var checkDate = new Date(date.getTime());
    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
    var time = checkDate.getTime();
    checkDate.setMonth(0);
    checkDate.setDate(1);
    return Math.floor(Math.round((time - checkDate.getTime()) / 86400000) / 7) + 1;
  };

  var isSelectable = function isSelectable(day, month, year, otherMonth) {
    var validMin = true;
    var validMax = true;
    var validDate = true;
    var validDay = true;
    var validMonth = true;

    if (props.minDate) {
      if (props.minDate.getFullYear() > year) {
        validMin = false;
      } else if (props.minDate.getFullYear() === year) {
        if (props.minDate.getMonth() > month) {
          validMin = false;
        } else if (props.minDate.getMonth() === month) {
          if (day > 0 && props.minDate.getDate() > day) {
            validMin = false;
          }
        }
      }
    }

    if (props.maxDate) {
      if (props.maxDate.getFullYear() < year) {
        validMax = false;
      } else if (props.maxDate.getFullYear() === year) {
        if (props.maxDate.getMonth() < month) {
          validMax = false;
        } else if (props.maxDate.getMonth() === month) {
          if (day > 0 && props.maxDate.getDate() < day) {
            validMax = false;
          }
        }
      }
    }

    if (props.disabledDates) {
      validDate = !isDateDisabled(day, month, year);
    }

    if (props.disabledDays) {
      validDay = !isDayDisabled(day, month, year);
    }

    if (props.selectOtherMonths === false && otherMonth) {
      validMonth = false;
    }

    return validMin && validMax && validDate && validDay && validMonth;
  };

  var isSelectableTime = function isSelectableTime(value) {
    var validMin = true;
    var validMax = true;

    if (props.minDate && props.minDate.toDateString() === value.toDateString()) {
      if (props.minDate.getHours() > value.getHours()) {
        validMin = false;
      } else if (props.minDate.getHours() === value.getHours()) {
        if (props.minDate.getMinutes() > value.getMinutes()) {
          validMin = false;
        } else if (props.minDate.getMinutes() === value.getMinutes()) {
          if (props.minDate.getSeconds() > value.getSeconds()) {
            validMin = false;
          } else if (props.minDate.getSeconds() === value.getSeconds()) {
            if (props.minDate.getMilliseconds() > value.getMilliseconds()) {
              validMin = false;
            }
          }
        }
      }
    }

    if (props.maxDate && props.maxDate.toDateString() === value.toDateString()) {
      if (props.maxDate.getHours() < value.getHours()) {
        validMax = false;
      } else if (props.maxDate.getHours() === value.getHours()) {
        if (props.maxDate.getMinutes() < value.getMinutes()) {
          validMax = false;
        } else if (props.maxDate.getMinutes() === value.getMinutes()) {
          if (props.maxDate.getSeconds() < value.getSeconds()) {
            validMax = false;
          } else if (props.maxDate.getSeconds() === value.getSeconds()) {
            if (props.maxDate.getMilliseconds() < value.getMilliseconds()) {
              validMax = false;
            }
          }
        }
      }
    }

    return validMin && validMax;
  };

  var isSelected = function isSelected(dateMeta) {
    if (props.value) {
      if (isSingleSelection()) {
        return isDateEquals(props.value, dateMeta);
      } else if (isMultipleSelection()) {
        var selected = false;

        var _iterator = _createForOfIteratorHelper$7(props.value),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var date = _step.value;
            selected = isDateEquals(date, dateMeta);

            if (selected) {
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return selected;
      } else if (isRangeSelection()) {
        if (props.value[1]) return isDateEquals(props.value[0], dateMeta) || isDateEquals(props.value[1], dateMeta) || isDateBetween(props.value[0], props.value[1], dateMeta);else {
          return isDateEquals(props.value[0], dateMeta);
        }
      }
    } else {
      return false;
    }
  };

  var isComparable = function isComparable() {
    return props.value != null && typeof props.value !== 'string';
  };

  var isMonthSelected = function isMonthSelected(month) {
    if (isComparable()) {
      var value = isRangeSelection() ? props.value[0] : props.value;
      return !isMultipleSelection() ? value.getMonth() === month && value.getFullYear() === currentYear : false;
    }

    return false;
  };

  var isYearSelected = function isYearSelected(year) {
    if (isComparable()) {
      var value = isRangeSelection() ? props.value[0] : props.value;
      return !isMultipleSelection() && isComparable() ? value.getFullYear() === year : false;
    }

    return false;
  };

  var switchViewButtonDisabled = function switchViewButtonDisabled() {
    return props.numberOfMonths > 1 || props.disabled;
  };

  var isDateEquals = function isDateEquals(value, dateMeta) {
    if (value && value instanceof Date) return value.getDate() === dateMeta.day && value.getMonth() === dateMeta.month && value.getFullYear() === dateMeta.year;else return false;
  };

  var isDateBetween = function isDateBetween(start, end, dateMeta) {
    var between = false;

    if (start && end) {
      var date = new Date(dateMeta.year, dateMeta.month, dateMeta.day);
      return start.getTime() <= date.getTime() && end.getTime() >= date.getTime();
    }

    return between;
  };

  var isSingleSelection = function isSingleSelection() {
    return props.selectionMode === 'single';
  };

  var isRangeSelection = function isRangeSelection() {
    return props.selectionMode === 'range';
  };

  var isMultipleSelection = function isMultipleSelection() {
    return props.selectionMode === 'multiple';
  };

  var isToday = function isToday(today, day, month, year) {
    return today.getDate() === day && today.getMonth() === month && today.getFullYear() === year;
  };

  var isDateDisabled = function isDateDisabled(day, month, year) {
    return props.disabledDates ? props.disabledDates.some(function (d) {
      return d.getFullYear() === year && d.getMonth() === month && d.getDate() === day;
    }) : false;
  };

  var isDayDisabled = function isDayDisabled(day, month, year) {
    if (props.disabledDays) {
      var weekday = new Date(year, month, day);
      var weekdayNumber = weekday.getDay();
      return props.disabledDays.indexOf(weekdayNumber) !== -1;
    }

    return false;
  };

  var updateInputfield = function updateInputfield(value) {
    if (!inputRef.current) {
      return;
    }

    var formattedValue = '';

    if (value) {
      try {
        if (isSingleSelection()) {
          formattedValue = isValidDate(value) ? formatDateTime(value) : '';
        } else if (isMultipleSelection()) {
          for (var i = 0; i < value.length; i++) {
            var selectedValue = value[i];
            var dateAsString = isValidDate(selectedValue) ? formatDateTime(selectedValue) : '';
            formattedValue += dateAsString;

            if (i !== value.length - 1) {
              formattedValue += ', ';
            }
          }
        } else if (isRangeSelection()) {
          if (value && value.length) {
            var startDate = value[0];
            var endDate = value[1];
            formattedValue = isValidDate(startDate) ? formatDateTime(startDate) : '';

            if (endDate) {
              formattedValue += isValidDate(endDate) ? ' - ' + formatDateTime(endDate) : '';
            }
          }
        }
      } catch (err) {
        formattedValue = value;
      }
    }

    inputRef.current.value = formattedValue;
  };

  var formatDateTime = function formatDateTime(date) {
    var formattedValue = null;

    if (date) {
      if (props.timeOnly) {
        formattedValue = formatTime(date);
      } else {
        formattedValue = formatDate(date, getDateFormat());

        if (props.showTime) {
          formattedValue += ' ' + formatTime(date);
        }
      }
    }

    return formattedValue;
  };

  var formatDate = function formatDate(date, format) {
    if (!date) {
      return '';
    }

    var iFormat;

    var lookAhead = function lookAhead(match) {
      var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;

      if (matches) {
        iFormat++;
      }

      return matches;
    },
        formatNumber = function formatNumber(match, value, len) {
      var num = '' + value;

      if (lookAhead(match)) {
        while (num.length < len) {
          num = '0' + num;
        }
      }

      return num;
    },
        formatName = function formatName(match, value, shortNames, longNames) {
      return lookAhead(match) ? longNames[value] : shortNames[value];
    };

    var output = '';
    var literal = false;

    var _localeOptions2 = localeOptions$1(props.locale),
        dayNamesShort = _localeOptions2.dayNamesShort,
        dayNames = _localeOptions2.dayNames,
        monthNamesShort = _localeOptions2.monthNamesShort,
        monthNames = _localeOptions2.monthNames;

    if (date) {
      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
            literal = false;
          } else {
            output += format.charAt(iFormat);
          }
        } else {
          switch (format.charAt(iFormat)) {
            case 'd':
              output += formatNumber('d', date.getDate(), 2);
              break;

            case 'D':
              output += formatName('D', date.getDay(), dayNamesShort, dayNames);
              break;

            case 'o':
              output += formatNumber('o', Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
              break;

            case 'm':
              output += formatNumber('m', date.getMonth() + 1, 2);
              break;

            case 'M':
              output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
              break;

            case 'y':
              output += lookAhead('y') ? date.getFullYear() : (date.getFullYear() % 100 < 10 ? '0' : '') + date.getFullYear() % 100;
              break;

            case '@':
              output += date.getTime();
              break;

            case '!':
              output += date.getTime() * 10000 + ticksTo1970;
              break;

            case "'":
              if (lookAhead("'")) {
                output += "'";
              } else {
                literal = true;
              }

              break;

            default:
              output += format.charAt(iFormat);
          }
        }
      }
    }

    return output;
  };

  var formatTime = function formatTime(date) {
    if (!date) {
      return '';
    }

    var output = '';
    var hours = date.getHours();
    var minutes = date.getMinutes();
    var seconds = date.getSeconds();
    var milliseconds = date.getMilliseconds();

    if (props.hourFormat === '12' && hours > 11 && hours !== 12) {
      hours -= 12;
    }

    if (props.hourFormat === '12') {
      output += hours === 0 ? 12 : hours < 10 ? '0' + hours : hours;
    } else {
      output += hours < 10 ? '0' + hours : hours;
    }

    output += ':';
    output += minutes < 10 ? '0' + minutes : minutes;

    if (props.showSeconds) {
      output += ':';
      output += seconds < 10 ? '0' + seconds : seconds;
    }

    if (props.showMillisec) {
      output += '.';
      output += milliseconds < 100 ? (milliseconds < 10 ? '00' : '0') + milliseconds : milliseconds;
    }

    if (props.hourFormat === '12') {
      output += date.getHours() > 11 ? ' PM' : ' AM';
    }

    return output;
  };

  var parseValueFromString = function parseValueFromString(text) {
    if (!text || text.trim().length === 0) {
      return null;
    }

    var value;

    if (isSingleSelection()) {
      value = parseDateTime(text);
    } else if (isMultipleSelection()) {
      var tokens = text.split(',');
      value = [];

      var _iterator2 = _createForOfIteratorHelper$7(tokens),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var token = _step2.value;
          value.push(parseDateTime(token.trim()));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } else if (isRangeSelection()) {
      var _tokens = text.split(' - ');

      value = [];

      for (var i = 0; i < _tokens.length; i++) {
        value[i] = parseDateTime(_tokens[i].trim());
      }
    }

    return value;
  };

  var parseDateTime = function parseDateTime(text) {
    var date;
    var parts = text.split(' ');

    if (props.timeOnly) {
      date = new Date();
      populateTime(date, parts[0], parts[1]);
    } else {
      if (props.showTime) {
        date = parseDate(parts[0], getDateFormat());
        populateTime(date, parts[1], parts[2]);
      } else {
        date = parseDate(text, getDateFormat());
      }
    }

    return date;
  };

  var populateTime = function populateTime(value, timeString, ampm) {
    if (props.hourFormat === '12' && ampm !== 'PM' && ampm !== 'AM') {
      throw new Error('Invalid Time');
    }

    var time = parseTime(timeString, ampm);
    value.setHours(time.hour);
    value.setMinutes(time.minute);
    value.setSeconds(time.second);
    value.setMilliseconds(time.millisecond);
  };

  var parseTime = function parseTime(value, ampm) {
    value = props.showMillisec ? value.replace('.', ':') : value;
    var tokens = value.split(':');
    var validTokenLength = props.showSeconds ? 3 : 2;
    validTokenLength = props.showMillisec ? validTokenLength + 1 : validTokenLength;

    if (tokens.length !== validTokenLength || tokens[0].length !== 2 || tokens[1].length !== 2 || props.showSeconds && tokens[2].length !== 2 || props.showMillisec && tokens[3].length !== 3) {
      throw new Error('Invalid time');
    }

    var h = parseInt(tokens[0], 10);
    var m = parseInt(tokens[1], 10);
    var s = props.showSeconds ? parseInt(tokens[2], 10) : null;
    var ms = props.showMillisec ? parseInt(tokens[3], 10) : null;

    if (isNaN(h) || isNaN(m) || h > 23 || m > 59 || props.hourFormat === '12' && h > 12 || props.showSeconds && (isNaN(s) || s > 59) || props.showMillisec && (isNaN(s) || s > 1000)) {
      throw new Error('Invalid time');
    } else {
      if (props.hourFormat === '12' && h !== 12 && ampm === 'PM') {
        h += 12;
      }

      return {
        hour: h,
        minute: m,
        second: s,
        millisecond: ms
      };
    }
  }; // Ported from jquery-ui datepicker parseDate


  var parseDate = function parseDate(value, format) {
    if (format == null || value == null) {
      throw new Error('Invalid arguments');
    }

    value = _typeof$1(value) === 'object' ? value.toString() : value + '';

    if (value === '') {
      return null;
    }

    var iFormat,
        dim,
        extra,
        iValue = 0,
        shortYearCutoff = typeof props.shortYearCutoff !== 'string' ? props.shortYearCutoff : new Date().getFullYear() % 100 + parseInt(props.shortYearCutoff, 10),
        year = -1,
        month = -1,
        day = -1,
        doy = -1,
        literal = false,
        date,
        lookAhead = function lookAhead(match) {
      var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;

      if (matches) {
        iFormat++;
      }

      return matches;
    },
        getNumber = function getNumber(match) {
      var isDoubled = lookAhead(match),
          size = match === '@' ? 14 : match === '!' ? 20 : match === 'y' && isDoubled ? 4 : match === 'o' ? 3 : 2,
          minSize = match === 'y' ? size : 1,
          digits = new RegExp('^\\d{' + minSize + ',' + size + '}'),
          num = value.substring(iValue).match(digits);

      if (!num) {
        throw new Error('Missing number at position ' + iValue);
      }

      iValue += num[0].length;
      return parseInt(num[0], 10);
    },
        getName = function getName(match, shortNames, longNames) {
      var index = -1;
      var arr = lookAhead(match) ? longNames : shortNames;
      var names = [];

      for (var i = 0; i < arr.length; i++) {
        names.push([i, arr[i]]);
      }

      names.sort(function (a, b) {
        return -(a[1].length - b[1].length);
      });

      for (var _i = 0; _i < names.length; _i++) {
        var name = names[_i][1];

        if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
          index = names[_i][0];
          iValue += name.length;
          break;
        }
      }

      if (index !== -1) {
        return index + 1;
      } else {
        throw new Error('Unknown name at position ' + iValue);
      }
    },
        checkLiteral = function checkLiteral() {
      if (value.charAt(iValue) !== format.charAt(iFormat)) {
        throw new Error('Unexpected literal at position ' + iValue);
      }

      iValue++;
    };

    if (props.view === 'month') {
      day = 1;
    }

    var _localeOptions3 = localeOptions$1(props.locale),
        dayNamesShort = _localeOptions3.dayNamesShort,
        dayNames = _localeOptions3.dayNames,
        monthNamesShort = _localeOptions3.monthNamesShort,
        monthNames = _localeOptions3.monthNames;

    for (iFormat = 0; iFormat < format.length; iFormat++) {
      if (literal) {
        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
          literal = false;
        } else {
          checkLiteral();
        }
      } else {
        switch (format.charAt(iFormat)) {
          case 'd':
            day = getNumber('d');
            break;

          case 'D':
            getName('D', dayNamesShort, dayNames);
            break;

          case 'o':
            doy = getNumber('o');
            break;

          case 'm':
            month = getNumber('m');
            break;

          case 'M':
            month = getName('M', monthNamesShort, monthNames);
            break;

          case 'y':
            year = getNumber('y');
            break;

          case '@':
            date = new Date(getNumber('@'));
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;

          case '!':
            date = new Date((getNumber('!') - ticksTo1970) / 10000);
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;

          case "'":
            if (lookAhead("'")) {
              checkLiteral();
            } else {
              literal = true;
            }

            break;

          default:
            checkLiteral();
        }
      }
    }

    if (iValue < value.length) {
      extra = value.substr(iValue);

      if (!/^\s+/.test(extra)) {
        throw new Error('Extra/unparsed characters found in date: ' + extra);
      }
    }

    if (year === -1) {
      year = new Date().getFullYear();
    } else if (year < 100) {
      year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
    }

    if (doy > -1) {
      month = 1;
      day = doy;

      do {
        dim = getDaysCountInMonth(year, month - 1);

        if (day <= dim) {
          break;
        }

        month++;
        day -= dim;
      } while (true);
    }

    date = daylightSavingAdjust(new Date(year, month - 1, day));

    if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
      throw new Error('Invalid date'); // E.g. 31/02/00
    }

    return date;
  };

  var isInMinYear = function isInMinYear(viewDate) {
    return props.minDate && props.minDate.getFullYear() === viewDate.getFullYear();
  };

  var isInMaxYear = function isInMaxYear(viewDate) {
    return props.maxDate && props.maxDate.getFullYear() === viewDate.getFullYear();
  };

  React.useEffect(function () {
    ObjectUtils.combinedRefs(inputRef, props.inputRef);
  }, [inputRef, props.inputRef]);
  useMountEffect(function () {
    var unbindMaskEvents = null;
    var viewDate = getViewDate(props.viewDate);
    validateDate(viewDate);
    setViewDateState(viewDate);
    setCurrentMonth(viewDate.getMonth());
    setCurrentYear(viewDate.getFullYear());
    setCurrentView(props.view);

    if (props.inline) {
      overlayRef && overlayRef.current.setAttribute(attributeSelector, '');

      if (!props.disabled) {
        initFocusableCell();

        if (props.numberOfMonths === 1) {
          overlayRef.current.style.width = DomHandler.getOuterWidth(overlayRef.current) + 'px';
        }
      }
    } else if (props.mask) {
      unbindMaskEvents = mask(inputRef.current, {
        mask: props.mask,
        readOnly: props.readOnlyInput || props.disabled,
        onChange: function onChange(e) {
          !ignoreMaskChange.current && updateValueOnInput(e.originalEvent, e.value);
          ignoreMaskChange.current = false;
        },
        onBlur: function onBlur() {
          ignoreMaskChange.current = true;
        }
      }).unbindEvents;
    }

    if (props.value) {
      updateInputfield(props.value);
      setValue(props.value);
    }

    return function () {
      props.mask && unbindMaskEvents();
    };
  });
  useUpdateEffect(function () {
    setCurrentView(props.view);
  }, [props.view]);
  useUpdateEffect(function () {
    if (!props.onViewDateChange && !viewStateChanged.current) {
      setValue(props.value);
    }
  }, [props.onViewDateChange, props.value]);
  useUpdateEffect(function () {
    if (previousValue !== props.value && (!viewStateChanged.current || !visible)) {
      updateInputfield(props.value);
    }
  }, [props.value, visible]);
  useUpdateEffect(function () {
    updateInputfield(props.value);
  }, [props.dateFormat, props.hourFormat, props.timeOnly, props.showSeconds, props.showMillisec]);
  useUpdateEffect(function () {
    if (overlayRef.current) {
      setNavigationState(viewDateState);
      updateFocus();
    }
  });
  useUnmountEffect(function () {
    if (touchUIMask.current) {
      disableModality();
      touchUIMask.current = null;
    }

    ZIndexUtils.clear(overlayRef.current);
  });
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      show: show,
      hide: hide,
      getCurrentDateTime: getCurrentDateTime,
      getViewDate: getViewDate,
      updateViewDate: updateViewDate,
      getElement: function getElement() {
        return elementRef.current;
      },
      getOverlay: function getOverlay() {
        return overlayRef.current;
      },
      getInput: function getInput() {
        return inputRef.current;
      }
    };
  });

  var setValue = function setValue(propValue) {
    if (Array.isArray(propValue)) {
      propValue = propValue[0];
    }

    var prevPropValue = previousValue;

    if (Array.isArray(prevPropValue)) {
      prevPropValue = prevPropValue[0];
    }

    if (!prevPropValue && propValue || propValue && propValue instanceof Date && propValue.getTime() !== prevPropValue.getTime()) {
      var viewDate = props.viewDate && isValidDate(props.viewDate) ? props.viewDate : propValue && isValidDate(propValue) ? propValue : new Date();
      validateDate(viewDate);
      setViewDateState(viewDate);
      viewStateChanged.current = true;
    }
  };

  var createBackwardNavigator = function createBackwardNavigator(isVisible) {
    var navigatorProps = isVisible ? {
      onClick: onPrevButtonClick,
      onKeyDown: function onKeyDown(e) {
        return onContainerButtonKeydown(e);
      }
    } : {
      style: {
        visibility: 'hidden'
      }
    };
    return /*#__PURE__*/React.createElement("button", _extends$o({
      type: "button",
      className: "p-datepicker-prev"
    }, navigatorProps), /*#__PURE__*/React.createElement("span", {
      className: "p-datepicker-prev-icon pi pi-chevron-left"
    }), /*#__PURE__*/React.createElement(Ripple, null));
  };

  var createForwardNavigator = function createForwardNavigator(isVisible) {
    var navigatorProps = isVisible ? {
      onClick: onNextButtonClick,
      onKeyDown: function onKeyDown(e) {
        return onContainerButtonKeydown(e);
      }
    } : {
      style: {
        visibility: 'hidden'
      }
    };
    return /*#__PURE__*/React.createElement("button", _extends$o({
      type: "button",
      className: "p-datepicker-next"
    }, navigatorProps), /*#__PURE__*/React.createElement("span", {
      className: "p-datepicker-next-icon pi pi-chevron-right"
    }), /*#__PURE__*/React.createElement(Ripple, null));
  };

  var createTitleMonthElement = function createTitleMonthElement(month) {
    var monthNames = localeOption$1('monthNames', props.locale);

    if (props.monthNavigator && props.view !== 'month') {
      var viewDate = getViewDate();
      var viewMonth = viewDate.getMonth();
      var displayedMonthOptions = monthNames.map(function (month, index) {
        return (!isInMinYear(viewDate) || index >= props.minDate.getMonth()) && (!isInMaxYear(viewDate) || index <= props.maxDate.getMonth()) ? {
          label: month,
          value: index,
          index: index
        } : null;
      }).filter(function (option) {
        return !!option;
      });
      var displayedMonthNames = displayedMonthOptions.map(function (option) {
        return option.label;
      });

      var _content = /*#__PURE__*/React.createElement("select", {
        className: "p-datepicker-month",
        onChange: function onChange(e) {
          return onMonthDropdownChange(e, e.target.value);
        },
        value: viewMonth
      }, displayedMonthOptions.map(function (option) {
        return /*#__PURE__*/React.createElement("option", {
          key: option.label,
          value: option.value
        }, option.label);
      }));

      if (props.monthNavigatorTemplate) {
        var defaultContentOptions = {
          onChange: onMonthDropdownChange,
          className: 'p-datepicker-month',
          value: viewMonth,
          names: displayedMonthNames,
          options: displayedMonthOptions,
          element: _content,
          props: props
        };
        return ObjectUtils.getJSXElement(props.monthNavigatorTemplate, defaultContentOptions);
      }

      return _content;
    }

    return currentView === 'date' && /*#__PURE__*/React.createElement("button", {
      className: "p-datepicker-month p-link",
      onClick: switchToMonthView,
      disabled: switchViewButtonDisabled()
    }, monthNames[month]);
  };

  var createTitleYearElement = function createTitleYearElement() {
    if (props.yearNavigator) {
      var _yearOptions2 = [];
      var years = props.yearRange.split(':');
      var yearStart = parseInt(years[0], 10);
      var yearEnd = parseInt(years[1], 10);

      for (var i = yearStart; i <= yearEnd; i++) {
        _yearOptions2.push(i);
      }

      var viewDate = getViewDate();
      var viewYear = viewDate.getFullYear();

      var displayedYearNames = _yearOptions2.filter(function (year) {
        return !(props.minDate && props.minDate.getFullYear() > year) && !(props.maxDate && props.maxDate.getFullYear() < year);
      });

      var _content2 = /*#__PURE__*/React.createElement("select", {
        className: "p-datepicker-year",
        onChange: function onChange(e) {
          return onYearDropdownChange(e, e.target.value);
        },
        value: viewYear
      }, displayedYearNames.map(function (year) {
        return /*#__PURE__*/React.createElement("option", {
          key: year,
          value: year
        }, year);
      }));

      if (props.yearNavigatorTemplate) {
        var options = displayedYearNames.map(function (name, i) {
          return {
            label: name,
            value: name,
            index: i
          };
        });
        var defaultContentOptions = {
          onChange: onYearDropdownChange,
          className: 'p-datepicker-year',
          value: viewYear,
          names: displayedYearNames,
          options: options,
          element: _content2,
          props: props
        };
        return ObjectUtils.getJSXElement(props.yearNavigatorTemplate, defaultContentOptions);
      }

      return _content2;
    }

    return currentView !== 'year' && /*#__PURE__*/React.createElement("button", {
      className: "p-datepicker-year p-link",
      onClick: switchToYearView,
      disabled: switchViewButtonDisabled()
    }, currentYear);
  };

  var createTitleDecadeElement = function createTitleDecadeElement() {
    var years = yearPickerValues();

    if (currentView === 'year') {
      return /*#__PURE__*/React.createElement("span", {
        className: "p-datepicker-decade"
      }, props.decadeTemplate ? props.decadeTemplate(years) : /*#__PURE__*/React.createElement("span", null, "".concat(yearPickerValues()[0], " - ").concat(yearPickerValues()[yearPickerValues().length - 1])));
    }

    return null;
  };

  var createTitle = function createTitle(monthMetaData) {
    var month = createTitleMonthElement(monthMetaData.month);
    var year = createTitleYearElement(monthMetaData.year);
    var decade = createTitleDecadeElement();
    return /*#__PURE__*/React.createElement("div", {
      className: "p-datepicker-title"
    }, month, year, decade);
  };

  var createDayNames = function createDayNames(weekDays) {
    var dayNames = weekDays.map(function (weekDay, index) {
      return /*#__PURE__*/React.createElement("th", {
        key: "".concat(weekDay, "-").concat(index),
        scope: "col"
      }, /*#__PURE__*/React.createElement("span", null, weekDay));
    });

    if (props.showWeek) {
      var weekHeader = /*#__PURE__*/React.createElement("th", {
        scope: "col",
        key: "wn",
        className: "p-datepicker-weekheader p-disabled"
      }, /*#__PURE__*/React.createElement("span", null, localeOption$1('weekHeader', props.locale)));
      return [weekHeader].concat(_toConsumableArray$9(dayNames));
    }

    return dayNames;
  };

  var createDateCellContent = function createDateCellContent(date, className, groupIndex) {
    var content = props.dateTemplate ? props.dateTemplate(date) : date.day;
    return /*#__PURE__*/React.createElement("span", {
      className: className,
      onClick: function onClick(e) {
        return onDateSelect(e, date);
      },
      onKeyDown: function onKeyDown(e) {
        return onDateCellKeydown(e, date, groupIndex);
      }
    }, content, /*#__PURE__*/React.createElement(Ripple, null));
  };

  var createWeek = function createWeek(weekDates, weekNumber, groupIndex) {
    var week = weekDates.map(function (date) {
      var selected = isSelected(date);
      var cellClassName = classNames({
        'p-datepicker-other-month': date.otherMonth,
        'p-datepicker-today': date.today
      });
      var dateClassName = classNames({
        'p-highlight': selected,
        'p-disabled': !date.selectable
      });
      var content = date.otherMonth && !props.showOtherMonths ? null : createDateCellContent(date, dateClassName, groupIndex);
      return /*#__PURE__*/React.createElement("td", {
        key: date.day,
        className: cellClassName
      }, content);
    });

    if (props.showWeek) {
      var weekNumberCell = /*#__PURE__*/React.createElement("td", {
        key: 'wn' + weekNumber,
        className: "p-datepicker-weeknumber"
      }, /*#__PURE__*/React.createElement("span", {
        className: "p-disabled"
      }, weekNumber));
      return [weekNumberCell].concat(_toConsumableArray$9(week));
    }

    return week;
  };

  var createDates = function createDates(monthMetaData, groupIndex) {
    return monthMetaData.dates.map(function (weekDates, index) {
      return /*#__PURE__*/React.createElement("tr", {
        key: index
      }, createWeek(weekDates, monthMetaData.weekNumbers[index], groupIndex));
    });
  };

  var createDateViewGrid = function createDateViewGrid(monthMetaData, weekDays, groupIndex) {
    var dayNames = createDayNames(weekDays);
    var dates = createDates(monthMetaData, groupIndex);
    return currentView === 'date' && /*#__PURE__*/React.createElement("div", {
      className: "p-datepicker-calendar-container"
    }, /*#__PURE__*/React.createElement("table", {
      className: "p-datepicker-calendar"
    }, /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement("tr", null, dayNames)), /*#__PURE__*/React.createElement("tbody", null, dates)));
  };

  var createMonth = function createMonth(monthMetaData, index) {
    var weekDays = createWeekDaysMeta();
    var backwardNavigator = createBackwardNavigator(index === 0);
    var forwardNavigator = createForwardNavigator(props.numberOfMonths === 1 || index === props.numberOfMonths - 1);
    var title = createTitle(monthMetaData);
    var dateViewGrid = createDateViewGrid(monthMetaData, weekDays, index);
    var header = props.headerTemplate ? props.headerTemplate() : null;
    return /*#__PURE__*/React.createElement("div", {
      key: monthMetaData.month,
      className: "p-datepicker-group"
    }, /*#__PURE__*/React.createElement("div", {
      className: "p-datepicker-header"
    }, header, backwardNavigator, title, forwardNavigator), dateViewGrid);
  };

  var createMonths = function createMonths(monthsMetaData) {
    var groups = monthsMetaData.map(createMonth);
    return /*#__PURE__*/React.createElement("div", {
      className: "p-datepicker-group-container"
    }, groups);
  };

  var createDateView = function createDateView() {
    var viewDate = getViewDate();
    var monthsMetaData = createMonthsMeta(viewDate.getMonth(), viewDate.getFullYear());
    var months = createMonths(monthsMetaData);
    return months;
  };

  var monthPickerValues = function monthPickerValues() {
    var monthPickerValues = [];
    var monthNamesShort = localeOption$1('monthNamesShort', props.locale);

    for (var i = 0; i <= 11; i++) {
      monthPickerValues.push(monthNamesShort[i]);
    }

    return monthPickerValues;
  };

  var yearPickerValues = function yearPickerValues() {
    var yearPickerValues = [];
    var base = currentYear - currentYear % 10;

    for (var i = 0; i < 10; i++) {
      yearPickerValues.push(base + i);
    }

    return yearPickerValues;
  };

  var createMonthYearView = function createMonthYearView() {
    var backwardNavigator = createBackwardNavigator(true);
    var forwardNavigator = createForwardNavigator(true);
    var yearElement = createTitleYearElement(getViewDate().getFullYear());
    var decade = createTitleDecadeElement();
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      className: "p-datepicker-group-container"
    }, /*#__PURE__*/React.createElement("div", {
      className: "p-datepicker-group"
    }, /*#__PURE__*/React.createElement("div", {
      className: "p-datepicker-header"
    }, backwardNavigator, /*#__PURE__*/React.createElement("div", {
      className: "p-datepicker-title"
    }, yearElement, decade), forwardNavigator))));
  };

  var createDatePicker = function createDatePicker() {
    if (!props.timeOnly) {
      if (props.view === 'date') {
        return createDateView();
      } else {
        return createMonthYearView();
      }
    }

    return null;
  };

  var createHourPicker = function createHourPicker() {
    var currentTime = getCurrentDateTime();
    var hour = currentTime.getHours();

    if (props.hourFormat === '12') {
      if (hour === 0) hour = 12;else if (hour > 11 && hour !== 12) hour = hour - 12;
    }

    var hourDisplay = hour < 10 ? '0' + hour : hour;
    return /*#__PURE__*/React.createElement("div", {
      className: "p-hour-picker"
    }, /*#__PURE__*/React.createElement("button", {
      type: "button",
      className: "p-link",
      onMouseDown: function onMouseDown(e) {
        return onTimePickerElementMouseDown(e, 0, 1);
      },
      onMouseUp: onTimePickerElementMouseUp,
      onMouseLeave: onTimePickerElementMouseLeave,
      onKeyDown: function onKeyDown(e) {
        return onContainerButtonKeydown(e);
      }
    }, /*#__PURE__*/React.createElement("span", {
      className: "pi pi-chevron-up"
    }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("span", null, hourDisplay), /*#__PURE__*/React.createElement("button", {
      type: "button",
      className: "p-link",
      onMouseDown: function onMouseDown(e) {
        return onTimePickerElementMouseDown(e, 0, -1);
      },
      onMouseUp: onTimePickerElementMouseUp,
      onMouseLeave: onTimePickerElementMouseLeave,
      onKeyDown: function onKeyDown(e) {
        return onContainerButtonKeydown(e);
      }
    }, /*#__PURE__*/React.createElement("span", {
      className: "pi pi-chevron-down"
    }), /*#__PURE__*/React.createElement(Ripple, null)));
  };

  var createMinutePicker = function createMinutePicker() {
    var currentTime = getCurrentDateTime();
    var minute = currentTime.getMinutes();
    var minuteDisplay = minute < 10 ? '0' + minute : minute;
    return /*#__PURE__*/React.createElement("div", {
      className: "p-minute-picker"
    }, /*#__PURE__*/React.createElement("button", {
      type: "button",
      className: "p-link",
      onMouseDown: function onMouseDown(e) {
        return onTimePickerElementMouseDown(e, 1, 1);
      },
      onMouseUp: onTimePickerElementMouseUp,
      onMouseLeave: onTimePickerElementMouseLeave,
      onKeyDown: function onKeyDown(e) {
        return onContainerButtonKeydown(e);
      }
    }, /*#__PURE__*/React.createElement("span", {
      className: "pi pi-chevron-up"
    }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("span", null, minuteDisplay), /*#__PURE__*/React.createElement("button", {
      type: "button",
      className: "p-link",
      onMouseDown: function onMouseDown(e) {
        return onTimePickerElementMouseDown(e, 1, -1);
      },
      onMouseUp: onTimePickerElementMouseUp,
      onMouseLeave: onTimePickerElementMouseLeave,
      onKeyDown: function onKeyDown(e) {
        return onContainerButtonKeydown(e);
      }
    }, /*#__PURE__*/React.createElement("span", {
      className: "pi pi-chevron-down"
    }), /*#__PURE__*/React.createElement(Ripple, null)));
  };

  var createSecondPicker = function createSecondPicker() {
    if (props.showSeconds) {
      var currentTime = getCurrentDateTime();
      var second = currentTime.getSeconds();
      var secondDisplay = second < 10 ? '0' + second : second;
      return /*#__PURE__*/React.createElement("div", {
        className: "p-second-picker"
      }, /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-link",
        onMouseDown: function onMouseDown(e) {
          return onTimePickerElementMouseDown(e, 2, 1);
        },
        onMouseUp: onTimePickerElementMouseUp,
        onMouseLeave: onTimePickerElementMouseLeave,
        onKeyDown: function onKeyDown(e) {
          return onContainerButtonKeydown(e);
        }
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-up"
      }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("span", null, secondDisplay), /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-link",
        onMouseDown: function onMouseDown(e) {
          return onTimePickerElementMouseDown(e, 2, -1);
        },
        onMouseUp: onTimePickerElementMouseUp,
        onMouseLeave: onTimePickerElementMouseLeave,
        onKeyDown: function onKeyDown(e) {
          return onContainerButtonKeydown(e);
        }
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-down"
      }), /*#__PURE__*/React.createElement(Ripple, null)));
    }

    return null;
  };

  var createMiliSecondPicker = function createMiliSecondPicker() {
    if (props.showMillisec) {
      var currentTime = getCurrentDateTime();
      var millisecond = currentTime.getMilliseconds();
      var millisecondDisplay = millisecond < 100 ? (millisecond < 10 ? '00' : '0') + millisecond : millisecond;
      return /*#__PURE__*/React.createElement("div", {
        className: "p-millisecond-picker"
      }, /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-link",
        onMouseDown: function onMouseDown(e) {
          return onTimePickerElementMouseDown(e, 3, 1);
        },
        onMouseUp: onTimePickerElementMouseUp,
        onMouseLeave: onTimePickerElementMouseLeave,
        onKeyDown: function onKeyDown(e) {
          return onContainerButtonKeydown(e);
        }
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-up"
      }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("span", null, millisecondDisplay), /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-link",
        onMouseDown: function onMouseDown(e) {
          return onTimePickerElementMouseDown(e, 3, -1);
        },
        onMouseUp: onTimePickerElementMouseUp,
        onMouseLeave: onTimePickerElementMouseLeave,
        onKeyDown: function onKeyDown(e) {
          return onContainerButtonKeydown(e);
        }
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-down"
      }), /*#__PURE__*/React.createElement(Ripple, null)));
    }

    return null;
  };

  var createAmPmPicker = function createAmPmPicker() {
    if (props.hourFormat === '12') {
      var currentTime = getCurrentDateTime();
      var hour = currentTime.getHours();
      var display = hour > 11 ? 'PM' : 'AM';
      return /*#__PURE__*/React.createElement("div", {
        className: "p-ampm-picker"
      }, /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-link",
        onClick: toggleAmPm
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-up"
      }), /*#__PURE__*/React.createElement(Ripple, null)), /*#__PURE__*/React.createElement("span", null, display), /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-link",
        onClick: toggleAmPm
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-down"
      }), /*#__PURE__*/React.createElement(Ripple, null)));
    }

    return null;
  };

  var createSeparator = function createSeparator(separator) {
    return /*#__PURE__*/React.createElement("div", {
      className: "p-separator"
    }, /*#__PURE__*/React.createElement("span", null, separator));
  };

  var createTimePicker = function createTimePicker() {
    if ((props.showTime || props.timeOnly) && currentView === 'date') {
      return /*#__PURE__*/React.createElement("div", {
        className: "p-timepicker"
      }, createHourPicker(), createSeparator(':'), createMinutePicker(), props.showSeconds && createSeparator(':'), createSecondPicker(), props.showMillisec && createSeparator('.'), createMiliSecondPicker(), props.hourFormat === '12' && createSeparator(':'), createAmPmPicker());
    }

    return null;
  };

  var createInputElement = function createInputElement() {
    if (!props.inline) {
      return /*#__PURE__*/React.createElement(InputText$1, {
        ref: inputRef,
        id: props.inputId,
        name: props.name,
        type: "text",
        className: props.inputClassName,
        style: props.inputStyle,
        readOnly: props.readOnlyInput,
        disabled: props.disabled,
        required: props.required,
        autoComplete: "off",
        placeholder: props.placeholder,
        tabIndex: props.tabIndex,
        onInput: onUserInput,
        onFocus: onInputFocus,
        onBlur: onInputBlur,
        onKeyDown: onInputKeyDown,
        "aria-labelledby": props.ariaLabelledBy,
        inputMode: props.inputMode,
        tooltip: props.tooltip,
        tooltipOptions: props.tooltipOptions
      });
    }

    return null;
  };

  var createButton = function createButton() {
    if (props.showIcon) {
      return /*#__PURE__*/React.createElement(Button$1, {
        type: "button",
        icon: props.icon,
        onClick: onButtonClick,
        tabIndex: "-1",
        disabled: props.disabled,
        className: "p-datepicker-trigger"
      });
    }

    return null;
  };

  var createContent = function createContent() {
    var input = createInputElement();
    var button = createButton();

    if (props.iconPos === 'left') {
      return /*#__PURE__*/React.createElement(React.Fragment, null, button, input);
    }

    return /*#__PURE__*/React.createElement(React.Fragment, null, input, button);
  };

  var createButtonBar = function createButtonBar() {
    if (props.showButtonBar) {
      var todayClassName = classNames('p-button-text', props.todayButtonClassName);
      var clearClassName = classNames('p-button-text', props.clearButtonClassName);

      var _localeOptions4 = localeOptions$1(props.locale),
          today = _localeOptions4.today,
          clear = _localeOptions4.clear;

      return /*#__PURE__*/React.createElement("div", {
        className: "p-datepicker-buttonbar"
      }, /*#__PURE__*/React.createElement(Button$1, {
        type: "button",
        label: today,
        onClick: onTodayButtonClick,
        onKeyDown: function onKeyDown(e) {
          return onContainerButtonKeydown(e);
        },
        className: todayClassName
      }), /*#__PURE__*/React.createElement(Button$1, {
        type: "button",
        label: clear,
        onClick: onClearButtonClick,
        onKeyDown: function onKeyDown(e) {
          return onContainerButtonKeydown(e);
        },
        className: clearClassName
      }));
    }

    return null;
  };

  var createFooter = function createFooter() {
    if (props.footerTemplate) {
      var _content3 = props.footerTemplate();

      return /*#__PURE__*/React.createElement("div", {
        className: "p-datepicker-footer"
      }, _content3);
    }

    return null;
  };

  var createMonthPicker = function createMonthPicker() {
    if (currentView === 'month') {
      return /*#__PURE__*/React.createElement("div", {
        className: "p-monthpicker"
      }, monthPickerValues().map(function (m, i) {
        return /*#__PURE__*/React.createElement("span", {
          onClick: function onClick(event) {
            return onMonthSelect(event, i);
          },
          key: "month".concat(i + 1),
          className: classNames('p-monthpicker-month', {
            'p-highlight': isMonthSelected(i),
            'p-disabled': !isSelectable(0, i, currentYear)
          })
        }, m);
      }));
    }

    return null;
  };

  var createYearPicker = function createYearPicker() {
    if (currentView === 'year') {
      return /*#__PURE__*/React.createElement("div", {
        className: "p-yearpicker"
      }, yearPickerValues().map(function (y, i) {
        return /*#__PURE__*/React.createElement("span", {
          onClick: function onClick(event) {
            return onYearSelect(event, y);
          },
          key: "year".concat(i + 1),
          className: classNames('p-yearpicker-year', {
            'p-highlight': isYearSelected(y)
          })
        }, y);
      }));
    }

    return null;
  };

  var otherProps = ObjectUtils.findDiffKeys(props, Calendar.defaultProps);
  var className = classNames('p-calendar p-component p-inputwrapper', props.className, (_classNames = {}, _defineProperty$7(_classNames, "p-calendar-w-btn p-calendar-w-btn-".concat(props.iconPos), props.showIcon), _defineProperty$7(_classNames, 'p-calendar-disabled', props.disabled), _defineProperty$7(_classNames, 'p-calendar-timeonly', props.timeOnly), _defineProperty$7(_classNames, 'p-inputwrapper-filled', props.value || DomHandler.hasClass(inputRef.current, 'p-filled') && inputRef.current.value !== ''), _defineProperty$7(_classNames, 'p-inputwrapper-focus', focusedState), _classNames));
  var panelClassName = classNames('p-datepicker p-component', props.panelClassName, {
    'p-datepicker-inline': props.inline,
    'p-disabled': props.disabled,
    'p-datepicker-timeonly': props.timeOnly,
    'p-datepicker-multiple-month': props.numberOfMonths > 1,
    'p-datepicker-monthpicker': currentView === 'month',
    'p-datepicker-touch-ui': props.touchUI
  });
  var content = createContent();
  var datePicker = createDatePicker();
  var timePicker = createTimePicker();
  var buttonBar = createButtonBar();
  var footer = createFooter();
  var monthPicker = createMonthPicker();
  var yearPicker = createYearPicker();
  return /*#__PURE__*/React.createElement("span", _extends$o({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style
  }, otherProps), content, /*#__PURE__*/React.createElement(CalendarPanel, {
    ref: overlayRef,
    className: panelClassName,
    style: props.panelStyle,
    appendTo: props.appendTo,
    inline: props.inline,
    onClick: onPanelClick,
    onMouseUp: onPanelMouseUp,
    "in": visible,
    onEnter: onOverlayEnter,
    onEntered: onOverlayEntered,
    onExit: onOverlayExit,
    onExited: onOverlayExited,
    transitionOptions: props.transitionOptions
  }, datePicker, timePicker, monthPicker, yearPicker, buttonBar, footer));
}));
Calendar.displayName = 'Calendar';
Calendar.defaultProps = {
  __TYPE: 'Calendar',
  appendTo: null,
  ariaLabelledBy: null,
  autoZIndex: true,
  baseZIndex: 0,
  className: null,
  clearButtonClassName: 'p-button-secondary',
  dateFormat: null,
  dateTemplate: null,
  decadeTemplate: null,
  disabled: false,
  disabledDates: null,
  disabledDays: null,
  footerTemplate: null,
  headerTemplate: null,
  hideOnDateTimeSelect: false,
  hourFormat: '24',
  icon: 'pi pi-calendar',
  iconPos: 'right',
  id: null,
  inline: false,
  inputClassName: null,
  inputId: null,
  inputMode: 'none',
  inputRef: null,
  inputStyle: null,
  keepInvalid: false,
  locale: null,
  mask: null,
  maxDate: null,
  maxDateCount: null,
  minDate: null,
  monthNavigator: false,
  monthNavigatorTemplate: null,
  name: null,
  numberOfMonths: 1,
  onBlur: null,
  onChange: null,
  onClearButtonClick: null,
  onFocus: null,
  onHide: null,
  onInput: null,
  onMonthChange: null,
  onSelect: null,
  onShow: null,
  onTodayButtonClick: null,
  onViewDateChange: null,
  onVisibleChange: null,
  panelClassName: null,
  panelStyle: null,
  placeholder: null,
  readOnlyInput: false,
  required: false,
  selectOtherMonths: false,
  selectionMode: 'single',
  shortYearCutoff: '+10',
  showButtonBar: false,
  showIcon: false,
  showMillisec: false,
  showMinMaxRange: false,
  showOnFocus: true,
  showOtherMonths: true,
  showSeconds: false,
  showTime: false,
  showWeek: false,
  stepHour: 1,
  stepMillisec: 1,
  stepMinute: 1,
  stepSecond: 1,
  style: null,
  tabIndex: null,
  timeOnly: false,
  todayButtonClassName: 'p-button-secondary',
  tooltip: null,
  tooltipOptions: null,
  touchUI: false,
  transitionOptions: null,
  value: null,
  view: 'date',
  viewDate: null,
  visible: false,
  yearNavigator: false,
  yearNavigatorTemplate: null,
  yearRange: null
};

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var LOCALES_RANGE_BLOCKS = {
  ru: {
    today: "",
    yesterday: "",
    week: "",
    last30days: "30 ",
    thisMonth: " ",
    lastMonth: " ",
    last180days: "180 ",
    allTime: " ",
    clear: ""
  },
  en: {
    today: "Today",
    yesterday: "Yesterday",
    week: "Week",
    last30days: "30 days",
    thisMonth: "This month",
    lastMonth: "Last month",
    last180days: "180 days",
    allTime: "All period",
    clear: "Clear"
  }
};
var MONTHS = {
  ru: {
    0: "",
    1: "",
    2: "",
    3: "",
    4: "",
    5: "",
    6: "",
    7: "",
    8: "",
    9: "",
    10: "",
    11: ""
  },
  en: {
    0: "January",
    1: "February",
    2: "March",
    3: "April",
    4: "May",
    5: "June",
    6: "July",
    7: "August",
    8: "September",
    9: "October",
    10: "November",
    11: "December"
  }
};
var START_DATE = new Date("2010-01-01T00:00");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var withRange = function withRange(Component) {
  return /*#__PURE__*/function (_React$Component) {
    _inherits(_class2, _React$Component);

    var _super = _createSuper(_class2);

    function _class2(props) {
      var _this;

      _classCallCheck$1(this, _class2);

      _this = _super.call(this, props);

      _defineProperty$6(_assertThisInitialized(_this), "clear", function () {
        _this.onChange(null);
      });

      _defineProperty$6(_assertThisInitialized(_this), "setToday", function () {
        var newDate = [new Date(), new Date()];

        _this.onChange(newDate);
      });

      _defineProperty$6(_assertThisInitialized(_this), "setYesterday", function () {
        var _getPartsOfTime = getPartsOfTime(),
            day = _getPartsOfTime.day,
            month = _getPartsOfTime.month,
            year = _getPartsOfTime.year;

        var yesterday = new Date(year, month, day - 1);
        var newDate = [yesterday, yesterday];

        _this.onChange(newDate);
      });

      _defineProperty$6(_assertThisInitialized(_this), "setCurrentMonth", function () {
        var _getPartsOfTime2 = getPartsOfTime(),
            month = _getPartsOfTime2.month,
            year = _getPartsOfTime2.year;

        var lastDayInMonth = new Date(year, month + 1, 0).getDate();
        var newDate = [new Date(year, month, 1), new Date(year, month, lastDayInMonth)];

        _this.onChange(newDate);
      });

      _defineProperty$6(_assertThisInitialized(_this), "setLastMonth", function () {
        var _getPartsOfTime3 = getPartsOfTime(),
            month = _getPartsOfTime3.month,
            year = _getPartsOfTime3.year;

        var prevMonth = month - 1;
        var lastDayInPrevMonth = new Date(year, month, 0).getDate();
        var newDate = [new Date(year, prevMonth, 1), new Date(year, prevMonth, lastDayInPrevMonth)];

        _this.onChange(newDate);
      });

      _defineProperty$6(_assertThisInitialized(_this), "setAllTime", function () {
        var _getPartsOfTime4 = getPartsOfTime(),
            month = _getPartsOfTime4.month,
            day = _getPartsOfTime4.day,
            year = _getPartsOfTime4.year;

        var newDate = [_this.props.startCalendarDate, new Date(year, month, day)];

        _this.onChange(newDate);
      });

      _defineProperty$6(_assertThisInitialized(_this), "setWeek", function () {
        _this.setLastDays(7);
      });

      _defineProperty$6(_assertThisInitialized(_this), "setLast30Days", function () {
        _this.setLastDays(30);
      });

      _defineProperty$6(_assertThisInitialized(_this), "setLast180Days", function () {
        _this.setLastDays(180);
      });

      _defineProperty$6(_assertThisInitialized(_this), "setLastDays", function (days) {
        var _getPartsOfTime5 = getPartsOfTime(),
            month = _getPartsOfTime5.month,
            day = _getPartsOfTime5.day,
            year = _getPartsOfTime5.year;

        var daysDiff = day - (days - 1);
        var startDate = new Date(year, month, daysDiff);
        var date = [startDate, new Date(year, month, day)];

        _this.onChange(date);
      });

      _defineProperty$6(_assertThisInitialized(_this), "onChange", function (value) {
        _this.refCalendar.current.onButtonClick();

        _this.props.onChange({
          target: {
            name: _this.props.name || null,
            id: _this.props.id || null,
            value: value
          }
        });
      });

      _defineProperty$6(_assertThisInitialized(_this), "renderFooter", function () {
        if (!_this.props.rangeButtonsBar) return null;
        var translations = LOCALES_RANGE_BLOCKS[_this.props.locale];
        var blocks = [{
          title: translations.today,
          method: _this.setToday
        }, {
          title: translations.yesterday,
          method: _this.setYesterday
        }, {
          title: translations.week,
          method: _this.setWeek
        }, {
          title: translations.last30days,
          method: _this.setLast30Days
        }, {
          title: translations.thisMonth,
          method: _this.setCurrentMonth
        }, {
          title: translations.lastMonth,
          method: _this.setLastMonth
        }, {
          title: translations.last180days,
          method: _this.setLast180Days
        }, {
          title: translations.allTime,
          method: _this.setAllTime
        }];
        return /*#__PURE__*/React__default.createElement("div", {
          className: "flex flex-column p-datepicker-range-buttons"
        }, blocks.map(function (block, index) {
          return /*#__PURE__*/React__default.createElement(Button, {
            key: index,
            className: "p-button-text p-button-plain",
            label: block.title,
            size: "small",
            onClick: block.method
          });
        }), /*#__PURE__*/React__default.createElement(Button, {
          label: translations.clear,
          size: "small",
          onClick: _this.clear
        }));
      });

      _this.refCalendar = /*#__PURE__*/React__default.createRef();
      return _this;
    }

    _createClass$1(_class2, [{
      key: "render",
      value: function render() {
        var panelClassName = classNames(this.props.panelClassName, {
          "p-datepicker_buttons-bar": this.props.rangeButtonsBar
        });
        return /*#__PURE__*/React__default.createElement(Component, _extends$J({}, this.props, {
          panelClassName: panelClassName,
          selectionMode: "range",
          ref: this.refCalendar,
          footerTemplate: this.renderFooter
        }));
      }
    }]);

    return _class2;
  }(React__default.Component);
};

var DatePicker = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      onChange = _ref.onChange,
      yearRange = _ref.yearRange,
      _ref$name = _ref.name,
      name = _ref$name === void 0 ? "" : _ref$name,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder,
      _ref$mode = _ref.mode,
      mode = _ref$mode === void 0 ? "default" : _ref$mode,
      _ref$dateFormat = _ref.dateFormat,
      dateFormat = _ref$dateFormat === void 0 ? "dd.mm.yy" : _ref$dateFormat,
      _ref$showIcon = _ref.showIcon,
      showIcon = _ref$showIcon === void 0 ? true : _ref$showIcon,
      _ref$rangeButtonsBar = _ref.rangeButtonsBar,
      rangeButtonsBar = _ref$rangeButtonsBar === void 0 ? false : _ref$rangeButtonsBar,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$monthNavigator = _ref.monthNavigator,
      monthNavigator = _ref$monthNavigator === void 0 ? true : _ref$monthNavigator,
      _ref$yearNavigator = _ref.yearNavigator,
      yearNavigator = _ref$yearNavigator === void 0 ? true : _ref$yearNavigator,
      _ref$startRangeOfYear = _ref.startRangeOfYears,
      startRangeOfYears = _ref$startRangeOfYear === void 0 ? "2010" : _ref$startRangeOfYear,
      _ref$minDate = _ref.minDate,
      minDate = _ref$minDate === void 0 ? null : _ref$minDate,
      _ref$maxDate = _ref.maxDate,
      maxDate = _ref$maxDate === void 0 ? null : _ref$maxDate,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      style = _ref.style,
      inputClassName = _ref.inputClassName,
      inputStyle = _ref.inputStyle,
      panelClassName = _ref.panelClassName,
      panelStyle = _ref.panelStyle,
      _ref$mask = _ref.mask,
      mask = _ref$mask === void 0 ? null : _ref$mask,
      _ref$startCalendarDat = _ref.startCalendarDate,
      startCalendarDate = _ref$startCalendarDat === void 0 ? START_DATE : _ref$startCalendarDat,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      _ref$required = _ref.required,
      required = _ref$required === void 0 ? false : _ref$required,
      inputId = _ref.inputId,
      _ref$readOnlyInput = _ref.readOnlyInput,
      readOnlyInput = _ref$readOnlyInput === void 0 ? false : _ref$readOnlyInput,
      tabIndex = _ref.tabIndex,
      _ref$autoZIndex = _ref.autoZIndex,
      autoZIndex = _ref$autoZIndex === void 0 ? true : _ref$autoZIndex,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 50 : _ref$baseZIndex,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur,
      onInput = _ref.onInput,
      onSelect = _ref.onSelect,
      onShow = _ref.onShow,
      onHide = _ref.onHide,
      onVisibleChange = _ref.onVisibleChange;
  var defaultViewDate = (value === null || value === void 0 ? void 0 : value[0]) || new Date();

  var _useState = useState(defaultViewDate),
      _useState2 = _slicedToArray$s(_useState, 2),
      viewDate = _useState2[0],
      setViewDate = _useState2[1];

  var getDefaultProps = function getDefaultProps() {
    return {
      id: id,
      ref: ref,
      name: name,
      value: value,
      showIcon: showIcon,
      onChange: onChange,
      dateFormat: dateFormat,
      placeholder: placeholder,
      yearRange: getYearRange(),
      locale: locale().locale,
      disabled: disabled,
      monthNavigator: monthNavigator,
      yearNavigator: yearNavigator,
      startRangeOfYears: startRangeOfYears,
      minDate: minDate,
      maxDate: maxDate,
      className: className,
      style: style,
      inputClassName: inputClassName,
      inputStyle: inputStyle,
      panelClassName: panelClassName,
      panelStyle: panelStyle,
      mask: mask,
      selectOtherMonths: true,
      tooltip: tooltip,
      tooltipOptions: filterTooltipOptions(tooltipOptions),
      required: required,
      inputId: inputId,
      readOnlyInput: readOnlyInput,
      tabIndex: tabIndex,
      autoZIndex: autoZIndex,
      baseZIndex: baseZIndex,
      onFocus: onFocus,
      onBlur: onBlur,
      onInput: onInput,
      onSelect: onSelect,
      onShow: onShow,
      viewDate: viewDate,
      onHide: onHide,
      onVisibleChange: onVisibleChange,
      onViewDateChange: onViewDateChangeCustom
    };
  };

  var factory = function factory() {
    switch (mode) {
      case "range":
        return renderDateRangePicker();

      case "default":
        return renderDatePicker();

      default:
        throw new Error("Invalid mode");
    }
  };

  var onViewDateChangeCustom = function onViewDateChangeCustom(e) {
    setViewDate(e.value);
  };

  var getYearRange = function getYearRange() {
    var _getPartsOfTime = getPartsOfTime(),
        year = _getPartsOfTime.year;

    var startYear = startCalendarDate ? startCalendarDate.getFullYear() : startRangeOfYears;
    return yearRange || "".concat(startYear, ":").concat(year);
  };

  var renderDateRangePicker = function renderDateRangePicker() {
    var RangePicker = useMemo(function () {
      return withRange(Calendar);
    }, []);
    return /*#__PURE__*/React__default.createElement(RangePicker, _extends$J({}, getDefaultProps(), {
      rangeButtonsBar: rangeButtonsBar,
      headerTemplate: headerTemplate,
      viewDate: viewDate,
      onViewDateChange: onViewDateChangeCustom,
      numberOfMonths: 2,
      startCalendarDate: startCalendarDate
    }));
  };

  var headerTemplate = function headerTemplate() {
    var month = viewDate.getMonth();
    var nextMonth = month === 11 ? 0 : month + 1;
    var monthName = MONTHS[locale().locale][nextMonth];
    var year = viewDate.getFullYear();
    var displayedYear = month === 11 ? year + 1 : year;
    return /*#__PURE__*/React__default.createElement("div", {
      className: "p-datepicker-header-custom"
    }, /*#__PURE__*/React__default.createElement("span", {
      className: "p-datepicker-month-name"
    }, monthName), /*#__PURE__*/React__default.createElement("span", {
      className: "p-datepicker-year-name"
    }, displayedYear));
  };

  var renderDatePicker = function renderDatePicker() {
    return /*#__PURE__*/React__default.createElement(Calendar, _extends$J({}, getDefaultProps(), {
      numberOfMonths: 1
    }));
  };

  return factory();
});

var DateTimePicker = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      name = _ref.name,
      value = _ref.value,
      onChange = _ref.onChange,
      yearRange = _ref.yearRange,
      _ref$showSeconds = _ref.showSeconds,
      showSeconds = _ref$showSeconds === void 0 ? true : _ref$showSeconds,
      _ref$showMillisec = _ref.showMillisec,
      showMillisec = _ref$showMillisec === void 0 ? false : _ref$showMillisec,
      _ref$showUTC = _ref.showUTC,
      showUTC = _ref$showUTC === void 0 ? false : _ref$showUTC,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$stepHour = _ref.stepHour,
      stepHour = _ref$stepHour === void 0 ? 1 : _ref$stepHour,
      _ref$stepSecond = _ref.stepSecond,
      stepSecond = _ref$stepSecond === void 0 ? 1 : _ref$stepSecond,
      _ref$stepMinute = _ref.stepMinute,
      stepMinute = _ref$stepMinute === void 0 ? 1 : _ref$stepMinute,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder,
      _ref$showIcon = _ref.showIcon,
      showIcon = _ref$showIcon === void 0 ? false : _ref$showIcon,
      _ref$viewDate = _ref.viewDate,
      viewDate = _ref$viewDate === void 0 ? null : _ref$viewDate,
      _ref$mask = _ref.mask,
      mask = _ref$mask === void 0 ? null : _ref$mask,
      _ref$startCalendarDat = _ref.startCalendarDate,
      startCalendarDate = _ref$startCalendarDat === void 0 ? START_DATE : _ref$startCalendarDat,
      _ref$minDate = _ref.minDate,
      minDate = _ref$minDate === void 0 ? null : _ref$minDate,
      _ref$maxDate = _ref.maxDate,
      maxDate = _ref$maxDate === void 0 ? null : _ref$maxDate,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      style = _ref.style,
      inputClassName = _ref.inputClassName,
      inputStyle = _ref.inputStyle,
      panelClassName = _ref.panelClassName,
      panelStyle = _ref.panelStyle,
      _ref$dateFormat = _ref.dateFormat,
      dateFormat = _ref$dateFormat === void 0 ? "dd.mm.yy" : _ref$dateFormat,
      _ref$monthNavigator = _ref.monthNavigator,
      monthNavigator = _ref$monthNavigator === void 0 ? true : _ref$monthNavigator,
      _ref$yearNavigator = _ref.yearNavigator,
      yearNavigator = _ref$yearNavigator === void 0 ? true : _ref$yearNavigator,
      _ref$startRangeOfYear = _ref.startRangeOfYears,
      startRangeOfYears = _ref$startRangeOfYear === void 0 ? "2010" : _ref$startRangeOfYear,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      _ref$required = _ref.required,
      required = _ref$required === void 0 ? false : _ref$required,
      inputId = _ref.inputId,
      _ref$readOnlyInput = _ref.readOnlyInput,
      readOnlyInput = _ref$readOnlyInput === void 0 ? false : _ref$readOnlyInput,
      tabIndex = _ref.tabIndex,
      _ref$autoZIndex = _ref.autoZIndex,
      autoZIndex = _ref$autoZIndex === void 0 ? true : _ref$autoZIndex,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 50 : _ref$baseZIndex,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur,
      onInput = _ref.onInput,
      onSelect = _ref.onSelect,
      onShow = _ref.onShow,
      onHide = _ref.onHide,
      onVisibleChange = _ref.onVisibleChange;

  var getYearRange = function getYearRange() {
    var _getPartsOfTime = getPartsOfTime(),
        year = _getPartsOfTime.year;

    var startYear = startCalendarDate ? startCalendarDate.getFullYear() : startRangeOfYears;
    return yearRange || "".concat(startYear, ":").concat(year);
  };

  var renderFooter = function renderFooter() {
    if (!showUTC || !value) return null;
    var day = value.getUTCDate();
    var month = value.getUTCMonth() + 1;
    var year = value.getUTCFullYear();
    var formattedDay = String(day).padStart(2, "0");
    var formattedMonth = String(month).padStart(2, "0");
    var hours = value.getUTCHours();
    var minutes = value.getUTCMinutes();
    var formattedHours = String(hours).padStart(2, "0");
    var formattedMinutes = String(minutes).padStart(2, "0");
    var date = "".concat(formattedDay, ".").concat(formattedMonth, ".").concat(year);
    var baseTime = "".concat(formattedHours, ":").concat(formattedMinutes);
    var formattedUTCDate = "".concat(date, " ").concat(baseTime);

    if (showSeconds) {
      var seconds = value.getUTCSeconds();
      var formattedSeconds = String(seconds).padStart(2, "0");
      formattedUTCDate += ":".concat(formattedSeconds);

      if (showMillisec) {
        var milliseconds = value.getUTCMilliseconds();
        var formattedMilliseconds = String(milliseconds).padStart(3, "0");
        formattedUTCDate += ".".concat(formattedMilliseconds);
      }
    }

    return /*#__PURE__*/React__default.createElement("div", {
      className: "text-center"
    }, /*#__PURE__*/React__default.createElement("span", {
      className: "font-bold"
    }, "UTC: "), /*#__PURE__*/React__default.createElement("span", null, formattedUTCDate));
  };

  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(Calendar, {
    id: id,
    name: name,
    ref: ref,
    value: value,
    onChange: onChange,
    showSeconds: showSeconds,
    showMillisec: showMillisec,
    stepHour: stepHour,
    stepSecond: stepSecond,
    stepMinute: stepMinute,
    placeholder: placeholder,
    disabled: disabled,
    showIcon: showIcon,
    viewDate: viewDate,
    mask: mask,
    minDate: minDate,
    maxDate: maxDate,
    className: className,
    style: style,
    inputClassName: inputClassName,
    inputStyle: inputStyle,
    panelClassName: panelClassName,
    panelStyle: panelStyle,
    dateFormat: dateFormat,
    hourFormat: "24",
    showTime: true,
    monthNavigator: monthNavigator,
    yearNavigator: yearNavigator,
    startRangeOfYears: startRangeOfYears,
    yearRange: getYearRange(),
    footerTemplate: renderFooter,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    required: required,
    inputId: inputId,
    readOnlyInput: readOnlyInput,
    tabIndex: tabIndex,
    autoZIndex: autoZIndex,
    baseZIndex: baseZIndex,
    onFocus: onFocus,
    onBlur: onBlur,
    onInput: onInput,
    onSelect: onSelect,
    onShow: onShow,
    onHide: onHide,
    onVisibleChange: onVisibleChange
  });
});

var Dialog = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      header = _ref.header,
      footer = _ref.footer,
      visible = _ref.visible,
      onHide = _ref.onHide,
      onShow = _ref.onShow,
      contentStyle = _ref.contentStyle,
      contentClassName = _ref.contentClassName,
      style = _ref.style,
      className = _ref.className,
      showHeader = _ref.showHeader,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 100 : _ref$baseZIndex,
      breakpoints = _ref.breakpoints,
      onClick = _ref.onClick,
      onMaskClick = _ref.onMaskClick,
      children = _ref.children;
  return /*#__PURE__*/React__default.createElement(Dialog$1, {
    ref: ref,
    id: id,
    header: header,
    footer: footer,
    visible: visible,
    onHide: onHide,
    onShow: onShow,
    contentStyle: contentStyle,
    contentClassName: contentClassName,
    style: style,
    className: className,
    showHeader: showHeader,
    baseZIndex: baseZIndex,
    breakpoints: breakpoints,
    onClick: onClick,
    onMaskClick: onMaskClick // props below are unavailable for users
    ,
    draggable: false,
    resizable: false,
    modal: true,
    closeOnEscape: true,
    dismissableMask: true,
    rtl: false,
    closable: true,
    maximizable: false,
    blockScroll: true,
    keepInViewport: true,
    maximized: false
  }, children);
});

function _extends$n() {
  _extends$n = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$n.apply(this, arguments);
}

var Divider$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(null);
  var horizontal = props.layout === 'horizontal';
  var vertical = props.layout === 'vertical';
  var otherProps = ObjectUtils.findDiffKeys(props, Divider$1.defaultProps);
  var className = classNames("p-divider p-component p-divider-".concat(props.layout, " p-divider-").concat(props.type), {
    'p-divider-left': horizontal && (!props.align || props.align === 'left'),
    'p-divider-right': horizontal && props.align === 'right',
    'p-divider-center': horizontal && props.align === 'center' || vertical && (!props.align || props.align === 'center'),
    'p-divider-top': vertical && props.align === 'top',
    'p-divider-bottom': vertical && props.align === 'bottom'
  }, props.className);
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  return /*#__PURE__*/React.createElement("div", _extends$n({
    ref: elementRef,
    className: className,
    style: props.style,
    role: "separator"
  }, otherProps), /*#__PURE__*/React.createElement("div", {
    className: "p-divider-content"
  }, props.children));
});
Divider$1.displayName = 'Divider';
Divider$1.defaultProps = {
  __TYPE: 'Divider',
  align: null,
  layout: 'horizontal',
  type: 'solid',
  style: null,
  className: null
};

var Divider = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var align = _ref.align,
      layout = _ref.layout,
      type = _ref.type,
      style = _ref.style,
      className = _ref.className,
      children = _ref.children;
  return /*#__PURE__*/React__default.createElement(Divider$1, {
    ref: ref,
    align: align,
    layout: layout,
    type: type,
    style: style,
    className: className
  }, children);
});

var EMPTY_MESSAGE = {
  ru: "  ",
  en: "Nothing found"
};
var Dropdown = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      name = _ref.name,
      value = _ref.value,
      options = _ref.options,
      optionLabel = _ref.optionLabel,
      optionValue = _ref.optionValue,
      optionDisabled = _ref.optionDisabled,
      optionGroupLabel = _ref.optionGroupLabel,
      optionGroupChildren = _ref.optionGroupChildren,
      style = _ref.style,
      className = _ref.className,
      filter = _ref.filter,
      filterBy = _ref.filterBy,
      placeholder = _ref.placeholder,
      required = _ref.required,
      disabled = _ref.disabled,
      panelClassName = _ref.panelClassName,
      panelStyle = _ref.panelStyle,
      inputId = _ref.inputId,
      showClear = _ref.showClear,
      ariaLabel = _ref.ariaLabel,
      ariaLabelledBy = _ref.ariaLabelledBy,
      autoFocus = _ref.autoFocus,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      onChange = _ref.onChange,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur,
      onShow = _ref.onShow,
      onHide = _ref.onHide;
  var emptyMessage = EMPTY_MESSAGE[locale().locale];
  var dropdownClassName = classNames(className, "w-full");
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(Dropdown$1, {
    ref: ref,
    id: id,
    name: name,
    value: value,
    options: options,
    optionLabel: optionLabel,
    optionValue: optionValue,
    optionDisabled: optionDisabled,
    optionGroupLabel: optionGroupLabel,
    optionGroupChildren: optionGroupChildren,
    style: style,
    className: dropdownClassName,
    filter: filter,
    filterBy: filterBy,
    placeholder: placeholder,
    required: required,
    disabled: disabled,
    panelClassName: panelClassName,
    panelStyle: panelStyle,
    inputId: inputId,
    showClear: showClear,
    ariaLabelledBy: ariaLabelledBy,
    ariaLabel: ariaLabel,
    emptyMessage: emptyMessage,
    emptyFilterMessage: emptyMessage,
    autoFocus: autoFocus,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    showFilterClear: true,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur,
    onShow: onShow,
    onHide: onHide
  });
});

function _extends$m() {
  _extends$m = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$m.apply(this, arguments);
}

function _arrayLikeToArray$i(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$8(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$i(arr);
}

function _iterableToArray$8(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$i(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$i(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$i(o, minLen);
}

function _nonIterableSpread$8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$8(arr) {
  return _arrayWithoutHoles$8(arr) || _iterableToArray$8(arr) || _unsupportedIterableToArray$i(arr) || _nonIterableSpread$8();
}

function _arrayWithHoles$e(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$e(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$e() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$e(arr, i) {
  return _arrayWithHoles$e(arr) || _iterableToArrayLimit$e(arr, i) || _unsupportedIterableToArray$i(arr, i) || _nonIterableRest$e();
}

var UIMessage = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _props$message = props.message,
      severity = _props$message.severity,
      content = _props$message.content,
      summary = _props$message.summary,
      detail = _props$message.detail,
      closable = _props$message.closable,
      life = _props$message.life,
      sticky = _props$message.sticky,
      icon = _props$message.icon;

  var _useTimeout = useTimeout(function () {
    onClose(null);
  }, life || 3000, !sticky),
      _useTimeout2 = _slicedToArray$e(_useTimeout, 1),
      clearTimer = _useTimeout2[0];

  var onClose = function onClose(event) {
    clearTimer();
    props.onClose && props.onClose(props.message);

    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
  };

  var onClick = function onClick() {
    props.onClick && props.onClick(props.message);
  };

  var createCloseIcon = function createCloseIcon() {
    if (closable !== false) {
      var ariaLabel = localeOption$1('close');
      return /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-message-close p-link",
        "aria-label": ariaLabel,
        onClick: onClose
      }, /*#__PURE__*/React.createElement("i", {
        className: "p-message-close-icon pi pi-times",
        "aria-hidden": "true"
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }

    return null;
  };

  var createMessage = function createMessage() {
    if (props.message) {
      var iconValue = icon;

      if (!iconValue) {
        iconValue = classNames('pi', {
          'pi-info-circle': severity === 'info',
          'pi-exclamation-triangle': severity === 'warn',
          'pi-times-circle': severity === 'error',
          'pi-check': severity === 'success'
        });
      }

      var iconContent = IconUtils.getJSXIcon(iconValue, {
        className: 'p-message-icon'
      }, {
        props: props
      });
      return content || /*#__PURE__*/React.createElement(React.Fragment, null, iconContent, /*#__PURE__*/React.createElement("span", {
        className: "p-message-summary"
      }, summary), /*#__PURE__*/React.createElement("span", {
        className: "p-message-detail"
      }, detail));
    }

    return null;
  };

  var className = classNames('p-message p-component p-message-' + severity);
  var closeIcon = createCloseIcon();
  var message = createMessage();
  return /*#__PURE__*/React.createElement("div", {
    ref: ref,
    className: className,
    onClick: onClick
  }, /*#__PURE__*/React.createElement("div", {
    className: "p-message-wrapper"
  }, message, closeIcon));
}));
UIMessage.displayName = 'UIMessage';
var messageIdx$1 = 0;
var Messages = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState([]),
      _React$useState2 = _slicedToArray$e(_React$useState, 2),
      messagesState = _React$useState2[0],
      setMessagesState = _React$useState2[1];

  var elementRef = React.useRef(null);

  var show = function show(value) {
    if (value) {
      var messages = assignIdentifiers(value, true);

      if (Array.isArray(value)) {
        for (var i = 0; i < value.length; i++) {
          value[i].id = messageIdx$1++;
          messages = [].concat(_toConsumableArray$8(messagesState), _toConsumableArray$8(value));
        }
      } else {
        value.id = messageIdx$1++;
        messages = messagesState ? [].concat(_toConsumableArray$8(messagesState), [value]) : [value];
      }

      setMessagesState(messages);
    }
  };

  var assignIdentifiers = function assignIdentifiers(value, copy) {
    var messages;

    if (Array.isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        value[i].id = messageIdx$1++;

        if (copy) {
          messages = [].concat(_toConsumableArray$8(messagesState), _toConsumableArray$8(value));
        } else {
          messages = value;
        }
      }
    } else {
      value.id = messageIdx$1++;

      if (copy) {
        messages = messagesState ? [].concat(_toConsumableArray$8(messagesState), [value]) : [value];
      } else {
        messages = [value];
      }
    }

    return messages;
  };

  var clear = function clear() {
    setMessagesState([]);
  };

  var replace = function replace(value) {
    var replaced = assignIdentifiers(value, false);
    setMessagesState(replaced);
  };

  var onClose = function onClose(message) {
    setMessagesState(messagesState.filter(function (msg) {
      return msg.id !== message.id;
    }));
    props.onRemove && props.onRemove(message);
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      show: show,
      replace: replace,
      clear: clear,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  var otherProps = ObjectUtils.findDiffKeys(props, Messages.defaultProps);
  return /*#__PURE__*/React.createElement("div", _extends$m({
    id: props.id,
    ref: elementRef,
    className: props.className,
    style: props.style
  }, otherProps), /*#__PURE__*/React.createElement(TransitionGroup$1, null, messagesState.map(function (message) {
    var messageRef = /*#__PURE__*/React.createRef();
    return /*#__PURE__*/React.createElement(CSSTransition, {
      nodeRef: messageRef,
      key: message.id,
      classNames: "p-message",
      unmountOnExit: true,
      timeout: {
        enter: 300,
        exit: 300
      },
      options: props.transitionOptions
    }, /*#__PURE__*/React.createElement(UIMessage, {
      ref: messageRef,
      message: message,
      onClick: props.onClick,
      onClose: onClose
    }));
  })));
}));
Messages.displayName = 'Messages';
Messages.defaultProps = {
  __TYPE: 'Messages',
  id: null,
  className: null,
  style: null,
  transitionOptions: null,
  onRemove: null,
  onClick: null
};

function _extends$l() {
  _extends$l = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$l.apply(this, arguments);
}

var ProgressBar$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(null);

  var createLabel = function createLabel() {
    if (props.showValue && props.value != null) {
      var label = props.displayValueTemplate ? props.displayValueTemplate(props.value) : props.value + props.unit;
      return /*#__PURE__*/React.createElement("div", {
        className: "p-progressbar-label"
      }, label);
    }

    return null;
  };

  var createDeterminate = function createDeterminate() {
    var otherProps = ObjectUtils.findDiffKeys(props, ProgressBar$1.defaultProps);
    var className = classNames('p-progressbar p-component p-progressbar-determinate', props.className);
    var label = createLabel();
    return /*#__PURE__*/React.createElement("div", _extends$l({
      role: "progressbar",
      id: props.id,
      ref: elementRef,
      className: className,
      style: props.style,
      "aria-valuemin": "0",
      "aria-valuenow": props.value,
      "aria-valuemax": "100"
    }, otherProps), /*#__PURE__*/React.createElement("div", {
      className: "p-progressbar-value p-progressbar-value-animate",
      style: {
        width: props.value + '%',
        display: 'block',
        backgroundColor: props.color
      }
    }), label);
  };

  var createIndeterminate = function createIndeterminate() {
    var otherProps = ObjectUtils.findDiffKeys(props, ProgressBar$1.defaultProps);
    var className = classNames('p-progressbar p-component p-progressbar-indeterminate', props.className);
    return /*#__PURE__*/React.createElement("div", _extends$l({
      role: "progressbar",
      id: props.id,
      ref: elementRef,
      className: className,
      style: props.style
    }, otherProps), /*#__PURE__*/React.createElement("div", {
      className: "p-progressbar-indeterminate-container"
    }, /*#__PURE__*/React.createElement("div", {
      className: "p-progressbar-value p-progressbar-value-animate",
      style: {
        backgroundColor: props.color
      }
    })));
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  if (props.mode === 'determinate') return createDeterminate();else if (props.mode === 'indeterminate') return createIndeterminate();else throw new Error(props.mode + " is not a valid mode for the ProgressBar. Valid values are 'determinate' and 'indeterminate'");
}));
ProgressBar$1.displayName = 'ProgressBar';
ProgressBar$1.defaultProps = {
  __TYPE: 'ProgressBar',
  id: null,
  value: null,
  showValue: true,
  unit: '%',
  style: null,
  className: null,
  mode: 'determinate',
  displayValueTemplate: null,
  color: null
};

function _extends$k() {
  _extends$k = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$k.apply(this, arguments);
}

function _arrayLikeToArray$1$3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$7(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1$3(arr);
}

function _iterableToArray$7(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$1$3(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$3(o, minLen);
}

function _nonIterableSpread$7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$7(arr) {
  return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$1$3(arr) || _nonIterableSpread$7();
}

function _arrayWithHoles$d(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$d(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$d() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$d(arr, i) {
  return _arrayWithHoles$d(arr) || _iterableToArrayLimit$d(arr, i) || _unsupportedIterableToArray$1$3(arr, i) || _nonIterableRest$d();
}

function _readOnlyError$1(name) {
  throw new TypeError("\"" + name + "\" is read-only");
}

function _createForOfIteratorHelper$6(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$h(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$h(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$h(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$h(o, minLen);
}

function _arrayLikeToArray$h(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var FileUpload$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState([]),
      _React$useState2 = _slicedToArray$d(_React$useState, 2),
      filesState = _React$useState2[0],
      setFilesState = _React$useState2[1];

  var _React$useState3 = React.useState(0),
      _React$useState4 = _slicedToArray$d(_React$useState3, 2),
      progressState = _React$useState4[0],
      setProgressState = _React$useState4[1];

  var _React$useState5 = React.useState(false),
      _React$useState6 = _slicedToArray$d(_React$useState5, 2),
      focusedState = _React$useState6[0],
      setFocusedState = _React$useState6[1];

  var _React$useState7 = React.useState(false),
      _React$useState8 = _slicedToArray$d(_React$useState7, 2),
      uploadingState = _React$useState8[0],
      setUploadingState = _React$useState8[1];

  var fileInputRef = React.useRef(null);
  var messagesRef = React.useRef(null);
  var contentRef = React.useRef(null);
  var duplicateIEEvent = React.useRef(false);
  var uploadedFileCount = React.useRef(0);
  var hasFiles = ObjectUtils.isNotEmpty(filesState);
  var disabled = props.disabled || uploadingState;
  var chooseButtonLabel = props.chooseLabel || props.chooseOptions.label || localeOption$1('choose');
  var uploadButtonLabel = props.uploadLabel || props.uploadOptions.label || localeOption$1('upload');
  var cancelButtonLabel = props.cancelLabel || props.cancelOptions.label || localeOption$1('cancel');
  var chooseDisabled = disabled || props.fileLimit && props.fileLimit <= filesState.length + uploadedFileCount;
  var uploadDisabled = disabled || !hasFiles;
  var cancelDisabled = disabled || !hasFiles;

  var isImage = function isImage(file) {
    return /^image\//.test(file.type);
  };

  var remove = function remove(event, index) {
    clearInput();

    var currentFiles = _toConsumableArray$7(filesState);

    var removedFile = filesState[index];
    currentFiles.splice(index, 1);
    setFilesState(currentFiles);

    if (props.onRemove) {
      props.onRemove({
        originalEvent: event,
        file: removedFile
      });
    }
  };

  var clearInput = function clearInput() {
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  var clearIEInput = function clearIEInput() {
    if (fileInputRef.current) {
      duplicateIEEvent.current = true; //IE11 fix to prevent onFileChange trigger again

      fileInputRef.current.value = '';
    }
  };

  var formatSize = function formatSize(bytes) {
    if (bytes === 0) {
      return '0 B';
    }

    var k = 1000,
        dm = 3,
        sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
        i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  };

  var onFileSelect = function onFileSelect(event) {
    // give caller a chance to stop the selection
    if (props.onBeforeSelect && props.onBeforeSelect({
      originalEvent: event,
      files: filesState
    }) === false) {
      return;
    }

    if (event.type !== 'drop' && isIE11() && duplicateIEEvent.current) {
      duplicateIEEvent.current = false;
      return;
    }

    var currentFiles = [];

    if (props.multiple) {
      currentFiles = filesState ? _toConsumableArray$7(filesState) : [];
    }

    var selectedFiles = event.dataTransfer ? event.dataTransfer.files : event.target.files;

    for (var i = 0; i < selectedFiles.length; i++) {
      var file = selectedFiles[i];

      if (!isFileSelected(file) && validate(file)) {
        if (isImage(file)) {
          file.objectURL = window.URL.createObjectURL(file);
        }

        currentFiles.push(file);
      }
    }

    setFilesState(currentFiles);

    if (ObjectUtils.isNotEmpty(currentFiles) && props.auto) {
      upload(currentFiles);
    }

    if (props.onSelect) {
      props.onSelect({
        originalEvent: event,
        files: selectedFiles
      });
    }

    if (event.type !== 'drop' && isIE11()) {
      clearIEInput();
    } else {
      clearInput();
    }

    if (props.mode === 'basic' && currentFiles.length > 0) {
      fileInputRef.current.style.display = 'none';
    }
  };

  var isFileSelected = function isFileSelected(file) {
    return filesState.some(function (f) {
      return f.name + f.type + f.size === file.name + file.type + file.size;
    });
  };

  var isIE11 = function isIE11() {
    return !!window['MSInputMethodContext'] && !!document['documentMode'];
  };

  var validate = function validate(file) {
    if (props.maxFileSize && file.size > props.maxFileSize) {
      var message = {
        severity: 'error',
        summary: props.invalidFileSizeMessageSummary.replace('{0}', file.name),
        detail: props.invalidFileSizeMessageDetail.replace('{0}', formatSize(props.maxFileSize)),
        sticky: true
      };

      if (props.mode === 'advanced') {
        messagesRef.current.show(message);
      }

      props.onValidationFail && props.onValidationFail(file);
      return false;
    }

    return true;
  };

  var upload = function upload(files) {
    files = files || filesState;

    if (files && files.nativeEvent) {
      files = filesState;
    }

    if (props.customUpload) {
      if (props.fileLimit) {
        uploadedFileCount + files.length, _readOnlyError$1("uploadedFileCount");
      }

      if (props.uploadHandler) {
        props.uploadHandler({
          files: files,
          options: {
            clear: clear,
            props: props
          }
        });
      }
    } else {
      setUploadingState(true);
      var xhr = new XMLHttpRequest();
      var formData = new FormData();

      if (props.onBeforeUpload) {
        props.onBeforeUpload({
          xhr: xhr,
          formData: formData
        });
      }

      var _iterator = _createForOfIteratorHelper$6(files),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var file = _step.value;
          formData.append(props.name, file, file.name);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      xhr.upload.addEventListener('progress', function (event) {
        if (event.lengthComputable) {
          var progress = Math.round(event.loaded * 100 / event.total);
          setProgressState(progress);

          if (props.onProgress) {
            props.onProgress({
              originalEvent: event,
              progress: progress
            });
          }
        }
      });

      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          setProgressState(0);
          setUploadingState(false);

          if (xhr.status >= 200 && xhr.status < 300) {
            if (props.fileLimit) {
              uploadedFileCount + files.length, _readOnlyError$1("uploadedFileCount");
            }

            if (props.onUpload) {
              props.onUpload({
                xhr: xhr,
                files: files
              });
            }
          } else {
            if (props.onError) {
              props.onError({
                xhr: xhr,
                files: files
              });
            }
          }

          clear();
        }
      };

      xhr.open('POST', props.url, true);

      if (props.onBeforeSend) {
        props.onBeforeSend({
          xhr: xhr,
          formData: formData
        });
      }

      xhr.withCredentials = props.withCredentials;
      xhr.send(formData);
    }
  };

  var clear = function clear() {
    setFilesState([]);
    setUploadingState(false);
    props.onClear && props.onClear();
    clearInput();
  };

  var choose = function choose() {
    fileInputRef.current.click();
  };

  var onFocus = function onFocus() {
    setFocusedState(true);
  };

  var onBlur = function onBlur() {
    setFocusedState(false);
  };

  var onKeyDown = function onKeyDown(event) {
    if (event.which === 13) {
      // enter
      choose();
    }
  };

  var onDragEnter = function onDragEnter(event) {
    if (!disabled) {
      event.dataTransfer.dropEffect = 'copy';
      event.stopPropagation();
      event.preventDefault();
    }
  };

  var onDragOver = function onDragOver(event) {
    if (!disabled) {
      event.dataTransfer.dropEffect = 'copy';
      DomHandler.addClass(contentRef.current, 'p-fileupload-highlight');
      event.stopPropagation();
      event.preventDefault();
    }
  };

  var onDragLeave = function onDragLeave(event) {
    if (!disabled) {
      event.dataTransfer.dropEffect = 'copy';
      DomHandler.removeClass(contentRef.current, 'p-fileupload-highlight');
    }
  };

  var onDrop = function onDrop(event) {
    if (props.disabled) {
      return;
    }

    DomHandler.removeClass(contentRef.current, 'p-fileupload-highlight');
    event.stopPropagation();
    event.preventDefault(); // give caller a chance to stop the drop

    if (props.onBeforeDrop && props.onBeforeDrop(event) === false) {
      return;
    }

    var files = event.dataTransfer ? event.dataTransfer.files : event.target.files;
    var allowDrop = props.multiple || ObjectUtils.isEmpty(filesState) && files && files.length === 1;
    allowDrop && onFileSelect(event);
  };

  var onSimpleUploaderClick = function onSimpleUploaderClick() {
    !disabled && hasFiles ? upload() : fileInputRef.current.click();
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      upload: upload,
      clear: clear,
      formatSize: formatSize,
      onFileSelect: onFileSelect,
      getInput: function getInput() {
        return fileInputRef.current;
      },
      getContent: function getContent() {
        return contentRef.current;
      },
      getFiles: function getFiles() {
        return filesState;
      }
    };
  });

  var createChooseButton = function createChooseButton() {
    var _props$chooseOptions = props.chooseOptions,
        className = _props$chooseOptions.className,
        style = _props$chooseOptions.style,
        _icon = _props$chooseOptions.icon,
        iconOnly = _props$chooseOptions.iconOnly;
    var chooseClassName = classNames('p-button p-fileupload-choose p-component', {
      'p-disabled': disabled,
      'p-focus': focusedState,
      'p-button-icon-only': iconOnly
    }, className);
    var labelClassName = 'p-button-label p-clickable';
    var label = iconOnly ? /*#__PURE__*/React.createElement("span", {
      className: labelClassName,
      dangerouslySetInnerHTML: {
        __html: '&nbsp;'
      }
    }) : /*#__PURE__*/React.createElement("span", {
      className: labelClassName
    }, chooseButtonLabel);
    var input = /*#__PURE__*/React.createElement("input", {
      ref: fileInputRef,
      type: "file",
      onChange: onFileSelect,
      multiple: props.multiple,
      accept: props.accept,
      disabled: chooseDisabled
    });
    var icon = IconUtils.getJSXIcon(_icon || 'pi pi-fw pi-plus', {
      className: 'p-button-icon p-button-icon-left p-clickable'
    }, {
      props: props
    });
    return /*#__PURE__*/React.createElement("span", {
      className: chooseClassName,
      style: style,
      onClick: choose,
      onKeyDown: onKeyDown,
      onFocus: onFocus,
      onBlur: onBlur,
      tabIndex: 0
    }, input, icon, label, /*#__PURE__*/React.createElement(Ripple, null));
  };

  var createFile = function createFile(file, index) {
    var key = file.name + file.type + file.size;
    var preview = isImage(file) ? /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("img", {
      alt: file.name,
      role: "presentation",
      src: file.objectURL,
      width: props.previewWidth
    })) : null;
    var fileName = /*#__PURE__*/React.createElement("div", {
      className: "p-fileupload-filename"
    }, file.name);
    var size = /*#__PURE__*/React.createElement("div", null, formatSize(file.size));
    var removeButton = /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Button$1, {
      type: "button",
      icon: "pi pi-times",
      onClick: function onClick(e) {
        return remove(e, index);
      },
      disabled: disabled
    }));
    var content = /*#__PURE__*/React.createElement(React.Fragment, null, preview, fileName, size, removeButton);

    if (props.itemTemplate) {
      var defaultContentOptions = {
        onRemove: function onRemove(event) {
          return remove(event, index);
        },
        previewElement: preview,
        fileNameElement: fileName,
        sizeElement: size,
        removeElement: removeButton,
        formatSize: formatSize(file.size),
        element: content,
        props: props
      };
      content = ObjectUtils.getJSXElement(props.itemTemplate, file, defaultContentOptions);
    }

    return /*#__PURE__*/React.createElement("div", {
      className: "p-fileupload-row",
      key: key
    }, content);
  };

  var createFiles = function createFiles() {
    var content = filesState.map(createFile);
    return /*#__PURE__*/React.createElement("div", {
      className: "p-fileupload-files"
    }, content);
  };

  var createEmptyContent = function createEmptyContent() {
    return props.emptyTemplate && !hasFiles ? ObjectUtils.getJSXElement(props.emptyTemplate, props) : null;
  };

  var createProgressBarContent = function createProgressBarContent() {
    if (props.progressBarTemplate) {
      return ObjectUtils.getJSXElement(props.progressBarTemplate, props);
    }

    return /*#__PURE__*/React.createElement(ProgressBar$1, {
      value: progressState,
      showValue: false
    });
  };

  var createAdvanced = function createAdvanced() {
    var otherProps = ObjectUtils.findDiffKeys(props, FileUpload$1.defaultProps);
    var className = classNames('p-fileupload p-fileupload-advanced p-component', props.className);
    var headerClassName = classNames('p-fileupload-buttonbar', props.headerClassName);
    var contentClassName = classNames('p-fileupload-content', props.contentClassName);
    var chooseButton = createChooseButton();
    var emptyContent = createEmptyContent();
    var uploadButton, cancelButton, filesList, progressBar;

    if (!props.auto) {
      var uploadOptions = props.uploadOptions;
      var cancelOptions = props.cancelOptions;
      var uploadLabel = !uploadOptions.iconOnly ? uploadButtonLabel : '';
      var cancelLabel = !cancelOptions.iconOnly ? cancelButtonLabel : '';
      uploadButton = /*#__PURE__*/React.createElement(Button$1, {
        type: "button",
        label: uploadLabel,
        icon: uploadOptions.icon || 'pi pi-upload',
        onClick: upload,
        disabled: uploadDisabled,
        style: uploadOptions.style,
        className: uploadOptions.className
      });
      cancelButton = /*#__PURE__*/React.createElement(Button$1, {
        type: "button",
        label: cancelLabel,
        icon: cancelOptions.icon || 'pi pi-times',
        onClick: clear,
        disabled: cancelDisabled,
        style: cancelOptions.style,
        className: cancelOptions.className
      });
    }

    if (hasFiles) {
      filesList = createFiles();
      progressBar = createProgressBarContent();
    }

    var header = /*#__PURE__*/React.createElement("div", {
      className: headerClassName,
      style: props.headerStyle
    }, chooseButton, uploadButton, cancelButton);

    if (props.headerTemplate) {
      var defaultContentOptions = {
        className: headerClassName,
        chooseButton: chooseButton,
        uploadButton: uploadButton,
        cancelButton: cancelButton,
        element: header,
        props: props
      };
      header = ObjectUtils.getJSXElement(props.headerTemplate, defaultContentOptions);
    }

    return /*#__PURE__*/React.createElement("div", _extends$k({
      id: props.id,
      className: className,
      style: props.style
    }, otherProps), header, /*#__PURE__*/React.createElement("div", {
      ref: contentRef,
      className: contentClassName,
      style: props.contentStyle,
      onDragEnter: onDragEnter,
      onDragOver: onDragOver,
      onDragLeave: onDragLeave,
      onDrop: onDrop
    }, progressBar, /*#__PURE__*/React.createElement(Messages, {
      ref: messagesRef
    }), filesList, emptyContent));
  };

  var createBasic = function createBasic() {
    var chooseOptions = props.chooseOptions;
    var otherProps = ObjectUtils.findDiffKeys(props, FileUpload$1.defaultProps);
    var className = classNames('p-fileupload p-fileupload-basic p-component', props.className);
    var buttonClassName = classNames('p-button p-component p-fileupload-choose', {
      'p-fileupload-choose-selected': hasFiles,
      'p-disabled': disabled,
      'p-focus': focusedState
    }, chooseOptions.className);
    var chooseIcon = chooseOptions.icon || classNames({
      'pi pi-plus': !chooseOptions.icon && (!hasFiles || props.auto),
      'pi pi-upload': !chooseOptions.icon && hasFiles && !props.auto
    });
    var labelClassName = 'p-button-label p-clickable';
    var chooseLabel = chooseOptions.iconOnly ? /*#__PURE__*/React.createElement("span", {
      className: labelClassName,
      dangerouslySetInnerHTML: {
        __html: '&nbsp;'
      }
    }) : /*#__PURE__*/React.createElement("span", {
      className: labelClassName
    }, chooseButtonLabel);
    var label = props.auto ? chooseLabel : /*#__PURE__*/React.createElement("span", {
      className: labelClassName
    }, hasFiles ? filesState[0].name : chooseLabel);
    var icon = IconUtils.getJSXIcon(chooseIcon, {
      className: 'p-button-icon p-button-icon-left'
    }, {
      props: props,
      hasFiles: hasFiles
    });
    var input = !hasFiles && /*#__PURE__*/React.createElement("input", {
      ref: fileInputRef,
      type: "file",
      accept: props.accept,
      multiple: props.multiple,
      disabled: disabled,
      onChange: onFileSelect
    });
    return /*#__PURE__*/React.createElement("div", _extends$k({
      className: className,
      style: props.style
    }, otherProps), /*#__PURE__*/React.createElement(Messages, {
      ref: messagesRef
    }), /*#__PURE__*/React.createElement("span", {
      className: buttonClassName,
      style: chooseOptions.style,
      onMouseUp: onSimpleUploaderClick,
      onKeyDown: onKeyDown,
      onFocus: onFocus,
      onBlur: onBlur,
      tabIndex: 0
    }, icon, label, input, /*#__PURE__*/React.createElement(Ripple, null)));
  };

  if (props.mode === 'advanced') return createAdvanced();else if (props.mode === 'basic') return createBasic();
}));
FileUpload$1.displayName = 'FileUpload';
FileUpload$1.defaultProps = {
  __TYPE: 'FileUpload',
  id: null,
  name: null,
  url: null,
  mode: 'advanced',
  multiple: false,
  accept: null,
  disabled: false,
  auto: false,
  maxFileSize: null,
  invalidFileSizeMessageSummary: '{0}: Invalid file size, ',
  invalidFileSizeMessageDetail: 'maximum upload size is {0}.',
  style: null,
  className: null,
  widthCredentials: false,
  previewWidth: 50,
  chooseLabel: null,
  uploadLabel: null,
  cancelLabel: null,
  chooseOptions: {
    label: null,
    icon: null,
    iconOnly: false,
    className: null,
    style: null
  },
  uploadOptions: {
    label: null,
    icon: null,
    iconOnly: false,
    className: null,
    style: null
  },
  cancelOptions: {
    label: null,
    icon: null,
    iconOnly: false,
    className: null,
    style: null
  },
  customUpload: false,
  headerClassName: null,
  headerStyle: null,
  contentClassName: null,
  contentStyle: null,
  headerTemplate: null,
  itemTemplate: null,
  emptyTemplate: null,
  progressBarTemplate: null,
  onBeforeUpload: null,
  onBeforeSend: null,
  onBeforeDrop: null,
  onBeforeSelect: null,
  onUpload: null,
  onError: null,
  onClear: null,
  onSelect: null,
  onProgress: null,
  onValidationFail: null,
  uploadHandler: null,
  onRemove: null
};

var getValidationMessage = function getValidationMessage(file, maxFileSize) {
  return {
    /* eslint-disable max-len */
    en: "".concat(file.name, ": Invalid file size (").concat(file.size, " bytes), maximum upload size is ").concat(maxFileSize, " bytes."),
    ru: "".concat(file.name, ": \u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u044B\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u0444\u0430\u0439\u043B\u0430 (").concat(file.size, " \u0431\u0430\u0439\u0442), \u043C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u044B\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u2014 ").concat(maxFileSize, " \u0431\u0430\u0439\u0442.")
    /* eslint-enable max-len */

  };
};

var FileUpload = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      name = _ref.name,
      url = _ref.url,
      _ref$multiple = _ref.multiple,
      multiple = _ref$multiple === void 0 ? false : _ref$multiple,
      accept = _ref.accept,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$auto = _ref.auto,
      auto = _ref$auto === void 0 ? false : _ref$auto,
      maxFileSize = _ref.maxFileSize,
      style = _ref.style,
      className = _ref.className,
      _ref$withCredentials = _ref.withCredentials,
      withCredentials = _ref$withCredentials === void 0 ? false : _ref$withCredentials,
      chooseLabel = _ref.chooseLabel,
      chooseOptions = _ref.chooseOptions,
      _ref$customUpload = _ref.customUpload,
      customUpload = _ref$customUpload === void 0 ? false : _ref$customUpload,
      onBeforeUpload = _ref.onBeforeUpload,
      onBeforeSend = _ref.onBeforeSend,
      onUpload = _ref.onUpload,
      onError = _ref.onError,
      onClear = _ref.onClear,
      onSelect = _ref.onSelect,
      onProgress = _ref.onProgress,
      handleFailedValidation = _ref.onValidationFail,
      uploadHandler = _ref.uploadHandler,
      onRemove = _ref.onRemove;

  // adding validation message because Prime don't do it in basic mode
  var onValidationFail = function onValidationFail(file) {
    var message = null;

    if (maxFileSize && file.size > Number(maxFileSize)) {
      message = getValidationMessage(file, maxFileSize)[locale().locale];
    }

    handleFailedValidation && handleFailedValidation({
      file: file,
      message: message
    });
  };

  return /*#__PURE__*/React__default.createElement(FileUpload$1, {
    ref: ref,
    mode: "basic",
    id: id,
    name: name,
    url: url,
    multiple: multiple,
    accept: accept,
    disabled: disabled,
    auto: auto,
    maxFileSize: maxFileSize,
    style: style,
    className: className,
    withCredentials: withCredentials,
    chooseLabel: chooseLabel,
    chooseOptions: chooseOptions,
    customUpload: customUpload,
    onBeforeUpload: onBeforeUpload,
    onBeforeSend: onBeforeSend,
    onUpload: onUpload,
    onError: onError,
    onClear: onClear,
    onSelect: onSelect,
    onProgress: onProgress,
    onValidationFail: onValidationFail,
    uploadHandler: uploadHandler,
    onRemove: onRemove
  });
});

function _extends$j() {
  _extends$j = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$j.apply(this, arguments);
}

function _arrayWithHoles$c(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$c(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$g(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$g(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$g(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(o, minLen);
}

function _nonIterableRest$c() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$c(arr, i) {
  return _arrayWithHoles$c(arr) || _iterableToArrayLimit$c(arr, i) || _unsupportedIterableToArray$g(arr, i) || _nonIterableRest$c();
}

var Image$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$c(_React$useState, 2),
      maskVisibleState = _React$useState2[0],
      setMaskVisibleState = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _React$useState4 = _slicedToArray$c(_React$useState3, 2),
      previewVisibleState = _React$useState4[0],
      setPreviewVisibleState = _React$useState4[1];

  var _React$useState5 = React.useState(0),
      _React$useState6 = _slicedToArray$c(_React$useState5, 2),
      rotateState = _React$useState6[0],
      setRotateState = _React$useState6[1];

  var _React$useState7 = React.useState(1),
      _React$useState8 = _slicedToArray$c(_React$useState7, 2),
      scaleState = _React$useState8[0],
      setScaleState = _React$useState8[1];

  var elementRef = React.useRef(null);
  var imageRef = React.useRef(null);
  var maskRef = React.useRef(null);
  var previewRef = React.useRef(null);
  var previewClick = React.useRef(false);

  var onImageClick = function onImageClick() {
    if (props.preview) {
      setMaskVisibleState(true);
      setTimeout(function () {
        setPreviewVisibleState(true);
      }, 25);
    }
  };

  var onPreviewImageClick = function onPreviewImageClick() {
    previewClick.current = true;
  };

  var onMaskClick = function onMaskClick() {
    if (!previewClick.current) {
      setPreviewVisibleState(false);
      setRotateState(0);
      setScaleState(1);
    }

    previewClick.current = false;
  };

  var onDownload = function onDownload() {
    var name = props.alt,
        src = props.src;
    DomHandler.saveAs({
      name: name,
      src: src
    });
    previewClick.current = true;
  };

  var rotateRight = function rotateRight() {
    setRotateState(function (prevRotate) {
      return prevRotate + 90;
    });
    previewClick.current = true;
  };

  var rotateLeft = function rotateLeft() {
    setRotateState(function (prevRotate) {
      return prevRotate - 90;
    });
    previewClick.current = true;
  };

  var zoomIn = function zoomIn() {
    setScaleState(function (prevScale) {
      return prevScale + 0.1;
    });
    previewClick.current = true;
  };

  var zoomOut = function zoomOut() {
    setScaleState(function (prevScale) {
      return prevScale - 0.1;
    });
    previewClick.current = true;
  };

  var onEntering = function onEntering() {
    ZIndexUtils.set('modal', maskRef.current, PrimeReact$1.autoZIndex, PrimeReact$1.zIndex['modal']);
  };

  var onEntered = function onEntered() {
    props.onShow && props.onShow();
  };

  var onExit = function onExit() {
    DomHandler.addClass(maskRef.current, 'p-component-overlay-leave');
  };

  var onExiting = function onExiting() {
    props.onHide && props.onHide();
  };

  var onExited = function onExited() {
    ZIndexUtils.clear(maskRef.current);
    setMaskVisibleState(false);
  };

  useUnmountEffect(function () {
    maskRef.current && ZIndexUtils.clear(maskRef.current);
  });

  var createPreview = function createPreview() {
    if (props.preview) {
      return /*#__PURE__*/React.createElement("div", {
        className: "p-image-preview-indicator",
        onClick: onImageClick
      }, content);
    }

    return null;
  };

  var createElement = function createElement() {
    var downloadable = props.downloadable;
    var imagePreviewStyle = {
      transform: 'rotate(' + rotateState + 'deg) scale(' + scaleState + ')'
    };
    var zoomDisabled = scaleState <= 0.5 || scaleState >= 1.5; // const rotateClassName = 'p-image-preview-rotate-' + rotateScale;

    return /*#__PURE__*/React.createElement("div", {
      ref: maskRef,
      className: "p-image-mask p-component-overlay p-component-overlay-enter",
      onClick: onMaskClick
    }, /*#__PURE__*/React.createElement("div", {
      className: "p-image-toolbar"
    }, downloadable && /*#__PURE__*/React.createElement("button", {
      className: "p-image-action p-link",
      onClick: onDownload,
      type: "button"
    }, /*#__PURE__*/React.createElement("i", {
      className: "pi pi-download"
    })), /*#__PURE__*/React.createElement("button", {
      className: "p-image-action p-link",
      onClick: rotateRight,
      type: "button"
    }, /*#__PURE__*/React.createElement("i", {
      className: "pi pi-refresh"
    })), /*#__PURE__*/React.createElement("button", {
      className: "p-image-action p-link",
      onClick: rotateLeft,
      type: "button"
    }, /*#__PURE__*/React.createElement("i", {
      className: "pi pi-undo"
    })), /*#__PURE__*/React.createElement("button", {
      className: "p-image-action p-link",
      onClick: zoomOut,
      type: "button",
      disabled: zoomDisabled
    }, /*#__PURE__*/React.createElement("i", {
      className: "pi pi-search-minus"
    })), /*#__PURE__*/React.createElement("button", {
      className: "p-image-action p-link",
      onClick: zoomIn,
      type: "button",
      disabled: zoomDisabled
    }, /*#__PURE__*/React.createElement("i", {
      className: "pi pi-search-plus"
    })), /*#__PURE__*/React.createElement("button", {
      className: "p-image-action p-link",
      type: "button",
      "aria-label": localeOption$1('close')
    }, /*#__PURE__*/React.createElement("i", {
      className: "pi pi-times"
    }))), /*#__PURE__*/React.createElement(CSSTransition, {
      nodeRef: previewRef,
      classNames: "p-image-preview",
      "in": previewVisibleState,
      timeout: {
        enter: 150,
        exit: 150
      },
      unmountOnExit: true,
      onEntering: onEntering,
      onEntered: onEntered,
      onExit: onExit,
      onExiting: onExiting,
      onExited: onExited
    }, /*#__PURE__*/React.createElement("div", {
      ref: previewRef
    }, /*#__PURE__*/React.createElement("img", {
      src: props.src,
      className: "p-image-preview",
      style: imagePreviewStyle,
      onClick: onPreviewImageClick,
      alt: props.alt
    }))));
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      },
      getImage: function getImage() {
        return imageRef.current;
      }
    };
  });
  var src = props.src,
      alt = props.alt,
      width = props.width,
      height = props.height;
  var otherProps = ObjectUtils.findDiffKeys(props, Image$1.defaultProps);
  var containerClassName = classNames('p-image p-component', props.className, {
    'p-image-preview-container': props.preview
  });
  var element = createElement();
  var content = props.template ? ObjectUtils.getJSXElement(props.template, props) : /*#__PURE__*/React.createElement("i", {
    className: "p-image-preview-icon pi pi-eye"
  });
  var preview = createPreview();
  var image = /*#__PURE__*/React.createElement("img", {
    ref: imageRef,
    src: src,
    className: props.imageClassName,
    width: width,
    height: height,
    style: props.imageStyle,
    alt: alt,
    onError: props.onError
  });
  return /*#__PURE__*/React.createElement("span", _extends$j({
    ref: elementRef,
    className: containerClassName
  }, otherProps), image, preview, maskVisibleState && /*#__PURE__*/React.createElement(Portal, {
    element: element,
    appendTo: document.body
  }));
}));
Image$1.displayName = 'Image';
Image$1.defaultProps = {
  __TYPE: 'Image',
  preview: false,
  className: null,
  downloadable: false,
  imageStyle: null,
  imageClassName: null,
  template: null,
  src: null,
  alt: null,
  width: null,
  height: null,
  onError: null
};

var Image = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _ref$preview = _ref.preview,
      preview = _ref$preview === void 0 ? false : _ref$preview,
      src = _ref.src,
      alt = _ref.alt,
      width = _ref.width,
      height = _ref.height,
      _ref$downloadable = _ref.downloadable,
      downloadable = _ref$downloadable === void 0 ? false : _ref$downloadable,
      containerStyle = _ref.containerStyle,
      containerClassName = _ref.containerClassName,
      imageStyle = _ref.imageStyle,
      imageClassName = _ref.imageClassName,
      onShow = _ref.onShow,
      onHide = _ref.onHide;
  return /*#__PURE__*/React__default.createElement(Image$1, {
    ref: ref,
    preview: preview,
    downloadable: downloadable,
    src: src,
    alt: alt,
    width: width,
    height: height,
    style: containerStyle,
    className: containerClassName,
    imageStyle: imageStyle,
    imageClassName: imageClassName,
    onShow: onShow,
    onHide: onHide
  });
});

var InputNumber = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var value = _ref.value,
      inputRef = _ref.inputRef,
      _ref$format = _ref.format,
      format = _ref$format === void 0 ? true : _ref$format,
      _ref$showButtons = _ref.showButtons,
      showButtons = _ref$showButtons === void 0 ? false : _ref$showButtons,
      locale = _ref.locale,
      suffix = _ref.suffix,
      prefix = _ref.prefix,
      _ref$useGrouping = _ref.useGrouping,
      useGrouping = _ref$useGrouping === void 0 ? true : _ref$useGrouping,
      minFractionDigits = _ref.minFractionDigits,
      maxFractionDigits = _ref.maxFractionDigits,
      id = _ref.id,
      name = _ref.name,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? "text" : _ref$type,
      _ref$allowEmpty = _ref.allowEmpty,
      allowEmpty = _ref$allowEmpty === void 0 ? true : _ref$allowEmpty,
      _ref$step = _ref.step,
      step = _ref$step === void 0 ? 1 : _ref$step,
      min = _ref.min,
      max = _ref.max,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$required = _ref.required,
      required = _ref$required === void 0 ? false : _ref$required,
      tabIndex = _ref.tabIndex,
      pattern = _ref.pattern,
      inputMode = _ref.inputMode,
      placeholder = _ref.placeholder,
      _ref$readOnly = _ref.readOnly,
      readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly,
      size = _ref.size,
      style = _ref.style,
      className = _ref.className,
      inputId = _ref.inputId,
      _ref$autoFocus = _ref.autoFocus,
      autoFocus = _ref$autoFocus === void 0 ? false : _ref$autoFocus,
      inputStyle = _ref.inputStyle,
      inputClassName = _ref.inputClassName,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onValueChange = _ref.onValueChange,
      onChange = _ref.onChange,
      onBlur = _ref.onBlur,
      onFocus = _ref.onFocus,
      onKeyDown = _ref.onKeyDown;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(InputNumber$1, {
    ref: ref,
    value: value,
    inputRef: inputRef,
    format: format,
    showButtons: showButtons,
    locale: locale,
    suffix: suffix,
    prefix: prefix,
    useGrouping: useGrouping,
    minFractionDigits: minFractionDigits,
    maxFractionDigits: maxFractionDigits,
    id: id,
    name: name,
    type: type,
    allowEmpty: allowEmpty,
    step: step,
    min: min,
    max: max,
    disabled: disabled,
    required: required,
    tabIndex: tabIndex,
    pattern: pattern,
    inputMode: inputMode,
    placeholder: placeholder,
    readOnly: readOnly,
    size: size,
    style: style,
    className: className,
    inputId: inputId,
    autoFocus: autoFocus,
    inputStyle: inputStyle,
    inputClassName: inputClassName,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onValueChange: onValueChange,
    onChange: onChange,
    onBlur: onBlur,
    onFocus: onFocus,
    onKeyDown: onKeyDown
  });
});

function _extends$i() {
  _extends$i = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$i.apply(this, arguments);
}

var InputMask$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(ref);
  var firstNonMaskPos = React.useRef(null);
  var lastRequiredNonMaskPos = React.useRef(0);
  var tests = React.useRef([]);
  var buffer = React.useRef([]);
  var len = React.useRef(0);
  var oldVal = React.useRef(null);
  var focus = React.useRef(false);
  var focusText = React.useRef(null);
  var isValueChecked = React.useRef(null);
  var partialPosition = React.useRef(null);
  var defaultBuffer = React.useRef(null);
  var caretTimeoutId = React.useRef(null);
  var androidChrome = React.useRef(false);

  var caret = function caret(first, last) {
    var range, begin, end;
    var inputEl = elementRef.current;

    if (!inputEl || !inputEl.offsetParent || inputEl !== document.activeElement) {
      return;
    }

    if (typeof first === 'number') {
      begin = first;
      end = typeof last === 'number' ? last : begin;

      if (inputEl.setSelectionRange) {
        inputEl.setSelectionRange(begin, end);
      } else if (inputEl['createTextRange']) {
        range = inputEl['createTextRange']();
        range.collapse(true);
        range.moveEnd('character', end);
        range.moveStart('character', begin);
        range.select();
      }
    } else {
      if (inputEl.setSelectionRange) {
        begin = inputEl.selectionStart;
        end = inputEl.selectionEnd;
      } else if (document['selection'] && document['selection'].createRange) {
        range = document['selection'].createRange();
        begin = 0 - range.duplicate().moveStart('character', -100000);
        end = begin + range.text.length;
      }

      return {
        begin: begin,
        end: end
      };
    }
  };

  var isCompleted = function isCompleted() {
    for (var i = firstNonMaskPos.current; i <= lastRequiredNonMaskPos.current; i++) {
      if (tests.current[i] && buffer.current[i] === getPlaceholder(i)) {
        return false;
      }
    }

    return true;
  };

  var getPlaceholder = React.useCallback(function (i) {
    if (i < props.slotChar.length) {
      return props.slotChar.charAt(i);
    }

    return props.slotChar.charAt(0);
  }, [props.slotChar]);

  var getValue = function getValue() {
    return props.unmask ? getUnmaskedValue() : elementRef.current && elementRef.current.value;
  };

  var seekNext = function seekNext(pos) {
    while (++pos < len.current && !tests.current[pos]) {}

    return pos;
  };

  var seekPrev = function seekPrev(pos) {
    while (--pos >= 0 && !tests.current[pos]) {}

    return pos;
  };

  var shiftL = function shiftL(begin, end) {
    var i, j;

    if (begin < 0) {
      return;
    }

    for (i = begin, j = seekNext(end); i < len.current; i++) {
      if (tests.current[i]) {
        if (j < len.current && tests.current[i].test(buffer.current[j])) {
          buffer.current[i] = buffer.current[j];
          buffer.current[j] = getPlaceholder(j);
        } else {
          break;
        }

        j = seekNext(j);
      }
    }

    writeBuffer();
    caret(Math.max(firstNonMaskPos.current, begin));
  };

  var shiftR = function shiftR(pos) {
    var i, c, j, t;

    for (i = pos, c = getPlaceholder(pos); i < len.current; i++) {
      if (tests.current[i]) {
        j = seekNext(i);
        t = buffer.current[i];
        buffer.current[i] = c;

        if (j < len.current && tests.current[j].test(t)) {
          c = t;
        } else {
          break;
        }
      }
    }
  };

  var handleAndroidInput = function handleAndroidInput(e) {
    var curVal = elementRef.current.value;
    var pos = caret();

    if (oldVal.current.length && oldVal.current.length > curVal.length) {
      // a deletion or backspace happened
      checkVal(true);

      while (pos.begin > 0 && !tests.current[pos.begin - 1]) {
        pos.begin--;
      }

      if (pos.begin === 0) {
        while (pos.begin < firstNonMaskPos.current && !tests.current[pos.begin]) {
          pos.begin++;
        }
      }

      caret(pos.begin, pos.begin);
    } else {
      checkVal(true);

      while (pos.begin < len.current && !tests.current[pos.begin]) {
        pos.begin++;
      }

      caret(pos.begin, pos.begin);
    }

    if (props.onComplete && isCompleted()) {
      props.onComplete({
        originalEvent: e,
        value: getValue()
      });
    }

    updateModel(e);
  };

  var onBlur = function onBlur(e) {
    focus.current = false;
    checkVal();
    updateModel(e);
    updateFilledState();
    props.onBlur && props.onBlur(e);

    if (elementRef.current.value !== focusText.current) {
      var event = document.createEvent('HTMLEvents');
      event.initEvent('change', true, false);
      elementRef.current.dispatchEvent(event);
    }
  };

  var onKeyDown = function onKeyDown(e) {
    if (props.readOnly) {
      return;
    }

    var k = e.which || e.keyCode,
        pos,
        begin,
        end;
    var iPhone = /iphone/i.test(DomHandler.getUserAgent());
    oldVal.current = elementRef.current.value; //backspace, delete, and escape get special treatment

    if (k === 8 || k === 46 || iPhone && k === 127) {
      pos = caret();
      begin = pos.begin;
      end = pos.end;

      if (end - begin === 0) {
        begin = k !== 46 ? seekPrev(begin) : end = seekNext(begin - 1);
        end = k === 46 ? seekNext(end) : end;
      }

      clearBuffer(begin, end);
      shiftL(begin, end - 1);
      updateModel(e);
      e.preventDefault();
    } else if (k === 13) {
      // enter
      onBlur(e);
      updateModel(e);
    } else if (k === 27) {
      // escape
      elementRef.current.value = focusText.current;
      caret(0, checkVal());
      updateModel(e);
      e.preventDefault();
    }
  };

  var onKeyPress = function onKeyPress(e) {
    if (props.readOnly) {
      return;
    }

    var k = e.which || e.keyCode,
        pos = caret(),
        p,
        c,
        next,
        completed;

    if (e.ctrlKey || e.altKey || e.metaKey || k < 32) {
      //Ignore
      return;
    } else if (k && k !== 13) {
      if (pos.end - pos.begin !== 0) {
        clearBuffer(pos.begin, pos.end);
        shiftL(pos.begin, pos.end - 1);
      }

      p = seekNext(pos.begin - 1);

      if (p < len.current) {
        c = String.fromCharCode(k);

        if (tests.current[p].test(c)) {
          shiftR(p);
          buffer.current[p] = c;
          writeBuffer();
          next = seekNext(p);

          if (/android/i.test(DomHandler.getUserAgent())) {
            //Path for CSP Violation on FireFox OS 1.1
            var proxy = function proxy() {
              caret(next);
            };

            setTimeout(proxy, 0);
          } else {
            caret(next);
          }

          if (pos.begin <= lastRequiredNonMaskPos.current) {
            completed = isCompleted();
          }
        }
      }

      e.preventDefault();
    }

    updateModel(e);

    if (props.onComplete && completed) {
      props.onComplete({
        originalEvent: e,
        value: getValue()
      });
    }
  };

  var clearBuffer = function clearBuffer(start, end) {
    var i;

    for (i = start; i < end && i < len.current; i++) {
      if (tests.current[i]) {
        buffer.current[i] = getPlaceholder(i);
      }
    }
  };

  var writeBuffer = function writeBuffer() {
    elementRef.current.value = buffer.current.join('');
  };

  var checkVal = function checkVal(allow) {
    isValueChecked.current = true; //try to place characters where they belong

    var test = elementRef.current.value,
        lastMatch = -1,
        i,
        c,
        pos;

    for (i = 0, pos = 0; i < len.current; i++) {
      if (tests.current[i]) {
        buffer.current[i] = getPlaceholder(i);

        while (pos++ < test.length) {
          c = test.charAt(pos - 1);

          if (tests.current[i].test(c)) {
            buffer.current[i] = c;
            lastMatch = i;
            break;
          }
        }

        if (pos > test.length) {
          clearBuffer(i + 1, len.current);
          break;
        }
      } else {
        if (buffer.current[i] === test.charAt(pos)) {
          pos++;
        }

        if (i < partialPosition.current) {
          lastMatch = i;
        }
      }
    }

    if (allow) {
      writeBuffer();
    } else if (lastMatch + 1 < partialPosition.current) {
      if (props.autoClear || buffer.current.join('') === defaultBuffer.current) {
        // Invalid value. Remove it and replace it with the
        // mask, which is the default behavior.
        if (elementRef.current.value) elementRef.current.value = '';
        clearBuffer(0, len.current);
      } else {
        // Invalid value, but we opt to show the value to the
        // user and allow them to correct their mistake.
        writeBuffer();
      }
    } else {
      writeBuffer();
      elementRef.current.value = elementRef.current.value.substring(0, lastMatch + 1);
    }

    return partialPosition.current ? i : firstNonMaskPos.current;
  };

  var onFocus = function onFocus(e) {
    if (props.readOnly) {
      return;
    }

    focus.current = true;
    clearTimeout(caretTimeoutId.current);
    var pos;
    focusText.current = elementRef.current.value;
    pos = checkVal();
    caretTimeoutId.current = setTimeout(function () {
      if (elementRef.current !== document.activeElement) {
        return;
      }

      writeBuffer();

      if (pos === props.mask.replace('?', '').length) {
        caret(0, pos);
      } else {
        caret(pos);
      }

      updateFilledState();
    }, 10);
    props.onFocus && props.onFocus(e);
  };

  var onInput = function onInput(event) {
    androidChrome.current ? handleAndroidInput(event) : handleInputChange(event);
  };

  var handleInputChange = function handleInputChange(e) {
    if (props.readOnly) {
      return;
    }

    var pos = checkVal(true);
    caret(pos);
    updateModel(e);

    if (props.onComplete && isCompleted()) {
      props.onComplete({
        originalEvent: e,
        value: getValue()
      });
    }
  };

  var getUnmaskedValue = React.useCallback(function () {
    var unmaskedBuffer = [];

    for (var i = 0; i < buffer.current.length; i++) {
      var c = buffer.current[i];

      if (tests.current[i] && c !== getPlaceholder(i)) {
        unmaskedBuffer.push(c);
      }
    }

    return unmaskedBuffer.join('');
  }, [getPlaceholder]);

  var updateModel = function updateModel(e) {
    if (props.onChange) {
      var val = props.unmask ? getUnmaskedValue() : e && e.target.value;
      props.onChange({
        originalEvent: e,
        value: defaultBuffer.current !== val ? val : '',
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        target: {
          name: props.name,
          id: props.id,
          value: defaultBuffer.current !== val ? val : ''
        }
      });
    }
  };

  var updateFilledState = function updateFilledState() {
    if (elementRef.current && elementRef.current.value && elementRef.current.value.length > 0) DomHandler.addClass(elementRef.current, 'p-filled');else DomHandler.removeClass(elementRef.current, 'p-filled');
  };

  var updateValue = function updateValue(allow) {
    var pos;

    if (elementRef.current) {
      if (props.value == null) {
        elementRef.current.value = '';
      } else {
        elementRef.current.value = props.value;
        pos = checkVal(allow);
        setTimeout(function () {
          if (elementRef.current) {
            writeBuffer();
            return checkVal(allow);
          }
        }, 10);
      }

      focusText.current = elementRef.current.value;
    }

    updateFilledState();
    return pos;
  };

  var isValueUpdated = React.useCallback(function () {
    return props.unmask ? props.value !== getUnmaskedValue() : defaultBuffer.current !== elementRef.current.value && elementRef.current.value !== props.value;
  }, [props.unmask, props.value, getUnmaskedValue]);

  var init = function init() {
    if (props.mask) {
      tests.current = [];
      partialPosition.current = props.mask.length;
      len.current = props.mask.length;
      firstNonMaskPos.current = null;
      var defs = {
        9: '[0-9]',
        a: '[A-Za-z]',
        '*': '[A-Za-z0-9]'
      };
      var ua = DomHandler.getUserAgent();
      androidChrome.current = /chrome/i.test(ua) && /android/i.test(ua);
      var maskTokens = props.mask.split('');

      for (var i = 0; i < maskTokens.length; i++) {
        var c = maskTokens[i];

        if (c === '?') {
          len.current--;
          partialPosition.current = i;
        } else if (defs[c]) {
          tests.current.push(new RegExp(defs[c]));

          if (firstNonMaskPos.current === null) {
            firstNonMaskPos.current = tests.current.length - 1;
          }

          if (i < partialPosition.current) {
            lastRequiredNonMaskPos.current = tests.current.length - 1;
          }
        } else {
          tests.current.push(null);
        }
      }

      buffer.current = [];

      for (var _i = 0; _i < maskTokens.length; _i++) {
        var _c = maskTokens[_i];

        if (_c !== '?') {
          if (defs[_c]) buffer.current.push(getPlaceholder(_i));else buffer.current.push(_c);
        }
      }

      defaultBuffer.current = buffer.current.join('');
    }
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  React.useEffect(function () {
    ObjectUtils.combinedRefs(elementRef, ref);
  }, [elementRef, ref]);
  useMountEffect(function () {
    init();
    updateValue();
  });
  useUpdateEffect(function () {
    init();
    caret(updateValue(true));

    if (props.unmask) {
      updateModel();
    }
  }, [props.mask]);
  useUpdateEffect(function () {
    if (isValueUpdated()) {
      updateValue();
    }
  }, [isValueUpdated]);
  var otherProps = ObjectUtils.findDiffKeys(props, InputMask$1.defaultProps);
  var className = classNames('p-inputmask', props.className);
  return /*#__PURE__*/React.createElement(InputText$1, _extends$i({
    ref: elementRef,
    id: props.id,
    type: props.type,
    name: props.name,
    style: props.style,
    className: className
  }, otherProps, {
    placeholder: props.placeholder,
    size: props.size,
    maxLength: props.maxLength,
    tabIndex: props.tabIndex,
    disabled: props.disabled,
    readOnly: props.readOnly,
    onFocus: onFocus,
    onBlur: onBlur,
    onKeyDown: onKeyDown,
    onKeyPress: onKeyPress,
    onInput: onInput,
    onPaste: handleInputChange,
    required: props.required,
    tooltip: props.tooltip,
    tooltipOptions: props.tooltipOptions
  }));
}));
InputMask$1.displayName = 'InputMask';
InputMask$1.defaultProps = {
  __TYPE: 'InputMask',
  id: null,
  value: null,
  type: 'text',
  mask: null,
  slotChar: '_',
  autoClear: true,
  unmask: false,
  style: null,
  className: null,
  placeholder: null,
  size: null,
  maxLength: null,
  tabIndex: null,
  disabled: false,
  readOnly: false,
  name: null,
  required: false,
  tooltip: null,
  tooltipOptions: null,
  onComplete: null,
  onChange: null,
  onFocus: null,
  onBlur: null
};

var InputMask = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      inputRef = _ref.inputRef,
      value = _ref.value,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? "text" : _ref$type,
      mask = _ref.mask,
      _ref$slotChar = _ref.slotChar,
      slotChar = _ref$slotChar === void 0 ? "_" : _ref$slotChar,
      _ref$autoClear = _ref.autoClear,
      autoClear = _ref$autoClear === void 0 ? false : _ref$autoClear,
      _ref$unmask = _ref.unmask,
      unmask = _ref$unmask === void 0 ? true : _ref$unmask,
      style = _ref.style,
      className = _ref.className,
      placeholder = _ref.placeholder,
      size = _ref.size,
      maxLength = _ref.maxLength,
      tabIndex = _ref.tabIndex,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$readOnly = _ref.readOnly,
      readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly,
      name = _ref.name,
      _ref$required = _ref.required,
      required = _ref$required === void 0 ? false : _ref$required,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onComplete = _ref.onComplete,
      onChange = _ref.onChange,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(InputMask$1, {
    ref: ref,
    id: id,
    inputRef: inputRef,
    value: value,
    type: type,
    mask: mask,
    slotChar: slotChar,
    autoClear: autoClear,
    unmask: unmask,
    style: style,
    className: className,
    placeholder: placeholder,
    size: size,
    maxLength: maxLength,
    tabIndex: tabIndex,
    disabled: disabled,
    readOnly: readOnly,
    name: name,
    required: required,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onComplete: onComplete,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur
  });
});

function _extends$h() {
  _extends$h = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$h.apply(this, arguments);
}

function _arrayWithHoles$b(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$b(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$f(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$f(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$f(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$f(o, minLen);
}

function _nonIterableRest$b() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$b(arr, i) {
  return _arrayWithHoles$b(arr) || _iterableToArrayLimit$b(arr, i) || _unsupportedIterableToArray$f(arr, i) || _nonIterableRest$b();
}

var InputSwitch$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$b(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var elementRef = React.useRef(null);
  var inputRef = React.useRef(props.inputRef);
  var checked = props.checked === props.trueValue;

  var onClick = function onClick(event) {
    if (props.disabled) {
      return;
    }

    toggle(event);
    DomHandler.focus(inputRef.current);
    event.preventDefault();
  };

  var toggle = function toggle(event) {
    if (props.onChange) {
      var value = checked ? props.falseValue : props.trueValue;
      props.onChange({
        originalEvent: event,
        value: value,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        target: {
          name: props.name,
          id: props.id,
          value: value
        }
      });
    }
  };

  var onFocus = function onFocus(event) {
    setFocusedState(true);
    props.onFocus && props.onFocus(event);
  };

  var onBlur = function onBlur(event) {
    setFocusedState(false);
    props.onBlur && props.onBlur(event);
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      },
      getInput: function getInput() {
        return elementRef.current;
      }
    };
  });
  React.useEffect(function () {
    ObjectUtils.combinedRefs(inputRef, props.inputRef);
  }, [inputRef, props.inputRef]);
  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, InputSwitch$1.defaultProps);
  var dataProps = ObjectUtils.reduceKeys(otherProps, DomHandler.DATA_PROPS);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var className = classNames('p-inputswitch p-component', {
    'p-inputswitch-checked': checked,
    'p-disabled': props.disabled,
    'p-focus': focusedState
  }, props.className);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends$h({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style
  }, otherProps, {
    onClick: onClick,
    role: "checkbox",
    "aria-checked": checked
  }), /*#__PURE__*/React.createElement("div", {
    className: "p-hidden-accessible"
  }, /*#__PURE__*/React.createElement("input", _extends$h({
    ref: inputRef,
    type: "checkbox",
    id: props.inputId,
    name: props.name,
    checked: checked,
    onChange: toggle,
    onFocus: onFocus,
    onBlur: onBlur,
    disabled: props.disabled,
    role: "switch",
    tabIndex: props.tabIndex,
    "aria-checked": checked
  }, ariaProps, dataProps))), /*#__PURE__*/React.createElement("span", {
    className: "p-inputswitch-slider"
  })), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$h({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
InputSwitch$1.displayName = 'InputSwitch';
InputSwitch$1.defaultProps = {
  __TYPE: 'InputSwitch',
  checked: false,
  className: null,
  disabled: false,
  falseValue: false,
  id: null,
  inputId: null,
  inputRef: null,
  name: null,
  onBlur: null,
  onChange: null,
  onFocus: null,
  style: null,
  tabIndex: null,
  tooltip: null,
  tooltipOptions: null,
  trueValue: true
};

var InputSwitch = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      inputRef = _ref.inputRef,
      style = _ref.style,
      className = _ref.className,
      inputId = _ref.inputId,
      name = _ref.name,
      _ref$checked = _ref.checked,
      checked = _ref$checked === void 0 ? false : _ref$checked,
      _ref$trueValue = _ref.trueValue,
      trueValue = _ref$trueValue === void 0 ? true : _ref$trueValue,
      _ref$falseValue = _ref.falseValue,
      falseValue = _ref$falseValue === void 0 ? false : _ref$falseValue,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onChange = _ref.onChange,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(InputSwitch$1, {
    ref: ref,
    id: id,
    inputRef: inputRef,
    inputId: inputId,
    checked: checked,
    trueValue: trueValue,
    falseValue: falseValue,
    style: style,
    className: className,
    disabled: disabled,
    name: name,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur
  });
});

var _excluded$3 = ["keyfilter", "tooltip", "tooltipOptions", "validateOnly"];
var InputText = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var keyfilter = _ref.keyfilter,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions;
      _ref.validateOnly;
      var props = _objectWithoutProperties$1(_ref, _excluded$3);

  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(InputText$1, _extends$J({}, props, {
    ref: ref,
    keyfilter: keyfilter,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions
  }));
});

function _extends$g() {
  _extends$g = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$g.apply(this, arguments);
}

var InputTextarea$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(ref);
  var cachedScrollHeight = React.useRef(0);

  var onFocus = function onFocus(event) {
    if (props.autoResize) {
      resize();
    }

    props.onFocus && props.onFocus(event);
  };

  var onBlur = function onBlur(event) {
    if (props.autoResize) {
      resize();
    }

    props.onBlur && props.onBlur(event);
  };

  var onKeyUp = function onKeyUp(event) {
    if (props.autoResize) {
      resize();
    }

    props.onKeyUp && props.onKeyUp(event);
  };

  var onInput = function onInput(event) {
    if (props.autoResize) {
      resize();
    }

    props.onInput && props.onInput(event);
    var target = event.target;
    ObjectUtils.isNotEmpty(target.value) ? DomHandler.addClass(target, 'p-filled') : DomHandler.removeClass(target, 'p-filled');
  };

  var resize = function resize(initial) {
    var inputEl = elementRef.current;

    if (inputEl && DomHandler.isVisible(inputEl)) {
      if (!cachedScrollHeight.current) {
        cachedScrollHeight.current = inputEl.scrollHeight;
        inputEl.style.overflow = 'hidden';
      }

      if (cachedScrollHeight.current !== inputEl.scrollHeight || initial) {
        inputEl.style.height = '';
        inputEl.style.height = inputEl.scrollHeight + 'px';

        if (parseFloat(inputEl.style.height) >= parseFloat(inputEl.style.maxHeight)) {
          inputEl.style.overflowY = 'scroll';
          inputEl.style.height = inputEl.style.maxHeight;
        } else {
          inputEl.style.overflow = 'hidden';
        }

        cachedScrollHeight.current = inputEl.scrollHeight;
      }
    }
  };

  var currentValue = elementRef.current && elementRef.current.value;
  var isFilled = React.useMemo(function () {
    return ObjectUtils.isNotEmpty(props.value) || ObjectUtils.isNotEmpty(props.defaultValue) || ObjectUtils.isNotEmpty(currentValue);
  }, [props.value, props.defaultValue, currentValue]);
  React.useEffect(function () {
    ObjectUtils.combinedRefs(elementRef, ref);
  }, [elementRef, ref]);
  React.useEffect(function () {
    if (props.autoResize) {
      resize(true);
    }
  }, [props.autoResize]);
  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, InputTextarea$1.defaultProps);
  var className = classNames('p-inputtextarea p-inputtext p-component', {
    'p-disabled': props.disabled,
    'p-filled': isFilled,
    'p-inputtextarea-resizable': props.autoResize
  }, props.className);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("textarea", _extends$g({
    ref: elementRef
  }, otherProps, {
    className: className,
    onFocus: onFocus,
    onBlur: onBlur,
    onKeyUp: onKeyUp,
    onInput: onInput
  })), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$g({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
InputTextarea$1.displayName = 'InputTextarea';
InputTextarea$1.defaultProps = {
  __TYPE: 'InputTextarea',
  autoResize: false,
  tooltip: null,
  tooltipOptions: null,
  onInput: null
};

var _excluded$2 = ["autoResize", "tooltip", "tooltipOptions"];
var InputTextarea = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _ref$autoResize = _ref.autoResize,
      autoResize = _ref$autoResize === void 0 ? false : _ref$autoResize,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      props = _objectWithoutProperties$1(_ref, _excluded$2);

  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(InputTextarea$1, _extends$J({}, props, {
    ref: ref,
    autoResize: autoResize,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions
  }));
});

function _extends$f() {
  _extends$f = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$f.apply(this, arguments);
}

var Message$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(null);

  var createContent = function createContent() {
    if (props.content) {
      return ObjectUtils.getJSXElement(props.content, props);
    }

    var text = ObjectUtils.getJSXElement(props.text, props);
    var iconValue = props.icon;

    if (!iconValue) {
      iconValue = classNames('pi', {
        'pi-info-circle': props.severity === 'info',
        'pi-exclamation-triangle': props.severity === 'warn',
        'pi-times-circle': props.severity === 'error',
        'pi-check': props.severity === 'success'
      });
    }

    var icon = IconUtils.getJSXIcon(iconValue, {
      className: 'p-inline-message-icon'
    }, {
      props: props
    });
    return /*#__PURE__*/React.createElement(React.Fragment, null, icon, /*#__PURE__*/React.createElement("span", {
      className: "p-inline-message-text"
    }, text));
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  var otherProps = ObjectUtils.findDiffKeys(props, Message$1.defaultProps);
  var className = classNames('p-inline-message p-component', {
    'p-inline-message-info': props.severity === 'info',
    'p-inline-message-warn': props.severity === 'warn',
    'p-inline-message-error': props.severity === 'error',
    'p-inline-message-success': props.severity === 'success',
    'p-inline-message-icon-only': !props.text
  }, props.className);
  var content = createContent();
  return /*#__PURE__*/React.createElement("div", _extends$f({
    id: props.id,
    ref: elementRef,
    className: className,
    style: props.style
  }, otherProps, {
    role: "alert",
    "aria-live": "polite"
  }), content);
}));
Message$1.displayName = 'Message';
Message$1.defaultProps = {
  __TYPE: 'Message',
  id: null,
  className: null,
  style: null,
  text: null,
  icon: null,
  severity: 'info',
  content: null
};

var Message = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      className = _ref.className,
      style = _ref.style,
      severity = _ref.severity,
      text = _ref.text,
      content = _ref.content;
  var messageClassName = classNames(className, {
    "p-inline-message-secondary": severity === "secondary",
    "p-inline-message-help": severity === "help"
  });
  return /*#__PURE__*/React__default.createElement(Message$1, {
    ref: ref,
    id: id,
    style: style,
    className: messageClassName,
    severity: severity,
    text: text,
    content: content
  });
});

/*
 *      bignumber.js v9.0.2
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2021 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,
    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',
    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,
    // 2^53 - 1
// MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,
    // EDITABLE
// The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
// the arguments to toExponential, toFixed, toFormat, and toPrecision.
MAX = 1E9; // 0 to MAX_INT32

/*
 * Create and return a BigNumber constructor.
 */

function clone(configObject) {
  var div,
      convertBase,
      parseNumeric,
      P = BigNumber.prototype = {
    constructor: BigNumber,
    toString: null,
    valueOf: null
  },
      ONE = new BigNumber(1),
      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------
  // The default values below must be integers within the inclusive ranges stated.
  // The values can also be changed at run-time using BigNumber.set.
  // The maximum number of decimal places for operations involving division.
  DECIMAL_PLACES = 20,
      // 0 to MAX
  // The rounding mode used when rounding to the above decimal places, and when using
  // toExponential, toFixed, toFormat and toPrecision, and round (default value).
  // UP         0 Away from zero.
  // DOWN       1 Towards zero.
  // CEIL       2 Towards +Infinity.
  // FLOOR      3 Towards -Infinity.
  // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  ROUNDING_MODE = 4,
      // 0 to 8
  // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]
  // The exponent value at and beneath which toString returns exponential notation.
  // Number type: -7
  TO_EXP_NEG = -7,
      // 0 to -MAX
  // The exponent value at and above which toString returns exponential notation.
  // Number type: 21
  TO_EXP_POS = 21,
      // 0 to MAX
  // RANGE : [MIN_EXP, MAX_EXP]
  // The minimum exponent value, beneath which underflow to zero occurs.
  // Number type: -324  (5e-324)
  MIN_EXP = -1e7,
      // -1 to -MAX
  // The maximum exponent value, above which overflow to Infinity occurs.
  // Number type:  308  (1.7976931348623157e+308)
  // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
  MAX_EXP = 1e7,
      // 1 to MAX
  // Whether to use cryptographically-secure random number generation, if available.
  CRYPTO = false,
      // true or false
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP        0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN      1 The remainder has the same sign as the dividend.
  //             This modulo mode is commonly known as 'truncated division' and is
  //             equivalent to (a % n) in JavaScript.
  // FLOOR     3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
  // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
  //             The remainder is always positive.
  //
  // The truncated division, floored division, Euclidian division and IEEE 754 remainder
  // modes are commonly used for the modulus operation.
  // Although the other rounding modes can also be used, they may not give useful results.
  MODULO_MODE = 1,
      // 0 to 9
  // The maximum number of significant digits of the result of the exponentiatedBy operation.
  // If POW_PRECISION is 0, there will be unlimited significant digits.
  POW_PRECISION = 0,
      // 0 to MAX
  // The format specification used by the BigNumber.prototype.toFormat method.
  FORMAT = {
    prefix: '',
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ',',
    decimalSeparator: '.',
    fractionGroupSize: 0,
    fractionGroupSeparator: '\xA0',
    // non-breaking space
    suffix: ''
  },
      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
  // '-', '.', whitespace, or repeated character.
  // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
  ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true; //------------------------------------------------------------------------------------------
  // CONSTRUCTOR

  /*
   * The BigNumber constructor and exported function.
   * Create and return a new instance of a BigNumber object.
   *
   * v {number|string|BigNumber} A numeric value.
   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
   */

  function BigNumber(v, b) {
    var alphabet,
        c,
        caseChanged,
        e,
        i,
        isNum,
        len,
        str,
        x = this; // Enable constructor call without `new`.

    if (!(x instanceof BigNumber)) return new BigNumber(v, b);

    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;

        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }

        return;
      }

      if ((isNum = typeof v == 'number') && v * 0 == 0) {
        // Use `1 / n` to handle minus zero also.
        x.s = 1 / v < 0 ? (v = -v, -1) : 1; // Fast path for integers, where n < 2147483648 (2**31).

        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++);

          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }

          return;
        }

        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      } // Decimal point?


      if ((e = str.indexOf('.')) > -1) str = str.replace('.', ''); // Exponential form?

      if ((i = str.search(/e/i)) > 0) {
        // Determine exponent.
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        // Integer.
        e = str.length;
      }
    } else {
      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
      intCheck(b, 2, ALPHABET.length, 'Base'); // Allow exponential notation to be used with base 10 argument, while
      // also rounding to DECIMAL_PLACES as with other bases.

      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }

      str = String(v);

      if (isNum = typeof v == 'number') {
        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1; // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'

        if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }

      alphabet = ALPHABET.slice(0, b);
      e = i = 0; // Check that str is a valid base b number.
      // Don't use RegExp, so alphabet can contain special characters.

      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == '.') {
            // If '.' is not the first character and it has not be found before.
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            // Allow e.g. hexadecimal 'FF' as well as 'ff'.
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }

          return parseNumeric(x, String(v), isNum, b);
        }
      } // Prevent later check for length on converted number.


      isNum = false;
      str = convertBase(str, b, 10, x.s); // Decimal point?

      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');else e = str.length;
    } // Determine leading zeros.


    for (i = 0; str.charCodeAt(i) === 48; i++); // Determine trailing zeros.


    for (len = str.length; str.charCodeAt(--len) === 48;);

    if (str = str.slice(i, ++len)) {
      len -= i; // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'

      if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      } // Overflow?


      if ((e = e - i - 1) > MAX_EXP) {
        // Infinity.
        x.c = x.e = null; // Underflow?
      } else if (e < MIN_EXP) {
        // Zero.
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = []; // Transform base
        // e is the base 10 exponent.
        // i is where to slice str to get the first element of the coefficient array.

        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE; // i < 1

        if (i < len) {
          if (i) x.c.push(+str.slice(0, i));

          for (len -= LOG_BASE; i < len;) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }

          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }

        for (; i--; str += '0');

        x.c.push(+str);
      }
    } else {
      // Zero.
      x.c = [x.e = 0];
    }
  } // CONSTRUCTOR PROPERTIES


  BigNumber.clone = clone;
  BigNumber.ROUND_UP = 0;
  BigNumber.ROUND_DOWN = 1;
  BigNumber.ROUND_CEIL = 2;
  BigNumber.ROUND_FLOOR = 3;
  BigNumber.ROUND_HALF_UP = 4;
  BigNumber.ROUND_HALF_DOWN = 5;
  BigNumber.ROUND_HALF_EVEN = 6;
  BigNumber.ROUND_HALF_CEIL = 7;
  BigNumber.ROUND_HALF_FLOOR = 8;
  BigNumber.EUCLID = 9;
  /*
   * Configure infrequently-changing library-wide settings.
   *
   * Accept an object with the following optional properties (if the value of a property is
   * a number, it must be an integer within the inclusive range stated):
   *
   *   DECIMAL_PLACES   {number}           0 to MAX
   *   ROUNDING_MODE    {number}           0 to 8
   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
   *   CRYPTO           {boolean}          true or false
   *   MODULO_MODE      {number}           0 to 9
   *   POW_PRECISION       {number}           0 to MAX
   *   ALPHABET         {string}           A string of two or more unique characters which does
   *                                       not contain '.'.
   *   FORMAT           {object}           An object with some of the following properties:
   *     prefix                 {string}
   *     groupSize              {number}
   *     secondaryGroupSize     {number}
   *     groupSeparator         {string}
   *     decimalSeparator       {string}
   *     fractionGroupSize      {number}
   *     fractionGroupSeparator {string}
   *     suffix                 {string}
   *
   * (The values assigned to the above FORMAT object properties are not checked for validity.)
   *
   * E.g.
   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
   *
   * Ignore properties/parameters set to null or undefined, except for ALPHABET.
   *
   * Return an object with the properties current values.
   */

  BigNumber.config = BigNumber.set = function (obj) {
    var p, v;

    if (obj != null) {
      if (typeof obj == 'object') {
        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        } // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'


        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        } // EXPONENTIAL_AT {number|number[]}
        // Integer, -MAX to MAX inclusive or
        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'


        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
          v = obj[p];

          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        } // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'


        if (obj.hasOwnProperty(p = 'RANGE')) {
          v = obj[p];

          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);

            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + ' cannot be zero: ' + v);
            }
          }
        } // CRYPTO {boolean} true or false.
        // '[BigNumber Error] CRYPTO not true or false: {v}'
        // '[BigNumber Error] crypto unavailable'


        if (obj.hasOwnProperty(p = 'CRYPTO')) {
          v = obj[p];

          if (v === !!v) {
            if (v) {
              if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + 'crypto unavailable');
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + ' not true or false: ' + v);
          }
        } // MODULO_MODE {number} Integer, 0 to 9 inclusive.
        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'


        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        } // POW_PRECISION {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'


        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        } // FORMAT {object}
        // '[BigNumber Error] FORMAT not an object: {v}'


        if (obj.hasOwnProperty(p = 'FORMAT')) {
          v = obj[p];
          if (typeof v == 'object') FORMAT = v;else throw Error(bignumberError + p + ' not an object: ' + v);
        } // ALPHABET {string}
        // '[BigNumber Error] ALPHABET invalid: {v}'


        if (obj.hasOwnProperty(p = 'ALPHABET')) {
          v = obj[p]; // Disallow if less than two characters,
          // or if it contains '+', '-', '.', whitespace, or a repeated character.

          if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + ' invalid: ' + v);
          }
        }
      } else {
        // '[BigNumber Error] Object expected: {v}'
        throw Error(bignumberError + 'Object expected: ' + obj);
      }
    }

    return {
      DECIMAL_PLACES: DECIMAL_PLACES,
      ROUNDING_MODE: ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO: CRYPTO,
      MODULO_MODE: MODULO_MODE,
      POW_PRECISION: POW_PRECISION,
      FORMAT: FORMAT,
      ALPHABET: ALPHABET
    };
  };
  /*
   * Return true if v is a BigNumber instance, otherwise return false.
   *
   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
   *
   * v {any}
   *
   * '[BigNumber Error] Invalid BigNumber: {v}'
   */


  BigNumber.isBigNumber = function (v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber.DEBUG) return true;
    var i,
        n,
        c = v.c,
        e = v.e,
        s = v.s;

    out: if ({}.toString.call(c) == '[object Array]') {
      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
        // If the first element is zero, the BigNumber value must be zero.
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        } // Calculate number of digits that c[0] should have, based on the exponent.


        i = (e + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE; // Calculate number of digits of c[0].
        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {

        if (String(c[0]).length == i) {
          for (i = 0; i < c.length; i++) {
            n = c[i];
            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
          } // Last element cannot be zero, unless it is the only element.


          if (n !== 0) return true;
        }
      } // Infinity/NaN

    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }

    throw Error(bignumberError + 'Invalid BigNumber: ' + v);
  };
  /*
   * Return a new BigNumber whose value is the maximum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */


  BigNumber.maximum = BigNumber.max = function () {
    return maxOrMin(arguments, P.lt);
  };
  /*
   * Return a new BigNumber whose value is the minimum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */


  BigNumber.minimum = BigNumber.min = function () {
    return maxOrMin(arguments, P.gt);
  };
  /*
   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
   * zeros are produced).
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
   * '[BigNumber Error] crypto unavailable'
   */


  BigNumber.random = function () {
    var pow2_53 = 0x20000000000000; // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
    // Check if Math.random() produces more than 32 bits of randomness.
    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.

    var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function () {
      return mathfloor(Math.random() * pow2_53);
    } : function () {
      return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);
    };
    return function (dp) {
      var a,
          b,
          e,
          k,
          v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);
      if (dp == null) dp = DECIMAL_PLACES;else intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);

      if (CRYPTO) {
        // Browsers supporting crypto.getRandomValues.
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));

          for (; i < k;) {
            // 53 bits:
            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
            //                                     11111 11111111 11111111
            // 0x20000 is 2^21.
            v = a[i] * 0x20000 + (a[i + 1] >>> 11); // Rejection sampling:
            // 0 <= v < 9007199254740992
            // Probability that v >= 9e15, is
            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251

            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              // 0 <= v <= 8999999999999999
              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 2;
            }
          }

          i = k / 2; // Node.js supporting crypto.randomBytes.
        } else if (crypto.randomBytes) {
          // buffer
          a = crypto.randomBytes(k *= 7);

          for (; i < k;) {
            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
            // 0x100000000 is 2^32, 0x1000000 is 2^24
            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
            // 0 <= v < 9007199254740992
            v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 7;
            }
          }

          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + 'crypto unavailable');
        }
      } // Use Math.random.


      if (!CRYPTO) {
        for (; i < k;) {
          v = random53bitInt();
          if (v < 9e15) c[i++] = v % 1e14;
        }
      }

      k = c[--i];
      dp %= LOG_BASE; // Convert trailing digits to zeros according to dp.

      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      } // Remove trailing elements which are zero.


      for (; c[i] === 0; c.pop(), i--); // Zero?


      if (i < 0) {
        c = [e = 0];
      } else {
        // Remove leading elements which are zero and adjust exponent accordingly.
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE); // Count the digits of the first element of c to determine leading zeros, and...


        for (i = 1, v = c[0]; v >= 10; v /= 10, i++); // adjust the exponent accordingly.


        if (i < LOG_BASE) e -= LOG_BASE - i;
      }

      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  /*
  * Return a BigNumber whose value is the sum of the arguments.
  *
  * arguments {number|string|BigNumber}
  */


  BigNumber.sum = function () {
    var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);

    for (; i < args.length;) sum = sum.plus(args[i++]);

    return sum;
  }; // PRIVATE FUNCTIONS
  // Called by BigNumber and BigNumber.prototype.toString.


  convertBase = function () {
    var decimal = '0123456789';
    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. toBaseOut('255', 10, 16) returns [15, 15].
     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
     */

    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

      for (; i < len;) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

        arr[0] += alphabet.indexOf(str.charAt(i++));

        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }

      return arr.reverse();
    } // Convert a numeric string of baseIn to a numeric string of baseOut.
    // If the caller is toString, we are converting from base 10 to baseOut.
    // If the caller is BigNumber, we are converting from baseIn to base 10.


    return function (str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet,
          d,
          e,
          k,
          r,
          x,
          xc,
          y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE; // Non-integer.

      if (i >= 0) {
        k = POW_PRECISION; // Unlimited precision.

        POW_PRECISION = 0;
        str = str.replace('.', '');
        y = new BigNumber(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k; // Convert str as if an integer, then restore the fraction part by dividing the
        // result by its base raised to a power.

        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal);
        y.e = y.c.length;
      } // Convert the number as integer.


      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET)); // xc now represents str as an integer and converted to baseOut. e is the exponent.

      e = k = xc.length; // Remove trailing zeros.

      for (; xc[--k] == 0; xc.pop()); // Zero?


      if (!xc[0]) return alphabet.charAt(0); // Does str represent an integer? If so, no need for the division.

      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e; // The sign is needed for correct rounding.

        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      } // xc now represents str converted to baseOut.
      // THe index of the rounding digit.


      d = e + dp + 1; // The rounding digit: the digit to the right of the digit that may be rounded up.

      i = xc[d]; // Look at the rounding digits and mode to determine whether to round up.

      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7)); // If the index of the rounding digit is not greater than zero, or xc represents
      // zero, then the result of the base conversion is zero or, if rounding up, a value
      // such as 0.00001.

      if (d < 1 || !xc[0]) {
        // 1^-dp or 0
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        // Truncate xc to the required number of decimal places.
        xc.length = d; // Round up?

        if (r) {
          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (--baseOut; ++xc[--d] > baseOut;) {
            xc[d] = 0;

            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        } // Determine trailing zeros.


        for (k = xc.length; !xc[--k];); // E.g. [4, 11, 15] becomes 4bf.


        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++])); // Add leading zeros, decimal point and trailing zeros as required.


        str = toFixedPoint(str, e, alphabet.charAt(0));
      } // The caller will add the sign.


      return str;
    };
  }(); // Perform division in the specified base. Called by div and convertBase.


  div = function () {
    // Assume non-zero x and k.
    function multiply(x, k, base) {
      var m,
          temp,
          xlo,
          xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

      for (x = x.slice(); i--;) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }

      if (carry) x = [carry].concat(x);
      return x;
    }

    function compare(a, b, aL, bL) {
      var i, cmp;

      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return cmp;
    }

    function subtract(a, b, aL, base) {
      var i = 0; // Subtract b from a.

      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      } // Remove leading zeros.


      for (; !a[0] && a.length > 1; a.splice(0, 1));
    } // x: dividend, y: divisor.


    return function (x, y, dp, rm, base) {
      var cmp,
          e,
          i,
          more,
          n,
          prod,
          prodL,
          q,
          qc,
          rem,
          remL,
          rem0,
          xi,
          xL,
          yc0,
          yL,
          yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c; // Either NaN, Infinity or 0?

      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber( // Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
        xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
      }

      q = new BigNumber(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;

      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      } // Result exponent may be one less then the current value of e.
      // The coefficients of the BigNumbers from convertBase may have trailing zeros.


      for (i = 0; yc[i] == (xc[i] || 0); i++);

      if (yc[i] > (xc[i] || 0)) e--;

      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2; // Normalise xc and yc so highest order digit of yc is >= base / 2.

        n = mathfloor(base / (yc[0] + 1)); // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {

        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }

        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length; // Add zeros to make remainder as long as divisor.

        for (; remL < yL; rem[remL++] = 0);

        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2) yc0++; // Not necessary, but to prevent trial digit n > base, when using base 3.
        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

        do {
          n = 0; // Compare divisor and remainder.

          cmp = compare(yc, rem, yL, remL); // If divisor < remainder.

          if (cmp < 0) {
            // Calculate trial digit, n.
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0); // n is how many times the divisor goes into the current remainder.

            n = mathfloor(rem0 / yc0); //  Algorithm:
            //  product = divisor multiplied by trial digit (n).
            //  Compare product and remainder.
            //  If product is greater than remainder:
            //    Subtract divisor from product, decrement trial digit.
            //  Subtract product from remainder.
            //  If product was less than remainder at the last compare:
            //    Compare new remainder and divisor.
            //    If remainder is greater than divisor:
            //      Subtract divisor from remainder, increment trial digit.

            if (n > 1) {
              // n may be > base only when base is 3.
              if (n >= base) n = base - 1; // product = divisor * trial digit.

              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length; // Compare product and remainder.
              // If product > remainder then trial digit n too high.
              // n is 1 too high about 5% of the time, and is not known to have
              // ever been more than 1 too high.

              while (compare(prod, rem, prodL, remL) == 1) {
                n--; // Subtract divisor from product.

                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              // n is 0 or 1, cmp is -1.
              // If n is 0, there is no need to compare yc and rem again below,
              // so change cmp to 1 to avoid it.
              // If n is 1, leave cmp as -1, so yc and rem are compared again.
              if (n == 0) {
                // divisor < remainder, so n must be at least 1.
                cmp = n = 1;
              } // product = divisor


              prod = yc.slice();
              prodL = prod.length;
            }

            if (prodL < remL) prod = [0].concat(prod); // Subtract product from remainder.

            subtract(rem, prod, remL, base);
            remL = rem.length; // If product was < remainder.

            if (cmp == -1) {
              // Compare divisor and new remainder.
              // If divisor < new remainder, subtract divisor from remainder.
              // Trial digit n too low.
              // n is 1 too low about 5% of the time, and very rarely 2 too low.
              while (compare(yc, rem, yL, remL) < 1) {
                n++; // Subtract divisor from remainder.

                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          } // else cmp === 1 and n will be 0
          // Add the next digit, n, to the result array.


          qc[i++] = n; // Update the remainder.

          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);

        more = rem[0] != null; // Leading zero?

        if (!qc[0]) qc.splice(0, 1);
      }

      if (base == BASE) {
        // To calculate q.e, first get the number of digits of qc[0].
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more); // Caller is convertBase.
      } else {
        q.e = e;
        q.r = +more;
      }

      return q;
    };
  }();
  /*
   * Return a string representing the value of BigNumber n in fixed-point or exponential
   * notation rounded to the specified decimal places or significant digits.
   *
   * n: a BigNumber.
   * i: the index of the last digit required (i.e. the digit that may be rounded up).
   * rm: the rounding mode.
   * id: 1 (toExponential) or 2 (toPrecision).
   */


  function format(n, i, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
    if (!n.c) return n.toString();
    c0 = n.c[0];
    ne = n.e;

    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, '0');
    } else {
      n = round(new BigNumber(n), i, rm); // n.e may have changed if the value was rounded up.

      e = n.e;
      str = coeffToString(n.c);
      len = str.length; // toPrecision returns exponential notation if the number of significant digits
      // specified is less than the number of digits necessary to represent the integer
      // part of the value in fixed-point notation.
      // Exponential notation.

      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        // Append zeros?
        for (; len < i; str += '0', len++);

        str = toExponential(str, e); // Fixed-point notation.
      } else {
        i -= ne;
        str = toFixedPoint(str, e, '0'); // Append zeros?

        if (e + 1 > len) {
          if (--i > 0) for (str += '.'; i--; str += '0');
        } else {
          i += e - len;

          if (i > 0) {
            if (e + 1 == len) str += '.';

            for (; i--; str += '0');
          }
        }
      }
    }

    return n.s < 0 && c0 ? '-' + str : str;
  } // Handle BigNumber.max and BigNumber.min.


  function maxOrMin(args, method) {
    var n,
        i = 1,
        m = new BigNumber(args[0]);

    for (; i < args.length; i++) {
      n = new BigNumber(args[i]); // If any number is NaN, return NaN.

      if (!n.s) {
        m = n;
        break;
      } else if (method.call(m, n)) {
        m = n;
      }
    }

    return m;
  }
  /*
   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
   * Called by minus, plus and times.
   */


  function normalise(n, c, e) {
    var i = 1,
        j = c.length; // Remove trailing zeros.

    for (; !c[--j]; c.pop()); // Calculate the base 10 exponent. First get the number of digits of c[0].


    for (j = c[0]; j >= 10; j /= 10, i++); // Overflow?


    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      // Infinity.
      n.c = n.e = null; // Underflow?
    } else if (e < MIN_EXP) {
      // Zero.
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }

    return n;
  } // Handle values that fail the validity test in BigNumber.


  parseNumeric = function () {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function (x, str, isNum, b) {
      var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, ''); // No exception on Infinity or NaN.

      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
          s = s.replace(basePrefix, function (m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
            return !b || b == base ? p1 : m;
          });

          if (b) {
            base = b; // E.g. '1.' to '1', '.1' to '0.1'

            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
          }

          if (str != s) return new BigNumber(s, base);
        } // '[BigNumber Error] Not a number: {n}'
        // '[BigNumber Error] Not a base {b} number: {n}'


        if (BigNumber.DEBUG) {
          throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
        } // NaN


        x.s = null;
      }

      x.c = x.e = null;
    };
  }();
  /*
   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
   * If r is truthy, it is known that there are more digits after the rounding digit.
   */


  function round(x, sd, rm, r) {
    var d,
        i,
        j,
        k,
        n,
        ni,
        rd,
        xc = x.c,
        pows10 = POWS_TEN; // if x is not Infinity or NaN...

    if (xc) {
      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
      // n is a base 1e14 number, the value of the element of array x.c containing rd.
      // ni is the index of n within x.c.
      // d is the number of digits of n.
      // i is the index of rd within n including leading zeros.
      // j is the actual index of rd within n (if < 0, rd is a leading zero).
      out: {
        // Get the number of digits of the first element of xc.
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);

        i = sd - d; // If the rounding digit is in the first element of xc...

        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0]; // Get the rounding digit at index j of n.

          rd = n / pows10[d - j - 1] % 10 | 0;
        } else {
          ni = mathceil((i + 1) / LOG_BASE);

          if (ni >= xc.length) {
            if (r) {
              // Needed by sqrt.
              for (; xc.length <= ni; xc.push(0));

              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni]; // Get the number of digits of n.

            for (d = 1; k >= 10; k /= 10, d++); // Get the index of rd within n.


            i %= LOG_BASE; // Get the index of rd within n, adjusted for leading zeros.
            // The number of leading zeros of n is given by LOG_BASE - d.

            j = i - LOG_BASE + d; // Get the rounding digit at index j of n.

            rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
          }
        }

        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));

        if (sd < 1 || !xc[0]) {
          xc.length = 0;

          if (r) {
            // Convert sd to decimal places.
            sd -= x.e + 1; // 1, 0.1, 0.01, 0.001, 0.0001 etc.

            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            // Zero.
            xc[0] = x.e = 0;
          }

          return x;
        } // Remove excess digits.


        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i]; // E.g. 56700 becomes 56000 if 7 is the rounding digit.
          // j > 0 means i > number of leading zeros of n.

          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        } // Round up?


        if (r) {
          for (;;) {
            // If the digit to be rounded up is in the first element of xc...
            if (ni == 0) {
              // i will be the length of xc[0] before k is added.
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);

              j = xc[0] += k;

              for (k = 1; j >= 10; j /= 10, k++); // if i != k the length has increased.


              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }

              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        } // Remove trailing zeros.


        for (i = xc.length; xc[--i] === 0; xc.pop());
      } // Overflow? Infinity.


      if (x.e > MAX_EXP) {
        x.c = x.e = null; // Underflow? Zero.
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }

    return x;
  }

  function valueOf(n) {
    var str,
        e = n.e;
    if (e === null) return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0');
    return n.s < 0 ? '-' + str : str;
  } // PROTOTYPE/INSTANCE METHODS

  /*
   * Return a new BigNumber whose value is the absolute value of this BigNumber.
   */


  P.absoluteValue = P.abs = function () {
    var x = new BigNumber(this);
    if (x.s < 0) x.s = 1;
    return x;
  };
  /*
   * Return
   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
   *   0 if they have the same value,
   *   or null if the value of either is NaN.
   */


  P.comparedTo = function (y, b) {
    return compare(this, new BigNumber(y, b));
  };
  /*
   * If dp is undefined or null or true or false, return the number of decimal places of the
   * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
   *
   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */


  P.decimalPlaces = P.dp = function (dp, rm) {
    var c,
        n,
        v,
        x = this;

    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
      return round(new BigNumber(x), dp + x.e + 1, rm);
    }

    if (!(c = x.c)) return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE; // Subtract the number of trailing zeros of the last number.

    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
    if (n < 0) n = 0;
    return n;
  };
  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */


  P.dividedBy = P.div = function (y, b) {
    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  /*
   * Return a new BigNumber whose value is the integer part of dividing the value of this
   * BigNumber by the value of BigNumber(y, b).
   */


  P.dividedToIntegerBy = P.idiv = function (y, b) {
    return div(this, new BigNumber(y, b), 0, 1);
  };
  /*
   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
   *
   * If m is present, return the result modulo m.
   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
   *
   * The modular power operation works efficiently when x, n, and m are integers, otherwise it
   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
   *
   * n {number|string|BigNumber} The exponent. An integer.
   * [m] {number|string|BigNumber} The modulus.
   *
   * '[BigNumber Error] Exponent not an integer: {n}'
   */


  P.exponentiatedBy = P.pow = function (n, m) {
    var half,
        isModExp,
        i,
        k,
        more,
        nIsBig,
        nIsNeg,
        nIsOdd,
        y,
        x = this;
    n = new BigNumber(n); // Allow NaN and Infinity, but not other non-integers.

    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
    }

    if (m != null) m = new BigNumber(m); // Exponent of MAX_SAFE_INTEGER is 15.

    nIsBig = n.e > 14; // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.

    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      // The sign of the result of pow when x is negative depends on the evenness of n.
      // If +n overflows to Infinity, the evenness of n would be not be known.
      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }

    nIsNeg = n.s < 0;

    if (m) {
      // x % m returns NaN if abs(m) is zero, or m is NaN.
      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp) x = x.mod(m); // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 // [1, 240000000]
    ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 // [80000000000000]  [99999750000000]
    : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      // If x is negative and n is odd, k = -0, else k = 0.
      k = x.s < 0 && isOdd(n) ? -0 : 0; // If x >= 1, k = Infinity.

      if (x.e > -1) k = 1 / k; // If n is negative return 0, else return Infinity.

      return new BigNumber(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      // Truncating each coefficient array to a length of k after each multiplication
      // equates to truncating significant digits to POW_PRECISION + [28, 41],
      // i.e. there will be a minimum of 28 guard digits retained.
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }

    if (nIsBig) {
      half = new BigNumber(0.5);
      if (nIsNeg) n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }

    y = new BigNumber(ONE); // Performs 54 loop iterations for n of 9007199254740991.

    for (;;) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;

        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
        }
      }

      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);

        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }

      x = x.times(x);

      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
      }
    }

    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  /*
   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
   */


  P.integerValue = function (rm) {
    var n = new BigNumber(this);
    if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  /*
   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
   * otherwise return false.
   */


  P.isEqualTo = P.eq = function (y, b) {
    return compare(this, new BigNumber(y, b)) === 0;
  };
  /*
   * Return true if the value of this BigNumber is a finite number, otherwise return false.
   */


  P.isFinite = function () {
    return !!this.c;
  };
  /*
   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
   * otherwise return false.
   */


  P.isGreaterThan = P.gt = function (y, b) {
    return compare(this, new BigNumber(y, b)) > 0;
  };
  /*
   * Return true if the value of this BigNumber is greater than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */


  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
  };
  /*
   * Return true if the value of this BigNumber is an integer, otherwise return false.
   */


  P.isInteger = function () {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  /*
   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
   * otherwise return false.
   */


  P.isLessThan = P.lt = function (y, b) {
    return compare(this, new BigNumber(y, b)) < 0;
  };
  /*
   * Return true if the value of this BigNumber is less than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */


  P.isLessThanOrEqualTo = P.lte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
  };
  /*
   * Return true if the value of this BigNumber is NaN, otherwise return false.
   */


  P.isNaN = function () {
    return !this.s;
  };
  /*
   * Return true if the value of this BigNumber is negative, otherwise return false.
   */


  P.isNegative = function () {
    return this.s < 0;
  };
  /*
   * Return true if the value of this BigNumber is positive, otherwise return false.
   */


  P.isPositive = function () {
    return this.s > 0;
  };
  /*
   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
   */


  P.isZero = function () {
    return !!this.c && this.c[0] == 0;
  };
  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber minus the value of
   * BigNumber(y, b).
   */


  P.minus = function (y, b) {
    var i,
        j,
        t,
        xLTy,
        x = this,
        a = x.s;
    y = new BigNumber(y, b);
    b = y.s; // Either NaN?

    if (!a || !b) return new BigNumber(NaN); // Signs differ?

    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }

    var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

    if (!xe || !ye) {
      // Either Infinity?
      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN); // Either zero?

      if (!xc[0] || !yc[0]) {
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
        ROUNDING_MODE == 3 ? -0 : 0);
      }
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice(); // Determine which is the bigger number.

    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }

      t.reverse(); // Prepend zeros to equalise exponents.

      for (b = a; b--; t.push(0));

      t.reverse();
    } else {
      // Exponents equal. Check digit by digit.
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    } // x < y? Point xc to the array of the bigger number.


    if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;
    b = (j = yc.length) - (i = xc.length); // Append zeros to xc if shorter.
    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.

    if (b > 0) for (; b--; xc[i++] = 0);
    b = BASE - 1; // Subtract yc from xc.

    for (; j > a;) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b);

        --xc[i];
        xc[j] += BASE;
      }

      xc[j] -= yc[j];
    } // Remove leading zeros and adjust exponent accordingly.


    for (; xc[0] == 0; xc.splice(0, 1), --ye); // Zero?


    if (!xc[0]) {
      // Following IEEE 754 (2008) 6.3,
      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    } // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
    // for finite x and y.


    return normalise(y, xc, ye);
  };
  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
   * BigNumber(y, b). The result depends on the value of MODULO_MODE.
   */


  P.modulo = P.mod = function (y, b) {
    var q,
        s,
        x = this;
    y = new BigNumber(y, b); // Return NaN if x is Infinity or NaN, or y is NaN or zero.

    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber(NaN); // Return x if y is Infinity or x is zero.
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber(x);
    }

    if (MODULO_MODE == 9) {
      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // r = x - qy    where  0 <= r < abs(y)
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }

    y = x.minus(q.times(y)); // To match JavaScript %, ensure sign of zero is sign of dividend.

    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
    return y;
  };
  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
   * of BigNumber(y, b).
   */


  P.multipliedBy = P.times = function (y, b) {
    var c,
        e,
        i,
        j,
        k,
        m,
        xcL,
        xlo,
        xhi,
        ycL,
        ylo,
        yhi,
        zc,
        base,
        sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c; // Either NaN, Infinity or 0?

    if (!xc || !yc || !xc[0] || !yc[0]) {
      // Return NaN if either is NaN, or one is 0 and the other is Infinity.
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s; // Return Infinity if either is Infinity.

        if (!xc || !yc) {
          y.c = y.e = null; // Return 0 if either is 0.
        } else {
          y.c = [0];
          y.e = 0;
        }
      }

      return y;
    }

    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length; // Ensure xc points to longer array and xcL to its length.

    if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i; // Initialise the result array with zeros.

    for (i = xcL + ycL, zc = []; i--; zc.push(0));

    base = BASE;
    sqrtBase = SQRT_BASE;

    for (i = ycL; --i >= 0;) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;

      for (k = xcL, j = i + k; j > i;) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }

      zc[j] = c;
    }

    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }

    return normalise(y, zc, e);
  };
  /*
   * Return a new BigNumber whose value is the value of this BigNumber negated,
   * i.e. multiplied by -1.
   */


  P.negated = function () {
    var x = new BigNumber(this);
    x.s = -x.s || null;
    return x;
  };
  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber plus the value of
   * BigNumber(y, b).
   */


  P.plus = function (y, b) {
    var t,
        x = this,
        a = x.s;
    y = new BigNumber(y, b);
    b = y.s; // Either NaN?

    if (!a || !b) return new BigNumber(NaN); // Signs differ?

    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }

    var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

    if (!xe || !ye) {
      // Return Infinity if either Infinity.
      if (!xc || !yc) return new BigNumber(a / 0); // Either zero?
      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.

      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice(); // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.

    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }

      t.reverse();

      for (; a--; t.push(0));

      t.reverse();
    }

    a = xc.length;
    b = yc.length; // Point xc to the longer array, and b to the shorter length.

    if (a - b < 0) t = yc, yc = xc, xc = t, b = a; // Only start adding at yc.length - 1 as the further digits of xc can be ignored.

    for (a = 0; b;) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }

    if (a) {
      xc = [a].concat(xc);
      ++ye;
    } // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    // ye = MAX_EXP + 1 possible


    return normalise(y, xc, ye);
  };
  /*
   * If sd is undefined or null or true or false, return the number of significant digits of
   * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
   * If sd is true include integer-part trailing zeros in the count.
   *
   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
   *                     boolean: whether to count integer-part trailing zeros: true or false.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */


  P.precision = P.sd = function (sd, rm) {
    var c,
        n,
        v,
        x = this;

    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
      return round(new BigNumber(x), sd, rm);
    }

    if (!(c = x.c)) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;

    if (v = c[v]) {
      // Subtract the number of trailing zeros of the last element.
      for (; v % 10 == 0; v /= 10, n--); // Add the number of digits of the first element.


      for (v = c[0]; v >= 10; v /= 10, n++);
    }

    if (sd && x.e + 1 > n) n = x.e + 1;
    return n;
  };
  /*
   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
   *
   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
   */


  P.shiftedBy = function (k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times('1e' + k);
  };
  /*
   *  sqrt(-n) =  N
   *  sqrt(N) =  N
   *  sqrt(-I) =  N
   *  sqrt(I) =  I
   *  sqrt(0) =  0
   *  sqrt(-0) = -0
   *
   * Return a new BigNumber whose value is the square root of the value of this BigNumber,
   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */


  P.squareRoot = P.sqrt = function () {
    var m,
        n,
        r,
        rep,
        t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5'); // Negative/NaN/Infinity/zero?

    if (s !== 1 || !c || !c[0]) {
      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    } // Initial estimate.


    s = Math.sqrt(+valueOf(x)); // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.

    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new BigNumber(n);
    } else {
      r = new BigNumber(s + '');
    } // Check for zero.
    // r could be zero if MIN_EXP is changed after the this value was created.
    // This would cause a division by zero (x/t) and hence Infinity below, which would cause
    // coeffToString to throw.


    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3) s = 0; // Newton-Raphson iteration.

      for (;;) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));

        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          // The exponent of r may here be one less than the final result exponent,
          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
          // are indexed correctly.
          if (r.e < e) --s;
          n = n.slice(s - 3, s + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
          // iteration.

          if (n == '9999' || !rep && n == '4999') {
            // On the first iteration only, check to see if rounding up gives the
            // exact result as the nines may infinitely repeat.
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);

              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }

            dp += 4;
            s += 4;
            rep = 1;
          } else {
            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
            // result. If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
              // Truncate to the first rounding digit.
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }

            break;
          }
        }
      }
    }

    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  /*
   * Return a string representing the value of this BigNumber in exponential notation and
   * rounded using ROUNDING_MODE to dp fixed decimal places.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */


  P.toExponential = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }

    return format(this, dp, rm, 1);
  };
  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounding
   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
   * but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */


  P.toFixed = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }

    return format(this, dp, rm);
  };
  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounded
   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
   * of the format or FORMAT object (see BigNumber.set).
   *
   * The formatting object may contain some or all of the properties shown below.
   *
   * FORMAT = {
   *   prefix: '',
   *   groupSize: 3,
   *   secondaryGroupSize: 0,
   *   groupSeparator: ',',
   *   decimalSeparator: '.',
   *   fractionGroupSize: 0,
   *   fractionGroupSeparator: '\xA0',      // non-breaking space
   *   suffix: ''
   * };
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   * [format] {object} Formatting options. See FORMAT pbject above.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   * '[BigNumber Error] Argument not an object: {format}'
   */


  P.toFormat = function (dp, rm, format) {
    var str,
        x = this;

    if (format == null) {
      if (dp != null && rm && typeof rm == 'object') {
        format = rm;
        rm = null;
      } else if (dp && typeof dp == 'object') {
        format = dp;
        dp = rm = null;
      } else {
        format = FORMAT;
      }
    } else if (typeof format != 'object') {
      throw Error(bignumberError + 'Argument not an object: ' + format);
    }

    str = x.toFixed(dp, rm);

    if (x.c) {
      var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;
      if (g2) i = g1, g1 = g2, g2 = i, len -= i;

      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);

        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);

        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = '-' + intPart;
      }

      str = fractionPart ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'), '$&' + (format.fractionGroupSeparator || '')) : fractionPart) : intPart;
    }

    return (format.prefix || '') + str + (format.suffix || '');
  };
  /*
   * Return an array of two BigNumbers representing the value of this BigNumber as a simple
   * fraction with an integer numerator and an integer denominator.
   * The denominator will be a positive non-zero value less than or equal to the specified
   * maximum denominator. If a maximum denominator is not specified, the denominator will be
   * the lowest value necessary to represent the number exactly.
   *
   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
   *
   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
   */


  P.toFraction = function (md) {
    var d,
        d0,
        d1,
        d2,
        e,
        exp,
        n,
        n0,
        n1,
        q,
        r,
        s,
        x = this,
        xc = x.c;

    if (md != null) {
      n = new BigNumber(md); // Throw if md is less than one or is not an integer, unless it is Infinity.

      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error(bignumberError + 'Argument ' + (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
      }
    }

    if (!xc) return new BigNumber(x);
    d = new BigNumber(ONE);
    n1 = d0 = new BigNumber(ONE);
    d1 = n0 = new BigNumber(ONE);
    s = coeffToString(xc); // Determine initial denominator.
    // d is a power of 10 and the minimum max denominator that specifies the value exactly.

    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber(s); // n0 = d1 = 0

    n0.c[0] = 0;

    for (;;) {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }

    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2; // Determine which fraction is closer to x, n0/d0 or n1/d1

    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  /*
   * Return the value of this BigNumber converted to a number primitive.
   */


  P.toNumber = function () {
    return +valueOf(this);
  };
  /*
   * Return a string representing the value of this BigNumber rounded to sd significant digits
   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
   * necessary to represent the integer part of the value in fixed-point notation, then use
   * exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */


  P.toPrecision = function (sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  /*
   * Return a string representing the value of this BigNumber in base b, or base 10 if b is
   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
   * TO_EXP_NEG, return exponential notation.
   *
   * [b] {number} Integer, 2 to ALPHABET.length inclusive.
   *
   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
   */


  P.toString = function (b) {
    var str,
        n = this,
        s = n.s,
        e = n.e; // Infinity or NaN?

    if (e === null) {
      if (s) {
        str = 'Infinity';
        if (s < 0) str = '-' + str;
      } else {
        str = 'NaN';
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, '0');
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, '0');
      } else {
        intCheck(b, 2, ALPHABET.length, 'Base');
        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
      }

      if (s < 0 && n.c[0]) str = '-' + str;
    }

    return str;
  };
  /*
   * Return as toString, but do not accept a base argument, and include the minus sign for
   * negative zero.
   */


  P.valueOf = P.toJSON = function () {
    return valueOf(this);
  };

  P._isBigNumber = true;
  P[Symbol.toStringTag] = 'BigNumber'; // Node.js v10.12.0+

  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;
  if (configObject != null) BigNumber.set(configObject);
  return BigNumber;
} // PRIVATE HELPER FUNCTIONS
// These functions don't need access to variables,
// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
} // Return a coefficient array as a string of base 10 digits.


function coeffToString(a) {
  var s,
      z,
      i = 1,
      j = a.length,
      r = a[0] + '';

  for (; i < j;) {
    s = a[i++] + '';
    z = LOG_BASE - s.length;

    for (; z--; s = '0' + s);

    r += s;
  } // Determine trailing zeros.


  for (j = r.length; r.charCodeAt(--j) === 48;);

  return r.slice(0, j + 1 || 1);
} // Compare the value of BigNumbers x and y.


function compare(x, y) {
  var a,
      b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e; // Either NaN?

  if (!i || !j) return null;
  a = xc && !xc[0];
  b = yc && !yc[0]; // Either zero?

  if (a || b) return a ? b ? 0 : -j : i; // Signs differ?

  if (i != j) return i;
  a = i < 0;
  b = k == l; // Either Infinity?

  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1; // Compare exponents.

  if (!b) return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l; // Compare digit by digit.

  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1; // Compare lengths.


  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
/*
 * Check that n is a primitive number, an integer, and in range, otherwise throw.
 */


function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ? n < min || n > max ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n));
  }
} // Assumes finite n.


function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}

function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e;
}

function toFixedPoint(str, e, z) {
  var len, zs; // Negative exponent?

  if (e < 0) {
    // Prepend zeros.
    for (zs = z + '.'; ++e; zs += z);

    str = zs + str; // Positive exponent
  } else {
    len = str.length; // Append zeros.

    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z);

      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + '.' + str.slice(e);
    }
  }

  return str;
} // EXPORT


var BigNumber = clone();

var _excluded$1 = ["value", "enforcePrecision"];
var DEFAULT_PRECISION = 2;
var DEFAULT_DELIMITER = ",";
var DEFAULT_SEPARATOR = "\xA0";
var Number$1 = function Number(_ref) {
  var value = _ref.value,
      _ref$enforcePrecision = _ref.enforcePrecision,
      enforcePrecision = _ref$enforcePrecision === void 0 ? true : _ref$enforcePrecision,
      options = _objectWithoutProperties$1(_ref, _excluded$1);

  var instance = new BigNumber(value);
  var format = {
    groupSize: 3
  };
  var precision = options.precision == null ? DEFAULT_PRECISION : options.precision;
  format.decimalSeparator = options.delimiter == null ? DEFAULT_DELIMITER : options.delimiter;
  format.groupSeparator = options.separator == null ? DEFAULT_SEPARATOR : options.separator;
  var string = instance.toFormat(precision, undefined, format);
  return enforcePrecision ? string : string.replace(new RegExp("(\\".concat(DEFAULT_DELIMITER, "\\d+)0+")), "$1");
};

var _excluded = ["money", "precision"];

var Money = function Money(_ref) {
  var _ref$money = _slicedToArray$s(_ref.money, 2),
      amount = _ref$money[0],
      currency = _ref$money[1],
      _ref$precision = _ref.precision,
      precision = _ref$precision === void 0 ? 2 : _ref$precision,
      options = _objectWithoutProperties$1(_ref, _excluded);

  return /*#__PURE__*/React__default.createElement(Fragment, null, /*#__PURE__*/React__default.createElement(Number$1, _extends$J({
    value: amount
  }, options, {
    precision: precision
  })), " ", currency);
};

Money.build = function (amount, currency) {
  return /*#__PURE__*/React__default.createElement(Money, {
    money: [amount, currency]
  });
};

function _extends$e() {
  _extends$e = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$e.apply(this, arguments);
}

function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _arrayLikeToArray$1$2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$6(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1$2(arr);
}

function _iterableToArray$6(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$1$2(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$2(o, minLen);
}

function _nonIterableSpread$6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$6(arr) {
  return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$1$2(arr) || _nonIterableSpread$6();
}

function _arrayWithHoles$a(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$a(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$a() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$a(arr, i) {
  return _arrayWithHoles$a(arr) || _iterableToArrayLimit$a(arr, i) || _unsupportedIterableToArray$1$2(arr, i) || _nonIterableRest$a();
}

var Checkbox = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$a(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var elementRef = React.useRef(null);
  var inputRef = React.useRef(props.inputRef);

  var onClick = function onClick(event) {
    if (!props.disabled && !props.readOnly && props.onChange) {
      var _checked = isChecked();

      var checkboxClicked = event.target instanceof HTMLDivElement || event.target instanceof HTMLSpanElement;
      var isInputToggled = event.target === inputRef.current;
      var isCheckboxToggled = checkboxClicked && event.target.checked !== _checked;

      if (isInputToggled || isCheckboxToggled) {
        var value = _checked ? props.falseValue : props.trueValue;
        props.onChange({
          originalEvent: event,
          value: props.value,
          checked: value,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            type: 'checkbox',
            name: props.name,
            id: props.id,
            value: props.value,
            checked: value
          }
        });
      }

      DomHandler.focus(inputRef.current);
      event.preventDefault();
    }
  };

  var onFocus = function onFocus() {
    setFocusedState(true);
  };

  var onBlur = function onBlur() {
    setFocusedState(false);
  };

  var onKeyDown = function onKeyDown(event) {
    if (event.code === 'Space') {
      onClick(event);
    }
  };

  var isChecked = function isChecked() {
    return props.checked === props.trueValue;
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      },
      getInput: function getInput() {
        return inputRef.current;
      }
    };
  });
  React.useEffect(function () {
    ObjectUtils.combinedRefs(inputRef, props.inputRef);
  }, [inputRef, props.inputRef]);
  useUpdateEffect(function () {
    inputRef.current.checked = isChecked();
  }, [props.checked, props.trueValue]);
  var checked = isChecked();
  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, Checkbox.defaultProps);
  var dataProps = ObjectUtils.reduceKeys(otherProps, DomHandler.DATA_PROPS);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var className = classNames('p-checkbox p-component', {
    'p-checkbox-checked': checked,
    'p-checkbox-disabled': props.disabled,
    'p-checkbox-focused': focusedState
  }, props.className);
  var boxClass = classNames('p-checkbox-box', {
    'p-highlight': checked,
    'p-disabled': props.disabled,
    'p-focus': focusedState
  });
  var icon = IconUtils.getJSXIcon(checked ? props.icon : '', {
    className: 'p-checkbox-icon p-c'
  }, {
    props: props,
    checked: checked
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends$e({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style
  }, otherProps, {
    onClick: onClick,
    onContextMenu: props.onContextMenu,
    onMouseDown: props.onMouseDown
  }), /*#__PURE__*/React.createElement("div", {
    className: "p-hidden-accessible"
  }, /*#__PURE__*/React.createElement("input", _extends$e({
    ref: inputRef,
    type: "checkbox",
    id: props.inputId,
    name: props.name,
    tabIndex: props.tabIndex,
    defaultChecked: checked,
    onFocus: onFocus,
    onBlur: onBlur,
    onKeyDown: onKeyDown,
    disabled: props.disabled,
    readOnly: props.readOnly,
    required: props.required
  }, ariaProps, dataProps))), /*#__PURE__*/React.createElement("div", {
    className: boxClass
  }, icon)), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$e({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
Checkbox.displayName = 'Checkbox';
Checkbox.defaultProps = {
  __TYPE: 'Checkbox',
  id: null,
  inputRef: null,
  inputId: null,
  value: null,
  name: null,
  checked: false,
  trueValue: true,
  falseValue: false,
  style: null,
  className: null,
  disabled: false,
  required: false,
  readOnly: false,
  tabIndex: null,
  icon: 'pi pi-check',
  tooltip: null,
  tooltipOptions: null,
  onChange: null,
  onMouseDown: null,
  onContextMenu: null
};
var MultiSelectHeader = /*#__PURE__*/React.memo(function (props) {
  var filterOptions = {
    filter: function filter(e) {
      return onFilter(e);
    },
    reset: function reset() {
      return props.resetFilter();
    }
  };

  var onFilter = function onFilter(event) {
    if (props.onFilter) {
      props.onFilter({
        originalEvent: event,
        query: event.target.value
      });
    }
  };

  var onSelectAll = function onSelectAll(event) {
    if (props.onSelectAll) {
      props.onSelectAll({
        originalEvent: event,
        checked: props.selectAll
      });
    }

    event.preventDefault();
  };

  var createFilterElement = function createFilterElement() {
    if (props.filter) {
      var containerClassName = classNames('p-multiselect-filter-container');
      var content = /*#__PURE__*/React.createElement("div", {
        className: containerClassName
      }, /*#__PURE__*/React.createElement(InputText$1, {
        type: "text",
        role: "textbox",
        value: props.filterValue,
        onChange: onFilter,
        className: "p-multiselect-filter",
        placeholder: props.filterPlaceholder
      }), /*#__PURE__*/React.createElement("span", {
        className: "p-multiselect-filter-icon pi pi-search"
      }));

      if (props.filterTemplate) {
        var defaultContentOptions = {
          className: containerClassName,
          element: content,
          filterOptions: filterOptions,
          onFilter: onFilter,
          filterIconClassName: 'p-multeselect-filter-icon pi pi-search',
          props: props
        };
        content = ObjectUtils.getJSXElement(props.filterTemplate, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement(React.Fragment, null, content);
    }

    return null;
  };

  var filterElement = createFilterElement();
  var checkboxElement = props.showSelectAll && /*#__PURE__*/React.createElement(Checkbox, {
    checked: props.selectAll,
    onChange: onSelectAll,
    role: "checkbox",
    "aria-checked": props.selectAll
  });
  var closeElement = /*#__PURE__*/React.createElement("button", {
    type: "button",
    className: "p-multiselect-close p-link",
    "aria-label": localeOption$1('close'),
    onClick: props.onClose
  }, /*#__PURE__*/React.createElement("span", {
    className: "p-multiselect-close-icon pi pi-times",
    "aria-hidden": "true"
  }), /*#__PURE__*/React.createElement(Ripple, null));
  var element = /*#__PURE__*/React.createElement("div", {
    className: "p-multiselect-header"
  }, checkboxElement, filterElement, closeElement);

  if (props.template) {
    var defaultOptions = {
      className: 'p-multiselect-header',
      checkboxElement: checkboxElement,
      checked: props.selectAll,
      onChange: onSelectAll,
      filterElement: filterElement,
      closeElement: closeElement,
      closeElementClassName: 'p-multiselect-close p-link',
      closeIconClassName: 'p-multiselect-close-icon pi pi-times',
      onCloseClick: props.onClose,
      element: element,
      props: props
    };
    return ObjectUtils.getJSXElement(props.template, defaultOptions);
  }

  return element;
});
MultiSelectHeader.displayName = 'MultiSelectHeader';
var MultiSelectItem = /*#__PURE__*/React.memo(function (props) {
  var onClick = function onClick(event) {
    if (props.onClick) {
      props.onClick({
        originalEvent: event,
        option: props.option
      });
    }

    event.preventDefault();
  };

  var onKeyDown = function onKeyDown(event) {
    if (props.onKeyDown) {
      props.onKeyDown({
        originalEvent: event,
        option: props.option
      });
    }
  };

  var className = classNames('p-multiselect-item', {
    'p-highlight': props.selected,
    'p-disabled': props.disabled
  }, props.option.className);
  var checkboxClassName = classNames('p-checkbox-box', {
    'p-highlight': props.selected
  });
  var checkboxIcon = classNames('p-checkbox-icon p-c', {
    'pi pi-check': props.selected
  });
  var content = props.template ? ObjectUtils.getJSXElement(props.template, props.option) : props.label;
  var tabIndex = props.disabled ? null : props.tabIndex || 0;
  return /*#__PURE__*/React.createElement("li", {
    className: className,
    style: props.style,
    onClick: onClick,
    tabIndex: tabIndex,
    onKeyDown: onKeyDown,
    role: "option",
    "aria-selected": props.selected
  }, /*#__PURE__*/React.createElement("div", {
    className: "p-checkbox p-component"
  }, /*#__PURE__*/React.createElement("div", {
    className: checkboxClassName
  }, /*#__PURE__*/React.createElement("span", {
    className: checkboxIcon
  }))), /*#__PURE__*/React.createElement("span", null, content), /*#__PURE__*/React.createElement(Ripple, null));
});
MultiSelectItem.displayName = 'MultiSelectItem';

function ownKeys$1$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1$2(Object(source), !0).forEach(function (key) {
      _defineProperty$5(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$2(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var MultiSelectPanel = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var virtualScrollerRef = React.useRef(null);

  var onEnter = function onEnter() {
    props.onEnter(function () {
      if (virtualScrollerRef.current) {
        var selectedIndex = props.getSelectedOptionIndex();

        if (selectedIndex !== -1) {
          setTimeout(function () {
            return virtualScrollerRef.current.scrollToIndex(selectedIndex);
          }, 0);
        }
      }
    });
  };

  var onFilterInputChange = function onFilterInputChange(event) {
    if (virtualScrollerRef.current) {
      virtualScrollerRef.current.scrollToIndex(0);
    }

    props.onFilterInputChange && props.onFilterInputChange(event);
  };

  var isEmptyFilter = function isEmptyFilter() {
    return !(props.visibleOptions && props.visibleOptions.length) && props.hasFilter;
  };

  var createHeader = function createHeader() {
    return /*#__PURE__*/React.createElement(MultiSelectHeader, {
      filter: props.filter,
      filterValue: props.filterValue,
      filterTemplate: props.filterTemplate,
      onFilter: onFilterInputChange,
      filterPlaceholder: props.filterPlaceholder,
      onClose: props.onCloseClick,
      showSelectAll: props.showSelectAll,
      selectAll: props.isAllSelected(),
      onSelectAll: props.onSelectAll,
      template: props.panelHeaderTemplate
    });
  };

  var createFooter = function createFooter() {
    if (props.panelFooterTemplate) {
      var content = ObjectUtils.getJSXElement(props.panelFooterTemplate, props, props.onOverlayHide);
      return /*#__PURE__*/React.createElement("div", {
        className: "p-multiselect-footer"
      }, content);
    }

    return null;
  };

  var createGroupChildren = function createGroupChildren(optionGroup, style) {
    var groupChildren = props.getOptionGroupChildren(optionGroup);
    return groupChildren.map(function (option, j) {
      var optionLabel = props.getOptionLabel(option);
      var optionKey = j + '_' + props.getOptionRenderKey(option);
      var disabled = props.isOptionDisabled(option);
      var tabIndex = disabled ? null : props.tabIndex || 0;
      var selected = props.isSelected(option);
      return /*#__PURE__*/React.createElement(MultiSelectItem, {
        key: optionKey,
        label: optionLabel,
        option: option,
        style: style,
        template: props.itemTemplate,
        selected: selected,
        onClick: props.onOptionSelect,
        onKeyDown: props.onOptionKeyDown,
        tabIndex: tabIndex,
        disabled: disabled
      });
    });
  };

  var createEmptyFilter = function createEmptyFilter() {
    var emptyFilterMessage = ObjectUtils.getJSXElement(props.emptyFilterMessage, props) || localeOption$1('emptyFilterMessage');
    return /*#__PURE__*/React.createElement("li", {
      className: "p-multiselect-empty-message"
    }, emptyFilterMessage);
  };

  var createItem = function createItem(option, index) {
    var scrollerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var style = {
      height: scrollerOptions.props ? scrollerOptions.props.itemSize : undefined
    };

    if (props.optionGroupLabel) {
      var groupContent = props.optionGroupTemplate ? ObjectUtils.getJSXElement(props.optionGroupTemplate, option, index) : props.getOptionGroupLabel(option);
      var groupChildrenContent = createGroupChildren(option, style);
      var key = index + '_' + props.getOptionGroupRenderKey(option);
      return /*#__PURE__*/React.createElement(React.Fragment, {
        key: key
      }, /*#__PURE__*/React.createElement("li", {
        className: "p-multiselect-item-group",
        style: style
      }, groupContent), groupChildrenContent);
    } else {
      var optionLabel = props.getOptionLabel(option);
      var optionKey = index + '_' + props.getOptionRenderKey(option);
      var disabled = props.isOptionDisabled(option);
      var tabIndex = disabled ? null : props.tabIndex || 0;
      var selected = props.isSelected(option);
      return /*#__PURE__*/React.createElement(MultiSelectItem, {
        key: optionKey,
        label: optionLabel,
        option: option,
        style: style,
        template: props.itemTemplate,
        selected: selected,
        onClick: props.onOptionSelect,
        onKeyDown: props.onOptionKeyDown,
        tabIndex: tabIndex,
        disabled: disabled
      });
    }
  };

  var createItems = function createItems() {
    if (ObjectUtils.isNotEmpty(props.visibleOptions)) {
      return props.visibleOptions.map(createItem);
    } else if (props.hasFilter) {
      return createEmptyFilter();
    }

    return null;
  };

  var createContent = function createContent() {
    if (props.virtualScrollerOptions) {
      var virtualScrollerProps = _objectSpread$1$2(_objectSpread$1$2({}, props.virtualScrollerOptions), {
        style: _objectSpread$1$2(_objectSpread$1$2({}, props.virtualScrollerOptions.style), {
          height: props.scrollHeight
        }),
        className: classNames('p-multiselect-items-wrapper', props.virtualScrollerOptions.className),
        items: props.visibleOptions,
        autoSize: true,
        onLazyLoad: function onLazyLoad(event) {
          return props.virtualScrollerOptions.onLazyLoad(_objectSpread$1$2(_objectSpread$1$2({}, event), {
            filter: props.filterValue
          }));
        },
        itemTemplate: function itemTemplate(item, options) {
          return item && createItem(item, options.index, options);
        },
        contentTemplate: function contentTemplate(options) {
          var className = classNames('p-multiselect-items p-component', options.className);
          var content = isEmptyFilter() ? createEmptyFilter() : options.children;
          return /*#__PURE__*/React.createElement("ul", {
            ref: options.contentRef,
            className: className,
            role: "listbox",
            "aria-multiselectable": true
          }, content);
        }
      });

      return /*#__PURE__*/React.createElement(VirtualScroller, _extends$e({
        ref: virtualScrollerRef
      }, virtualScrollerProps));
    } else {
      var items = createItems();
      return /*#__PURE__*/React.createElement("div", {
        className: "p-multiselect-items-wrapper",
        style: {
          maxHeight: props.scrollHeight
        }
      }, /*#__PURE__*/React.createElement("ul", {
        className: "p-multiselect-items p-component",
        role: "listbox",
        "aria-multiselectable": true
      }, items));
    }
  };

  var createElement = function createElement() {
    var allowOptionSelect = props.allowOptionSelect();
    var panelClassName = classNames('p-multiselect-panel p-component', {
      'p-multiselect-limited': !allowOptionSelect
    }, props.panelClassName);
    var header = createHeader();
    var content = createContent();
    var footer = createFooter();
    return /*#__PURE__*/React.createElement(CSSTransition, {
      nodeRef: ref,
      classNames: "p-connected-overlay",
      "in": props["in"],
      timeout: {
        enter: 120,
        exit: 100
      },
      options: props.transitionOptions,
      unmountOnExit: true,
      onEnter: onEnter,
      onEntered: props.onEntered,
      onExit: props.onExit,
      onExited: props.onExited
    }, /*#__PURE__*/React.createElement("div", {
      ref: ref,
      className: panelClassName,
      style: props.panelStyle,
      onClick: props.onClick
    }, header, content, footer));
  };

  var element = createElement();
  return /*#__PURE__*/React.createElement(Portal, {
    element: element,
    appendTo: props.appendTo
  });
}));
MultiSelectPanel.displayName = 'MultiSelectPanel';

function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) {
      _defineProperty$5(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createForOfIteratorHelper$5(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$e(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$e(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$e(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(o, minLen);
}

function _arrayLikeToArray$e(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var MultiSelect$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(''),
      _React$useState2 = _slicedToArray$a(_React$useState, 2),
      filterState = _React$useState2[0],
      setFilterState = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _React$useState4 = _slicedToArray$a(_React$useState3, 2),
      focusedState = _React$useState4[0],
      setFocusedState = _React$useState4[1];

  var _React$useState5 = React.useState(false),
      _React$useState6 = _slicedToArray$a(_React$useState5, 2),
      overlayVisibleState = _React$useState6[0],
      setOverlayVisibleState = _React$useState6[1];

  var elementRef = React.useRef(null);
  var inputRef = React.useRef(props.inputRef);
  var labelRef = React.useRef(null);
  var overlayRef = React.useRef(null);
  var hasFilter = filterState && filterState.trim().length > 0;
  var empty = ObjectUtils.isEmpty(props.value);
  var equalityKey = props.optionValue ? null : props.dataKey;

  var _useOverlayListener = useOverlayListener({
    target: elementRef,
    overlay: overlayRef,
    listener: function listener(event, _ref) {
      var type = _ref.type,
          valid = _ref.valid;

      if (valid) {
        type === 'outside' ? !isClearClicked(event) && hide() : hide();
      }
    },
    when: overlayVisibleState
  }),
      _useOverlayListener2 = _slicedToArray$a(_useOverlayListener, 2),
      bindOverlayListener = _useOverlayListener2[0],
      unbindOverlayListener = _useOverlayListener2[1];

  var onPanelClick = function onPanelClick(event) {
    OverlayService.emit('overlay-click', {
      originalEvent: event,
      target: elementRef.current
    });
  };

  var allowOptionSelect = function allowOptionSelect() {
    return !props.selectionLimit || !props.value || props.value && props.value.length < props.selectionLimit;
  };

  var onOptionSelect = function onOptionSelect(event) {
    var originalEvent = event.originalEvent,
        option = event.option;

    if (props.disabled || isOptionDisabled(option)) {
      return;
    }

    var optionValue = getOptionValue(option);
    var isUsed = isOptionValueUsed(option);
    var selected = isSelected(option);
    var allowSelect = allowOptionSelect();
    if (selected) updateModel(originalEvent, props.value.filter(function (val) {
      return !ObjectUtils.equals(isUsed ? val : getOptionValue(val), optionValue, equalityKey);
    }));else if (allowSelect) updateModel(originalEvent, [].concat(_toConsumableArray$6(props.value || []), [optionValue]));
  };

  var onOptionKeyDown = function onOptionKeyDown(event) {
    var originalEvent = event.originalEvent;
    var listItem = originalEvent.currentTarget;

    switch (originalEvent.which) {
      //down
      case 40:
        var nextItem = findNextItem(listItem);
        nextItem && nextItem.focus();
        originalEvent.preventDefault();
        break;
      //up

      case 38:
        var prevItem = findPrevItem(listItem);
        prevItem && prevItem.focus();
        originalEvent.preventDefault();
        break;
      //enter and space

      case 13:
      case 32:
        onOptionSelect(event);
        originalEvent.preventDefault();
        break;
      //escape

      case 27:
        hide();
        DomHandler.focus(inputRef.current);
        break;
    }
  };

  var findNextItem = function findNextItem(item) {
    var nextItem = item.nextElementSibling;
    return nextItem ? DomHandler.hasClass(nextItem, 'p-disabled') || DomHandler.hasClass(nextItem, 'p-multiselect-item-group') ? findNextItem(nextItem) : nextItem : null;
  };

  var findPrevItem = function findPrevItem(item) {
    var prevItem = item.previousElementSibling;
    return prevItem ? DomHandler.hasClass(prevItem, 'p-disabled') || DomHandler.hasClass(prevItem, 'p-multiselect-item-group') ? findPrevItem(prevItem) : prevItem : null;
  };

  var onClick = function onClick(event) {
    if (!props.disabled && !isPanelClicked(event) && !DomHandler.hasClass(event.target, 'p-multiselect-token-icon') && !isClearClicked(event)) {
      overlayVisibleState ? hide() : show();
      DomHandler.focus(inputRef.current);
      event.preventDefault();
    }
  };

  var onKeyDown = function onKeyDown(event) {
    switch (event.which) {
      //down
      case 40:
        if (!overlayVisibleState && event.altKey) {
          show();
          event.preventDefault();
        }

        break;
      //space

      case 32:
        overlayVisibleState ? hide() : show();
        event.preventDefault();
        break;
      //escape

      case 27:
        hide();
        break;
      //tab

      case 9:
        if (overlayVisibleState) {
          var firstFocusableElement = DomHandler.getFirstFocusableElement(overlayRef.current);

          if (firstFocusableElement) {
            firstFocusableElement.focus();
            event.preventDefault();
          }
        }

        break;
    }
  };

  var onSelectAll = function onSelectAll(event) {
    if (props.onSelectAll) {
      props.onSelectAll(event);
    } else {
      var value = null;

      if (event.checked) {
        value = [];

        if (visibleOptions) {
          var selectedOptions = visibleOptions.filter(function (option) {
            return isOptionDisabled(option) && isSelected(option);
          });
          value = selectedOptions.map(function (option) {
            return getOptionValue(option);
          });
        }
      } else if (visibleOptions) {
        var options = visibleOptions.filter(function (option) {
          return !isOptionDisabled(option);
        });

        if (props.optionGroupLabel) {
          value = [];
          options.forEach(function (optionGroup) {
            return value = [].concat(_toConsumableArray$6(value), _toConsumableArray$6(getOptionGroupChildren(optionGroup).filter(function (option) {
              return !isOptionDisabled(option);
            }).map(function (option) {
              return getOptionValue(option);
            })));
          });
        } else {
          value = options.map(function (option) {
            return getOptionValue(option);
          });
        }
      }

      updateModel(event.originalEvent, value);
    }
  };

  var updateModel = function updateModel(event, value) {
    if (props.onChange) {
      props.onChange({
        originalEvent: event,
        value: value,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        target: {
          name: props.name,
          id: props.id,
          value: value
        }
      });
    }
  };

  var onFilterInputChange = function onFilterInputChange(event) {
    var filter = event.query;
    setFilterState(filter);

    if (props.onFilter) {
      props.onFilter({
        originalEvent: event,
        filter: filter
      });
    }
  };

  var resetFilter = function resetFilter() {
    setFilterState('');
    props.onFilter && props.onFilter({
      filter: ''
    });
  };

  var scrollInView = function scrollInView() {
    var highlightItem = DomHandler.findSingle(overlayRef.current, 'li.p-highlight');

    if (highlightItem && highlightItem.scrollIntoView) {
      highlightItem.scrollIntoView({
        block: 'nearest',
        inline: 'nearest'
      });
    }
  };

  var show = function show() {
    setOverlayVisibleState(true);
  };

  var hide = function hide() {
    setOverlayVisibleState(false);
  };

  var onOverlayEnter = function onOverlayEnter(callback) {
    ZIndexUtils.set('overlay', overlayRef.current, PrimeReact$1.autoZIndex, PrimeReact$1.zIndex['overlay']);
    alignOverlay();
    scrollInView();
    callback && callback();
  };

  var onOverlayEntered = function onOverlayEntered() {
    bindOverlayListener();
    props.onShow && props.onShow();
  };

  var onOverlayExit = function onOverlayExit() {
    unbindOverlayListener();
  };

  var onOverlayExited = function onOverlayExited() {
    if (props.filter && props.resetFilterOnHide) {
      resetFilter();
    }

    ZIndexUtils.clear(overlayRef.current);
    props.onHide && props.onHide();
  };

  var alignOverlay = function alignOverlay() {
    DomHandler.alignOverlay(overlayRef.current, labelRef.current.parentElement, props.appendTo || PrimeReact$1.appendTo);
  };

  var isClearClicked = function isClearClicked(event) {
    return DomHandler.hasClass(event.target, 'p-multiselect-clear-icon');
  };

  var isPanelClicked = function isPanelClicked(event) {
    return overlayRef.current && overlayRef.current.contains(event.target);
  };

  var onCloseClick = function onCloseClick(event) {
    hide();
    DomHandler.focus(inputRef.current);
    event.preventDefault();
    event.stopPropagation();
  };

  var getSelectedOptionIndex = function getSelectedOptionIndex() {
    if (props.value != null && props.options) {
      if (props.optionGroupLabel) {
        var groupIndex = 0;
        var optionIndex = props.options.findIndex(function (optionGroup, i) {
          return (groupIndex = i) && findOptionIndexInList(props.value, getOptionGroupChildren(optionGroup)) !== -1;
        });
        return optionIndex !== -1 ? {
          group: groupIndex,
          option: optionIndex
        } : -1;
      } else {
        return findOptionIndexInList(props.value, props.options);
      }
    }

    return -1;
  };

  var findOptionIndexInList = function findOptionIndexInList(value, list) {
    return list.findIndex(function (item) {
      return value.some(function (val) {
        return ObjectUtils.equals(val, getOptionValue(item), equalityKey);
      });
    });
  };

  var isSelected = function isSelected(option) {
    if (props.value) {
      var optionValue = getOptionValue(option);
      var isUsed = isOptionValueUsed(option);
      return props.value.some(function (val) {
        return ObjectUtils.equals(isUsed ? val : getOptionValue(val), optionValue, equalityKey);
      });
    }

    return false;
  };

  var getLabelByValue = function getLabelByValue(val) {
    var option;

    if (props.options) {
      if (props.optionGroupLabel) {
        var _iterator = _createForOfIteratorHelper$5(props.options),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var optionGroup = _step.value;
            option = findOptionByValue(val, getOptionGroupChildren(optionGroup));

            if (option) {
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        option = findOptionByValue(val, props.options);
      }
    }

    return option ? getOptionLabel(option) : null;
  };

  var findOptionByValue = function findOptionByValue(val, list) {
    return list.find(function (option) {
      return ObjectUtils.equals(getOptionValue(option), val, equalityKey);
    });
  };

  var onFocus = function onFocus(event) {
    setFocusedState(true);
    props.onFocus && props.onFocus(event);
  };

  var onBlur = function onBlur(event) {
    setFocusedState(false);
    props.onBlur && props.onBlur(event);
  };

  var isAllSelected = function isAllSelected() {
    if (props.onSelectAll) {
      return props.selectAll;
    } else {
      if (ObjectUtils.isEmpty(visibleOptions)) {
        return false;
      }

      var options = visibleOptions.filter(function (option) {
        return !isOptionDisabled(option);
      });

      if (props.optionGroupLabel) {
        var _iterator2 = _createForOfIteratorHelper$5(options),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var optionGroup = _step2.value;
            var visibleOptionsGroupChildren = getOptionGroupChildren(optionGroup).filter(function (option) {
              return !isOptionDisabled(option);
            });
            return !visibleOptionsGroupChildren.some(function (option) {
              return !isSelected(option);
            });
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else {
        return !options.some(function (option) {
          return !isSelected(option);
        });
      }
    }

    return true;
  };

  var getOptionLabel = function getOptionLabel(option) {
    return props.optionLabel ? ObjectUtils.resolveFieldData(option, props.optionLabel) : option && option['label'] !== undefined ? option['label'] : option;
  };

  var getOptionValue = function getOptionValue(option) {
    if (props.optionValue) {
      var data = ObjectUtils.resolveFieldData(option, props.optionValue);
      return data !== null ? data : option;
    }

    return option && option['value'] !== undefined ? option['value'] : option;
  };

  var getOptionRenderKey = function getOptionRenderKey(option) {
    return props.dataKey ? ObjectUtils.resolveFieldData(option, props.dataKey) : getOptionLabel(option);
  };

  var getOptionGroupRenderKey = function getOptionGroupRenderKey(optionGroup) {
    return ObjectUtils.resolveFieldData(optionGroup, props.optionGroupLabel);
  };

  var getOptionGroupLabel = function getOptionGroupLabel(optionGroup) {
    return ObjectUtils.resolveFieldData(optionGroup, props.optionGroupLabel);
  };

  var getOptionGroupChildren = function getOptionGroupChildren(optionGroup) {
    return ObjectUtils.resolveFieldData(optionGroup, props.optionGroupChildren);
  };

  var isOptionDisabled = function isOptionDisabled(option) {
    if (props.optionDisabled) {
      return ObjectUtils.isFunction(props.optionDisabled) ? props.optionDisabled(option) : ObjectUtils.resolveFieldData(option, props.optionDisabled);
    }

    return option && option['disabled'] !== undefined ? option['disabled'] : false;
  };

  var isOptionValueUsed = function isOptionValueUsed(option) {
    return props.optionValue || option && option['value'] !== undefined;
  };

  var removeChip = function removeChip(event, item) {
    var value = props.value.filter(function (val) {
      return !ObjectUtils.equals(val, item, equalityKey);
    });
    updateModel(event, value);
  };

  var getSelectedItemsLabel = function getSelectedItemsLabel() {
    var pattern = /{(.*?)}/;

    if (pattern.test(props.selectedItemsLabel)) {
      return props.selectedItemsLabel.replace(props.selectedItemsLabel.match(pattern)[0], props.value.length + '');
    }

    return props.selectedItemsLabel;
  };

  var getLabel = function getLabel() {
    var label;

    if (!empty && !props.fixedPlaceholder) {
      if (ObjectUtils.isNotEmpty(props.maxSelectedLabels) && props.value.length > props.maxSelectedLabels) {
        return getSelectedItemsLabel();
      } else {
        return props.value.reduce(function (acc, value, index) {
          return acc + (index !== 0 ? ',' : '') + getLabelByValue(value);
        }, '');
      }
    }

    return label;
  };

  var getLabelContent = function getLabelContent() {
    if (props.selectedItemTemplate) {
      if (!empty) {
        if (ObjectUtils.isNotEmpty(props.maxSelectedLabels) && props.value.length > props.maxSelectedLabels) {
          return getSelectedItemsLabel();
        } else {
          return props.value.map(function (val, index) {
            var item = ObjectUtils.getJSXElement(props.selectedItemTemplate, val);
            return /*#__PURE__*/React.createElement(React.Fragment, {
              key: index
            }, item);
          });
        }
      } else {
        return ObjectUtils.getJSXElement(props.selectedItemTemplate);
      }
    } else {
      if (props.display === 'chip' && !empty) {
        var value = props.value.slice(0, props.maxSelectedLabels || props.value.length);
        return value.map(function (val) {
          var label = getLabelByValue(val);
          var icon = !props.disabled && IconUtils.getJSXIcon(props.removeIcon, {
            className: 'p-multiselect-token-icon',
            onClick: function onClick(e) {
              return removeChip(e, val);
            }
          }, {
            props: props
          });
          return /*#__PURE__*/React.createElement("div", {
            className: "p-multiselect-token",
            key: label
          }, /*#__PURE__*/React.createElement("span", {
            className: "p-multiselect-token-label"
          }, label), icon);
        });
      }

      return getLabel();
    }
  };

  var getVisibleOptions = function getVisibleOptions() {
    if (hasFilter) {
      var filterValue = filterState.trim().toLocaleLowerCase(props.filterLocale);
      var searchFields = props.filterBy ? props.filterBy.split(',') : [props.optionLabel || 'label'];

      if (props.optionGroupLabel) {
        var filteredGroups = [];

        var _iterator3 = _createForOfIteratorHelper$5(props.options),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var optgroup = _step3.value;
            var filteredSubOptions = FilterService.filter(getOptionGroupChildren(optgroup), searchFields, filterValue, props.filterMatchMode, props.filterLocale);

            if (filteredSubOptions && filteredSubOptions.length) {
              filteredGroups.push(_objectSpread$5(_objectSpread$5({}, optgroup), _defineProperty$5({}, props.optionGroupChildren, filteredSubOptions)));
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return filteredGroups;
      } else {
        return FilterService.filter(props.options, searchFields, filterValue, props.filterMatchMode, props.filterLocale);
      }
    } else {
      return props.options;
    }
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      show: show,
      hide: hide,
      getElement: function getElement() {
        return elementRef.current;
      },
      getOverlay: function getOverlay() {
        return overlayRef.current;
      },
      getInput: function getInput() {
        return inputRef.current;
      }
    };
  });
  React.useEffect(function () {
    ObjectUtils.combinedRefs(inputRef, props.inputRef);
  }, [inputRef, props.inputRef]);
  useUpdateEffect(function () {
    if (overlayVisibleState && hasFilter) {
      alignOverlay();
    }
  }, [overlayVisibleState, hasFilter]);
  useUnmountEffect(function () {
    ZIndexUtils.clear(overlayRef.current);
  });

  var createClearIcon = function createClearIcon() {
    if (!empty && props.showClear && !props.disabled) {
      return /*#__PURE__*/React.createElement("i", {
        className: "p-multiselect-clear-icon pi pi-times",
        onClick: function onClick(e) {
          return updateModel(e, null);
        }
      });
    }

    return null;
  };

  var createLabel = function createLabel() {
    var content = getLabelContent();
    var className = classNames('p-multiselect-label', {
      'p-placeholder': empty && props.placeholder,
      'p-multiselect-label-empty': empty && !props.placeholder && !props.selectedItemTemplate,
      'p-multiselect-items-label': !empty && props.display !== 'chip' && props.value.length > props.maxSelectedLabels
    });
    return /*#__PURE__*/React.createElement("div", {
      ref: labelRef,
      className: "p-multiselect-label-container"
    }, /*#__PURE__*/React.createElement("div", {
      className: className
    }, content || props.placeholder || 'empty'));
  };

  var visibleOptions = getVisibleOptions();
  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, MultiSelect$1.defaultProps);
  var dataProps = ObjectUtils.reduceKeys(otherProps, DomHandler.DATA_PROPS);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var className = classNames('p-multiselect p-component p-inputwrapper', {
    'p-multiselect-chip': props.display === 'chip',
    'p-disabled': props.disabled,
    'p-multiselect-clearable': props.showClear && !props.disabled,
    'p-focus': focusedState,
    'p-inputwrapper-filled': ObjectUtils.isNotEmpty(props.value),
    'p-inputwrapper-focus': focusedState || overlayVisibleState
  }, props.className);
  var label = createLabel();
  var clearIcon = createClearIcon();
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends$e({
    ref: elementRef,
    id: props.id,
    style: props.style,
    className: className
  }, otherProps, {
    onClick: onClick
  }), /*#__PURE__*/React.createElement("div", {
    className: "p-hidden-accessible"
  }, /*#__PURE__*/React.createElement("input", _extends$e({
    ref: inputRef,
    id: props.inputId,
    name: props.name,
    readOnly: true,
    type: "text",
    onFocus: onFocus,
    onBlur: onBlur,
    onKeyDown: onKeyDown,
    role: "listbox",
    "aria-expanded": overlayVisibleState,
    disabled: props.disabled,
    tabIndex: props.tabIndex
  }, ariaProps, dataProps))), label, clearIcon, /*#__PURE__*/React.createElement("div", {
    className: "p-multiselect-trigger"
  }, IconUtils.getJSXIcon(props.dropdownIcon, {
    className: 'p-multiselect-trigger-icon p-c'
  }, {
    props: props
  })), /*#__PURE__*/React.createElement(MultiSelectPanel, _extends$e({
    ref: overlayRef,
    visibleOptions: visibleOptions
  }, props, {
    onClick: onPanelClick,
    onOverlayHide: hide,
    filterValue: filterState,
    hasFilter: hasFilter,
    onFilterInputChange: onFilterInputChange,
    resetFilter: resetFilter,
    onCloseClick: onCloseClick,
    onSelectAll: onSelectAll,
    getOptionLabel: getOptionLabel,
    getOptionRenderKey: getOptionRenderKey,
    isOptionDisabled: isOptionDisabled,
    getOptionGroupChildren: getOptionGroupChildren,
    getOptionGroupLabel: getOptionGroupLabel,
    getOptionGroupRenderKey: getOptionGroupRenderKey,
    isSelected: isSelected,
    getSelectedOptionIndex: getSelectedOptionIndex,
    isAllSelected: isAllSelected,
    onOptionSelect: onOptionSelect,
    allowOptionSelect: allowOptionSelect,
    onOptionKeyDown: onOptionKeyDown,
    "in": overlayVisibleState,
    onEnter: onOverlayEnter,
    onEntered: onOverlayEntered,
    onExit: onOverlayExit,
    onExited: onOverlayExited
  }))), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$e({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
MultiSelect$1.displayName = 'MultiSelect';
MultiSelect$1.defaultProps = {
  __TYPE: 'MultiSelect',
  appendTo: null,
  ariaLabelledBy: null,
  className: null,
  dataKey: null,
  disabled: false,
  display: 'comma',
  dropdownIcon: 'pi pi-chevron-down',
  emptyFilterMessage: null,
  filter: false,
  filterBy: null,
  filterLocale: undefined,
  filterMatchMode: 'contains',
  filterPlaceholder: null,
  filterTemplate: null,
  fixedPlaceholder: false,
  id: null,
  inputId: null,
  inputRef: null,
  itemTemplate: null,
  maxSelectedLabels: null,
  name: null,
  onBlur: null,
  onChange: null,
  onFilter: null,
  onFocus: null,
  onHide: null,
  onSelectAll: null,
  onShow: null,
  optionDisabled: null,
  optionGroupChildren: null,
  optionGroupLabel: null,
  optionGroupTemplate: null,
  optionLabel: null,
  optionValue: null,
  options: null,
  panelClassName: null,
  panelFooterTemplate: null,
  panelHeaderTemplate: null,
  panelStyle: null,
  placeholder: null,
  removeIcon: 'pi pi-times-circle',
  resetFilterOnHide: false,
  scrollHeight: '200px',
  selectAll: false,
  selectedItemTemplate: null,
  selectedItemsLabel: '{0} items selected',
  selectionLimit: null,
  showClear: false,
  showSelectAll: true,
  style: null,
  tabIndex: 0,
  tooltip: null,
  tooltipOptions: null,
  transitionOptions: null,
  value: null,
  virtualScrollerOptions: null
};

var LOCALES_BUTTONS_SET = {
  ru: {
    selectAll: " ",
    clearAll: ""
  },
  en: {
    selectAll: "Select All",
    clearAll: "Clear"
  }
};

var MultiSelect = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var options = _ref.options,
      value = _ref.value,
      onChange = _ref.onChange,
      filter = _ref.filter,
      filterBy = _ref.filterBy,
      className = _ref.className,
      placeholder = _ref.placeholder,
      optionLabel = _ref.optionLabel,
      optionValue = _ref.optionValue,
      optionGroupLabel = _ref.optionGroupLabel,
      optionGroupChildren = _ref.optionGroupChildren,
      inputId = _ref.inputId,
      dropdownIcon = _ref.dropdownIcon,
      maxSelectedLabels = _ref.maxSelectedLabels,
      panelClassName = _ref.panelClassName,
      panelStyle = _ref.panelStyle,
      style = _ref.style,
      selectedItemsLabel = _ref.selectedItemsLabel,
      display = _ref.display,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      dataKey = _ref.dataKey,
      _ref$optionDisabled = _ref.optionDisabled,
      optionDisabled = _ref$optionDisabled === void 0 ? null : _ref$optionDisabled,
      _ref$name = _ref.name,
      name = _ref$name === void 0 ? null : _ref$name,
      _ref$id = _ref.id,
      id = _ref$id === void 0 ? null : _ref$id,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$showClear = _ref.showClear,
      showClear = _ref$showClear === void 0 ? false : _ref$showClear;
  var multiselectRef = useRef(ref);
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);

  var getRef = function getRef() {
    return ref || multiselectRef;
  };

  var handleSelectAll = function handleSelectAll(event) {
    var _getRef, _getRef$current;

    return (_getRef = getRef()) === null || _getRef === void 0 ? void 0 : (_getRef$current = _getRef.current) === null || _getRef$current === void 0 ? void 0 : _getRef$current.onSelectAll(event);
  };

  var handleClearAll = function handleClearAll() {
    var newValue = {
      target: {
        name: name,
        value: [],
        id: id
      }
    };
    onChange(newValue);
  };

  var isOptionDisabled = function isOptionDisabled() {
    if (!optionDisabled) return false;
    var isFunction = optionDisabled instanceof Function;
    return isFunction ? optionDisabled() : optionDisabled;
  };

  var removeIcon = function removeIcon() {
    return isOptionDisabled() ? false : "pi pi-times-circle";
  };

  var renderHeader = function renderHeader() {
    return filter ? null : /*#__PURE__*/React__default.createElement(React__default.Fragment, null);
  };

  var renderFooter = function renderFooter() {
    var translations = LOCALES_BUTTONS_SET[locale().locale];

    if (isOptionDisabled()) {
      return null;
    }

    return /*#__PURE__*/React__default.createElement("div", {
      className: "p-buttonset flex flex-row justify-content-center"
    }, /*#__PURE__*/React__default.createElement("button", {
      className: "p-button",
      onClick: handleSelectAll
    }, translations.selectAll), /*#__PURE__*/React__default.createElement("button", {
      className: "p-button",
      onClick: handleClearAll
    }, translations.clearAll));
  };

  return /*#__PURE__*/React__default.createElement(MultiSelect$1, {
    ref: getRef(),
    options: options,
    optionDisabled: optionDisabled,
    optionLabel: optionLabel,
    optionValue: optionValue,
    optionGroupLabel: optionGroupLabel,
    optionGroupChildren: optionGroupChildren,
    value: value,
    onChange: onChange,
    filter: filter,
    filterBy: filterBy,
    selectAll: false,
    showSelectAll: false,
    panelHeaderTemplate: renderHeader(),
    panelFooterTemplate: renderFooter(),
    className: className,
    placeholder: placeholder,
    inputId: inputId,
    dropdownIcon: dropdownIcon,
    maxSelectedLabels: maxSelectedLabels,
    panelClassName: panelClassName,
    panelStyle: panelStyle,
    style: style,
    name: name,
    id: id,
    disabled: disabled,
    selectedItemsLabel: selectedItemsLabel,
    showClear: showClear,
    display: display,
    removeIcon: removeIcon(),
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    dataKey: dataKey
  });
});

var Pagination = function Pagination(_ref) {
  var page = _ref.page,
      pages = _ref.pages,
      onPageClick = _ref.onPageClick;
  var prevPage = page > 1 ? page - 1 : 1;
  var nextPage = // eslint-disable-next-line no-nested-ternary
  pages ? page < pages ? page + 1 : pages : page + 1;
  var showPrevPage = prevPage > 1;
  var showNextPage = pages ? nextPage < pages : true;
  var showPrevDots = prevPage - 1 > 1;
  var showNextDots = nextPage + 1 < pages;
  var showFirstPage = page !== 1;
  var showLastPage = pages && page !== pages;
  var isTheFirstPage = page === 1;
  var isTheLastPage = page === pages;

  var goToFirst = function goToFirst() {
    return onPageClick(1);
  };

  var goToLast = function goToLast() {
    return onPageClick(pages);
  };

  var goToPrev = function goToPrev() {
    return onPageClick(prevPage);
  };

  var goToNext = function goToNext() {
    return onPageClick(nextPage);
  };

  return /*#__PURE__*/React__default.createElement("div", {
    className: "p-paginator"
  }, /*#__PURE__*/React__default.createElement("div", {
    className: "p-paginator-pages"
  }, /*#__PURE__*/React__default.createElement(Button$1, {
    className: "p-paginator-page",
    disabled: isTheFirstPage,
    icon: "pi pi-angle-left",
    onClick: goToPrev
  }), showFirstPage && /*#__PURE__*/React__default.createElement(Button$1, {
    className: "p-paginator-page",
    onClick: goToFirst
  }, "1"), showPrevDots && /*#__PURE__*/React__default.createElement("span", {
    className: "p-paginator-dots"
  }, "..."), showPrevPage && /*#__PURE__*/React__default.createElement(Button$1, {
    className: "p-paginator-page",
    onClick: goToPrev
  }, prevPage), /*#__PURE__*/React__default.createElement(Button$1, {
    className: "p-paginator-page p-highlight"
  }, page), showNextPage && /*#__PURE__*/React__default.createElement(Button$1, {
    className: "p-paginator-page",
    onClick: goToNext
  }, nextPage), showNextDots && /*#__PURE__*/React__default.createElement("span", {
    className: "p-paginator-dots"
  }, "..."), showLastPage && /*#__PURE__*/React__default.createElement(Button$1, {
    className: "p-paginator-page",
    onClick: goToLast
  }, pages), /*#__PURE__*/React__default.createElement(Button$1, {
    className: "p-paginator-page",
    disabled: isTheLastPage,
    icon: "pi pi-angle-right",
    onClick: goToNext
  })));
};

function _extends$d() {
  _extends$d = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$d.apply(this, arguments);
}

function _arrayLikeToArray$d(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$5(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$d(arr);
}

function _iterableToArray$5(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$d(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$d(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(o, minLen);
}

function _nonIterableSpread$5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$5(arr) {
  return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$d(arr) || _nonIterableSpread$5();
}

function _arrayWithHoles$9(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$9(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$9() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$9(arr, i) {
  return _arrayWithHoles$9(arr) || _iterableToArrayLimit$9(arr, i) || _unsupportedIterableToArray$d(arr, i) || _nonIterableRest$9();
}

var PanelMenuSub = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState(null),
      _React$useState2 = _slicedToArray$9(_React$useState, 2),
      activeItemState = _React$useState2[0],
      setActiveItemState = _React$useState2[1];

  var findActiveItem = function findActiveItem() {
    if (props.model) {
      if (props.multiple) {
        return props.model.filter(function (item) {
          return item.expanded;
        });
      } else {
        var activeItem = null;
        props.model.forEach(function (item) {
          if (item.expanded) {
            if (!activeItem) activeItem = item;else item.expanded = false;
          }
        });
        return activeItem;
      }
    }

    return null;
  };

  var onItemClick = function onItemClick(event, item) {
    if (item.disabled) {
      event.preventDefault();
      return;
    }

    if (!item.url) {
      event.preventDefault();
    }

    if (item.command) {
      item.command({
        originalEvent: event,
        item: item
      });
    }

    var activeItem = activeItemState;
    var active = isItemActive(item);

    if (active) {
      item.expanded = false;
      setActiveItemState(props.multiple ? activeItem.filter(function (a_item) {
        return a_item !== item;
      }) : null);
    } else {
      if (!props.multiple && activeItem) {
        activeItem.expanded = false;
      }

      item.expanded = true;
      setActiveItemState(props.multiple ? [].concat(_toConsumableArray$5(activeItem || []), [item]) : item);
    }
  };

  var isItemActive = function isItemActive(item) {
    return activeItemState && (props.multiple ? activeItemState.indexOf(item) > -1 : activeItemState === item);
  };

  useMountEffect(function () {
    setActiveItemState(findActiveItem());
  });

  var createSeparator = function createSeparator(index) {
    var key = 'separator_' + index;
    return /*#__PURE__*/React.createElement("li", {
      key: key,
      className: "p-menu-separator"
    });
  };

  var createSubmenu = function createSubmenu(item, active) {
    var className = classNames('p-toggleable-content', {
      'p-toggleable-content-collapsed': !active
    });
    var submenuRef = /*#__PURE__*/React.createRef();

    if (item.items) {
      return /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: submenuRef,
        classNames: "p-toggleable-content",
        timeout: {
          enter: 1000,
          exit: 450
        },
        "in": active,
        unmountOnExit: true
      }, /*#__PURE__*/React.createElement("div", {
        ref: submenuRef,
        className: className
      }, /*#__PURE__*/React.createElement(PanelMenuSub, {
        menuProps: props.menuProps,
        model: item.items,
        multiple: props.multiple
      })));
    }

    return null;
  };

  var createMenuItem = function createMenuItem(item, index) {
    if (item.visible === false) {
      return null;
    }

    var key = item.label + '_' + index;
    var active = isItemActive(item);
    var className = classNames('p-menuitem', item.className);
    var linkClassName = classNames('p-menuitem-link', {
      'p-disabled': item.disabled
    });
    var iconClassName = classNames('p-menuitem-icon', item.icon);
    var submenuIconClassName = classNames('p-panelmenu-icon pi pi-fw', {
      'pi-angle-right': !active,
      'pi-angle-down': active
    });
    var icon = IconUtils.getJSXIcon(item.icon, {
      className: 'p-menuitem-icon'
    }, {
      props: props.menuProps
    });
    var label = item.label && /*#__PURE__*/React.createElement("span", {
      className: "p-menuitem-text"
    }, item.label);
    var submenuIcon = item.items && /*#__PURE__*/React.createElement("span", {
      className: submenuIconClassName
    });
    var submenu = createSubmenu(item, active);
    var content = /*#__PURE__*/React.createElement("a", {
      href: item.url || '#',
      className: linkClassName,
      target: item.target,
      onClick: function onClick(event) {
        return onItemClick(event, item);
      },
      role: "menuitem",
      "aria-disabled": item.disabled
    }, submenuIcon, icon, label);

    if (item.template) {
      var defaultContentOptions = {
        onClick: function onClick(event) {
          return onItemClick(event, item);
        },
        className: linkClassName,
        labelClassName: 'p-menuitem-text',
        iconClassName: iconClassName,
        submenuIconClassName: submenuIconClassName,
        element: content,
        props: props,
        leaf: !item.items,
        active: active
      };
      content = ObjectUtils.getJSXElement(item.template, item, defaultContentOptions);
    }

    return /*#__PURE__*/React.createElement("li", {
      key: key,
      id: item.id,
      className: className,
      style: item.style,
      role: "none"
    }, content, submenu);
  };

  var createItem = function createItem(item, index) {
    return item.separator ? createSeparator(index) : createMenuItem(item, index);
  };

  var createMenu = function createMenu() {
    return props.model ? props.model.map(createItem) : null;
  };

  var className = classNames('p-submenu-list', props.className);
  var menu = createMenu();
  return /*#__PURE__*/React.createElement("ul", {
    className: className,
    role: "tree"
  }, menu);
});
PanelMenuSub.displayName = 'PanelMenuSub';
var PanelMenu$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(props.id),
      _React$useState2 = _slicedToArray$9(_React$useState, 2),
      idState = _React$useState2[0],
      setIdState = _React$useState2[1];

  var _React$useState3 = React.useState(null),
      _React$useState4 = _slicedToArray$9(_React$useState3, 2),
      activeItemState = _React$useState4[0],
      setActiveItemState = _React$useState4[1];

  var _React$useState5 = React.useState(false),
      _React$useState6 = _slicedToArray$9(_React$useState5, 2),
      animationDisabled = _React$useState6[0],
      setAnimationDisabled = _React$useState6[1];

  var elementRef = React.useRef(null);
  var headerId = idState + '_header';
  var contentId = idState + '_content';

  var findActiveItem = function findActiveItem() {
    if (props.model) {
      if (props.multiple) {
        return props.model.filter(function (item) {
          return item.expanded;
        });
      } else {
        var activeItem = null;
        props.model.forEach(function (item) {
          if (item.expanded) {
            if (!activeItem) activeItem = item;else item.expanded = false;
          }
        });
        return activeItem;
      }
    }

    return null;
  };

  var onItemClick = function onItemClick(event, item) {
    if (item.disabled) {
      event.preventDefault();
      return;
    }

    if (!item.url) {
      event.preventDefault();
    }

    if (item.command) {
      item.command({
        originalEvent: event,
        item: item
      });
    }

    var activeItem = activeItemState;
    var active = isItemActive(item);

    if (active) {
      item.expanded = false;
      setActiveItemState(props.multiple ? activeItem.filter(function (a_item) {
        return a_item !== item;
      }) : null);
    } else {
      if (!props.multiple && activeItem) {
        activeItem.expanded = false;
      }

      item.expanded = true;
      setActiveItemState(props.multiple ? [].concat(_toConsumableArray$5(activeItem || []), [item]) : item);
    }
  };

  var isItemActive = function isItemActive(item) {
    return activeItemState && (props.multiple ? activeItemState.indexOf(item) > -1 : activeItemState === item);
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  useMountEffect(function () {
    if (!idState) {
      setIdState(UniqueComponentId());
    }

    setActiveItemState(findActiveItem());
  });
  useUpdateEffect(function () {
    setAnimationDisabled(true);
    setActiveItemState(findActiveItem());
  }, [props.model]);

  var onEnter = function onEnter() {
    setAnimationDisabled(false);
  };

  var createPanel = function createPanel(item, index) {
    if (item.visible === false) {
      return null;
    }

    var key = item.label + '_' + index;
    var active = isItemActive(item);
    var className = classNames('p-panelmenu-panel', item.className);
    var headerClassName = classNames('p-component p-panelmenu-header', {
      'p-highlight': active,
      'p-disabled': item.disabled
    });
    var submenuIconClassName = classNames('p-panelmenu-icon pi', {
      'pi-chevron-right': !active,
      ' pi-chevron-down': active
    });
    var iconClassName = classNames('p-menuitem-icon', item.icon);
    var icon = IconUtils.getJSXIcon(item.icon, {
      className: 'p-menuitem-icon'
    }, {
      props: props
    });
    var submenuIcon = item.items && /*#__PURE__*/React.createElement("span", {
      className: submenuIconClassName
    });
    var label = item.label && /*#__PURE__*/React.createElement("span", {
      className: "p-menuitem-text"
    }, item.label);
    var contentWrapperClassName = classNames('p-toggleable-content', {
      'p-toggleable-content-collapsed': !active
    });
    var menuContentRef = /*#__PURE__*/React.createRef();
    var content = /*#__PURE__*/React.createElement("a", {
      href: item.url || '#',
      className: "p-panelmenu-header-link",
      onClick: function onClick(e) {
        return onItemClick(e, item);
      },
      "aria-expanded": active,
      id: headerId,
      "aria-controls": contentId,
      "aria-disabled": item.disabled
    }, submenuIcon, icon, label);

    if (item.template) {
      var defaultContentOptions = {
        onClick: function onClick(event) {
          return onItemClick(event, item);
        },
        className: 'p-panelmenu-header-link',
        labelClassName: 'p-menuitem-text',
        submenuIconClassName: submenuIconClassName,
        iconClassName: iconClassName,
        element: content,
        props: props,
        leaf: !item.items,
        active: active
      };
      content = ObjectUtils.getJSXElement(item.template, item, defaultContentOptions);
    }

    return /*#__PURE__*/React.createElement("div", {
      key: key,
      className: className,
      style: item.style
    }, /*#__PURE__*/React.createElement("div", {
      className: headerClassName,
      style: item.style
    }, content), /*#__PURE__*/React.createElement(CSSTransition, {
      nodeRef: menuContentRef,
      classNames: "p-toggleable-content",
      timeout: {
        enter: 1000,
        exit: 450
      },
      onEnter: onEnter,
      disabled: animationDisabled,
      "in": active,
      unmountOnExit: true,
      options: props.transitionOptions
    }, /*#__PURE__*/React.createElement("div", {
      ref: menuContentRef,
      className: contentWrapperClassName,
      role: "region",
      id: contentId,
      "aria-labelledby": headerId
    }, /*#__PURE__*/React.createElement("div", {
      className: "p-panelmenu-content"
    }, /*#__PURE__*/React.createElement(PanelMenuSub, {
      menuProps: props,
      model: item.items,
      className: "p-panelmenu-root-submenu",
      multiple: props.multiple
    })))));
  };

  var createPanels = function createPanels() {
    return props.model ? props.model.map(createPanel) : null;
  };

  var otherProps = ObjectUtils.findDiffKeys(props, PanelMenu$1.defaultProps);
  var className = classNames('p-panelmenu p-component', props.className);
  var panels = createPanels();
  return /*#__PURE__*/React.createElement("div", _extends$d({
    id: props.id,
    ref: elementRef,
    className: className,
    style: props.style
  }, otherProps), panels);
}));
PanelMenu$1.displayName = 'PanelMenu';
PanelMenu$1.defaultProps = {
  __TYPE: 'Panel',
  id: null,
  model: null,
  style: null,
  className: null,
  multiple: false,
  transitionOptions: null
};

var PanelMenu = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      model = _ref.model,
      style = _ref.style,
      className = _ref.className;
  return /*#__PURE__*/React__default.createElement(PanelMenu$1, {
    ref: ref,
    id: id,
    model: model,
    style: style,
    className: className,
    multiple: true
  });
});

var ProgressBar = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      showValue = _ref.showValue,
      unit = _ref.unit,
      color = _ref.color,
      style = _ref.style,
      className = _ref.className,
      displayValueTemplate = _ref.displayValueTemplate;
  return /*#__PURE__*/React__default.createElement(ProgressBar$1, {
    ref: ref,
    id: id,
    value: value,
    showValue: showValue,
    unit: unit,
    displayValueTemplate: displayValueTemplate,
    color: color,
    style: style,
    className: className
  });
});

function _extends$c() {
  _extends$c = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$c.apply(this, arguments);
}

function _arrayWithHoles$8(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$8(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$c(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$c(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$c(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(o, minLen);
}

function _nonIterableRest$8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$8(arr, i) {
  return _arrayWithHoles$8(arr) || _iterableToArrayLimit$8(arr, i) || _unsupportedIterableToArray$c(arr, i) || _nonIterableRest$8();
}

var RadioButton$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$8(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var elementRef = React.useRef(null);
  var inputRef = React.useRef(props.inputRef);

  var select = function select(e) {
    onClick(e);
  };

  var onClick = function onClick(e) {
    if (!props.disabled && props.onChange) {
      var checked = props.checked;
      var radioClicked = e.target instanceof HTMLDivElement;
      var inputClicked = e.target === inputRef.current;
      var isInputToggled = inputClicked && e.target.checked !== checked;
      var isRadioToggled = radioClicked && !e.target.checked;

      if (isInputToggled || isRadioToggled) {
        var value = !checked;
        props.onChange({
          originalEvent: e,
          value: props.value,
          checked: value,
          stopPropagation: function stopPropagation() {},
          preventDefault: function preventDefault() {},
          target: {
            type: 'radio',
            name: props.name,
            id: props.id,
            value: props.value,
            checked: value
          }
        });
      }

      DomHandler.focus(inputRef.current);
      e.preventDefault();
    }
  };

  var onFocus = function onFocus() {
    setFocusedState(true);
  };

  var onBlur = function onBlur() {
    setFocusedState(false);
  };

  var onKeyDown = function onKeyDown(event) {
    if (event.code === 'Space') {
      onClick(event);
    }
  };

  React.useEffect(function () {
    if (inputRef.current) {
      inputRef.current.checked = props.checked;
    }
  }, [props.checked]);
  React.useEffect(function () {
    ObjectUtils.combinedRefs(inputRef, props.inputRef);
  }, [inputRef, props.inputRef]);
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      select: select,
      getElement: function getElement() {
        return elementRef.current;
      },
      getInput: function getInput() {
        return inputRef.current;
      }
    };
  });
  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, RadioButton$1.defaultProps);
  var dataProps = ObjectUtils.reduceKeys(otherProps, DomHandler.DATA_PROPS);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var className = classNames('p-radiobutton p-component', {
    'p-radiobutton-checked': props.checked,
    'p-radiobutton-disabled': props.disabled,
    'p-radiobutton-focused': focusedState
  }, props.className);
  var boxClassName = classNames('p-radiobutton-box', {
    'p-highlight': props.checked,
    'p-disabled': props.disabled,
    'p-focus': focusedState
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends$c({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style
  }, otherProps, {
    onClick: onClick
  }), /*#__PURE__*/React.createElement("div", {
    className: "p-hidden-accessible"
  }, /*#__PURE__*/React.createElement("input", _extends$c({
    ref: inputRef,
    id: props.inputId,
    type: "radio",
    name: props.name,
    defaultChecked: props.checked,
    onFocus: onFocus,
    onBlur: onBlur,
    onKeyDown: onKeyDown,
    disabled: props.disabled,
    required: props.required,
    tabIndex: props.tabIndex
  }, ariaProps, dataProps))), /*#__PURE__*/React.createElement("div", {
    className: boxClassName
  }, /*#__PURE__*/React.createElement("div", {
    className: "p-radiobutton-icon"
  }))), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$c({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
RadioButton$1.displayName = 'RadioButton';
RadioButton$1.defaultProps = {
  __TYPE: 'RadioButton',
  id: null,
  inputRef: null,
  inputId: null,
  name: null,
  value: null,
  checked: false,
  style: null,
  className: null,
  disabled: false,
  required: false,
  tabIndex: null,
  tooltip: null,
  tooltipOptions: null,
  onChange: null
};

var RadioButton = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      inputId = _ref.inputId,
      name = _ref.name,
      value = _ref.value,
      checked = _ref.checked,
      style = _ref.style,
      className = _ref.className,
      disabled = _ref.disabled,
      required = _ref.required,
      tabIndex = _ref.tabIndex,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onChange = _ref.onChange;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(RadioButton$1, {
    ref: ref,
    id: id,
    inputId: inputId,
    name: name,
    value: value,
    checked: checked,
    style: style,
    className: className,
    disabled: disabled,
    required: required,
    tabIndex: tabIndex,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onChange: onChange
  });
});

function _extends$b() {
  _extends$b = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$b.apply(this, arguments);
}

var Row = function Row(props) {
  var otherProps = ObjectUtils.findDiffKeys(props, Row.defaultProps);
  return /*#__PURE__*/React.createElement("tr", _extends$b({
    className: props.className,
    style: props.style
  }, otherProps), props.children);
};

Row.displayName = 'Row';
Row.defaultProps = {
  __TYPE: 'Row',
  style: null,
  className: null
};

function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$a.apply(this, arguments);
}

function _arrayWithHoles$7(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$7(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$b(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$b(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$b(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen);
}

function _nonIterableRest$7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$7(arr, i) {
  return _arrayWithHoles$7(arr) || _iterableToArrayLimit$7(arr, i) || _unsupportedIterableToArray$b(arr, i) || _nonIterableRest$7();
}

var ScrollTop$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$7(_React$useState, 2),
      visibleState = _React$useState2[0],
      setVisibleState = _React$useState2[1];

  var scrollElementRef = React.useRef(null);
  var helperRef = React.useRef(null);
  var isTargetParent = props.target === 'parent';

  var _useEventListener = useEventListener({
    target: function target() {
      return helperRef.current && helperRef.current.parentElement;
    },
    type: 'scroll',
    listener: function listener(event) {
      checkVisibility(event.currentTarget.scrollTop);
    }
  }),
      _useEventListener2 = _slicedToArray$7(_useEventListener, 1),
      bindParentScrollListener = _useEventListener2[0];

  var _useEventListener3 = useEventListener({
    target: 'window',
    type: 'scroll',
    listener: function listener() {
      checkVisibility(DomHandler.getWindowScrollTop());
    }
  }),
      _useEventListener4 = _slicedToArray$7(_useEventListener3, 1),
      bindDocumentScrollListener = _useEventListener4[0];

  var onClick = function onClick() {
    var scrollElement = props.target === 'window' ? window : helperRef.current.parentElement;
    scrollElement.scroll({
      top: 0,
      behavior: props.behavior
    });
  };

  var checkVisibility = function checkVisibility(scrollY) {
    setVisibleState(scrollY > props.threshold);
  };

  var onEnter = function onEnter() {
    ZIndexUtils.set('overlay', scrollElementRef.current, PrimeReact$1.autoZIndex, PrimeReact$1.zIndex['overlay']);
  };

  var onEntered = function onEntered() {
    props.onShow && props.onShow();
  };

  var onExited = function onExited() {
    ZIndexUtils.clear(scrollElementRef.current);
    props.onHide && props.onHide();
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  useMountEffect(function () {
    if (props.target === 'window') bindDocumentScrollListener();else if (props.target === 'parent') bindParentScrollListener();
  });
  useUnmountEffect(function () {
    ZIndexUtils.clear(scrollElementRef.current);
  });
  var otherProps = ObjectUtils.findDiffKeys(props, ScrollTop$1.defaultProps);
  var className = classNames('p-scrolltop p-link p-component', {
    'p-scrolltop-sticky': props.target !== 'window'
  }, props.className);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(CSSTransition, {
    nodeRef: scrollElementRef,
    classNames: "p-scrolltop",
    "in": visibleState,
    timeout: {
      enter: 150,
      exit: 150
    },
    options: props.transitionOptions,
    unmountOnExit: true,
    onEnter: onEnter,
    onEntered: onEntered,
    onExited: onExited
  }, /*#__PURE__*/React.createElement("button", _extends$a({
    ref: scrollElementRef,
    type: "button",
    className: className,
    style: props.style
  }, otherProps, {
    onClick: onClick
  }), IconUtils.getJSXIcon(props.icon, {
    className: 'p-scrolltop-icon'
  }, {
    props: props
  }), /*#__PURE__*/React.createElement(Ripple, null))), isTargetParent && /*#__PURE__*/React.createElement("span", {
    ref: helperRef,
    className: "p-scrolltop-helper"
  }));
}));
ScrollTop$1.displayName = 'ScrollTop';
ScrollTop$1.defaultProps = {
  __TYPE: 'ScrollTop',
  target: 'window',
  threshold: 400,
  icon: 'pi pi-chevron-up',
  behavior: 'smooth',
  className: null,
  style: null,
  transitionOptions: null,
  onShow: null,
  onHide: null
};

var ScrollTop = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var target = _ref.target,
      threshold = _ref.threshold,
      behavior = _ref.behavior,
      onShow = _ref.onShow,
      onHide = _ref.onHide,
      className = _ref.className,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? "large" : _ref$size,
      style = _ref.style;
  var scrollTopClassName = classNames(className, "custom-scrolltop", {
    "custom-scrolltop_small": size === "small"
  });
  return /*#__PURE__*/React__default.createElement(ScrollTop$1, {
    ref: ref,
    target: target,
    threshold: threshold,
    behavior: behavior,
    className: scrollTopClassName,
    style: style,
    onShow: onShow,
    onHide: onHide,
    icon: "pi pi-arrow-up"
  });
});

function _extends$9() {
  _extends$9 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$9.apply(this, arguments);
}

function _arrayLikeToArray$a(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$4(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$a(arr);
}

function _iterableToArray$4(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$a(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$a(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen);
}

function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$4(arr) {
  return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$a(arr) || _nonIterableSpread$4();
}

function _arrayWithHoles$6(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$6(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$6(arr, i) {
  return _arrayWithHoles$6(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$a(arr, i) || _nonIterableRest$6();
}

var SelectButtonItem = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$6(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var onClick = function onClick(event) {
    if (props.onClick) {
      props.onClick({
        originalEvent: event,
        option: props.option
      });
    }
  };

  var onFocus = function onFocus() {
    setFocusedState(true);
  };

  var onBlur = function onBlur() {
    setFocusedState(false);
  };

  var onKeyDown = function onKeyDown(event) {
    var keyCode = event.which;

    if (keyCode === 32) {
      onClick(event);
      event.preventDefault();
    }
  };

  var createContent = function createContent() {
    return props.template ? ObjectUtils.getJSXElement(props.template, props.option) : /*#__PURE__*/React.createElement("span", {
      className: "p-button-label p-c"
    }, props.label);
  };

  var className = classNames('p-button p-component', {
    'p-highlight': props.selected,
    'p-disabled': props.disabled,
    'p-focus': focusedState
  }, props.className);
  var content = createContent();
  return /*#__PURE__*/React.createElement("div", {
    className: className,
    role: "button",
    "aria-label": props.label,
    "aria-pressed": props.selected,
    onClick: onClick,
    onKeyDown: onKeyDown,
    tabIndex: props.tabIndex,
    onFocus: onFocus,
    onBlur: onBlur
  }, content, !props.disabled && /*#__PURE__*/React.createElement(Ripple, null));
});
SelectButtonItem.displayName = 'SelectButtonItem';
var SelectButton$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(null);

  var onOptionClick = function onOptionClick(event) {
    if (props.disabled || isOptionDisabled(event.option)) {
      return;
    }

    var selected = isSelected(event.option);

    if (selected && !props.unselectable) {
      return;
    }

    var optionValue = getOptionValue(event.option);
    var newValue;

    if (props.multiple) {
      var currentValue = props.value ? _toConsumableArray$4(props.value) : [];
      newValue = selected ? currentValue.filter(function (val) {
        return !ObjectUtils.equals(val, optionValue, props.dataKey);
      }) : [].concat(_toConsumableArray$4(currentValue), [optionValue]);
    } else {
      newValue = selected ? null : optionValue;
    }

    if (props.onChange) {
      props.onChange({
        originalEvent: event.originalEvent,
        value: newValue,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        target: {
          name: props.name,
          id: props.id,
          value: newValue
        }
      });
    }
  };

  var getOptionLabel = function getOptionLabel(option) {
    return props.optionLabel ? ObjectUtils.resolveFieldData(option, props.optionLabel) : option && option['label'] !== undefined ? option['label'] : option;
  };

  var getOptionValue = function getOptionValue(option) {
    return props.optionValue ? ObjectUtils.resolveFieldData(option, props.optionValue) : option && option['value'] !== undefined ? option['value'] : option;
  };

  var isOptionDisabled = function isOptionDisabled(option) {
    if (props.optionDisabled) {
      return ObjectUtils.isFunction(props.optionDisabled) ? props.optionDisabled(option) : ObjectUtils.resolveFieldData(option, props.optionDisabled);
    }

    return option && option['disabled'] !== undefined ? option['disabled'] : false;
  };

  var isSelected = function isSelected(option) {
    var optionValue = getOptionValue(option);

    if (props.multiple) {
      if (props.value && props.value.length) {
        return props.value.some(function (val) {
          return ObjectUtils.equals(val, optionValue, props.dataKey);
        });
      }
    } else {
      return ObjectUtils.equals(props.value, optionValue, props.dataKey);
    }

    return false;
  };

  var createItems = function createItems() {
    if (props.options && props.options.length) {
      return props.options.map(function (option, index) {
        var isDisabled = props.disabled || isOptionDisabled(option);
        var optionLabel = getOptionLabel(option);
        var tabIndex = isDisabled ? null : 0;
        var selected = isSelected(option);
        var key = optionLabel + '_' + index;
        return /*#__PURE__*/React.createElement(SelectButtonItem, {
          key: key,
          label: optionLabel,
          className: option.className,
          option: option,
          onClick: onOptionClick,
          template: props.itemTemplate,
          selected: selected,
          tabIndex: tabIndex,
          disabled: isDisabled
        });
      });
    }

    return null;
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, SelectButton$1.defaultProps);
  var className = classNames('p-selectbutton p-buttonset p-component', props.className);
  var items = createItems();
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends$9({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style
  }, otherProps, {
    role: "group"
  }), items), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends$9({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
SelectButton$1.displayName = 'SelectButton';
SelectButton$1.defaultProps = {
  __TYPE: 'SelectButton',
  id: null,
  value: null,
  options: null,
  optionLabel: null,
  optionValue: null,
  optionDisabled: null,
  tabIndex: null,
  multiple: false,
  unselectable: true,
  disabled: false,
  style: null,
  className: null,
  dataKey: null,
  tooltip: null,
  tooltipOptions: null,
  itemTemplate: null,
  onChange: null
};

var SelectButton = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      options = _ref.options,
      optionDisabled = _ref.optionDisabled,
      tabIndex = _ref.tabIndex,
      multiple = _ref.multiple,
      unselectable = _ref.unselectable,
      disabled = _ref.disabled,
      style = _ref.style,
      className = _ref.className,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onChange = _ref.onChange,
      name = _ref.name;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(SelectButton$1, {
    ref: ref,
    id: id,
    value: value,
    options: options,
    optionDisabled: optionDisabled,
    tabIndex: tabIndex,
    multiple: multiple,
    unselectable: unselectable,
    disabled: disabled,
    style: style,
    className: className,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onChange: onChange,
    name: name
  });
});

function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$8.apply(this, arguments);
}

var Skeleton$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(null);
  var otherProps = ObjectUtils.findDiffKeys(props, Skeleton$1.defaultProps);
  var style = props.size ? {
    width: props.size,
    height: props.size,
    borderRadius: props.borderRadius
  } : {
    width: props.width,
    height: props.height,
    borderRadius: props.borderRadius
  };
  var className = classNames('p-skeleton p-component', {
    'p-skeleton-circle': props.shape === 'circle',
    'p-skeleton-none': props.animation === 'none'
  }, props.className);
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  return /*#__PURE__*/React.createElement("div", _extends$8({
    ref: elementRef,
    style: style,
    className: className
  }, otherProps));
}));
Skeleton$1.displayName = 'Skeleton';
Skeleton$1.defaultProps = {
  __TYPE: 'Skeleton',
  shape: 'rectangle',
  size: null,
  width: '100%',
  height: '1rem',
  borderRadius: null,
  animation: 'wave',
  style: null,
  className: null
};

var Skeleton = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var shape = _ref.shape,
      size = _ref.size,
      width = _ref.width,
      height = _ref.height,
      borderRadius = _ref.borderRadius,
      animation = _ref.animation,
      style = _ref.style,
      className = _ref.className;
  return /*#__PURE__*/React__default.createElement(Skeleton$1, {
    ref: ref,
    shape: shape,
    size: size,
    width: width,
    height: height,
    borderRadius: borderRadius,
    animation: animation,
    style: style,
    className: className
  });
});

function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$7.apply(this, arguments);
}

var ProgressSpinner = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var elementRef = React.useRef(null);
  var otherProps = ObjectUtils.findDiffKeys(props, ProgressSpinner.defaultProps);
  var className = classNames('p-progress-spinner', props.className);
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  return /*#__PURE__*/React.createElement("div", _extends$7({
    id: props.id,
    ref: elementRef,
    style: props.style,
    className: className,
    role: "alert",
    "aria-busy": true
  }, otherProps), /*#__PURE__*/React.createElement("svg", {
    className: "p-progress-spinner-svg",
    viewBox: "25 25 50 50",
    style: {
      animationDuration: props.animationDuration
    }
  }, /*#__PURE__*/React.createElement("circle", {
    className: "p-progress-spinner-circle",
    cx: "50",
    cy: "50",
    r: "20",
    fill: props.fill,
    strokeWidth: props.strokeWidth,
    strokeMiterlimit: "10"
  })));
}));
ProgressSpinner.displayName = 'ProgressSpinner';
ProgressSpinner.defaultProps = {
  __TYPE: 'ProgressSpinner',
  id: null,
  style: null,
  className: null,
  strokeWidth: '2',
  fill: 'none',
  animationDuration: '2s'
};

var Spinner = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? true : _ref$loading,
      style = _ref.style,
      className = _ref.className,
      strokeWidth = _ref.strokeWidth,
      children = _ref.children;

  if (loading) {
    return /*#__PURE__*/React__default.createElement("div", {
      className: "flex justify-content-center"
    }, /*#__PURE__*/React__default.createElement(ProgressSpinner, {
      ref: ref,
      loading: loading,
      strokeWidth: strokeWidth,
      style: style,
      className: className
    }));
  }

  return children;
});

function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$6.apply(this, arguments);
}

function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$3(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$9(arr);
}

function _iterableToArray$3(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$9(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen);
}

function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$3(arr) {
  return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableSpread$3();
}

function _arrayWithHoles$5(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$5(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$5(arr, i) {
  return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$9(arr, i) || _nonIterableRest$5();
}

function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var TabPanel = function TabPanel() {};

var TabView$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(props.id),
      _React$useState2 = _slicedToArray$5(_React$useState, 2),
      idState = _React$useState2[0],
      setIdState = _React$useState2[1];

  var _React$useState3 = React.useState(true),
      _React$useState4 = _slicedToArray$5(_React$useState3, 2),
      backwardIsDisabledState = _React$useState4[0],
      setBackwardIsDisabledState = _React$useState4[1];

  var _React$useState5 = React.useState(false),
      _React$useState6 = _slicedToArray$5(_React$useState5, 2),
      forwardIsDisabledState = _React$useState6[0],
      setForwardIsDisabledState = _React$useState6[1];

  var _React$useState7 = React.useState([]),
      _React$useState8 = _slicedToArray$5(_React$useState7, 2),
      hiddenTabsState = _React$useState8[0],
      setHiddenTabsState = _React$useState8[1];

  var _React$useState9 = React.useState(props.activeIndex),
      _React$useState10 = _slicedToArray$5(_React$useState9, 2),
      activeIndexState = _React$useState10[0],
      setActiveIndexState = _React$useState10[1];

  var elementRef = React.useRef(null);
  var contentRef = React.useRef(null);
  var navRef = React.useRef(null);
  var inkbarRef = React.useRef(null);
  var prevBtnRef = React.useRef(null);
  var nextBtnRef = React.useRef(null);
  var tabsRef = React.useRef({});
  var activeIndex = props.onTabChange ? props.activeIndex : activeIndexState;

  var isSelected = function isSelected(index) {
    return index === activeIndex;
  };

  var shouldUseTab = function shouldUseTab(tab, index) {
    return tab && tab.props.__TYPE === 'TabPanel' && hiddenTabsState.every(function (_i) {
      return _i !== index;
    });
  };

  var findVisibleActiveTab = function findVisibleActiveTab(i) {
    var tabsInfo = React.Children.map(props.children, function (tab, index) {
      if (shouldUseTab(tab, index)) {
        return {
          tab: tab,
          index: index
        };
      }
    });
    return tabsInfo.find(function (_ref) {
      var tab = _ref.tab,
          index = _ref.index;
      return !tab.props.disabled && index >= i;
    }) || tabsInfo.reverse().find(function (_ref2) {
      var tab = _ref2.tab,
          index = _ref2.index;
      return !tab.props.disabled && i > index;
    });
  };

  var onTabHeaderClose = function onTabHeaderClose(event, index) {
    event.preventDefault(); // give caller a chance to stop the selection

    if (props.onBeforeTabClose && props.onBeforeTabClose({
      originalEvent: event,
      index: index
    }) === false) {
      return;
    }

    setHiddenTabsState([].concat(_toConsumableArray$3(hiddenTabsState), [index]));

    if (props.onTabClose) {
      props.onTabClose({
        originalEvent: event,
        index: index
      });
    }
  };

  var onTabHeaderClick = function onTabHeaderClick(event, tab, index) {
    if (event) {
      event.preventDefault();
    }

    if (!tab.props.disabled) {
      // give caller a chance to stop the selection
      if (props.onBeforeTabChange && props.onBeforeTabChange({
        originalEvent: event,
        index: index
      }) === false) {
        return;
      }

      if (props.onTabChange) props.onTabChange({
        originalEvent: event,
        index: index
      });else setActiveIndexState(index);
    }

    updateScrollBar(index);
  };

  var _onKeyDown = function onKeyDown(event, tab, index) {
    if (event.code === 'Enter') {
      onTabHeaderClick(event, tab, index);
    }
  };

  var updateInkBar = function updateInkBar() {
    var tabHeader = tabsRef.current["tab_".concat(activeIndex)];
    inkbarRef.current.style.width = DomHandler.getWidth(tabHeader) + 'px';
    inkbarRef.current.style.left = DomHandler.getOffset(tabHeader).left - DomHandler.getOffset(navRef.current).left + 'px';
  };

  var updateScrollBar = function updateScrollBar(index) {
    var tabHeader = tabsRef.current["tab_".concat(index)];

    if (tabHeader && tabHeader.scrollIntoView) {
      tabHeader.scrollIntoView({
        block: 'nearest'
      });
    }
  };

  var updateButtonState = function updateButtonState() {
    var _contentRef$current = contentRef.current,
        scrollLeft = _contentRef$current.scrollLeft,
        scrollWidth = _contentRef$current.scrollWidth;
    var width = DomHandler.getWidth(contentRef.current);
    setBackwardIsDisabledState(scrollLeft === 0);
    setForwardIsDisabledState(scrollLeft === scrollWidth - width);
  };

  var onScroll = function onScroll(event) {
    props.scrollable && updateButtonState();
    event.preventDefault();
  };

  var getVisibleButtonWidths = function getVisibleButtonWidths() {
    return [prevBtnRef.current, nextBtnRef.current].reduce(function (acc, el) {
      return el ? acc + DomHandler.getWidth(el) : acc;
    }, 0);
  };

  var navBackward = function navBackward() {
    var width = DomHandler.getWidth(contentRef.current) - getVisibleButtonWidths();
    var pos = contentRef.current.scrollLeft - width;
    contentRef.current.scrollLeft = pos <= 0 ? 0 : pos;
  };

  var navForward = function navForward() {
    var width = DomHandler.getWidth(contentRef.current) - getVisibleButtonWidths();
    var pos = contentRef.current.scrollLeft + width;
    var lastPos = contentRef.current.scrollWidth - width;
    contentRef.current.scrollLeft = pos >= lastPos ? lastPos : pos;
  };

  var reset = function reset() {
    setBackwardIsDisabledState(true);
    setForwardIsDisabledState(false);
    setHiddenTabsState([]);
    if (props.onTabChange) props.onTabChange({
      index: activeIndex
    });else setActiveIndexState(props.activeIndex);
  };

  React.useEffect(function () {
    updateInkBar();
  });
  useMountEffect(function () {
    if (!idState) {
      setIdState(UniqueComponentId());
    }
  });
  useUpdateEffect(function () {
    if (ObjectUtils.isNotEmpty(hiddenTabsState)) {
      var tabInfo = findVisibleActiveTab(hiddenTabsState[hiddenTabsState.length - 1]);
      tabInfo && onTabHeaderClick(null, tabInfo.tab, tabInfo.index);
    }
  }, [hiddenTabsState]);
  useUpdateEffect(function () {
    updateScrollBar(props.activeIndex);
  }, [props.activeIndex]);
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      reset: reset,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });

  var createTabHeader = function createTabHeader(tab, index) {
    var selected = isSelected(index);
    var _tab$props = tab.props,
        headerStyle = _tab$props.headerStyle,
        headerClassName = _tab$props.headerClassName,
        _style = _tab$props.style,
        _className = _tab$props.className,
        disabled = _tab$props.disabled,
        leftIcon = _tab$props.leftIcon,
        rightIcon = _tab$props.rightIcon,
        header = _tab$props.header,
        headerTemplate = _tab$props.headerTemplate,
        closable = _tab$props.closable;

    var style = _objectSpread$4(_objectSpread$4({}, headerStyle || {}), _style || {});

    var className = classNames('p-unselectable-text', {
      'p-tabview-selected p-highlight': selected,
      'p-disabled': disabled
    }, headerClassName, _className);
    var headerId = idState + '_header_' + index;
    var ariaControls = idState + '_content_' + index;
    var tabIndex = disabled ? null : 0;
    var leftIconElement = leftIcon && /*#__PURE__*/React.createElement("i", {
      className: leftIcon
    });
    var titleElement = /*#__PURE__*/React.createElement("span", {
      className: "p-tabview-title"
    }, header);
    var rightIconElement = rightIcon && /*#__PURE__*/React.createElement("i", {
      className: rightIcon
    });
    var closableIconElement = closable && /*#__PURE__*/React.createElement("i", {
      className: "p-tabview-close pi pi-times",
      onClick: function onClick(e) {
        return onTabHeaderClose(e, index);
      }
    });
    var content =
    /*#__PURE__*/
    // eslint-disable /
    React.createElement("a", {
      role: "tab",
      className: "p-tabview-nav-link",
      onClick: function onClick(e) {
        return onTabHeaderClick(e, tab, index);
      },
      id: headerId,
      onKeyDown: function onKeyDown(e) {
        return _onKeyDown(e, tab, index);
      },
      "aria-controls": ariaControls,
      "aria-selected": selected,
      tabIndex: tabIndex
    }, leftIconElement, titleElement, rightIconElement, closableIconElement, /*#__PURE__*/React.createElement(Ripple, null)) // eslint-enable /
    ;

    if (headerTemplate) {
      var defaultContentOptions = {
        className: 'p-tabview-nav-link',
        titleClassName: 'p-tabview-title',
        onClick: function onClick(e) {
          return onTabHeaderClick(e, tab, index);
        },
        onKeyDown: function onKeyDown(e) {
          return _onKeyDown(e, tab, index);
        },
        leftIconElement: leftIconElement,
        titleElement: titleElement,
        rightIconElement: rightIconElement,
        element: content,
        props: props,
        index: index,
        selected: selected,
        ariaControls: ariaControls
      };
      content = ObjectUtils.getJSXElement(headerTemplate, defaultContentOptions);
    }

    return /*#__PURE__*/React.createElement("li", {
      ref: function ref(el) {
        return tabsRef.current["tab_".concat(index)] = el;
      },
      className: className,
      style: style,
      role: "presentation"
    }, content);
  };

  var createTabHeaders = function createTabHeaders() {
    return React.Children.map(props.children, function (tab, index) {
      if (shouldUseTab(tab, index)) {
        return createTabHeader(tab, index);
      }
    });
  };

  var createNavigator = function createNavigator() {
    var headers = createTabHeaders();
    return /*#__PURE__*/React.createElement("div", {
      ref: contentRef,
      id: idState,
      className: "p-tabview-nav-content",
      style: props.style,
      onScroll: onScroll
    }, /*#__PURE__*/React.createElement("ul", {
      ref: navRef,
      className: "p-tabview-nav",
      role: "tablist"
    }, headers, /*#__PURE__*/React.createElement("li", {
      ref: inkbarRef,
      className: "p-tabview-ink-bar"
    })));
  };

  var createContent = function createContent() {
    var className = classNames('p-tabview-panels', props.panelContainerClassName);
    var contents = React.Children.map(props.children, function (tab, index) {
      if (shouldUseTab(tab, index) && (!props.renderActiveOnly || isSelected(index))) {
        var selected = isSelected(index);

        var style = _objectSpread$4(_objectSpread$4({}, tab.props.contentStyle || {}), tab.props.style || {});

        var _className2 = classNames(tab.props.contentClassName, tab.props.className, 'p-tabview-panel', {
          'p-hidden': !selected
        });

        var contentId = idState + '_content_' + index;
        var ariaLabelledBy = idState + '_header_' + index;

        var _otherProps = ObjectUtils.findDiffKeys(tab.props, TabPanel.defaultProps);

        return /*#__PURE__*/React.createElement("div", _extends$6({}, _otherProps, {
          id: contentId,
          "aria-labelledby": ariaLabelledBy,
          "aria-hidden": !selected,
          className: _className2,
          style: style,
          role: "tabpanel"
        }), !props.renderActiveOnly ? tab.props.children : selected && tab.props.children);
      }
    });
    return /*#__PURE__*/React.createElement("div", {
      className: className,
      style: props.panelContainerStyle
    }, contents);
  };

  var createPrevButton = function createPrevButton() {
    if (props.scrollable && !backwardIsDisabledState) {
      return /*#__PURE__*/React.createElement("button", {
        ref: prevBtnRef,
        className: "p-tabview-nav-prev p-tabview-nav-btn p-link",
        onClick: navBackward,
        type: "button",
        "aria-label": ariaLabel('previousPageLabel')
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-left"
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }

    return null;
  };

  var createNextButton = function createNextButton() {
    if (props.scrollable && !forwardIsDisabledState) {
      return /*#__PURE__*/React.createElement("button", {
        ref: nextBtnRef,
        className: "p-tabview-nav-next p-tabview-nav-btn p-link",
        onClick: navForward,
        type: "button",
        "aria-label": ariaLabel('nextPageLabel')
      }, /*#__PURE__*/React.createElement("span", {
        className: "pi pi-chevron-right",
        "aria-hidden": "true"
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }
  };

  var otherProps = ObjectUtils.findDiffKeys(props, TabView$1.defaultProps);
  var className = classNames('p-tabview p-component', {
    'p-tabview-scrollable': props.scrollable
  }, props.className);
  var navigator = createNavigator();
  var content = createContent();
  var prevButton = createPrevButton();
  var nextButton = createNextButton();
  return /*#__PURE__*/React.createElement("div", _extends$6({
    ref: elementRef,
    className: className
  }, otherProps), /*#__PURE__*/React.createElement("div", {
    className: "p-tabview-nav-container"
  }, prevButton, navigator, nextButton), content);
});
TabPanel.displayName = 'TabPanel';
TabPanel.defaultProps = {
  __TYPE: 'TabPanel',
  className: null,
  closable: false,
  contentClassName: null,
  contentStyle: null,
  disabled: false,
  header: null,
  headerClassName: null,
  headerStyle: null,
  headerTemplate: null,
  leftIcon: null,
  rightIcon: null,
  style: null
};
TabView$1.displayName = 'TabView';
TabView$1.defaultProps = {
  __TYPE: 'TabView',
  id: null,
  activeIndex: 0,
  className: null,
  onBeforeTabChange: null,
  onBeforeTabClose: null,
  onTabChange: null,
  onTabClose: null,
  panelContainerClassName: null,
  panelContainerStyle: null,
  renderActiveOnly: true,
  scrollable: false,
  style: null
};

var TabView = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      activeIndex = _ref.activeIndex,
      style = _ref.style,
      className = _ref.className,
      renderActiveOnly = _ref.renderActiveOnly,
      scrollable = _ref.scrollable,
      onTabChange = _ref.onTabChange,
      children = _ref.children;
  return /*#__PURE__*/React__default.createElement(TabView$1, {
    ref: ref,
    id: id,
    activeIndex: activeIndex,
    renderActiveOnly: renderActiveOnly,
    scrollable: scrollable,
    style: style,
    onTabChange: onTabChange,
    className: className
  }, children);
});

function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$5.apply(this, arguments);
}

function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var Tag$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _classNames;

  var elementRef = React.useRef(null);
  var otherProps = ObjectUtils.findDiffKeys(props, Tag$1.defaultProps);
  var className = classNames('p-tag p-component', (_classNames = {}, _defineProperty$3(_classNames, "p-tag-".concat(props.severity), props.severity !== null), _defineProperty$3(_classNames, 'p-tag-rounded', props.rounded), _classNames), props.className);
  var icon = IconUtils.getJSXIcon(props.icon, {
    className: 'p-tag-icon'
  }, {
    props: props
  });
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  return /*#__PURE__*/React.createElement("span", _extends$5({
    ref: elementRef,
    className: className,
    style: props.style
  }, otherProps), icon, /*#__PURE__*/React.createElement("span", {
    className: "p-tag-value"
  }, props.value), /*#__PURE__*/React.createElement("span", null, props.children));
});
Tag$1.displayName = 'Tag';
Tag$1.defaultProps = {
  __TYPE: 'Tag',
  value: null,
  severity: null,
  rounded: false,
  icon: null,
  style: null,
  className: null
};

var Tag = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var value = _ref.value,
      severity = _ref.severity,
      icon = _ref.icon,
      style = _ref.style,
      className = _ref.className;
  var tagClassName = classNames(className, {
    "p-tag-secondary": severity === "secondary",
    "p-tag-help": severity === "help"
  });
  return /*#__PURE__*/React__default.createElement(Tag$1, {
    ref: ref,
    value: value,
    severity: severity,
    icon: icon,
    className: tagClassName,
    style: style
  });
});

function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$4.apply(this, arguments);
}

function _arrayWithHoles$4(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$4(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray$8(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$8(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$8(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen);
}

function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$4(arr, i) {
  return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$8(arr, i) || _nonIterableRest$4();
}

var TieredMenuSub = /*#__PURE__*/React.memo(function (props) {
  var _React$useState = React.useState(null),
      _React$useState2 = _slicedToArray$4(_React$useState, 2),
      activeItemState = _React$useState2[0],
      setActiveItemState = _React$useState2[1];

  var elementRef = React.useRef(null);

  var _useEventListener = useEventListener({
    type: 'click',
    listener: function listener(event) {
      if (elementRef.current && !elementRef.current.contains(event.target)) {
        setActiveItemState(null);
      }
    }
  }),
      _useEventListener2 = _slicedToArray$4(_useEventListener, 1),
      bindDocumentClickListener = _useEventListener2[0];

  var position = function position() {
    if (elementRef.current) {
      var parentItem = elementRef.current.parentElement;
      var containerOffset = DomHandler.getOffset(parentItem);
      var viewport = DomHandler.getViewport();
      var sublistWidth = elementRef.current.offsetParent ? elementRef.current.offsetWidth : DomHandler.getHiddenElementOuterWidth(elementRef.current);
      var itemOuterWidth = DomHandler.getOuterWidth(parentItem.children[0]);

      if (parseInt(containerOffset.left, 10) + itemOuterWidth + sublistWidth > viewport.width - DomHandler.calculateScrollbarWidth()) {
        DomHandler.addClass(elementRef.current, 'p-submenu-list-flipped');
      }
    }
  };

  var onItemMouseEnter = function onItemMouseEnter(event, item) {
    if (item.disabled) {
      event.preventDefault();
      return;
    }

    if (props.root) {
      if (activeItemState || props.popup) {
        setActiveItemState(item);
      }
    } else {
      setActiveItemState(item);
    }
  };

  var onItemClick = function onItemClick(event, item) {
    if (item.disabled) {
      event.preventDefault();
      return;
    }

    if (!item.url) {
      event.preventDefault();
    }

    if (item.command) {
      item.command({
        originalEvent: event,
        item: item
      });
    }

    if (props.root) {
      if (item.items) {
        if (activeItemState && item === activeItemState) setActiveItemState(null);else setActiveItemState(item);
      }
    }

    if (!item.items) {
      onLeafClick();
    }
  };

  var onItemKeyDown = function onItemKeyDown(event, item) {
    var listItem = event.currentTarget.parentElement;

    switch (event.which) {
      //down
      case 40:
        var nextItem = findNextItem(listItem);
        nextItem && nextItem.children[0].focus();
        event.preventDefault();
        break;
      //up

      case 38:
        var prevItem = findPrevItem(listItem);
        prevItem && prevItem.children[0].focus();
        event.preventDefault();
        break;
      //right

      case 39:
        if (item.items) {
          setActiveItemState(item);
          setTimeout(function () {
            listItem.children[1].children[0].children[0].focus();
          }, 50);
        }

        event.preventDefault();
        break;
    }

    props.onKeyDown && props.onKeyDown(event, listItem);
  };

  var onChildItemKeyDown = function onChildItemKeyDown(event, childListItem) {
    //left
    if (event.which === 37) {
      setActiveItemState(null);
      childListItem.parentElement.previousElementSibling.focus();
    }
  };

  var findNextItem = function findNextItem(item) {
    var nextItem = item.nextElementSibling;
    return nextItem ? DomHandler.hasClass(nextItem, 'p-disabled') || !DomHandler.hasClass(nextItem, 'p-menuitem') ? findNextItem(nextItem) : nextItem : null;
  };

  var findPrevItem = function findPrevItem(item) {
    var prevItem = item.previousElementSibling;
    return prevItem ? DomHandler.hasClass(prevItem, 'p-disabled') || !DomHandler.hasClass(prevItem, 'p-menuitem') ? findPrevItem(prevItem) : prevItem : null;
  };

  var onLeafClick = function onLeafClick() {
    setActiveItemState(null);
    props.onLeafClick && props.onLeafClick();
  };

  useMountEffect(function () {
    bindDocumentClickListener();
  });
  useUpdateEffect(function () {
    if (!props.parentActive) {
      setActiveItemState(null);
    }

    if (!props.root && props.parentActive) {
      position();
    }
  }, [props.parentActive]);

  var createSeparator = function createSeparator(index) {
    var key = 'separator_' + index;
    return /*#__PURE__*/React.createElement("li", {
      key: key,
      className: "p-menu-separator",
      role: "separator"
    });
  };

  var createSubmenu = function createSubmenu(item) {
    if (item.items) {
      return /*#__PURE__*/React.createElement(TieredMenuSub, {
        menuProps: props.menuProps,
        model: item.items,
        onLeafClick: onLeafClick,
        popup: props.popup,
        onKeyDown: onChildItemKeyDown,
        parentActive: item === activeItemState
      });
    }

    return null;
  };

  var createMenuItem = function createMenuItem(item, index) {
    if (item.visible === false) {
      return null;
    }

    item.id;
    var _className = item.className,
        style = item.style,
        disabled = item.disabled,
        _icon = item.icon,
        _label = item.label,
        items = item.items,
        target = item.target,
        url = item.url,
        template = item.template;
    var key = _label + '_' + index;
    var active = activeItemState === item;
    var className = classNames('p-menuitem', {
      'p-menuitem-active': active
    }, _className);
    var linkClassName = classNames('p-menuitem-link', {
      'p-disabled': disabled
    });
    var iconClassName = classNames('p-menuitem-icon', _icon);
    var submenuIconClassName = 'p-submenu-icon pi pi-angle-right';
    var icon = IconUtils.getJSXIcon(_icon, {
      className: 'p-menuitem-icon'
    }, {
      props: props.menuProps
    });

    var label = _label && /*#__PURE__*/React.createElement("span", {
      className: "p-menuitem-text"
    }, _label);

    var submenuIcon = items && /*#__PURE__*/React.createElement("span", {
      className: submenuIconClassName
    });
    var submenu = createSubmenu(item);
    var content = /*#__PURE__*/React.createElement("a", {
      href: url || '#',
      className: linkClassName,
      target: target,
      role: "menuitem",
      "aria-haspopup": items != null,
      onClick: function onClick(event) {
        return onItemClick(event, item);
      },
      onKeyDown: function onKeyDown(event) {
        return onItemKeyDown(event, item);
      },
      "aria-disabled": disabled
    }, icon, label, submenuIcon, /*#__PURE__*/React.createElement(Ripple, null));

    if (template) {
      var defaultContentOptions = {
        onClick: function onClick(event) {
          return onItemClick(event, item);
        },
        onKeyDown: function onKeyDown(event) {
          return onItemKeyDown(event, item);
        },
        className: linkClassName,
        labelClassName: 'p-menuitem-text',
        iconClassName: iconClassName,
        submenuIconClassName: submenuIconClassName,
        element: content,
        props: props,
        active: active,
        disabled: disabled
      };
      content = ObjectUtils.getJSXElement(template, item, defaultContentOptions);
    }

    return /*#__PURE__*/React.createElement("li", {
      key: key,
      id: item,
      className: className,
      style: style,
      onMouseEnter: function onMouseEnter(event) {
        return onItemMouseEnter(event, item);
      },
      role: "none"
    }, content, submenu);
  };

  var createItem = function createItem(item, index) {
    return item.separator ? createSeparator(index) : createMenuItem(item, index);
  };

  var createMenu = function createMenu() {
    return props.model ? props.model.map(createItem) : null;
  };

  var className = classNames({
    'p-submenu-list': !props.root
  });
  var submenu = createMenu();
  return /*#__PURE__*/React.createElement("ul", {
    ref: elementRef,
    className: className,
    role: props.root ? 'menubar' : 'menu',
    "aria-orientation": "horizontal"
  }, submenu);
});
TieredMenuSub.displayName = 'TieredMenuSub';
var TieredMenu$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(!props.popup),
      _React$useState2 = _slicedToArray$4(_React$useState, 2),
      visibleState = _React$useState2[0],
      setVisibleState = _React$useState2[1];

  var menuRef = React.useRef(null);
  var targetRef = React.useRef(null);

  var _useOverlayListener = useOverlayListener({
    target: targetRef,
    overlay: menuRef,
    listener: function listener(event, _ref) {
      var valid = _ref.valid;
      valid && hide(event);
    },
    when: visibleState
  }),
      _useOverlayListener2 = _slicedToArray$4(_useOverlayListener, 2),
      bindOverlayListener = _useOverlayListener2[0],
      unbindOverlayListener = _useOverlayListener2[1];

  var onPanelClick = function onPanelClick(event) {
    if (props.popup) {
      OverlayService.emit('overlay-click', {
        originalEvent: event,
        target: targetRef.current
      });
    }
  };

  var toggle = function toggle(event) {
    if (props.popup) {
      visibleState ? hide(event) : show(event);
    }
  };

  var show = function show(event) {
    targetRef.current = event.currentTarget;
    setVisibleState(true);
    props.onShow && props.onShow(event);
  };

  var hide = function hide(event) {
    targetRef.current = event.currentTarget;
    setVisibleState(false);
    props.onHide && props.onHide(event);
  };

  var onEnter = function onEnter() {
    if (props.autoZIndex) {
      ZIndexUtils.set('menu', menuRef.current, PrimeReact$1.autoZIndex, props.baseZIndex || PrimeReact$1.zIndex['menu']);
    }

    DomHandler.absolutePosition(menuRef.current, targetRef.current);
  };

  var onEntered = function onEntered() {
    bindOverlayListener();
  };

  var onExit = function onExit() {
    targetRef.current = null;
    unbindOverlayListener();
  };

  var onExited = function onExited() {
    ZIndexUtils.clear(menuRef.current);
  };

  useUnmountEffect(function () {
    ZIndexUtils.clear(menuRef.current);
  });
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      toggle: toggle,
      show: show,
      hide: hide,
      getElement: function getElement() {
        return menuRef.current;
      }
    };
  });

  var createElement = function createElement() {
    var otherProps = ObjectUtils.findDiffKeys(props, TieredMenu$1.defaultProps);
    var className = classNames('p-tieredmenu p-component', {
      'p-tieredmenu-overlay': props.popup
    }, props.className);
    return /*#__PURE__*/React.createElement(CSSTransition, {
      nodeRef: menuRef,
      classNames: "p-connected-overlay",
      "in": visibleState,
      timeout: {
        enter: 120,
        exit: 100
      },
      options: props.transitionOptions,
      unmountOnExit: true,
      onEnter: onEnter,
      onEntered: onEntered,
      onExit: onExit,
      onExited: onExited
    }, /*#__PURE__*/React.createElement("div", _extends$4({
      ref: menuRef,
      id: props.id,
      className: className,
      style: props.style
    }, otherProps, {
      onClick: onPanelClick
    }), /*#__PURE__*/React.createElement(TieredMenuSub, {
      menuProps: props,
      model: props.model,
      root: true,
      popup: props.popup
    })));
  };

  var element = createElement();
  return props.popup ? /*#__PURE__*/React.createElement(Portal, {
    element: element,
    appendTo: props.appendTo
  }) : element;
}));
TieredMenu$1.displayName = 'TieredMenu';
TieredMenu$1.defaultProps = {
  __TYPE: 'TieredMenu',
  id: null,
  model: null,
  popup: false,
  style: null,
  className: null,
  autoZIndex: true,
  baseZIndex: 0,
  appendTo: null,
  transitionOptions: null,
  onShow: null,
  onHide: null
};

var TieredMenu = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      model = _ref.model,
      style = _ref.style,
      className = _ref.className,
      _ref$autoZIndex = _ref.autoZIndex,
      autoZIndex = _ref$autoZIndex === void 0 ? true : _ref$autoZIndex,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 150 : _ref$baseZIndex;
  return /*#__PURE__*/React__default.createElement(TieredMenu$1, {
    ref: ref,
    id: id,
    model: model,
    style: style,
    className: className,
    autoZIndex: autoZIndex,
    baseZIndex: baseZIndex
  });
});

var TimePicker = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      name = _ref.name,
      value = _ref.value,
      onChange = _ref.onChange,
      _ref$showSeconds = _ref.showSeconds,
      showSeconds = _ref$showSeconds === void 0 ? false : _ref$showSeconds,
      _ref$showMillisec = _ref.showMillisec,
      showMillisec = _ref$showMillisec === void 0 ? false : _ref$showMillisec,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$stepHour = _ref.stepHour,
      stepHour = _ref$stepHour === void 0 ? 1 : _ref$stepHour,
      _ref$stepSecond = _ref.stepSecond,
      stepSecond = _ref$stepSecond === void 0 ? 1 : _ref$stepSecond,
      _ref$stepMinute = _ref.stepMinute,
      stepMinute = _ref$stepMinute === void 0 ? 1 : _ref$stepMinute,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder,
      _ref$showIcon = _ref.showIcon,
      showIcon = _ref$showIcon === void 0 ? false : _ref$showIcon,
      _ref$viewDate = _ref.viewDate,
      viewDate = _ref$viewDate === void 0 ? null : _ref$viewDate;
  return /*#__PURE__*/React__default.createElement(Calendar, {
    id: id,
    name: name,
    ref: ref,
    value: value,
    onChange: onChange,
    showSeconds: showSeconds,
    showMillisec: showMillisec,
    stepHour: stepHour,
    stepSecond: stepSecond,
    stepMinute: stepMinute,
    disabled: disabled,
    placeholder: placeholder,
    showIcon: showIcon,
    viewDate: viewDate,
    hourFormat: "24",
    showTime: true,
    timeOnly: true
  });
});

function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$3.apply(this, arguments);
}

function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$2(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$7(arr);
}

function _iterableToArray$2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$7(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
}

function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$2(arr) {
  return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$2();
}

function _arrayWithHoles$3(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$3(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$3(arr, i) {
  return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$7(arr, i) || _nonIterableRest$3();
}

function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var FilterMatchMode = Object.freeze({
  STARTS_WITH: 'startsWith',
  CONTAINS: 'contains',
  NOT_CONTAINS: 'notContains',
  ENDS_WITH: 'endsWith',
  EQUALS: 'equals',
  NOT_EQUALS: 'notEquals',
  IN: 'in',
  LESS_THAN: 'lt',
  LESS_THAN_OR_EQUAL_TO: 'lte',
  GREATER_THAN: 'gt',
  GREATER_THAN_OR_EQUAL_TO: 'gte',
  BETWEEN: 'between',
  DATE_IS: 'dateIs',
  DATE_IS_NOT: 'dateIsNot',
  DATE_BEFORE: 'dateBefore',
  DATE_AFTER: 'dateAfter',
  CUSTOM: 'custom'
});

var PrimeReact = /*#__PURE__*/_createClass(function PrimeReact() {
  _classCallCheck(this, PrimeReact);
});

_defineProperty$2(PrimeReact, "ripple", false);

_defineProperty$2(PrimeReact, "inputStyle", 'outlined');

_defineProperty$2(PrimeReact, "locale", 'en');

_defineProperty$2(PrimeReact, "appendTo", null);

_defineProperty$2(PrimeReact, "cssTransition", true);

_defineProperty$2(PrimeReact, "autoZIndex", true);

_defineProperty$2(PrimeReact, "nonce", null);

_defineProperty$2(PrimeReact, "nullSortOrder", 1);

_defineProperty$2(PrimeReact, "zIndex", {
  modal: 1100,
  overlay: 1000,
  menu: 1000,
  tooltip: 1100,
  toast: 1200
});

_defineProperty$2(PrimeReact, "filterMatchModeOptions", {
  text: [FilterMatchMode.STARTS_WITH, FilterMatchMode.CONTAINS, FilterMatchMode.NOT_CONTAINS, FilterMatchMode.ENDS_WITH, FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS],
  numeric: [FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS, FilterMatchMode.LESS_THAN, FilterMatchMode.LESS_THAN_OR_EQUAL_TO, FilterMatchMode.GREATER_THAN, FilterMatchMode.GREATER_THAN_OR_EQUAL_TO],
  date: [FilterMatchMode.DATE_IS, FilterMatchMode.DATE_IS_NOT, FilterMatchMode.DATE_BEFORE, FilterMatchMode.DATE_AFTER]
});

var locales = {
  en: {
    startsWith: 'Starts with',
    contains: 'Contains',
    notContains: 'Not contains',
    endsWith: 'Ends with',
    equals: 'Equals',
    notEquals: 'Not equals',
    noFilter: 'No Filter',
    filter: 'Filter',
    lt: 'Less than',
    lte: 'Less than or equal to',
    gt: 'Greater than',
    gte: 'Greater than or equal to',
    dateIs: 'Date is',
    dateIsNot: 'Date is not',
    dateBefore: 'Date is before',
    dateAfter: 'Date is after',
    custom: 'Custom',
    clear: 'Clear',
    close: 'Close',
    apply: 'Apply',
    matchAll: 'Match All',
    matchAny: 'Match Any',
    addRule: 'Add Rule',
    removeRule: 'Remove Rule',
    accept: 'Yes',
    reject: 'No',
    choose: 'Choose',
    upload: 'Upload',
    cancel: 'Cancel',
    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    today: 'Today',
    weekHeader: 'Wk',
    firstDayOfWeek: 0,
    dateFormat: 'mm/dd/yy',
    weak: 'Weak',
    medium: 'Medium',
    strong: 'Strong',
    passwordPrompt: 'Enter a password',
    emptyFilterMessage: 'No available options',
    emptyMessage: 'No results found',
    aria: {
      trueLabel: 'True',
      falseLabel: 'False',
      nullLabel: 'Not Selected',
      pageLabel: 'Page',
      firstPageLabel: 'First Page',
      lastPageLabel: 'Last Page',
      nextPageLabel: 'Next Page',
      previousPageLabel: 'Previous Page',
      selectLabel: 'Select',
      unselectLabel: 'Unselect',
      expandLabel: 'Expand',
      collapseLabel: 'Collapse'
    }
  }
};

function localeOption(key, locale) {
  var _locale = locale || PrimeReact.locale;

  try {
    return localeOptions(_locale)[key];
  } catch (error) {
    throw new Error("The ".concat(key, " option is not found in the current locale('").concat(_locale, "')."));
  }
}

function localeOptions(locale) {
  var _locale = locale || PrimeReact.locale;

  return locales[_locale];
}

var ToastMessage = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var messageInfo = props.messageInfo;
  var _messageInfo$message = messageInfo.message,
      severity = _messageInfo$message.severity,
      content = _messageInfo$message.content,
      summary = _messageInfo$message.summary,
      detail = _messageInfo$message.detail,
      closable = _messageInfo$message.closable,
      life = _messageInfo$message.life,
      sticky = _messageInfo$message.sticky,
      _className = _messageInfo$message.className,
      style = _messageInfo$message.style,
      _contentClassName = _messageInfo$message.contentClassName,
      contentStyle = _messageInfo$message.contentStyle;

  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$3(_React$useState, 2),
      focused = _React$useState2[0],
      setFocused = _React$useState2[1];

  var _useTimeout = useTimeout(function () {
    onClose();
  }, life || 3000, !sticky && !focused),
      _useTimeout2 = _slicedToArray$3(_useTimeout, 1),
      clearTimer = _useTimeout2[0];

  var onClose = function onClose() {
    clearTimer();
    props.onClose && props.onClose(messageInfo);
  };

  var onClick = function onClick(event) {
    if (props.onClick && !(DomHandler.hasClass(event.target, 'p-toast-icon-close') || DomHandler.hasClass(event.target, 'p-toast-icon-close-icon'))) {
      props.onClick(messageInfo.message);
    }
  };

  var onMouseEnter = function onMouseEnter(event) {
    props.onMouseEnter && props.onMouseEnter(event); // do not continue if the user has canceled the event

    if (event.defaultPrevented) {
      return;
    } // stop timer while user has focused message


    if (!sticky) {
      clearTimer();
      setFocused(true);
    }
  };

  var onMouseLeave = function onMouseLeave(event) {
    props.onMouseLeave && props.onMouseLeave(event); // do not continue if the user has canceled the event

    if (event.defaultPrevented) {
      return;
    } // restart timer when user has left message


    if (!sticky) {
      setFocused(false);
    }
  };

  var createCloseIcon = function createCloseIcon() {
    if (closable !== false) {
      return /*#__PURE__*/React.createElement("button", {
        type: "button",
        className: "p-toast-icon-close p-link",
        onClick: onClose,
        "aria-label": localeOption('close')
      }, /*#__PURE__*/React.createElement("span", {
        className: "p-toast-icon-close-icon pi pi-times",
        "aria-hidden": "true"
      }), /*#__PURE__*/React.createElement(Ripple, null));
    }

    return null;
  };

  var createMessage = function createMessage() {
    if (messageInfo) {
      var contentEl = ObjectUtils.getJSXElement(content, {
        message: messageInfo.message,
        onClick: onClick,
        onClose: onClose
      });
      var iconClassName = classNames('p-toast-message-icon pi', {
        'pi-info-circle': severity === 'info',
        'pi-exclamation-triangle': severity === 'warn',
        'pi-times': severity === 'error',
        'pi-check': severity === 'success'
      });
      return contentEl || /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
        className: iconClassName
      }), /*#__PURE__*/React.createElement("div", {
        className: "p-toast-message-text"
      }, /*#__PURE__*/React.createElement("span", {
        className: "p-toast-summary"
      }, summary), detail && /*#__PURE__*/React.createElement("div", {
        className: "p-toast-detail"
      }, detail)));
    }

    return null;
  };

  var className = classNames('p-toast-message', _defineProperty$2({}, "p-toast-message-".concat(severity), severity), _className);
  var contentClassName = classNames('p-toast-message-content', _contentClassName);
  var message = createMessage();
  var closeIcon = createCloseIcon();
  return /*#__PURE__*/React.createElement("div", {
    ref: ref,
    className: className,
    style: style,
    role: "alert",
    "aria-live": "assertive",
    "aria-atomic": "true",
    onClick: onClick,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave
  }, /*#__PURE__*/React.createElement("div", {
    className: contentClassName,
    style: contentStyle
  }, message, closeIcon));
}));
ToastMessage.displayName = 'ToastMessage';
var messageIdx = 0;
var Toast$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState([]),
      _React$useState2 = _slicedToArray$3(_React$useState, 2),
      messagesState = _React$useState2[0],
      setMessagesState = _React$useState2[1];

  var containerRef = React.useRef(null);

  var show = function show(value) {
    if (value) {
      var messages = assignIdentifiers(value, true);
      messagesState.length === 0 && ZIndexUtils.set('toast', containerRef.current, PrimeReact$1.autoZIndex, props.baseZIndex || PrimeReact$1.zIndex['toast']);
      setMessagesState(messages);
    }
  };

  var assignIdentifiers = function assignIdentifiers(value, copy) {
    var messages;

    if (Array.isArray(value)) {
      var multipleMessages = value.reduce(function (acc, message) {
        acc.push({
          _pId: messageIdx++,
          message: message
        });
        return acc;
      }, []);

      if (copy) {
        messages = messagesState ? [].concat(_toConsumableArray$2(messagesState), _toConsumableArray$2(multipleMessages)) : multipleMessages;
      } else {
        messages = multipleMessages;
      }
    } else {
      var message = {
        _pId: messageIdx++,
        message: value
      };

      if (copy) {
        messages = messagesState ? [].concat(_toConsumableArray$2(messagesState), [message]) : [message];
      } else {
        messages = [message];
      }
    }

    return messages;
  };

  var clear = function clear() {
    ZIndexUtils.clear(containerRef.current);
    setMessagesState([]);
  };

  var replace = function replace(value) {
    var replaced = assignIdentifiers(value, false);
    setMessagesState(replaced);
  };

  var onClose = function onClose(messageInfo) {
    var messages = messagesState.filter(function (msg) {
      return msg._pId !== messageInfo._pId;
    });
    setMessagesState(messages);
    props.onRemove && props.onRemove(messageInfo.message);
  };

  var onEntered = function onEntered() {
    props.onShow && props.onShow();
  };

  var onExited = function onExited() {
    messagesState.length === 1 && ZIndexUtils.clear(containerRef.current);
    props.onHide && props.onHide();
  };

  useUnmountEffect(function () {
    ZIndexUtils.clear(containerRef.current);
  });
  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      show: show,
      replace: replace,
      clear: clear,
      getElement: function getElement() {
        return containerRef.current;
      }
    };
  });

  var createElement = function createElement() {
    var otherProps = ObjectUtils.findDiffKeys(props, Toast$1.defaultProps);
    var className = classNames('p-toast p-component p-toast-' + props.position, props.className);
    return /*#__PURE__*/React.createElement("div", _extends$3({
      ref: containerRef,
      id: props.id,
      className: className,
      style: props.style
    }, otherProps), /*#__PURE__*/React.createElement(TransitionGroup$1, null, messagesState.map(function (messageInfo) {
      var messageRef = /*#__PURE__*/React.createRef();
      return /*#__PURE__*/React.createElement(CSSTransition, {
        nodeRef: messageRef,
        key: messageInfo._pId,
        classNames: "p-toast-message",
        unmountOnExit: true,
        timeout: {
          enter: 300,
          exit: 300
        },
        onEntered: onEntered,
        onExited: onExited,
        options: props.transitionOptions
      }, /*#__PURE__*/React.createElement(ToastMessage, {
        ref: messageRef,
        messageInfo: messageInfo,
        onClick: props.onClick,
        onClose: onClose,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave
      }));
    })));
  };

  var element = createElement();
  return /*#__PURE__*/React.createElement(Portal, {
    element: element,
    appendTo: props.appendTo
  });
}));
Toast$1.displayName = 'Toast';
Toast$1.defaultProps = {
  __TYPE: 'Toast',
  id: null,
  className: null,
  style: null,
  baseZIndex: 0,
  position: 'top-right',
  transitionOptions: null,
  appendTo: 'self',
  onClick: null,
  onRemove: null,
  onShow: null,
  onHide: null,
  onMouseEnter: null,
  onMouseLeave: null
};

var Toast = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      className = _ref.className,
      style = _ref.style,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 300 : _ref$baseZIndex,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? "top-right" : _ref$position,
      onClick = _ref.onClick,
      onRemove = _ref.onRemove,
      onShow = _ref.onShow,
      onHide = _ref.onHide;
  return /*#__PURE__*/React__default.createElement(Toast$1, {
    ref: ref,
    id: id,
    className: className,
    style: style,
    position: position,
    event: event,
    baseZIndex: baseZIndex,
    onClick: onClick,
    onRemove: onRemove,
    onShow: onShow,
    onHide: onHide
  });
});

var Tooltip = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      target = _ref.target,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      className = _ref.className,
      style = _ref.style,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? "right" : _ref$position,
      at = _ref.at,
      event = _ref.event,
      _ref$showEvent = _ref.showEvent,
      showEvent = _ref$showEvent === void 0 ? "mouseenter" : _ref$showEvent,
      _ref$hideEvent = _ref.hideEvent,
      hideEvent = _ref$hideEvent === void 0 ? "mouseleave" : _ref$hideEvent,
      _ref$autoZIndex = _ref.autoZIndex,
      autoZIndex = _ref$autoZIndex === void 0 ? true : _ref$autoZIndex,
      _ref$baseZIndex = _ref.baseZIndex,
      baseZIndex = _ref$baseZIndex === void 0 ? 200 : _ref$baseZIndex,
      _ref$showDelay = _ref.showDelay,
      showDelay = _ref$showDelay === void 0 ? 0 : _ref$showDelay,
      _ref$hideDelay = _ref.hideDelay,
      hideDelay = _ref$hideDelay === void 0 ? 0 : _ref$hideDelay,
      _ref$autoHide = _ref.autoHide,
      autoHide = _ref$autoHide === void 0 ? true : _ref$autoHide,
      _ref$showOnDisabled = _ref.showOnDisabled,
      showOnDisabled = _ref$showOnDisabled === void 0 ? false : _ref$showOnDisabled,
      onShow = _ref.onShow,
      onHide = _ref.onHide,
      children = _ref.children;
  return /*#__PURE__*/React__default.createElement(Tooltip$1, {
    ref: ref,
    id: id,
    target: target,
    disabled: disabled,
    className: className,
    style: style,
    position: position,
    at: at,
    event: event,
    showEvent: showEvent,
    hideEvent: hideEvent,
    autoZIndex: autoZIndex,
    baseZIndex: baseZIndex,
    showDelay: showDelay,
    hideDelay: hideDelay,
    autoHide: autoHide,
    showOnDisabled: showOnDisabled,
    onShow: onShow,
    onHide: onHide
  }, children);
});

function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$2.apply(this, arguments);
}

function _arrayLikeToArray$2$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$2$1(arr);
}

function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$2$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$2$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2$1(o, minLen);
}

function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$2$1(arr) || _nonIterableSpread$1();
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$2(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$2(arr, i) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$2$1(arr, i) || _nonIterableRest$2();
}

function _createForOfIteratorHelper$1$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$1$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1$1(o, minLen);
}

function _arrayLikeToArray$1$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function ownKeys$1$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1$1(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var UITreeNode = /*#__PURE__*/React.memo(function (props) {
  var contentRef = React.useRef(null);
  var nodeTouched = React.useRef(false);
  var isLeaf = props.isNodeLeaf(props.node);
  var expanded = (props.expandedKeys ? props.expandedKeys[props.node.key] !== undefined : false) || props.node.expanded;

  var expand = function expand(event) {
    var expandedKeys = props.expandedKeys ? _objectSpread$1$1({}, props.expandedKeys) : {};
    expandedKeys[props.node.key] = true;
    props.onToggle({
      originalEvent: event,
      value: expandedKeys
    });
    invokeToggleEvents(event, true);
  };

  var collapse = function collapse(event) {
    var expandedKeys = _objectSpread$1$1({}, props.expandedKeys);

    delete expandedKeys[props.node.key];
    props.onToggle({
      originalEvent: event,
      value: expandedKeys
    });
    invokeToggleEvents(event, false);
  };

  var onTogglerClick = function onTogglerClick(event) {
    if (props.disabled) {
      return;
    }

    expanded ? collapse(event) : expand(event);
    event.preventDefault();
    event.stopPropagation();
  };

  var invokeToggleEvents = function invokeToggleEvents(event, isExpanded) {
    if (isExpanded) {
      if (props.onExpand) {
        props.onExpand({
          originalEvent: event,
          node: props.node
        });
      }
    } else {
      if (props.onCollapse) {
        props.onCollapse({
          originalEvent: event,
          node: props.node
        });
      }
    }
  };

  var onNodeKeyDown = function onNodeKeyDown(event) {
    if (props.disabled) {
      return;
    }

    var nodeElement = event.target.parentElement;

    if (!DomHandler.hasClass(nodeElement, 'p-treenode')) {
      return;
    }

    switch (event.which) {
      //down arrow
      case 40:
        var listElement = nodeElement.children[1];

        if (listElement) {
          focusNode(listElement.children[0]);
        } else {
          var nextNodeElement = nodeElement.nextElementSibling;

          while (nextNodeElement) {
            if (!DomHandler.hasClass(nextNodeElement, 'p-treenode-droppoint')) {
              break;
            }

            nextNodeElement = nextNodeElement.nextElementSibling;
          }

          if (nextNodeElement) {
            focusNode(nextNodeElement);
          } else {
            var nextSiblingAncestor = findNextSiblingOfAncestor(nodeElement);
            nextSiblingAncestor && focusNode(nextSiblingAncestor);
          }
        }

        event.preventDefault();
        break;
      //up arrow

      case 38:
        if (nodeElement.previousElementSibling) {
          focusNode(findLastVisibleDescendant(nodeElement.previousElementSibling));
        } else {
          var parentNodeElement = getParentNodeElement(nodeElement);
          parentNodeElement && focusNode(parentNodeElement);
        }

        event.preventDefault();
        break;
      //right arrow

      case 39:
        if (!expanded) {
          expand(event);
        }

        event.preventDefault();
        break;
      //left arrow

      case 37:
        if (expanded) {
          collapse(event);
        }

        event.preventDefault();
        break;
      //enter

      case 13:
        onClick(event);
        event.preventDefault();
        break;
    }
  };

  var findNextSiblingOfAncestor = function findNextSiblingOfAncestor(nodeElement) {
    var parentNodeElement = getParentNodeElement(nodeElement);
    return parentNodeElement ? parentNodeElement.nextElementSibling || findNextSiblingOfAncestor(parentNodeElement) : null;
  };

  var findLastVisibleDescendant = function findLastVisibleDescendant(nodeElement) {
    var childrenListElement = nodeElement.children[1];

    if (childrenListElement) {
      var lastChildElement = childrenListElement.children[childrenListElement.children.length - 1];
      return findLastVisibleDescendant(lastChildElement);
    } else {
      return nodeElement;
    }
  };

  var getParentNodeElement = function getParentNodeElement(nodeElement) {
    var parentNodeElement = nodeElement.parentElement.parentElement;
    return DomHandler.hasClass(parentNodeElement, 'p-treenode') ? parentNodeElement : null;
  };

  var focusNode = function focusNode(element) {
    element && element.children[0] && element.children[0].focus();
  };

  var onClick = function onClick(event) {
    if (props.onClick) {
      props.onClick({
        originalEvent: event,
        node: props.node
      });
    }

    var targetNode = event.target.nodeName;

    if (props.disabled || targetNode === 'INPUT' || targetNode === 'BUTTON' || targetNode === 'A' || DomHandler.hasClass(event.target, 'p-clickable')) {
      return;
    }

    if (props.selectionMode && props.node.selectable !== false) {
      var selectionKeys;

      if (isCheckboxSelectionMode()) {
        var checked = isChecked();
        selectionKeys = props.selectionKeys ? _objectSpread$1$1({}, props.selectionKeys) : {};

        if (checked) {
          if (props.propagateSelectionDown) propagateDown(props.node, false, selectionKeys);else delete selectionKeys[props.node.key];

          if (props.propagateSelectionUp && props.onPropagateUp) {
            props.onPropagateUp({
              originalEvent: event,
              check: false,
              selectionKeys: selectionKeys
            });
          }

          if (props.onUnselect) {
            props.onUnselect({
              originalEvent: event,
              node: props.node
            });
          }
        } else {
          if (props.propagateSelectionDown) propagateDown(props.node, true, selectionKeys);else selectionKeys[props.node.key] = {
            checked: true
          };

          if (props.propagateSelectionUp && props.onPropagateUp) {
            props.onPropagateUp({
              originalEvent: event,
              check: true,
              selectionKeys: selectionKeys
            });
          }

          if (props.onSelect) {
            props.onSelect({
              originalEvent: event,
              node: props.node
            });
          }
        }
      } else {
        var selected = isSelected();
        var metaSelection = nodeTouched.current ? false : props.metaKeySelection;

        if (metaSelection) {
          var metaKey = event.metaKey || event.ctrlKey;

          if (selected && metaKey) {
            if (isSingleSelectionMode()) {
              selectionKeys = null;
            } else {
              selectionKeys = _objectSpread$1$1({}, props.selectionKeys);
              delete selectionKeys[props.node.key];
            }

            if (props.onUnselect) {
              props.onUnselect({
                originalEvent: event,
                node: props.node
              });
            }
          } else {
            if (isSingleSelectionMode()) {
              selectionKeys = props.node.key;
            } else if (isMultipleSelectionMode()) {
              selectionKeys = !metaKey ? {} : props.selectionKeys ? _objectSpread$1$1({}, props.selectionKeys) : {};
              selectionKeys[props.node.key] = true;
            }

            if (props.onSelect) {
              props.onSelect({
                originalEvent: event,
                node: props.node
              });
            }
          }
        } else {
          if (isSingleSelectionMode()) {
            if (selected) {
              selectionKeys = null;

              if (props.onUnselect) {
                props.onUnselect({
                  originalEvent: event,
                  node: props.node
                });
              }
            } else {
              selectionKeys = props.node.key;

              if (props.onSelect) {
                props.onSelect({
                  originalEvent: event,
                  node: props.node
                });
              }
            }
          } else {
            if (selected) {
              selectionKeys = _objectSpread$1$1({}, props.selectionKeys);
              delete selectionKeys[props.node.key];

              if (props.onUnselect) {
                props.onUnselect({
                  originalEvent: event,
                  node: props.node
                });
              }
            } else {
              selectionKeys = props.selectionKeys ? _objectSpread$1$1({}, props.selectionKeys) : {};
              selectionKeys[props.node.key] = true;

              if (props.onSelect) {
                props.onSelect({
                  originalEvent: event,
                  node: props.node
                });
              }
            }
          }
        }
      }

      if (props.onSelectionChange) {
        props.onSelectionChange({
          originalEvent: event,
          value: selectionKeys
        });
      }
    }

    nodeTouched.current = false;
  };

  var onDoubleClick = function onDoubleClick(event) {
    if (props.onDoubleClick) {
      props.onDoubleClick({
        originalEvent: event,
        node: props.node
      });
    }
  };

  var onRightClick = function onRightClick(event) {
    if (props.disabled) {
      return;
    }

    DomHandler.clearSelection();

    if (props.onContextMenuSelectionChange) {
      props.onContextMenuSelectionChange({
        originalEvent: event,
        value: props.node.key
      });
    }

    if (props.onContextMenu) {
      props.onContextMenu({
        originalEvent: event,
        node: props.node
      });
    }
  };

  var propagateUp = function propagateUp(event) {
    var check = event.check;
    var selectionKeys = event.selectionKeys;
    var checkedChildCount = 0;
    var childPartialSelected = false;

    var _iterator = _createForOfIteratorHelper$1$1(props.node.children),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var child = _step.value;
        if (selectionKeys[child.key] && selectionKeys[child.key].checked) checkedChildCount++;else if (selectionKeys[child.key] && selectionKeys[child.key].partialChecked) childPartialSelected = true;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    if (check && checkedChildCount === props.node.children.length) {
      selectionKeys[props.node.key] = {
        checked: true,
        partialChecked: false
      };
    } else {
      if (!check) {
        delete selectionKeys[props.node.key];
      }

      if (childPartialSelected || checkedChildCount > 0 && checkedChildCount !== props.node.children.length) selectionKeys[props.node.key] = {
        checked: false,
        partialChecked: true
      };else delete selectionKeys[props.node.key];
    }

    if (props.propagateSelectionUp && props.onPropagateUp) {
      props.onPropagateUp(event);
    }
  };

  var propagateDown = function propagateDown(node, check, selectionKeys) {
    if (check) selectionKeys[node.key] = {
      checked: true,
      partialChecked: false
    };else delete selectionKeys[node.key];

    if (node.children && node.children.length) {
      for (var i = 0; i < node.children.length; i++) {
        propagateDown(node.children[i], check, selectionKeys);
      }
    }
  };

  var isSelected = function isSelected() {
    if (props.selectionMode && props.selectionKeys) return isSingleSelectionMode() ? props.selectionKeys === props.node.key : props.selectionKeys[props.node.key] !== undefined;else return false;
  };

  var isChecked = function isChecked() {
    return props.selectionKeys ? props.selectionKeys[props.node.key] && props.selectionKeys[props.node.key].checked : false;
  };

  var isPartialChecked = function isPartialChecked() {
    return props.selectionKeys ? props.selectionKeys[props.node.key] && props.selectionKeys[props.node.key].partialChecked : false;
  };

  var isSingleSelectionMode = function isSingleSelectionMode() {
    return props.selectionMode && props.selectionMode === 'single';
  };

  var isMultipleSelectionMode = function isMultipleSelectionMode() {
    return props.selectionMode && props.selectionMode === 'multiple';
  };

  var isCheckboxSelectionMode = function isCheckboxSelectionMode() {
    return props.selectionMode && props.selectionMode === 'checkbox';
  };

  var onTouchEnd = function onTouchEnd() {
    nodeTouched.current = true;
  };

  var onDropPoint = function onDropPoint(event, position) {
    event.preventDefault();

    if (props.node.droppable !== false) {
      DomHandler.removeClass(event.target, 'p-treenode-droppoint-active');

      if (props.onDropPoint) {
        var dropIndex = position === -1 ? props.index : props.index + 1;
        props.onDropPoint({
          originalEvent: event,
          path: props.path,
          index: dropIndex,
          position: position
        });
      }
    }
  };

  var onDropPointDragOver = function onDropPointDragOver(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase()) {
      event.dataTransfer.dropEffect = 'move';
      event.preventDefault();
    }
  };

  var onDropPointDragEnter = function onDropPointDragEnter(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase()) {
      DomHandler.addClass(event.target, 'p-treenode-droppoint-active');
    }
  };

  var onDropPointDragLeave = function onDropPointDragLeave(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase()) {
      DomHandler.removeClass(event.target, 'p-treenode-droppoint-active');
    }
  };

  var onDrop = function onDrop(event) {
    if (props.dragdropScope && props.node.droppable !== false) {
      DomHandler.removeClass(contentRef.current, 'p-treenode-dragover');
      event.preventDefault();
      event.stopPropagation();

      if (props.onDrop) {
        props.onDrop({
          originalEvent: event,
          path: props.path,
          index: props.index
        });
      }
    }
  };

  var onDragOver = function onDragOver(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase() && props.node.droppable !== false) {
      event.dataTransfer.dropEffect = 'move';
      event.preventDefault();
      event.stopPropagation();
    }
  };

  var onDragEnter = function onDragEnter(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase() && props.node.droppable !== false) {
      DomHandler.addClass(contentRef.current, 'p-treenode-dragover');
    }
  };

  var onDragLeave = function onDragLeave(event) {
    if (event.dataTransfer.types[1] === props.dragdropScope.toLocaleLowerCase() && props.node.droppable !== false) {
      var rect = event.currentTarget.getBoundingClientRect();

      if (event.nativeEvent.x > rect.left + rect.width || event.nativeEvent.x < rect.left || event.nativeEvent.y >= Math.floor(rect.top + rect.height) || event.nativeEvent.y < rect.top) {
        DomHandler.removeClass(contentRef.current, 'p-treenode-dragover');
      }
    }
  };

  var onDragStart = function onDragStart(event) {
    event.dataTransfer.setData('text', props.dragdropScope);
    event.dataTransfer.setData(props.dragdropScope, props.dragdropScope);

    if (props.onDragStart) {
      props.onDragStart({
        originalEvent: event,
        path: props.path,
        index: props.index
      });
    }
  };

  var onDragEnd = function onDragEnd(event) {
    if (props.onDragEnd) {
      props.onDragEnd({
        originalEvent: event
      });
    }
  };

  var createLabel = function createLabel() {
    var content = /*#__PURE__*/React.createElement("span", {
      className: "p-treenode-label"
    }, props.node.label);

    if (props.nodeTemplate) {
      var defaultContentOptions = {
        onTogglerClick: onTogglerClick,
        className: 'p-treenode-label',
        element: content,
        props: props,
        expanded: expanded
      };
      content = ObjectUtils.getJSXElement(props.nodeTemplate, props.node, defaultContentOptions);
    }

    return content;
  };

  var createCheckbox = function createCheckbox() {
    if (isCheckboxSelectionMode() && props.node.selectable !== false) {
      var checked = isChecked();
      var partialChecked = isPartialChecked();
      var className = classNames('p-checkbox-box', {
        'p-highlight': checked,
        'p-indeterminate': partialChecked,
        'p-disabled': props.disabled
      });
      var icon = classNames('p-checkbox-icon p-c', {
        'pi pi-check': checked,
        'pi pi-minus': partialChecked
      });
      return /*#__PURE__*/React.createElement("div", {
        className: "p-checkbox p-component"
      }, /*#__PURE__*/React.createElement("div", {
        className: className,
        role: "checkbox",
        "aria-checked": checked
      }, /*#__PURE__*/React.createElement("span", {
        className: icon
      })));
    }

    return null;
  };

  var createIcon = function createIcon() {
    var icon = props.node.icon || (expanded ? props.node.expandedIcon : props.node.collapsedIcon);

    if (icon) {
      var className = classNames('p-treenode-icon', icon);
      return /*#__PURE__*/React.createElement("span", {
        className: className
      });
    }

    return null;
  };

  var createToggler = function createToggler() {
    var label = expanded ? ariaLabel('collapseLabel') : ariaLabel('expandLabel');
    var iconClassName = classNames('p-tree-toggler-icon pi pi-fw', {
      'pi-chevron-right': !expanded,
      'pi-chevron-down': expanded
    });
    var content = /*#__PURE__*/React.createElement("button", {
      type: "button",
      className: "p-tree-toggler p-link",
      tabIndex: -1,
      onClick: onTogglerClick,
      "aria-label": label
    }, /*#__PURE__*/React.createElement("span", {
      className: iconClassName,
      "aria-hidden": "true"
    }), /*#__PURE__*/React.createElement(Ripple, null));

    if (props.togglerTemplate) {
      var defaultContentOptions = {
        onClick: onTogglerClick,
        containerClassName: 'p-tree-toggler p-link',
        iconClassName: 'p-tree-toggler-icon',
        element: content,
        props: props,
        expanded: expanded
      };
      content = ObjectUtils.getJSXElement(props.togglerTemplate, props.node, defaultContentOptions);
    }

    return content;
  };

  var createDropPoint = function createDropPoint(position) {
    if (props.dragdropScope) {
      return /*#__PURE__*/React.createElement("li", {
        className: "p-treenode-droppoint",
        onDrop: function onDrop(event) {
          return onDropPoint(event, position);
        },
        onDragOver: onDropPointDragOver,
        onDragEnter: onDropPointDragEnter,
        onDragLeave: onDropPointDragLeave
      });
    }

    return null;
  };

  var createContent = function createContent() {
    var selected = isSelected();
    var checked = isChecked();
    var className = classNames('p-treenode-content', props.node.className, {
      'p-treenode-selectable': props.selectionMode && props.node.selectable !== false,
      'p-highlight': isCheckboxSelectionMode() ? checked : selected,
      'p-highlight-contextmenu': props.contextMenuSelectionKey && props.contextMenuSelectionKey === props.node.key,
      'p-disabled': props.disabled
    });
    var toggler = createToggler();
    var checkbox = createCheckbox();
    var icon = createIcon();
    var label = createLabel();
    var tabIndex = props.disabled ? undefined : 0;
    return /*#__PURE__*/React.createElement("div", {
      ref: contentRef,
      className: className,
      style: props.node.style,
      onClick: onClick,
      onDoubleClick: onDoubleClick,
      onContextMenu: onRightClick,
      onTouchEnd: onTouchEnd,
      draggable: props.dragdropScope && props.node.draggable !== false && !props.disabled,
      onDrop: onDrop,
      onDragOver: onDragOver,
      onDragEnter: onDragEnter,
      onDragLeave: onDragLeave,
      onDragStart: onDragStart,
      onDragEnd: onDragEnd,
      tabIndex: tabIndex,
      onKeyDown: onNodeKeyDown,
      role: "treeitem",
      "aria-posinset": props.index + 1,
      "aria-expanded": expanded,
      "aria-selected": checked || selected
    }, toggler, checkbox, icon, label);
  };

  var createChildren = function createChildren() {
    if (ObjectUtils.isNotEmpty(props.node.children) && expanded) {
      return /*#__PURE__*/React.createElement("ul", {
        className: "p-treenode-children",
        role: "group"
      }, props.node.children.map(function (childNode, index) {
        return /*#__PURE__*/React.createElement(UITreeNode, {
          key: childNode.key || childNode.label,
          node: childNode,
          parent: props.node,
          index: index,
          last: index === props.node.children.length - 1,
          path: props.path + '-' + index,
          disabled: props.disabled,
          selectionMode: props.selectionMode,
          selectionKeys: props.selectionKeys,
          onSelectionChange: props.onSelectionChange,
          metaKeySelection: props.metaKeySelection,
          propagateSelectionDown: props.propagateSelectionDown,
          propagateSelectionUp: props.propagateSelectionUp,
          contextMenuSelectionKey: props.contextMenuSelectionKey,
          onContextMenuSelectionChange: props.onContextMenuSelectionChange,
          onContextMenu: props.onContextMenu,
          onExpand: props.onExpand,
          onCollapse: props.onCollapse,
          onSelect: props.onSelect,
          onUnselect: props.onUnselect,
          onClick: props.onClick,
          onDoubleClick: props.onDoubleClick,
          expandedKeys: props.expandedKeys,
          onToggle: props.onToggle,
          onPropagateUp: propagateUp,
          nodeTemplate: props.nodeTemplate,
          togglerTemplate: props.togglerTemplate,
          isNodeLeaf: props.isNodeLeaf,
          dragdropScope: props.dragdropScope,
          onDragStart: props.onDragStart,
          onDragEnd: props.onDragEnd,
          onDrop: props.onDrop,
          onDropPoint: props.onDropPoint
        });
      }));
    }

    return null;
  };

  var createNode = function createNode() {
    var className = classNames('p-treenode', {
      'p-treenode-leaf': isLeaf
    }, props.node.className);
    var content = createContent();
    var children = createChildren();
    return /*#__PURE__*/React.createElement("li", {
      className: className,
      style: props.node.style
    }, content, children);
  };

  var node = createNode();

  if (props.dragdropScope && !props.disabled) {
    var beforeDropPoint = createDropPoint(-1);
    var afterDropPoint = props.last ? createDropPoint(1) : null;
    return /*#__PURE__*/React.createElement(React.Fragment, null, beforeDropPoint, node, afterDropPoint);
  }

  return node;
});
UITreeNode.displayName = 'UITreeNode';

function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createForOfIteratorHelper$4(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$6(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
}

function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var Tree$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(''),
      _React$useState2 = _slicedToArray$2(_React$useState, 2),
      filterValueState = _React$useState2[0],
      setFilterValueState = _React$useState2[1];

  var _React$useState3 = React.useState(props.expandedKeys),
      _React$useState4 = _slicedToArray$2(_React$useState3, 2),
      expandedKeysState = _React$useState4[0],
      setExpandedKeysState = _React$useState4[1];

  var elementRef = React.useRef(null);
  var filteredNodes = React.useRef([]);
  var dragState = React.useRef(null);
  var filterChanged = React.useRef(false);
  var filteredValue = props.onFilterValueChange ? props.filterValue : filterValueState;
  var expandedKeys = props.onToggle ? props.expandedKeys : expandedKeysState;
  var filterOptions = {
    filter: function filter(e) {
      return onFilterInputChange(e);
    },
    reset: function reset() {
      return resetFilter();
    }
  };

  var getRootNode = function getRootNode() {
    return props.filter && filteredNodes.current ? filteredNodes.current : props.value;
  };

  var onToggle = function onToggle(event) {
    if (props.onToggle) {
      props.onToggle(event);
    } else {
      setExpandedKeysState(event.value);
    }
  };

  var onDragStart = function onDragStart(event) {
    dragState.current = {
      path: event.path,
      index: event.index
    };
  };

  var onDragEnd = function onDragEnd() {
    dragState.current = null;
  };

  var onDrop = function onDrop(event) {
    if (validateDropNode(dragState.current.path, event.path)) {
      var value = JSON.parse(JSON.stringify(props.value));
      var dragPaths = dragState.current.path.split('-');
      dragPaths.pop();
      var dragNodeParent = findNode(value, dragPaths);
      var dragNode = dragNodeParent ? dragNodeParent.children[dragState.current.index] : value[dragState.current.index];
      var dropNode = findNode(value, event.path.split('-'));
      if (dropNode.children) dropNode.children.push(dragNode);else dropNode.children = [dragNode];
      if (dragNodeParent) dragNodeParent.children.splice(dragState.current.index, 1);else value.splice(dragState.current.index, 1);

      if (props.onDragDrop) {
        props.onDragDrop({
          originalEvent: event.originalEvent,
          value: value,
          dragNode: dragNode,
          dropNode: dropNode,
          dropIndex: event.index
        });
      }
    }
  };

  var onDropPoint = function onDropPoint(event) {
    if (validateDropPoint(event)) {
      var value = JSON.parse(JSON.stringify(props.value));
      var dragPaths = dragState.current.path.split('-');
      dragPaths.pop();
      var dropPaths = event.path.split('-');
      dropPaths.pop();
      var dragNodeParent = findNode(value, dragPaths);
      var dropNodeParent = findNode(value, dropPaths);
      var dragNode = dragNodeParent ? dragNodeParent.children[dragState.current.index] : value[dragState.current.index];
      var siblings = areSiblings(dragState.current.path, event.path);
      if (dragNodeParent) dragNodeParent.children.splice(dragState.current.index, 1);else value.splice(dragState.current.index, 1);

      if (event.position < 0) {
        var dropIndex = siblings ? dragState.current.index > event.index ? event.index : event.index - 1 : event.index;
        if (dropNodeParent) dropNodeParent.children.splice(dropIndex, 0, dragNode);else value.splice(dropIndex, 0, dragNode);
      } else {
        if (dropNodeParent) dropNodeParent.children.push(dragNode);else value.push(dragNode);
      }

      if (props.onDragDrop) {
        props.onDragDrop({
          originalEvent: event.originalEvent,
          value: value,
          dragNode: dragNode,
          dropNode: dropNodeParent,
          dropIndex: event.index
        });
      }
    }
  };

  var validateDrop = function validateDrop(dragPath, dropPath) {
    if (!dragPath) {
      return false;
    } else {
      //same node
      if (dragPath === dropPath) {
        return false;
      } //parent dropped on an descendant


      if (dropPath.indexOf(dragPath) === 0) {
        return false;
      }

      return true;
    }
  };

  var validateDropNode = function validateDropNode(dragPath, dropPath) {
    var _validateDrop = validateDrop(dragPath, dropPath);

    if (_validateDrop) {
      //child dropped on parent
      if (dragPath.indexOf('-') > 0 && dragPath.substring(0, dragPath.lastIndexOf('-')) === dropPath) {
        return false;
      }

      return true;
    } else {
      return false;
    }
  };

  var validateDropPoint = function validateDropPoint(event) {
    var _validateDrop = validateDrop(dragState.current.path, event.path);

    if (_validateDrop) {
      //child dropped to next sibling's drop point
      if (event.position === -1 && areSiblings(dragState.current.path, event.path) && dragState.current.index + 1 === event.index) {
        return false;
      }

      return true;
    } else {
      return false;
    }
  };

  var areSiblings = function areSiblings(path1, path2) {
    if (path1.length === 1 && path2.length === 1) return true;else return path1.substring(0, path1.lastIndexOf('-')) === path2.substring(0, path2.lastIndexOf('-'));
  };

  var findNode = function findNode(value, path) {
    if (path.length === 0) {
      return null;
    } else {
      var index = parseInt(path[0], 10);
      var nextSearchRoot = value.children ? value.children[index] : value[index];

      if (path.length === 1) {
        return nextSearchRoot;
      } else {
        path.shift();
        return findNode(nextSearchRoot, path);
      }
    }
  };

  var isNodeLeaf = function isNodeLeaf(node) {
    return node.leaf === false ? false : !(node.children && node.children.length);
  };

  var onFilterInputKeyDown = function onFilterInputKeyDown(event) {
    //enter
    if (event.which === 13) {
      event.preventDefault();
    }
  };

  var onFilterInputChange = function onFilterInputChange(event) {
    filterChanged.current = true;
    var value = event.target.value;

    if (props.onFilterValueChange) {
      props.onFilterValueChange({
        originalEvent: event,
        value: value
      });
    } else {
      setFilterValueState(value);
    }
  };

  var filter = function filter(value) {
    setFilterValueState(ObjectUtils.isNotEmpty(value) ? value : '');

    _filter();
  };

  var _filter = function _filter() {
    if (!filterChanged.current) {
      return;
    }

    if (ObjectUtils.isEmpty(filteredValue)) {
      filteredNodes.current = props.value;
    } else {
      filteredNodes.current = [];
      var searchFields = props.filterBy.split(',');
      var filterText = filteredValue.toLocaleLowerCase(props.filterLocale);
      var isStrictMode = props.filterMode === 'strict';

      var _iterator = _createForOfIteratorHelper$4(props.value),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var node = _step.value;

          var copyNode = _objectSpread$3({}, node);

          var paramsWithoutNode = {
            searchFields: searchFields,
            filterText: filterText,
            isStrictMode: isStrictMode
          };

          if (isStrictMode && (findFilteredNodes(copyNode, paramsWithoutNode) || isFilterMatched(copyNode, paramsWithoutNode)) || !isStrictMode && (isFilterMatched(copyNode, paramsWithoutNode) || findFilteredNodes(copyNode, paramsWithoutNode))) {
            filteredNodes.current.push(copyNode);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    filterChanged.current = false;
  };

  var findFilteredNodes = function findFilteredNodes(node, paramsWithoutNode) {
    if (node) {
      var matched = false;

      if (node.children) {
        var childNodes = _toConsumableArray$1(node.children);

        node.children = [];

        var _iterator2 = _createForOfIteratorHelper$4(childNodes),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var childNode = _step2.value;

            var copyChildNode = _objectSpread$3({}, childNode);

            if (isFilterMatched(copyChildNode, paramsWithoutNode)) {
              matched = true;
              node.children.push(copyChildNode);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      if (matched) {
        node.expanded = true;
        return true;
      }
    }
  };

  var isFilterMatched = function isFilterMatched(node, _ref) {
    var searchFields = _ref.searchFields,
        filterText = _ref.filterText,
        isStrictMode = _ref.isStrictMode;
    var matched = false;

    var _iterator3 = _createForOfIteratorHelper$4(searchFields),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var field = _step3.value;
        var fieldValue = String(ObjectUtils.resolveFieldData(node, field)).toLocaleLowerCase(props.filterLocale);

        if (fieldValue.indexOf(filterText) > -1) {
          matched = true;
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    if (!matched || isStrictMode && !isNodeLeaf(node)) {
      matched = findFilteredNodes(node, {
        searchFields: searchFields,
        filterText: filterText,
        isStrictMode: isStrictMode
      }) || matched;
    }

    return matched;
  };

  var resetFilter = function resetFilter() {
    setFilterValueState('');
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      filter: filter,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });

  var createRootChild = function createRootChild(node, index, last) {
    return /*#__PURE__*/React.createElement(UITreeNode, {
      key: node.key || node.label,
      node: node,
      index: index,
      last: last,
      path: String(index),
      disabled: props.disabled,
      selectionMode: props.selectionMode,
      selectionKeys: props.selectionKeys,
      onSelectionChange: props.onSelectionChange,
      metaKeySelection: props.metaKeySelection,
      contextMenuSelectionKey: props.contextMenuSelectionKey,
      onContextMenuSelectionChange: props.onContextMenuSelectionChange,
      onContextMenu: props.onContextMenu,
      propagateSelectionDown: props.propagateSelectionDown,
      propagateSelectionUp: props.propagateSelectionUp,
      onExpand: props.onExpand,
      onCollapse: props.onCollapse,
      onSelect: props.onSelect,
      onUnselect: props.onUnselect,
      expandedKeys: expandedKeys,
      onToggle: onToggle,
      nodeTemplate: props.nodeTemplate,
      togglerTemplate: props.togglerTemplate,
      isNodeLeaf: isNodeLeaf,
      dragdropScope: props.dragdropScope,
      onDragStart: onDragStart,
      onDragEnd: onDragEnd,
      onDrop: onDrop,
      onDropPoint: onDropPoint,
      onClick: props.onNodeClick,
      onDoubleClick: props.onNodeDoubleClick
    });
  };

  var createRootChildren = function createRootChildren() {
    if (props.filter) {
      filterChanged.current = true;

      _filter();
    }

    var value = getRootNode();
    return value.map(function (node, index) {
      return createRootChild(node, index, index === value.length - 1);
    });
  };

  var createModel = function createModel() {
    if (props.value) {
      var rootNodes = createRootChildren();
      var contentClass = classNames('p-tree-container', props.contentClassName);
      return /*#__PURE__*/React.createElement("ul", _extends$2({
        className: contentClass,
        role: "tree",
        style: props.contentStyle
      }, ariaProps), rootNodes);
    }

    return null;
  };

  var createLoader = function createLoader() {
    if (props.loading) {
      var icon = classNames('p-tree-loading-icon pi-spin', props.loadingIcon);
      return /*#__PURE__*/React.createElement("div", {
        className: "p-tree-loading-overlay p-component-overlay"
      }, /*#__PURE__*/React.createElement("i", {
        className: icon
      }));
    }

    return null;
  };

  var createFilter = function createFilter() {
    if (props.filter) {
      var value = ObjectUtils.isNotEmpty(filteredValue) ? filteredValue : '';

      var _content = /*#__PURE__*/React.createElement("div", {
        className: "p-tree-filter-container"
      }, /*#__PURE__*/React.createElement("input", {
        type: "text",
        value: value,
        autoComplete: "off",
        className: "p-tree-filter p-inputtext p-component",
        placeholder: props.filterPlaceholder,
        onKeyDown: onFilterInputKeyDown,
        onChange: onFilterInputChange,
        disabled: props.disabled
      }), /*#__PURE__*/React.createElement("span", {
        className: "p-tree-filter-icon pi pi-search"
      }));

      if (props.filterTemplate) {
        var defaultContentOptions = {
          className: 'p-tree-filter-container',
          element: _content,
          filterOptions: filterOptions,
          filterInputKeyDown: onFilterInputKeyDown,
          filterInputChange: onFilterInputChange,
          filterIconClassName: 'p-dropdown-filter-icon pi pi-search',
          props: props
        };
        _content = ObjectUtils.getJSXElement(props.filterTemplate, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement(React.Fragment, null, _content);
    }

    return null;
  };

  var createHeader = function createHeader() {
    if (props.showHeader) {
      var filterElement = createFilter();
      var _content2 = filterElement;

      if (props.header) {
        var defaultContentOptions = {
          filterContainerClassName: 'p-tree-filter-container',
          filterIconClasssName: 'p-tree-filter-icon pi pi-search',
          filterInput: {
            className: 'p-tree-filter p-inputtext p-component',
            onKeyDown: onFilterInputKeyDown,
            onChange: onFilterInputChange
          },
          filterElement: filterElement,
          element: _content2,
          props: props
        };
        _content2 = ObjectUtils.getJSXElement(props.header, defaultContentOptions);
      }

      return /*#__PURE__*/React.createElement("div", {
        className: "p-tree-header"
      }, _content2);
    }

    return null;
  };

  var createFooter = function createFooter() {
    var content = ObjectUtils.getJSXElement(props.footer, props);
    return /*#__PURE__*/React.createElement("div", {
      className: "p-tree-footer"
    }, content);
  };

  var otherProps = ObjectUtils.findDiffKeys(props, Tree$1.defaultProps);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var className = classNames('p-tree p-component', props.className, {
    'p-tree-selectable': props.selectionMode,
    'p-tree-loading': props.loading,
    'p-disabled': props.disabled
  });
  var loader = createLoader();
  var content = createModel();
  var header = createHeader();
  var footer = createFooter();
  return /*#__PURE__*/React.createElement("div", _extends$2({
    id: props.id,
    ref: elementRef,
    className: className,
    style: props.style
  }, otherProps), loader, header, content, footer);
}));
Tree$1.displayName = 'Tree';
Tree$1.defaultProps = {
  __TYPE: 'Tree',
  id: null,
  value: null,
  disabled: false,
  selectionMode: null,
  selectionKeys: null,
  onSelectionChange: null,
  contextMenuSelectionKey: null,
  onContextMenuSelectionChange: null,
  expandedKeys: null,
  style: null,
  className: null,
  contentStyle: null,
  contentClassName: null,
  metaKeySelection: true,
  propagateSelectionUp: true,
  propagateSelectionDown: true,
  loading: false,
  loadingIcon: 'pi pi-spinner',
  dragdropScope: null,
  header: null,
  footer: null,
  showHeader: true,
  filter: false,
  filterValue: null,
  filterBy: 'label',
  filterMode: 'lenient',
  filterPlaceholder: null,
  filterLocale: undefined,
  filterTemplate: null,
  nodeTemplate: null,
  togglerTemplate: null,
  onSelect: null,
  onUnselect: null,
  onExpand: null,
  onCollapse: null,
  onToggle: null,
  onDragDrop: null,
  onContextMenu: null,
  onFilterValueChange: null,
  onNodeClick: null,
  onNodeDoubleClick: null
};

var Tree = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      selectionMode = _ref.selectionMode,
      selectionKeys = _ref.selectionKeys,
      expandedKeys = _ref.expandedKeys,
      style = _ref.style,
      className = _ref.className,
      contentStyle = _ref.contentStyle,
      contentClassName = _ref.contentClassName,
      _ref$metaKeySelection = _ref.metaKeySelection,
      metaKeySelection = _ref$metaKeySelection === void 0 ? true : _ref$metaKeySelection,
      _ref$propagateSelecti = _ref.propagateSelectionUp,
      propagateSelectionUp = _ref$propagateSelecti === void 0 ? true : _ref$propagateSelecti,
      _ref$propagateSelecti2 = _ref.propagateSelectionDown,
      propagateSelectionDown = _ref$propagateSelecti2 === void 0 ? true : _ref$propagateSelecti2,
      _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? false : _ref$loading,
      dragdropScope = _ref.dragdropScope,
      header = _ref.header,
      footer = _ref.footer,
      ariaLabel = _ref.ariaLabel,
      ariaLabelledBy = _ref.ariaLabelledBy,
      nodeTemplate = _ref.nodeTemplate,
      togglerTemplate = _ref.togglerTemplate,
      _ref$showHeader = _ref.showHeader,
      showHeader = _ref$showHeader === void 0 ? true : _ref$showHeader,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      onSelect = _ref.onSelect,
      onUnselect = _ref.onUnselect,
      onExpand = _ref.onExpand,
      onCollapse = _ref.onCollapse,
      onSelectionChange = _ref.onSelectionChange,
      onToggle = _ref.onToggle,
      onDragDrop = _ref.onDragDrop,
      onNodeClick = _ref.onNodeClick;
  return /*#__PURE__*/React__default.createElement(Tree$1, {
    ref: ref,
    id: id,
    value: value,
    selectionMode: selectionMode,
    selectionKeys: selectionKeys,
    expandedKeys: expandedKeys,
    style: style,
    className: className,
    contentStyle: contentStyle,
    contentClassName: contentClassName,
    metaKeySelection: metaKeySelection,
    propagateSelectionUp: propagateSelectionUp,
    propagateSelectionDown: propagateSelectionDown,
    loading: loading,
    dragdropScope: dragdropScope,
    header: header,
    footer: footer,
    ariaLabel: ariaLabel,
    ariaLabelledBy: ariaLabelledBy,
    nodeTemplate: nodeTemplate,
    togglerTemplate: togglerTemplate,
    showHeader: showHeader,
    disabled: disabled,
    onSelect: onSelect,
    onUnselect: onUnselect,
    onExpand: onExpand,
    onCollapse: onCollapse,
    onSelectionChange: onSelectionChange,
    onToggle: onToggle,
    onDragDrop: onDragDrop,
    onNodeClick: onNodeClick
  });
});

function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1.apply(this, arguments);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$4(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$4(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread();
}

function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$1(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest$1();
}

function _readOnlyError(name) {
  throw new TypeError("\"" + name + "\" is read-only");
}

var TreeTableBodyCell = function TreeTableBodyCell(props) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray$1(_React$useState, 2),
      editingState = _React$useState2[0],
      setEditingState = _React$useState2[1];

  var elementRef = React.useRef(null);
  var keyHelperRef = React.useRef(null);
  var selfClick = React.useRef(false);
  var overlayEventListener = React.useRef(null);
  var tabIndexTimeout = React.useRef(null);

  var _useEventListener = useEventListener({
    type: 'click',
    listener: function listener(e) {
      if (!selfClick.current && isOutsideClicked(e.target)) {
        switchCellToViewMode(e);
      }

      selfClick.current = false;
    }
  }),
      _useEventListener2 = _slicedToArray$1(_useEventListener, 2),
      bindDocumentClickListener = _useEventListener2[0],
      unbindDocumentClickListener = _useEventListener2[1];

  var onClick = function onClick() {
    if (props.editor && !editingState && (props.selectOnEdit || !props.selectOnEdit && props.selected)) {
      selfClick.current = true;
      setEditingState(true);
      bindDocumentClickListener();

      overlayEventListener.current = function (e) {
        if (!isOutsideClicked(e.target)) {
          selfClick.current = true;
        }
      };

      OverlayService.on('overlay-click', overlayEventListener.current);
    }
  };

  var onKeyDown = function onKeyDown(event) {
    if (event.which === 13 || event.which === 9) {
      switchCellToViewMode(event);
    }
  };

  var isOutsideClicked = function isOutsideClicked(target) {
    return elementRef.current && !(elementRef.current.isSameNode(target) || elementRef.current.contains(target));
  };

  var closeCell = function closeCell() {
    /* When using the 'tab' key, the focus event of the next cell is not called in IE. */
    setTimeout(function () {
      setEditingState(false);
      unbindDocumentClickListener();
      OverlayService.off('overlay-click', overlayEventListener.current);

      _readOnlyError("overlayEventListener");
    }, 1);
  };

  var onEditorFocus = function onEditorFocus(event) {
    onClick();
  };

  var switchCellToViewMode = function switchCellToViewMode(event) {
    if (props.cellEditValidator) {
      var valid = props.cellEditValidator({
        originalEvent: event,
        columnProps: props
      });

      if (valid) {
        closeCell();
      }
    } else {
      closeCell();
    }
  };

  React.useEffect(function () {
    if (elementRef.current && props.editor) {
      clearTimeout(tabIndexTimeout.current);

      if (editingState) {
        var focusable = DomHandler.findSingle(elementRef.current, 'input');

        if (focusable && document.activeElement !== focusable && !focusable.hasAttribute('data-isCellEditing')) {
          focusable.setAttribute('data-isCellEditing', true);
          focusable.focus();
        }

        keyHelperRef.current.tabIndex = -1;
      } else {
        tabIndexTimeout.current = setTimeout(function () {
          if (keyHelperRef.current) {
            keyHelperRef.current.setAttribute('tabindex', 0);
          }
        }, 50);
      }
    }
  });
  useUnmountEffect(function () {
    if (overlayEventListener.current) {
      OverlayService.off('overlay-click', overlayEventListener.current);
      overlayEventListener.current = null;
    }
  });
  var className = classNames(props.bodyClassName || props.className, {
    'p-editable-column': props.editor,
    'p-cell-editing': props.editor ? editingState : false
  });
  var style = props.bodyStyle || props.style;
  var content;

  if (editingState) {
    if (props.editor) content = ObjectUtils.getJSXElement(props.editor, {
      node: props.node,
      rowData: props.node.data,
      value: ObjectUtils.resolveFieldData(props.node.data, props.field),
      field: props.field,
      rowIndex: props.rowIndex,
      props: props
    });else throw new Error('Editor is not found on column.');
  } else {
    if (props.body) content = ObjectUtils.getJSXElement(props.body, props.node, {
      field: props.field,
      rowIndex: props.rowIndex,
      props: props
    });else content = ObjectUtils.resolveFieldData(props.node.data, props.field);
  }
  /* eslint-disable */


  var editorKeyHelper = props.editor && /*#__PURE__*/React.createElement("a", {
    tabIndex: 0,
    ref: keyHelperRef,
    className: "p-cell-editor-key-helper p-hidden-accessible",
    onFocus: onEditorFocus
  }, /*#__PURE__*/React.createElement("span", null));
  /* eslint-enable */

  return /*#__PURE__*/React.createElement("td", {
    ref: elementRef,
    className: className,
    style: style,
    onClick: onClick,
    onKeyDown: onKeyDown
  }, props.children, editorKeyHelper, content);
};

TreeTableBodyCell.displayName = 'TreeTableBodyCell';

function _createForOfIteratorHelper$3(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$3(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
}

function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var TreeTableRow = /*#__PURE__*/React.memo(function (props) {
  var elementRef = React.useRef(null);
  var checkboxRef = React.useRef(null);
  var checkboxBoxRef = React.useRef(null);
  var nodeTouched = React.useRef(false);
  var expanded = props.expandedKeys ? props.expandedKeys[props.node.key] !== undefined : false;

  var onTogglerClick = function onTogglerClick(event) {
    expanded ? collapse(event) : expand(event);
    event.preventDefault();
    event.stopPropagation();
  };

  var expand = function expand(event) {
    var expandedKeys = props.expandedKeys ? _objectSpread$2({}, props.expandedKeys) : {};
    expandedKeys[props.node.key] = true;
    props.onToggle({
      originalEvent: event,
      value: expandedKeys
    });
    invokeToggleEvents(event, true);
  };

  var collapse = function collapse(event) {
    var expandedKeys = _objectSpread$2({}, props.expandedKeys);

    delete expandedKeys[props.node.key];
    props.onToggle({
      originalEvent: event,
      value: expandedKeys
    });
    invokeToggleEvents(event, false);
  };

  var invokeToggleEvents = function invokeToggleEvents(event, expanded) {
    if (expanded) {
      if (props.onExpand) {
        props.onExpand({
          originalEvent: event,
          node: props.node
        });
      }
    } else {
      if (props.onCollapse) {
        props.onCollapse({
          originalEvent: event,
          node: props.node
        });
      }
    }
  };

  var onClick = function onClick(event) {
    if (props.onRowClick) {
      props.onRowClick(event, props.node);
    }

    nodeTouched.current = false;
  };

  var onTouchEnd = function onTouchEnd() {
    nodeTouched.current = true;
  };

  var onCheckboxChange = function onCheckboxChange(event) {
    var checked = isChecked();
    var selectionKeys = props.selectionKeys ? _objectSpread$2({}, props.selectionKeys) : {};

    if (checked) {
      if (props.propagateSelectionDown) propagateDown(props.node, false, selectionKeys);else delete selectionKeys[props.node.key];

      if (props.propagateSelectionUp && props.onPropagateUp) {
        props.onPropagateUp({
          originalEvent: event,
          check: false,
          selectionKeys: selectionKeys
        });
      }

      if (props.onUnselect) {
        props.onUnselect({
          originalEvent: event,
          node: props.node
        });
      }
    } else {
      if (props.propagateSelectionDown) propagateDown(props.node, true, selectionKeys);else selectionKeys[props.node.key] = {
        checked: true
      };

      if (props.propagateSelectionUp && props.onPropagateUp) {
        props.onPropagateUp({
          originalEvent: event,
          check: true,
          selectionKeys: selectionKeys
        });
      }

      if (props.onSelect) {
        props.onSelect({
          originalEvent: event,
          node: props.node
        });
      }
    }

    if (props.onSelectionChange) {
      props.onSelectionChange({
        originalEvent: event,
        value: selectionKeys
      });
    }

    DomHandler.clearSelection();
  };

  var onCheckboxFocus = function onCheckboxFocus() {
    DomHandler.addClass(checkboxBoxRef.current, 'p-focus');
    DomHandler.addClass(checkboxRef.current, 'p-checkbox-focused');
  };

  var onCheckboxBlur = function onCheckboxBlur() {
    DomHandler.removeClass(checkboxBoxRef.current, 'p-focus');
    DomHandler.removeClass(checkboxRef.current, 'p-checkbox-focused');
  };

  var propagateUp = function propagateUp(event) {
    var check = event.check;
    var selectionKeys = event.selectionKeys;
    var checkedChildCount = 0;
    var childPartialSelected = false;

    var _iterator = _createForOfIteratorHelper$3(props.node.children),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var child = _step.value;
        if (selectionKeys[child.key] && selectionKeys[child.key].checked) checkedChildCount++;else if (selectionKeys[child.key] && selectionKeys[child.key].partialChecked) childPartialSelected = true;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    if (check && checkedChildCount === props.node.children.length) {
      selectionKeys[props.node.key] = {
        checked: true,
        partialChecked: false
      };
    } else {
      if (!check) {
        delete selectionKeys[props.node.key];
      }

      if (childPartialSelected || checkedChildCount > 0 && checkedChildCount !== props.node.children.length) selectionKeys[props.node.key] = {
        checked: false,
        partialChecked: true
      };else selectionKeys[props.node.key] = {
        checked: false,
        partialChecked: false
      };
    }

    if (props.propagateSelectionUp && props.onPropagateUp) {
      props.onPropagateUp(event);
    }
  };

  var propagateDown = function propagateDown(node, check, selectionKeys) {
    if (check) selectionKeys[node.key] = {
      checked: true,
      partialChecked: false
    };else delete selectionKeys[node.key];

    if (node.children && node.children.length) {
      for (var i = 0; i < node.children.length; i++) {
        propagateDown(node.children[i], check, selectionKeys);
      }
    }
  };

  var onRightClick = function onRightClick(event) {
    DomHandler.clearSelection();

    if (props.onContextMenuSelectionChange) {
      props.onContextMenuSelectionChange({
        originalEvent: event,
        value: props.node.key
      });
    }

    if (props.onContextMenu) {
      props.onContextMenu({
        originalEvent: event,
        node: props.node
      });
    }
  };

  var onKeyDown = function onKeyDown(event) {
    if (event.target === elementRef.current) {
      var rowElement = event.currentTarget;

      switch (event.which) {
        //down arrow
        case 40:
          var nextRow = rowElement.nextElementSibling;

          if (nextRow) {
            nextRow.focus();
          }

          event.preventDefault();
          break;
        //up arrow

        case 38:
          var previousRow = rowElement.previousElementSibling;

          if (previousRow) {
            previousRow.focus();
          }

          event.preventDefault();
          break;
        //right arrow

        case 39:
          if (!expanded) {
            expand(event);
          }

          event.preventDefault();
          break;
        //left arrow

        case 37:
          if (expanded) {
            collapse(event);
          }

          event.preventDefault();
          break;
        //enter

        case 13:
          onClick(event);
          event.preventDefault();
          break;
      }
    }
  };

  var isSelected = function isSelected() {
    if ((props.selectionMode === 'single' || props.selectionMode === 'multiple') && props.selectionKeys) return props.selectionMode === 'single' ? props.selectionKeys === props.node.key : props.selectionKeys[props.node.key] !== undefined;else return false;
  };

  var isChecked = function isChecked() {
    return props.selectionKeys ? props.selectionKeys[props.node.key] && props.selectionKeys[props.node.key].checked : false;
  };

  var isPartialChecked = function isPartialChecked() {
    return props.selectionKeys ? props.selectionKeys[props.node.key] && props.selectionKeys[props.node.key].partialChecked : false;
  };

  var createToggler = function createToggler() {
    var label = expanded ? ariaLabel('collapseLabel') : ariaLabel('expandLabel');
    var iconClassName = classNames('p-treetable-toggler-icon pi pi-fw', {
      'pi-chevron-right': !expanded,
      'pi-chevron-down': expanded
    });
    var style = {
      marginLeft: props.level * 16 + 'px',
      visibility: props.node.leaf === false || props.node.children && props.node.children.length ? 'visible' : 'hidden'
    };
    return /*#__PURE__*/React.createElement("button", {
      type: "button",
      className: "p-treetable-toggler p-link p-unselectable-text",
      onClick: onTogglerClick,
      tabIndex: -1,
      style: style,
      "aria-label": label
    }, /*#__PURE__*/React.createElement("i", {
      className: iconClassName,
      "aria-hidden": "true"
    }), /*#__PURE__*/React.createElement(Ripple, null));
  };

  var createCheckbox = function createCheckbox() {
    if (props.selectionMode === 'checkbox' && props.node.selectable !== false) {
      var checked = isChecked();
      var partialChecked = isPartialChecked();

      var _className = classNames('p-checkbox-box', {
        'p-highlight': checked,
        'p-indeterminate': partialChecked
      });

      var icon = classNames('p-checkbox-icon p-c', {
        'pi pi-check': checked,
        'pi pi-minus': partialChecked
      });
      return /*#__PURE__*/React.createElement("div", {
        className: "p-checkbox p-treetable-checkbox p-component",
        ref: checkboxRef,
        onClick: onCheckboxChange,
        role: "checkbox",
        "aria-checked": checked
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-hidden-accessible"
      }, /*#__PURE__*/React.createElement("input", {
        type: "checkbox",
        onFocus: onCheckboxFocus,
        onBlur: onCheckboxBlur
      })), /*#__PURE__*/React.createElement("div", {
        className: _className,
        ref: checkboxBoxRef
      }, /*#__PURE__*/React.createElement("span", {
        className: icon
      })));
    } else {
      return null;
    }
  };

  var createCell = function createCell(column) {
    var toggler, checkbox;

    if (column.props.expander) {
      toggler = createToggler();
      checkbox = createCheckbox();
    }

    return /*#__PURE__*/React.createElement(TreeTableBodyCell, _extends$1({
      key: column.props.columnKey || column.props.field
    }, column.props, {
      column: column,
      selectOnEdit: props.selectOnEdit,
      selected: isSelected(),
      node: props.node,
      rowIndex: props.rowIndex
    }), toggler, checkbox);
  };

  var createChildren = function createChildren() {
    if (expanded && props.node.children) {
      return props.node.children.map(function (childNode, index) {
        return /*#__PURE__*/React.createElement(TreeTableRow, {
          key: childNode.key || JSON.stringify(childNode.data),
          level: props.level + 1,
          rowIndex: props.rowIndex + '_' + index,
          node: childNode,
          columns: props.columns,
          expandedKeys: props.expandedKeys,
          selectOnEdit: props.selectOnEdit,
          onToggle: props.onToggle,
          onExpand: props.onExpand,
          onCollapse: props.onCollapse,
          selectionMode: props.selectionMode,
          selectionKeys: props.selectionKeys,
          onSelectionChange: props.onSelectionChange,
          metaKeySelection: props.metaKeySelection,
          onRowClick: props.onRowClick,
          onSelect: props.onSelect,
          onUnselect: props.onUnselect,
          propagateSelectionUp: props.propagateSelectionUp,
          propagateSelectionDown: props.propagateSelectionDown,
          onPropagateUp: propagateUp,
          rowClassName: props.rowClassName,
          contextMenuSelectionKey: props.contextMenuSelectionKey,
          onContextMenuSelectionChange: props.onContextMenuSelectionChange,
          onContextMenu: props.onContextMenu
        });
      });
    } else {
      return null;
    }
  };

  var cells = props.columns.map(createCell);
  var children = createChildren();
  var className = {
    'p-highlight': isSelected(),
    'p-highlight-contextmenu': props.contextMenuSelectionKey && props.contextMenuSelectionKey === props.node.key
  };

  if (props.rowClassName) {
    var rowClassName = props.rowClassName(props.node);
    className = _objectSpread$2(_objectSpread$2({}, className), rowClassName);
  }

  className = classNames(className, props.node.className);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("tr", {
    ref: elementRef,
    tabIndex: 0,
    className: className,
    style: props.node.style,
    onClick: onClick,
    onTouchEnd: onTouchEnd,
    onContextMenu: onRightClick,
    onKeyDown: onKeyDown
  }, cells), children);
});
TreeTableRow.displayName = 'TreeTableRow';

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _createForOfIteratorHelper$2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$2(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
}

function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var TreeTableBody = /*#__PURE__*/React.memo(function (props) {
  var isSingleSelectionMode = props.selectionMode === 'single';
  var isMultipleSelectionMode = props.selectionMode === 'multiple';

  var flattenizeTree = function flattenizeTree(nodes) {
    var rows = [];
    nodes = nodes || props.value;

    var _iterator = _createForOfIteratorHelper$2(nodes),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var node = _step.value;
        rows.push(node.key);

        if (isExpandedKey(node.key)) {
          rows = rows.concat(flattenizeTree(node.children));
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return rows;
  };

  var isExpandedKey = function isExpandedKey(key) {
    return props.expandedKeys && !!props.expandedKeys[key];
  };

  var onRowClick = function onRowClick(event, node) {
    if (props.onRowClick) {
      props.onRowClick({
        originalEvent: event,
        node: node
      });
    }

    var targetNode = event.target.nodeName;

    if (targetNode === 'INPUT' || targetNode === 'BUTTON' || targetNode === 'A' || DomHandler.hasClass(event.target, 'p-clickable')) {
      return;
    }

    if ((isSingleSelectionMode || isMultipleSelectionMode) && node.selectable !== false) {
      var selectionKeys;
      var selected = isSelected(node);
      var metaSelection = props.metaKeySelection;
      var flatKeys = flattenizeTree();
      var rowIndex = flatKeys.findIndex(function (key) {
        return key === node.key;
      });

      if (isMultipleSelectionMode && event.shiftKey) {
        DomHandler.clearSelection(); // find first selected row

        var anchorRowIndex = flatKeys.findIndex(function (key) {
          return props.selectionKeys[key];
        });
        var rangeStart = Math.min(rowIndex, anchorRowIndex);
        var rangeEnd = Math.max(rowIndex, anchorRowIndex);
        selectionKeys = _objectSpread$1({}, props.selectionKeys);

        for (var i = rangeStart; i <= rangeEnd; i++) {
          var rowKey = flatKeys[i];
          selectionKeys[rowKey] = true;
        }
      } else {
        //anchorRowIndex = rowIndex;
        if (metaSelection) {
          var metaKey = event.metaKey || event.ctrlKey;

          if (selected && metaKey) {
            if (isSingleSelectionMode) {
              selectionKeys = null;
            } else {
              selectionKeys = _objectSpread$1({}, props.selectionKeys);
              delete selectionKeys[node.key];
            }

            if (props.onUnselect) {
              props.onUnselect({
                originalEvent: event,
                node: node
              });
            }
          } else {
            if (isSingleSelectionMode) {
              selectionKeys = node.key;
            } else if (isMultipleSelectionMode) {
              selectionKeys = !metaKey ? {} : props.selectionKeys ? _objectSpread$1({}, props.selectionKeys) : {};
              selectionKeys[node.key] = true;
            }

            if (props.onSelect) {
              props.onSelect({
                originalEvent: event,
                node: node
              });
            }
          }
        } else {
          if (isSingleSelectionMode) {
            if (selected) {
              selectionKeys = null;

              if (props.onUnselect) {
                props.onUnselect({
                  originalEvent: event,
                  node: node
                });
              }
            } else {
              selectionKeys = node.key;

              if (props.onSelect) {
                props.onSelect({
                  originalEvent: event,
                  node: node
                });
              }
            }
          } else {
            if (selected) {
              selectionKeys = _objectSpread$1({}, props.selectionKeys);
              delete selectionKeys[node.key];

              if (props.onUnselect) {
                props.onUnselect({
                  originalEvent: event,
                  node: node
                });
              }
            } else {
              selectionKeys = props.selectionKeys ? _objectSpread$1({}, props.selectionKeys) : {};
              selectionKeys[node.key] = true;

              if (props.onSelect) {
                props.onSelect({
                  originalEvent: event,
                  node: node
                });
              }
            }
          }
        }
      }

      if (props.onSelectionChange) {
        props.onSelectionChange({
          originalEvent: event,
          value: selectionKeys
        });
      }
    }
  };

  var isSelected = function isSelected(node) {
    if ((isSingleSelectionMode || isMultipleSelectionMode) && props.selectionKeys) return isSingleSelectionMode ? props.selectionKeys === node.key : props.selectionKeys[node.key] !== undefined;else return false;
  };

  var createRow = function createRow(node, index) {
    return /*#__PURE__*/React.createElement(TreeTableRow, {
      key: node.key || JSON.stringify(node.data),
      level: 0,
      rowIndex: index,
      selectOnEdit: props.selectOnEdit,
      node: node,
      columns: props.columns,
      expandedKeys: props.expandedKeys,
      onToggle: props.onToggle,
      onExpand: props.onExpand,
      onCollapse: props.onCollapse,
      selectionMode: props.selectionMode,
      selectionKeys: props.selectionKeys,
      onSelectionChange: props.onSelectionChange,
      metaKeySelection: props.metaKeySelection,
      onRowClick: onRowClick,
      onSelect: props.onSelect,
      onUnselect: props.onUnselect,
      propagateSelectionUp: props.propagateSelectionUp,
      propagateSelectionDown: props.propagateSelectionDown,
      rowClassName: props.rowClassName,
      contextMenuSelectionKey: props.contextMenuSelectionKey,
      onContextMenuSelectionChange: props.onContextMenuSelectionChange,
      onContextMenu: props.onContextMenu
    });
  };

  var createRows = function createRows() {
    if (props.paginator && !props.lazy) {
      var rpp = props.rows || 0;
      var startIndex = props.first || 0;
      var endIndex = startIndex + rpp;
      var rows = [];

      for (var i = startIndex; i < endIndex; i++) {
        var rowData = props.value[i];
        if (rowData) rows.push(createRow(props.value[i]));else break;
      }

      return rows;
    } else {
      return props.value.map(createRow);
    }
  };

  var createEmptyMessage = function createEmptyMessage() {
    if (props.loading) {
      return null;
    } else {
      var colSpan = props.columns ? props.columns.length : null;

      var _content = props.emptyMessage || localeOption$1('emptyMessage');

      return /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("td", {
        className: "p-treetable-emptymessage",
        colSpan: colSpan
      }, _content));
    }
  };

  var content = props.value && props.value.length ? createRows() : createEmptyMessage();
  return /*#__PURE__*/React.createElement("tbody", {
    className: "p-treetable-tbody"
  }, content);
});
TreeTableBody.displayName = 'TreeTableBody';
var TreeTableFooter = /*#__PURE__*/React.memo(function (props) {
  var createFooterCell = function createFooterCell(column, index) {
    return /*#__PURE__*/React.createElement("td", {
      key: column.field || index,
      className: column.props.footerClassName || column.props.className,
      style: column.props.footerStyle || column.props.style,
      rowSpan: column.props.rowSpan,
      colSpan: column.props.colSpan
    }, column.props.footer);
  };

  var createFooterRow = function createFooterRow(row, index) {
    var rowColumns = React.Children.toArray(row.props.children);
    var rowFooterCells = rowColumns.map(createFooterCell);
    return /*#__PURE__*/React.createElement("tr", {
      key: index
    }, rowFooterCells);
  };

  var createColumnGroup = function createColumnGroup() {
    var rows = React.Children.toArray(props.columnGroup.props.children);
    return rows.map(createFooterRow);
  };

  var createColumns = function createColumns(columns) {
    if (columns) {
      var headerCells = columns.map(createFooterCell);
      return /*#__PURE__*/React.createElement("tr", null, headerCells);
    } else {
      return null;
    }
  };

  var hasFooter = function hasFooter() {
    if (props.columnGroup) {
      return true;
    } else {
      for (var i = 0; i < props.columns.length; i++) {
        if (props.columns[i].props.footer) {
          return true;
        }
      }
    }

    return false;
  };

  var content = props.columnGroup ? createColumnGroup() : createColumns(props.columns);

  if (hasFooter()) {
    return /*#__PURE__*/React.createElement("tfoot", {
      className: "p-treetable-tfoot"
    }, content);
  } else {
    return null;
  }
});
TreeTableFooter.displayName = 'TreeTableFooter';

function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}

function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var TreeTableHeader = /*#__PURE__*/React.memo(function (props) {
  var filterTimeout = React.useRef(null);

  var onHeaderClick = function onHeaderClick(event, column) {
    if (column.props.sortable) {
      var targetNode = event.target;

      if (DomHandler.hasClass(targetNode, 'p-sortable-column') || DomHandler.hasClass(targetNode, 'p-column-title') || DomHandler.hasClass(targetNode, 'p-sortable-column-icon') || DomHandler.hasClass(targetNode.parentElement, 'p-sortable-column-icon')) {
        props.onSort({
          originalEvent: event,
          sortField: column.props.sortField || column.props.field,
          sortFunction: column.props.sortFunction,
          sortable: column.props.sortable
        });
        DomHandler.clearSelection();
      }
    }
  };

  var onHeaderMouseDown = function onHeaderMouseDown(event, column) {
    if (props.reorderableColumns && column.props.reorderable) {
      if (event.target.nodeName !== 'INPUT') event.currentTarget.draggable = true;else if (event.target.nodeName === 'INPUT') event.currentTarget.draggable = false;
    }
  };

  var onHeaderKeyDown = function onHeaderKeyDown(event, column) {
    if (event.key === 'Enter') {
      onHeaderClick(event, column);
      event.preventDefault();
    }
  };

  var getMultiSortMetaDataIndex = function getMultiSortMetaDataIndex(column) {
    if (props.multiSortMeta) {
      for (var i = 0; i < props.multiSortMeta.length; i++) {
        if (props.multiSortMeta[i].field === column.props.field) {
          return i;
        }
      }
    }

    return -1;
  };

  var onResizerMouseDown = function onResizerMouseDown(event, column) {
    if (props.resizableColumns && props.onResizeStart) {
      props.onResizeStart({
        originalEvent: event,
        columnEl: event.target.parentElement,
        column: column
      });
    }
  };

  var _onDragStart = function onDragStart(event, column) {
    if (props.onDragStart) {
      props.onDragStart({
        originalEvent: event,
        column: column
      });
    }
  };

  var _onDragOver = function onDragOver(event, column) {
    if (props.onDragOver) {
      props.onDragOver({
        originalEvent: event,
        column: column
      });
    }
  };

  var _onDragLeave = function onDragLeave(event, column) {
    if (props.onDragLeave) {
      props.onDragLeave({
        originalEvent: event,
        column: column
      });
    }
  };

  var _onDrop = function onDrop(event, column) {
    if (props.onDrop) {
      props.onDrop({
        originalEvent: event,
        column: column
      });
    }
  };

  var onFilterInput = function onFilterInput(e, column) {
    if (column.props.filter && props.onFilter) {
      if (filterTimeout.current) {
        clearTimeout(filterTimeout.current);
      }

      var filterValue = e.target.value;
      filterTimeout.current = setTimeout(function () {
        props.onFilter({
          value: filterValue,
          field: column.props.field,
          matchMode: column.props.filterMatchMode || 'startsWith'
        });
        filterTimeout.current = null;
      }, props.filterDelay);
    }
  };

  var hasColumnFilter = function hasColumnFilter(columns) {
    if (columns) {
      var _iterator = _createForOfIteratorHelper$1(columns),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var col = _step.value;

          if (col.props.filter) {
            return true;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    return false;
  };

  var getAriaSort = function getAriaSort(column, sorted, sortOrder) {
    if (column.props.sortable) {
      var sortIcon = sorted ? sortOrder < 0 ? 'pi-sort-down' : 'pi-sort-up' : 'pi-sort';
      if (sortIcon === 'pi-sort-down') return 'descending';else if (sortIcon === 'pi-sort-up') return 'ascending';else return 'none';
    } else {
      return null;
    }
  };

  var getColumnProp = function getColumnProp(column) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return column ? typeof args[0] === 'string' ? column.props[args[0]] : (args[0] || column).props[args[1]] : null;
  };

  var createSortIcon = function createSortIcon(column, sorted, sortOrder) {
    if (column.props.sortable) {
      var sortIcon = sorted ? sortOrder < 0 ? 'pi-sort-amount-down' : 'pi-sort-amount-up-alt' : 'pi-sort-alt';
      var sortIconClassName = classNames('p-sortable-column-icon', 'pi pi-fw', sortIcon);
      return /*#__PURE__*/React.createElement("span", {
        className: sortIconClassName
      });
    } else {
      return null;
    }
  };

  var createResizer = function createResizer(column) {
    if (props.resizableColumns) {
      return /*#__PURE__*/React.createElement("span", {
        className: "p-column-resizer p-clickable",
        onMouseDown: function onMouseDown(e) {
          return onResizerMouseDown(e, column);
        }
      });
    } else {
      return null;
    }
  };

  var createSortBadge = function createSortBadge(sortMetaDataIndex) {
    if (sortMetaDataIndex !== -1 && props.multiSortMeta && props.multiSortMeta.length > 1) {
      return /*#__PURE__*/React.createElement("span", {
        className: "p-sortable-column-badge"
      }, sortMetaDataIndex + 1);
    }

    return null;
  };

  var createHeaderCell = function createHeaderCell(column, options) {
    var filterElement;

    if (column.props.filter && options.renderFilter) {
      filterElement = column.props.filterElement || /*#__PURE__*/React.createElement(InputText$1, {
        onInput: function onInput(e) {
          return onFilterInput(e, column);
        },
        type: props.filterType,
        defaultValue: props.filters && props.filters[column.props.field] ? props.filters[column.props.field].value : null,
        className: "p-column-filter",
        placeholder: column.props.filterPlaceholder,
        maxLength: column.props.filterMaxLength
      });
    }

    if (options.filterOnly) {
      return /*#__PURE__*/React.createElement("th", {
        key: column.props.columnKey || column.props.field || options.index,
        className: classNames('p-filter-column', column.props.filterHeaderClassName),
        style: column.props.filterHeaderStyle || column.props.style,
        rowSpan: column.props.rowSpan,
        colSpan: column.props.colSpan
      }, filterElement);
    } else {
      var sortMetaDataIndex = getMultiSortMetaDataIndex(column);
      var multiSortMetaData = sortMetaDataIndex !== -1 ? props.multiSortMeta[sortMetaDataIndex] : null;
      var singleSorted = column.props.field === props.sortField;
      var multipleSorted = multiSortMetaData !== null;
      var sorted = column.props.sortable && (singleSorted || multipleSorted);
      var sortOrder = 0;
      if (singleSorted) sortOrder = props.sortOrder;else if (multipleSorted) sortOrder = multiSortMetaData.order;
      var sortIconElement = createSortIcon(column, sorted, sortOrder);
      var ariaSortData = getAriaSort(column, sorted, sortOrder);
      var sortBadge = createSortBadge(sortMetaDataIndex);
      var className = classNames(column.props.headerClassName || column.props.className, {
        'p-sortable-column': column.props.sortable,
        'p-highlight': sorted,
        'p-resizable-column': props.resizableColumns && getColumnProp(column, 'resizeable')
      });
      var resizer = createResizer(column);
      return /*#__PURE__*/React.createElement("th", {
        key: column.columnKey || column.field || options.index,
        className: className,
        style: column.props.headerStyle || column.props.style,
        tabIndex: column.props.sortable ? props.tabIndex : null,
        onClick: function onClick(e) {
          return onHeaderClick(e, column);
        },
        onMouseDown: function onMouseDown(e) {
          return onHeaderMouseDown(e, column);
        },
        onKeyDown: function onKeyDown(e) {
          return onHeaderKeyDown(e, column);
        },
        rowSpan: column.props.rowSpan,
        colSpan: column.props.colSpan,
        "aria-sort": ariaSortData,
        onDragStart: function onDragStart(e) {
          return _onDragStart(e, column);
        },
        onDragOver: function onDragOver(e) {
          return _onDragOver(e, column);
        },
        onDragLeave: function onDragLeave(e) {
          return _onDragLeave(e, column);
        },
        onDrop: function onDrop(e) {
          return _onDrop(e, column);
        }
      }, resizer, /*#__PURE__*/React.createElement("span", {
        className: "p-column-title"
      }, column.props.header), sortIconElement, sortBadge, filterElement);
    }
  };

  var createHeaderRow = function createHeaderRow(row, index) {
    var rowColumns = React.Children.toArray(row.props.children);
    var rowHeaderCells = rowColumns.map(function (col, i) {
      return createHeaderCell(col, {
        index: i,
        filterOnly: false,
        renderFilter: true
      });
    });
    return /*#__PURE__*/React.createElement("tr", {
      key: index
    }, rowHeaderCells);
  };

  var createColumnGroup = function createColumnGroup() {
    var rows = React.Children.toArray(props.columnGroup.props.children);
    return rows.map(createHeaderRow);
  };

  var createColumns = function createColumns(columns) {
    if (columns) {
      if (hasColumnFilter(columns)) {
        return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("tr", null, columns.map(function (col, i) {
          return createHeaderCell(col, {
            index: i,
            filterOnly: false,
            renderFilter: false
          });
        })), /*#__PURE__*/React.createElement("tr", null, columns.map(function (col, i) {
          return createHeaderCell(col, {
            index: i,
            filterOnly: true,
            renderFilter: true
          });
        })));
      } else {
        return /*#__PURE__*/React.createElement("tr", null, columns.map(function (col, i) {
          return createHeaderCell(col, {
            index: i,
            filterOnly: false,
            renderFilter: false
          });
        }));
      }
    } else {
      return null;
    }
  };

  var content = props.columnGroup ? createColumnGroup() : createColumns(props.columns);
  return /*#__PURE__*/React.createElement("thead", {
    className: "p-treetable-thead"
  }, content);
});
TreeTableHeader.displayName = 'TreeTableHeader';
var TreeTableScrollableView = /*#__PURE__*/React.memo(function (props) {
  var elementRef = React.useRef(null);
  var scrollHeaderRef = React.useRef(null);
  var scrollHeaderBoxRef = React.useRef(null);
  var scrollBodyRef = React.useRef(null);
  var scrollTableRef = React.useRef(null);
  var scrollFooterRef = React.useRef(null);
  var scrollFooterBoxRef = React.useRef(null);

  var setScrollHeight = function setScrollHeight() {
    if (props.scrollHeight) {
      if (props.scrollHeight.indexOf('%') !== -1) {
        var datatableContainer = findDataTableContainer(elementRef.current);
        scrollBodyRef.current.style.visibility = 'hidden';
        scrollBodyRef.current.style.height = '100px'; //temporary height to calculate static height

        var containerHeight = DomHandler.getOuterHeight(datatableContainer);
        var relativeHeight = DomHandler.getOuterHeight(datatableContainer.parentElement) * parseInt(props.scrollHeight, 10) / 100;
        var staticHeight = containerHeight - 100; //total height of headers, footers, paginators

        var scrollBodyHeight = relativeHeight - staticHeight;
        scrollBodyRef.current.style.height = 'auto';
        scrollBodyRef.current.style.maxHeight = scrollBodyHeight + 'px';
        scrollBodyRef.current.style.visibility = 'visible';
      } else {
        scrollBodyRef.current.style.maxHeight = props.scrollHeight;
      }
    }
  };

  var findDataTableContainer = function findDataTableContainer(element) {
    if (element) {
      var el = element;

      while (el && !DomHandler.hasClass(el, 'p-treetable')) {
        el = el.parentElement;
      }

      return el;
    } else {
      return null;
    }
  };

  var onHeaderScroll = function onHeaderScroll() {
    scrollHeaderRef.current.scrollLeft = 0;
  };

  var onBodyScroll = function onBodyScroll() {
    var frozenView = elementRef.current.previousElementSibling;
    var frozenScrollBody;

    if (frozenView) {
      frozenScrollBody = DomHandler.findSingle(frozenView, '.p-treetable-scrollable-body');
    }

    scrollHeaderBoxRef.current.style.marginLeft = -1 * scrollBodyRef.current.scrollLeft + 'px';

    if (scrollFooterBoxRef.current) {
      scrollFooterBoxRef.current.style.marginLeft = -1 * scrollBodyRef.current.scrollLeft + 'px';
    }

    if (frozenScrollBody) {
      frozenScrollBody.scrollTop = scrollBodyRef.current.scrollTop;
    }
  };

  useMountEffect(function () {
    if (!props.frozen) {
      var scrollBarWidth = DomHandler.calculateScrollbarWidth();
      scrollHeaderBoxRef.current.style.marginRight = scrollBarWidth + 'px';

      if (scrollFooterBoxRef.current) {
        scrollFooterBoxRef.current.style.marginRight = scrollBarWidth + 'px';
      }
    } else {
      scrollBodyRef.current.style.paddingBottom = DomHandler.calculateScrollbarWidth() + 'px';
    }
  });
  React.useEffect(function () {
    setScrollHeight();
  });

  var createColGroup = function createColGroup() {
    if (ObjectUtils.isNotEmpty(props.columns)) {
      var cols = props.columns.map(function (col, i) {
        return /*#__PURE__*/React.createElement("col", {
          key: col.field + '_' + i
        });
      });
      return /*#__PURE__*/React.createElement("colgroup", {
        className: "p-treetable-scrollable-colgroup"
      }, cols);
    } else {
      return null;
    }
  };

  var className = classNames('p-treetable-scrollable-view', {
    'p-treetable-frozen-view': props.frozen,
    'p-treetable-unfrozen-view': !props.frozen && props.frozenWidth
  });
  var width = props.frozen ? props.frozenWidth : 'calc(100% - ' + props.frozenWidth + ')';
  var left = props.frozen ? null : props.frozenWidth;
  var colGroup = createColGroup();
  var scrollableBodyStyle = !props.frozen && props.scrollHeight ? {
    overflowY: 'scroll'
  } : null;
  return /*#__PURE__*/React.createElement("div", {
    className: className,
    style: {
      width: width,
      left: left
    },
    ref: elementRef
  }, /*#__PURE__*/React.createElement("div", {
    className: "p-treetable-scrollable-header",
    ref: scrollHeaderRef,
    onScroll: onHeaderScroll
  }, /*#__PURE__*/React.createElement("div", {
    className: "p-treetable-scrollable-header-box",
    ref: scrollHeaderBoxRef
  }, /*#__PURE__*/React.createElement("table", {
    className: "p-treetable-scrollable-header-table"
  }, colGroup, props.header))), /*#__PURE__*/React.createElement("div", {
    className: "p-treetable-scrollable-body",
    ref: scrollBodyRef,
    style: scrollableBodyStyle,
    onScroll: onBodyScroll
  }, /*#__PURE__*/React.createElement("table", {
    ref: scrollTableRef,
    style: {
      top: '0'
    },
    className: "p-treetable-scrollable-body-table"
  }, colGroup, props.body)), /*#__PURE__*/React.createElement("div", {
    className: "p-treetable-scrollable-footer",
    ref: scrollFooterRef
  }, /*#__PURE__*/React.createElement("div", {
    className: "p-treetable-scrollable-footer-box",
    ref: scrollFooterBoxRef
  }, /*#__PURE__*/React.createElement("table", {
    className: "p-treetable-scrollable-footer-table"
  }, colGroup, props.footer))));
});
TreeTableScrollableView.displayName = 'TreeTableScrollableView';

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray$5(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
}

function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

var TreeTable$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(props.expandedKeys),
      _React$useState2 = _slicedToArray$1(_React$useState, 2),
      expandedKeysState = _React$useState2[0],
      setExpandedKeysState = _React$useState2[1];

  var _React$useState3 = React.useState(props.first),
      _React$useState4 = _slicedToArray$1(_React$useState3, 2),
      firstState = _React$useState4[0],
      setFirstState = _React$useState4[1];

  var _React$useState5 = React.useState(props.rows),
      _React$useState6 = _slicedToArray$1(_React$useState5, 2),
      rowsState = _React$useState6[0],
      setRowsState = _React$useState6[1];

  var _React$useState7 = React.useState(props.sortField),
      _React$useState8 = _slicedToArray$1(_React$useState7, 2),
      sortFieldState = _React$useState8[0],
      setSortFieldState = _React$useState8[1];

  var _React$useState9 = React.useState(props.sortOrder),
      _React$useState10 = _slicedToArray$1(_React$useState9, 2),
      sortOrderState = _React$useState10[0],
      setSortOrderState = _React$useState10[1];

  var _React$useState11 = React.useState(props.multiSortMeta),
      _React$useState12 = _slicedToArray$1(_React$useState11, 2),
      multiSortMetaState = _React$useState12[0],
      setMultiSortMetaState = _React$useState12[1];

  var _React$useState13 = React.useState(props.filters),
      _React$useState14 = _slicedToArray$1(_React$useState13, 2),
      filtersState = _React$useState14[0],
      setFiltersState = _React$useState14[1];

  var _React$useState15 = React.useState([]),
      _React$useState16 = _slicedToArray$1(_React$useState15, 2),
      columnOrderState = _React$useState16[0],
      setColumnOrderState = _React$useState16[1];

  var elementRef = React.useRef(null);
  var resizerHelperRef = React.useRef(null);
  var reorderIndicatorUpRef = React.useRef(null);
  var reorderIndicatorDownRef = React.useRef(null);
  var columnResizing = React.useRef(null);
  var resizeColumn = React.useRef(null);
  var resizeColumnProps = React.useRef(null);
  var lastResizerHelperX = React.useRef(0);
  var iconWidth = React.useRef(0);
  var iconHeight = React.useRef(0);
  var draggedColumnEl = React.useRef(null);
  var draggedColumn = React.useRef(null);
  var dropPosition = React.useRef(null);
  var columnSortable = React.useRef(null);
  var columnSortFunction = React.useRef(null);
  var columnField = React.useRef(null);

  var _useEventListener = useEventListener({
    type: 'mousemove',
    listener: function listener(event) {
      if (columnResizing.current) {
        onColumnResize(event);
      }
    }
  }),
      _useEventListener2 = _slicedToArray$1(_useEventListener, 2),
      bindDocumentMouseMoveListener = _useEventListener2[0],
      unbindDocumentMouseMoveListener = _useEventListener2[1];

  var _useEventListener3 = useEventListener({
    type: 'mouseup',
    listener: function listener(event) {
      if (columnResizing.current) {
        columnResizing.current = false;
        onColumnResizeEnd();
      }
    }
  }),
      _useEventListener4 = _slicedToArray$1(_useEventListener3, 2),
      bindDocumentMouseUpListener = _useEventListener4[0],
      unbindDocumentMouseUpListener = _useEventListener4[1];

  var onToggle = function onToggle(event) {
    if (props.onToggle) {
      props.onToggle(event);
    } else {
      setExpandedKeysState(event.value);
    }
  };

  var onPageChange = function onPageChange(event) {
    if (props.onPage) {
      props.onPage(event);
    } else {
      setFirstState(event.first);
      setRowsState(event.rows);
    }
  };

  var onSort = function onSort(event) {
    var sortField = event.sortField;
    var sortOrder = props.defaultSortOrder;
    var multiSortMeta;
    var eventMeta;
    columnSortable.current = event.sortable;
    columnSortFunction.current = event.sortFunction;
    columnField.current = event.sortField;

    if (props.sortMode === 'multiple') {
      var metaKey = event.originalEvent.metaKey || event.originalEvent.ctrlKey;
      multiSortMeta = _toConsumableArray(getMultiSortMeta());

      if (multiSortMeta && multiSortMeta instanceof Array) {
        var sortMeta = multiSortMeta.find(function (sortMeta) {
          return sortMeta.field === sortField;
        });
        sortOrder = sortMeta ? getCalculatedSortOrder(sortMeta.order) : sortOrder;
      }

      var newMetaData = {
        field: sortField,
        order: sortOrder
      };

      if (sortOrder) {
        if (!multiSortMeta || !metaKey) {
          multiSortMeta = [];
        }

        addSortMeta(newMetaData, multiSortMeta);
      } else if (props.removableSort && multiSortMeta) {
        removeSortMeta(newMetaData, multiSortMeta);
      }

      eventMeta = {
        multiSortMeta: multiSortMeta
      };
    } else {
      sortOrder = getSortField() === sortField ? getCalculatedSortOrder(getSortOrder()) : sortOrder;

      if (props.removableSort) {
        sortField = sortOrder ? sortField : null;
      }

      eventMeta = {
        sortField: sortField,
        sortOrder: sortOrder
      };
    }

    if (props.onSort) {
      props.onSort(eventMeta);
    } else {
      setFirstState(0);
      setSortFieldState(eventMeta.sortField);
      setSortOrderState(eventMeta.sortOrder);
      setMultiSortMetaState(eventMeta.multiSortMeta);
    }
  };

  var getCalculatedSortOrder = function getCalculatedSortOrder(currentOrder) {
    return props.removableSort ? props.defaultSortOrder === currentOrder ? currentOrder * -1 : 0 : currentOrder * -1;
  };

  var addSortMeta = function addSortMeta(meta, multiSortMeta) {
    var index = -1;

    for (var i = 0; i < multiSortMeta.length; i++) {
      if (multiSortMeta[i].field === meta.field) {
        index = i;
        break;
      }
    }

    if (index >= 0) multiSortMeta[index] = meta;else multiSortMeta.push(meta);
  };

  var removeSortMeta = function removeSortMeta(meta, multiSortMeta) {
    var index = -1;

    for (var i = 0; i < multiSortMeta.length; i++) {
      if (multiSortMeta[i].field === meta.field) {
        index = i;
        break;
      }
    }

    if (index >= 0) {
      multiSortMeta.splice(index, 1);
    }

    multiSortMeta = multiSortMeta.length > 0 ? multiSortMeta : null;
  };

  var sortSingle = function sortSingle(data) {
    return sortNodes(data);
  };

  var sortNodes = function sortNodes(data) {
    var value = _toConsumableArray(data);

    if (columnSortable.current && columnSortable.current === 'custom' && columnSortFunction.current) {
      value = columnSortFunction.current({
        data: data,
        field: getSortField(),
        order: getSortOrder()
      });
    } else {
      value.sort(function (node1, node2) {
        var sortField = getSortField();
        var value1 = ObjectUtils.resolveFieldData(node1.data, sortField);
        var value2 = ObjectUtils.resolveFieldData(node2.data, sortField);
        return compareValuesOnSort(value1, value2, getSortOrder());
      });

      for (var i = 0; i < value.length; i++) {
        if (value[i].children && value[i].children.length) {
          value[i].children = sortNodes(value[i].children);
        }
      }
    }

    return value;
  };

  var sortMultiple = function sortMultiple(data) {
    var multiSortMeta = getMultiSortMeta();
    if (multiSortMeta) return sortMultipleNodes(data, multiSortMeta);else return data;
  };

  var sortMultipleNodes = function sortMultipleNodes(data, multiSortMeta) {
    var value = _toConsumableArray(data);

    value.sort(function (node1, node2) {
      return multisortField(node1, node2, multiSortMeta, 0);
    });

    for (var i = 0; i < value.length; i++) {
      if (value[i].children && value[i].children.length) {
        value[i].children = sortMultipleNodes(value[i].children, multiSortMeta);
      }
    }

    return value;
  };

  var multisortField = function multisortField(node1, node2, multiSortMeta, index) {
    var value1 = ObjectUtils.resolveFieldData(node1.data, multiSortMeta[index].field);
    var value2 = ObjectUtils.resolveFieldData(node2.data, multiSortMeta[index].field); // check if they are equal handling dates and locales

    if (ObjectUtils.compare(value1, value2, PrimeReact$1.locale) === 0) {
      return multiSortMeta.length - 1 > index ? multisortField(node1, node2, multiSortMeta, index + 1) : 0;
    }

    return compareValuesOnSort(value1, value2, multiSortMeta[index].order);
  };

  var compareValuesOnSort = function compareValuesOnSort(value1, value2, order) {
    return ObjectUtils.sort(value1, value2, order, PrimeReact$1.locale, PrimeReact$1.nullSortOrder);
  };

  var filter = function filter(value, field, mode) {
    onFilter({
      value: value,
      field: field,
      matchMode: mode
    });
  };

  var onFilter = function onFilter(event) {
    var filters = getFilters();
    var newFilters = filters ? _objectSpread({}, filters) : {};
    if (!isFilterBlank(event.value)) newFilters[event.field] = {
      value: event.value,
      matchMode: event.matchMode
    };else if (newFilters[event.field]) delete newFilters[event.field];

    if (props.onFilter) {
      props.onFilter({
        filters: newFilters
      });
    } else {
      setFirstState(0);
      setFiltersState(newFilters);
    }
  };

  var isFilterBlank = function isFilterBlank(filter) {
    if (filter !== null && filter !== undefined) {
      if (typeof filter === 'string' && filter.trim().length === 0 || filter instanceof Array && filter.length === 0) return true;else return false;
    }

    return true;
  };

  var onColumnResizeStart = function onColumnResizeStart(event) {
    var containerLeft = DomHandler.getOffset(elementRef.current).left;
    resizeColumn.current = event.columnEl;
    resizeColumnProps.current = event.column;
    columnResizing.current = true;
    lastResizerHelperX.current = event.originalEvent.pageX - containerLeft + elementRef.current.scrollLeft;
    bindColumnResizeEvents();
  };

  var onColumnResize = function onColumnResize(event) {
    var containerLeft = DomHandler.getOffset(elementRef.current).left;
    DomHandler.addClass(elementRef.current, 'p-unselectable-text');
    resizerHelperRef.current.style.height = elementRef.current.offsetHeight + 'px';
    resizerHelperRef.current.style.top = 0 + 'px';
    resizerHelperRef.current.style.left = event.pageX - containerLeft + elementRef.current.scrollLeft + 'px';
    resizerHelperRef.current.style.display = 'block';
  };

  var onColumnResizeEnd = function onColumnResizeEnd(event) {
    var delta = resizerHelperRef.current.offsetLeft - lastResizerHelperX.current;
    var columnWidth = resizeColumn.current.offsetWidth;
    var newColumnWidth = columnWidth + delta;
    var minWidth = resizeColumn.current.style.minWidth || 15;

    if (columnWidth + delta > parseInt(minWidth, 10)) {
      if (props.columnResizeMode === 'fit') {
        var nextColumn = resizeColumn.current.nextElementSibling;
        var nextColumnWidth = nextColumn.offsetWidth - delta;

        if (newColumnWidth > 15 && nextColumnWidth > 15) {
          if (props.scrollable) {
            var scrollableView = findParentScrollableView(resizeColumn.current);
            var scrollableBodyTable = DomHandler.findSingle(scrollableView, 'table.p-treetable-scrollable-body-table');
            var scrollableHeaderTable = DomHandler.findSingle(scrollableView, 'table.p-treetable-scrollable-header-table');
            var scrollableFooterTable = DomHandler.findSingle(scrollableView, 'table.p-treetable-scrollable-footer-table');
            var resizeColumnIndex = DomHandler.index(resizeColumn.current);
            resizeColGroup(scrollableHeaderTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
            resizeColGroup(scrollableBodyTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
            resizeColGroup(scrollableFooterTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
          } else {
            resizeColumn.current.style.width = newColumnWidth + 'px';

            if (nextColumn) {
              nextColumn.style.width = nextColumnWidth + 'px';
            }
          }
        }
      } else if (props.columnResizeMode === 'expand') {
        if (props.scrollable) {
          var _scrollableView = findParentScrollableView(resizeColumn.current);

          var _scrollableBodyTable = DomHandler.findSingle(_scrollableView, 'table.p-treetable-scrollable-body-table');

          var _scrollableHeaderTable = DomHandler.findSingle(_scrollableView, 'table.p-treetable-scrollable-header-table');

          var _scrollableFooterTable = DomHandler.findSingle(_scrollableView, 'table.p-treetable-scrollable-footer-table');

          _scrollableBodyTable.style.width = _scrollableBodyTable.offsetWidth + delta + 'px';
          _scrollableHeaderTable.style.width = _scrollableHeaderTable.offsetWidth + delta + 'px';

          if (_scrollableFooterTable) {
            _scrollableFooterTable.style.width = _scrollableHeaderTable.offsetWidth + delta + 'px';
          }

          var _resizeColumnIndex = DomHandler.index(resizeColumn.current);

          resizeColGroup(_scrollableHeaderTable, _resizeColumnIndex, newColumnWidth, null);
          resizeColGroup(_scrollableBodyTable, _resizeColumnIndex, newColumnWidth, null);
          resizeColGroup(_scrollableFooterTable, _resizeColumnIndex, newColumnWidth, null);
        } else {
          table.style.width = table.offsetWidth + delta + 'px';
          resizeColumn.current.style.width = newColumnWidth + 'px';
        }
      }

      if (props.onColumnResizeEnd) {
        props.onColumnResizeEnd({
          element: resizeColumn.current,
          column: resizeColumnProps.current,
          delta: delta
        });
      }
    }

    resizerHelperRef.current.style.display = 'none';
    resizeColumn.current = null;
    resizeColumnProps.current = null;
    DomHandler.removeClass(elementRef.current, 'p-unselectable-text');
    unbindColumnResizeEvents();
  };

  var findParentScrollableView = function findParentScrollableView(column) {
    if (column) {
      var parent = column.parentElement;

      while (parent && !DomHandler.hasClass(parent, 'p-treetable-scrollable-view')) {
        parent = parent.parentElement;
      }

      return parent;
    } else {
      return null;
    }
  };

  var resizeColGroup = function resizeColGroup(table, resizeColumnIndex, newColumnWidth, nextColumnWidth) {
    if (table) {
      var colGroup = table.children[0].nodeName === 'COLGROUP' ? table.children[0] : null;

      if (colGroup) {
        var col = colGroup.children[resizeColumnIndex];
        var nextCol = col.nextElementSibling;
        col.style.width = newColumnWidth + 'px';

        if (nextCol && nextColumnWidth) {
          nextCol.style.width = nextColumnWidth + 'px';
        }
      } else {
        throw new Error('Scrollable tables require a colgroup to support resizable columns');
      }
    }
  };

  var bindColumnResizeEvents = function bindColumnResizeEvents() {
    bindDocumentMouseMoveListener();
    bindDocumentMouseUpListener();
  };

  var unbindColumnResizeEvents = function unbindColumnResizeEvents() {
    unbindDocumentMouseMoveListener();
    unbindDocumentMouseUpListener();
  };

  var onColumnDragStart = function onColumnDragStart(e) {
    var event = e.originalEvent,
        column = e.column;

    if (columnResizing.current) {
      event.preventDefault();
      return;
    }

    iconWidth.current = DomHandler.getHiddenElementOuterWidth(reorderIndicatorUpRef.current);
    iconHeight.current = DomHandler.getHiddenElementOuterHeight(reorderIndicatorUpRef.current);
    draggedColumnEl.current = findParentHeader(event.currentTarget);
    draggedColumn.current = column;
    event.dataTransfer.setData('text', 'b'); // Firefox requires this to make dragging possible
  };

  var onColumnDragOver = function onColumnDragOver(e) {
    var event = e.originalEvent;
    var dropHeader = findParentHeader(event.currentTarget);

    if (props.reorderableColumns && draggedColumnEl.current && dropHeader) {
      event.preventDefault();
      var containerOffset = DomHandler.getOffset(elementRef.current);
      var dropHeaderOffset = DomHandler.getOffset(dropHeader);

      if (draggedColumnEl.current !== dropHeader) {
        var targetLeft = dropHeaderOffset.left - containerOffset.left; //let targetTop =  containerOffset.top - dropHeaderOffset.top;

        var columnCenter = dropHeaderOffset.left + dropHeader.offsetWidth / 2;
        reorderIndicatorUpRef.current.style.top = dropHeaderOffset.top - containerOffset.top - (iconHeight.current - 1) + 'px';
        reorderIndicatorDownRef.current.style.top = dropHeaderOffset.top - containerOffset.top + dropHeader.offsetHeight + 'px';

        if (event.pageX > columnCenter) {
          reorderIndicatorUpRef.current.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(iconWidth.current / 2) + 'px';
          reorderIndicatorDownRef.current.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(iconWidth.current / 2) + 'px';
          dropPosition.current = 1;
        } else {
          reorderIndicatorUpRef.current.style.left = targetLeft - Math.ceil(iconWidth.current / 2) + 'px';
          reorderIndicatorDownRef.current.style.left = targetLeft - Math.ceil(iconWidth.current / 2) + 'px';
          dropPosition.current = -1;
        }

        reorderIndicatorUpRef.current.style.display = 'block';
        reorderIndicatorDownRef.current.style.display = 'block';
      }
    }
  };

  var onColumnDragLeave = function onColumnDragLeave(e) {
    var event = e.originalEvent;

    if (props.reorderableColumns && draggedColumnEl.current) {
      event.preventDefault();
      reorderIndicatorUpRef.current.style.display = 'none';
      reorderIndicatorDownRef.current.style.display = 'none';
    }
  };

  var onColumnDrop = function onColumnDrop(e) {
    var event = e.originalEvent,
        column = e.column;
    event.preventDefault();

    if (draggedColumnEl.current) {
      var dragIndex = DomHandler.index(draggedColumnEl.current);
      var dropIndex = DomHandler.index(findParentHeader(event.currentTarget));
      var allowDrop = dragIndex !== dropIndex;

      if (allowDrop && (dropIndex - dragIndex === 1 && dropPosition.current === -1 || dragIndex - dropIndex === 1 && dropPosition.current === 1)) {
        allowDrop = false;
      }

      if (allowDrop) {
        var columns = columnOrderState ? getColumns() : React.Children.toArray(props.children);

        var isSameColumn = function isSameColumn(col1, col2) {
          return col1.props.columnKey || col2.props.columnKey ? ObjectUtils.equals(col1, col2, 'props.columnKey') : ObjectUtils.equals(col1, col2, 'props.field');
        };

        var dragColIndex = columns.findIndex(function (child) {
          return isSameColumn(child, draggedColumn.current);
        });
        var dropColIndex = columns.findIndex(function (child) {
          return isSameColumn(child, column);
        });

        if (dropColIndex < dragColIndex && dropPosition.current === 1) {
          dropColIndex++;
        }

        if (dropColIndex > dragColIndex && dropPosition.current === -1) {
          dropColIndex--;
        }

        ObjectUtils.reorderArray(columns, dragColIndex, dropColIndex);
        var columnOrder = [];

        var _iterator = _createForOfIteratorHelper(columns),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _column = _step.value;
            columnOrder.push(_column.props.columnKey || _column.props.field);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        setColumnOrderState(columnOrder);

        if (props.onColReorder) {
          props.onColReorder({
            dragIndex: dragColIndex,
            dropIndex: dropColIndex,
            columns: columns
          });
        }
      }

      reorderIndicatorUpRef.current.style.display = 'none';
      reorderIndicatorDownRef.current.style.display = 'none';
      draggedColumnEl.current.draggable = false;
      draggedColumnEl.current = null;
      dropPosition.current = null;
    }
  };

  var findParentHeader = function findParentHeader(element) {
    if (element.nodeName === 'TH') {
      return element;
    } else {
      var parent = element.parentElement;

      while (parent.nodeName !== 'TH') {
        parent = parent.parentElement;
        if (!parent) break;
      }

      return parent;
    }
  };

  var getExpandedKeys = function getExpandedKeys() {
    return props.onToggle ? props.expandedKeys : expandedKeysState;
  };

  var getFirst = function getFirst() {
    return props.onPage ? props.first : firstState;
  };

  var getRows = function getRows() {
    return props.onPage ? props.rows : rowsState;
  };

  var getSortField = function getSortField() {
    return props.onSort ? props.sortField : sortFieldState;
  };

  var getSortOrder = function getSortOrder() {
    return props.onSort ? props.sortOrder : sortOrderState;
  };

  var getMultiSortMeta = function getMultiSortMeta() {
    return (props.onSort ? props.multiSortMeta : multiSortMetaState) || [];
  };

  var getFilters = function getFilters() {
    return props.onFilter ? props.filters : filtersState;
  };

  var findColumnByKey = function findColumnByKey(columns, key) {
    if (columns && columns.length) {
      for (var i = 0; i < columns.length; i++) {
        var child = columns[i];

        if (child.props.columnKey === key || child.props.field === key) {
          return child;
        }
      }
    }

    return null;
  };

  var getColumns = function getColumns() {
    var columns = React.Children.toArray(props.children);

    if (columns && columns.length) {
      if (props.reorderableColumns && columnOrderState) {
        var orderedColumns = [];

        var _iterator2 = _createForOfIteratorHelper(columnOrderState),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var columnKey = _step2.value;
            var column = findColumnByKey(columns, columnKey);

            if (column) {
              orderedColumns.push(column);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return [].concat(orderedColumns, _toConsumableArray(columns.filter(function (item) {
          return orderedColumns.indexOf(item) < 0;
        })));
      } else {
        return columns;
      }
    }

    return null;
  };

  var getTotalRecords = function getTotalRecords(data) {
    return props.lazy ? props.totalRecords : data ? data.length : 0;
  };

  var isSingleSelectionMode = function isSingleSelectionMode() {
    return props.selectionMode && props.selectionMode === 'single';
  };

  var isMultipleSelectionMode = function isMultipleSelectionMode() {
    return props.selectionMode && props.selectionMode === 'multiple';
  };

  var isRowSelectionMode = function isRowSelectionMode() {
    return isSingleSelectionMode() || isMultipleSelectionMode();
  };

  var getFrozenColumns = function getFrozenColumns(columns) {
    var frozenColumns = null;

    var _iterator3 = _createForOfIteratorHelper(columns),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var col = _step3.value;

        if (col.props.frozen) {
          frozenColumns = frozenColumns || [];
          frozenColumns.push(col);
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return frozenColumns;
  };

  var getScrollableColumns = function getScrollableColumns(columns) {
    var scrollableColumns = null;

    var _iterator4 = _createForOfIteratorHelper(columns),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var col = _step4.value;

        if (!col.props.frozen) {
          scrollableColumns = scrollableColumns || [];
          scrollableColumns.push(col);
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    return scrollableColumns;
  };

  var filterLocal = function filterLocal(value) {
    var filteredNodes = [];
    var filters = getFilters();
    var columns = React.Children.toArray(props.children);
    var isStrictMode = props.filterMode === 'strict';

    var _iterator5 = _createForOfIteratorHelper(value),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var node = _step5.value;

        var copyNode = _objectSpread({}, node);

        var localMatch = true;
        var globalMatch = false;

        for (var j = 0; j < columns.length; j++) {
          var col = columns[j];
          var filterMeta = filters ? filters[col.props.field] : null;
          var filterField = col.props.field;
          var filterValue = void 0,
              filterConstraint = void 0,
              paramsWithoutNode = void 0,
              options = void 0; //local

          if (filterMeta) {
            var filterMatchMode = filterMeta.matchMode || col.props.filterMatchMode || 'startsWith';
            filterValue = filterMeta.value;
            filterConstraint = filterMatchMode === 'custom' ? col.props.filterFunction : FilterService.filters[filterMatchMode];
            options = {
              rowData: node,
              filters: filters,
              props: props,
              column: {
                filterMeta: filterMeta,
                filterField: filterField,
                props: col.props
              }
            };
            paramsWithoutNode = {
              filterField: filterField,
              filterValue: filterValue,
              filterConstraint: filterConstraint,
              isStrictMode: isStrictMode,
              options: options
            };

            if (isStrictMode && !(findFilteredNodes(copyNode, paramsWithoutNode) || isFilterMatched(copyNode, paramsWithoutNode)) || !isStrictMode && !(isFilterMatched(copyNode, paramsWithoutNode) || findFilteredNodes(copyNode, paramsWithoutNode))) {
              localMatch = false;
            }

            if (!localMatch) {
              break;
            }
          } //global


          if (props.globalFilter && !globalMatch) {
            var copyNodeForGlobal = _objectSpread({}, copyNode);

            filterValue = props.globalFilter;
            filterConstraint = FilterService.filters['contains'];
            paramsWithoutNode = {
              filterField: filterField,
              filterValue: filterValue,
              filterConstraint: filterConstraint,
              isStrictMode: isStrictMode
            };

            if (isStrictMode && (findFilteredNodes(copyNodeForGlobal, paramsWithoutNode) || isFilterMatched(copyNodeForGlobal, paramsWithoutNode)) || !isStrictMode && (isFilterMatched(copyNodeForGlobal, paramsWithoutNode) || findFilteredNodes(copyNodeForGlobal, paramsWithoutNode))) {
              globalMatch = true;
              copyNode = copyNodeForGlobal;
            }
          }
        }

        var matches = localMatch;

        if (props.globalFilter) {
          matches = localMatch && globalMatch;
        }

        if (matches) {
          filteredNodes.push(copyNode);
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    return filteredNodes;
  };

  var findFilteredNodes = function findFilteredNodes(node, paramsWithoutNode) {
    if (node) {
      var matched = false;

      if (node.children) {
        var childNodes = _toConsumableArray(node.children);

        node.children = [];

        var _iterator6 = _createForOfIteratorHelper(childNodes),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var childNode = _step6.value;

            var copyChildNode = _objectSpread({}, childNode);

            if (isFilterMatched(copyChildNode, paramsWithoutNode)) {
              matched = true;
              node.children.push(copyChildNode);
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }

      if (matched) {
        return true;
      }
    }
  };

  var isFilterMatched = function isFilterMatched(node, _ref) {
    var filterField = _ref.filterField,
        filterValue = _ref.filterValue,
        filterConstraint = _ref.filterConstraint,
        isStrictMode = _ref.isStrictMode,
        options = _ref.options;
    var matched = false;
    var dataFieldValue = ObjectUtils.resolveFieldData(node.data, filterField);

    if (filterConstraint(dataFieldValue, filterValue, props.filterLocale, options)) {
      matched = true;
    }

    if (!matched || isStrictMode && !isNodeLeaf(node)) {
      matched = findFilteredNodes(node, {
        filterField: filterField,
        filterValue: filterValue,
        filterConstraint: filterConstraint,
        isStrictMode: isStrictMode
      }) || matched;
    }

    return matched;
  };

  var isNodeLeaf = function isNodeLeaf(node) {
    return node.leaf === false ? false : !(node.children && node.children.length);
  };

  var processData = function processData() {
    var data = props.value || [];

    if (!props.lazy) {
      if (data && data.length) {
        var filters = getFilters();
        var sortField = getSortField();
        var multiSortMeta = getMultiSortMeta();

        if (ObjectUtils.isNotEmpty(filters) || props.globalFilter) {
          data = filterLocal(data);
        }

        if (sortField || ObjectUtils.isNotEmpty(multiSortMeta)) {
          if (props.sortMode === 'single') data = sortSingle(data);else if (props.sortMode === 'multiple') data = sortMultiple(data);
        }
      }
    }

    return data;
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      filter: filter,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });

  var createTableHeader = function createTableHeader(columns, columnGroup) {
    var sortField = getSortField();
    var sortOrder = getSortOrder();

    var multiSortMeta = _toConsumableArray(getMultiSortMeta());

    var filters = getFilters();
    return /*#__PURE__*/React.createElement(TreeTableHeader, {
      columns: columns,
      columnGroup: columnGroup,
      tabIndex: props.tabIndex,
      onSort: onSort,
      sortField: sortField,
      sortOrder: sortOrder,
      multiSortMeta: multiSortMeta,
      resizableColumns: props.resizableColumns,
      onResizeStart: onColumnResizeStart,
      reorderableColumns: props.reorderableColumns,
      onDragStart: onColumnDragStart,
      onDragOver: onColumnDragOver,
      onDragLeave: onColumnDragLeave,
      onDrop: onColumnDrop,
      onFilter: onFilter,
      filters: filters,
      filterDelay: props.filterDelay
    });
  };

  var createTableFooter = function createTableFooter(columns, columnGroup) {
    return /*#__PURE__*/React.createElement(TreeTableFooter, {
      columns: columns,
      columnGroup: columnGroup
    });
  };

  var createTableBody = function createTableBody(value, columns) {
    return /*#__PURE__*/React.createElement(TreeTableBody, {
      value: value,
      columns: columns,
      expandedKeys: getExpandedKeys(),
      selectOnEdit: props.selectOnEdit,
      onToggle: onToggle,
      onExpand: props.onExpand,
      onCollapse: props.onCollapse,
      paginator: props.paginator,
      first: getFirst(),
      rows: getRows(),
      selectionMode: props.selectionMode,
      selectionKeys: props.selectionKeys,
      onSelectionChange: props.onSelectionChange,
      metaKeySelection: props.metaKeySelection,
      onRowClick: props.onRowClick,
      onSelect: props.onSelect,
      onUnselect: props.onUnselect,
      propagateSelectionUp: props.propagateSelectionUp,
      propagateSelectionDown: props.propagateSelectionDown,
      lazy: props.lazy,
      rowClassName: props.rowClassName,
      emptyMessage: props.emptyMessage,
      loading: props.loading,
      contextMenuSelectionKey: props.contextMenuSelectionKey,
      onContextMenuSelectionChange: props.onContextMenuSelectionChange,
      onContextMenu: props.onContextMenu
    });
  };

  var createPaginator = function createPaginator(position, totalRecords) {
    var className = classNames('p-paginator-' + position, props.paginatorClassName);
    return /*#__PURE__*/React.createElement(Paginator, {
      first: getFirst(),
      rows: getRows(),
      pageLinkSize: props.pageLinkSize,
      className: className,
      onPageChange: onPageChange,
      template: props.paginatorTemplate,
      totalRecords: totalRecords,
      rowsPerPageOptions: props.rowsPerPageOptions,
      currentPageReportTemplate: props.currentPageReportTemplate,
      leftContent: props.paginatorLeft,
      rightContent: props.paginatorRight,
      alwaysShow: props.alwaysShowPaginator,
      dropdownAppendTo: props.paginatorDropdownAppendTo
    });
  };

  var createScrollableView = function createScrollableView(value, columns, frozen, headerColumnGroup, footerColumnGroup) {
    var header = createTableHeader(columns, headerColumnGroup);
    var footer = createTableFooter(columns, footerColumnGroup);
    var body = createTableBody(value, columns);
    return /*#__PURE__*/React.createElement(TreeTableScrollableView, {
      columns: columns,
      header: header,
      body: body,
      footer: footer,
      scrollHeight: props.scrollHeight,
      frozen: frozen,
      frozenWidth: props.frozenWidth
    });
  };

  var createScrollableTable = function createScrollableTable(value) {
    var columns = getColumns();
    var frozenColumns = getFrozenColumns(columns);
    var scrollableColumns = frozenColumns ? getScrollableColumns(columns) : columns;
    var frozenView, scrollableView;

    if (frozenColumns) {
      frozenView = createScrollableView(value, frozenColumns, true, props.frozenHeaderColumnGroup, props.frozenFooterColumnGroup);
    }

    scrollableView = createScrollableView(value, scrollableColumns, false, props.headerColumnGroup, props.footerColumnGroup);
    return /*#__PURE__*/React.createElement("div", {
      className: "p-treetable-scrollable-wrapper"
    }, frozenView, scrollableView);
  };

  var createRegularTable = function createRegularTable(value) {
    var columns = getColumns();
    var header = createTableHeader(columns, props.headerColumnGroup);
    var footer = createTableFooter(columns, props.footerColumnGroup);
    var body = createTableBody(value, columns);
    return /*#__PURE__*/React.createElement("div", {
      className: "p-treetable-wrapper"
    }, /*#__PURE__*/React.createElement("table", {
      style: props.tableStyle,
      className: props.tableClassName
    }, header, footer, body));
  };

  var createTable = function createTable(value) {
    return props.scrollable ? createScrollableTable(value) : createRegularTable(value);
  };

  var createLoader = function createLoader() {
    if (props.loading) {
      var iconClassName = classNames('p-treetable-loading-icon pi-spin', props.loadingIcon);
      return /*#__PURE__*/React.createElement("div", {
        className: "p-treetable-loading"
      }, /*#__PURE__*/React.createElement("div", {
        className: "p-treetable-loading-overlay p-component-overlay"
      }, /*#__PURE__*/React.createElement("i", {
        className: iconClassName
      })));
    }

    return null;
  };

  var data = processData();
  var otherProps = ObjectUtils.findDiffKeys(props, TreeTable$1.defaultProps);
  var className = classNames('p-treetable p-component', {
    'p-treetable-hoverable-rows': props.rowHover,
    'p-treetable-selectable': isRowSelectionMode(),
    'p-treetable-resizable': props.resizableColumns,
    'p-treetable-resizable-fit': props.resizableColumns && props.columnResizeMode === 'fit',
    'p-treetable-auto-layout': props.autoLayout,
    'p-treetable-striped': props.stripedRows,
    'p-treetable-gridlines': props.showGridlines
  }, props.className);
  var table = createTable(data);
  var totalRecords = getTotalRecords(data);
  var headerFacet = props.header && /*#__PURE__*/React.createElement("div", {
    className: "p-treetable-header"
  }, props.header);
  var footerFacet = props.footer && /*#__PURE__*/React.createElement("div", {
    className: "p-treetable-footer"
  }, props.footer);
  var paginatorTop = props.paginator && props.paginatorPosition !== 'bottom' && createPaginator('top', totalRecords);
  var paginatorBottom = props.paginator && props.paginatorPosition !== 'top' && createPaginator('bottom', totalRecords);
  var loader = createLoader();
  var resizeHelper = props.resizableColumns && /*#__PURE__*/React.createElement("div", {
    ref: resizerHelperRef,
    className: "p-column-resizer-helper",
    style: {
      display: 'none'
    }
  });
  var reorderIndicatorUp = props.reorderableColumns && /*#__PURE__*/React.createElement("span", {
    ref: reorderIndicatorUpRef,
    className: "pi pi-arrow-down p-datatable-reorder-indicator-up",
    style: {
      position: 'absolute',
      display: 'none'
    }
  });
  var reorderIndicatorDown = props.reorderableColumns && /*#__PURE__*/React.createElement("span", {
    ref: reorderIndicatorDownRef,
    className: "pi pi-arrow-up p-datatable-reorder-indicator-down",
    style: {
      position: 'absolute',
      display: 'none'
    }
  });
  return /*#__PURE__*/React.createElement("div", _extends$1({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style,
    "data-scrollselectors": ".p-treetable-scrollable-body"
  }, otherProps), loader, headerFacet, paginatorTop, table, paginatorBottom, footerFacet, resizeHelper, reorderIndicatorUp, reorderIndicatorDown);
});
TreeTable$1.displayName = 'TreeTable';
TreeTable$1.defaultProps = {
  __TYPE: 'TreeTable',
  id: null,
  value: null,
  header: null,
  footer: null,
  style: null,
  className: null,
  tableStyle: null,
  tableClassName: null,
  expandedKeys: null,
  paginator: false,
  paginatorPosition: 'bottom',
  alwaysShowPaginator: true,
  paginatorClassName: null,
  paginatorTemplate: 'FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown',
  paginatorLeft: null,
  paginatorRight: null,
  paginatorDropdownAppendTo: null,
  pageLinkSize: 5,
  rowsPerPageOptions: null,
  currentPageReportTemplate: '({currentPage} of {totalPages})',
  first: null,
  rows: null,
  totalRecords: null,
  lazy: false,
  sortField: null,
  sortOrder: null,
  multiSortMeta: null,
  sortMode: 'single',
  defaultSortOrder: 1,
  removableSort: false,
  selectionMode: null,
  selectionKeys: null,
  contextMenuSelectionKey: null,
  metaKeySelection: true,
  selectOnEdit: true,
  propagateSelectionUp: true,
  propagateSelectionDown: true,
  autoLayout: false,
  rowClassName: null,
  loading: false,
  loadingIcon: 'pi pi-spinner',
  tabIndex: 0,
  scrollable: false,
  scrollHeight: null,
  reorderableColumns: false,
  headerColumnGroup: null,
  footerColumnGroup: null,
  frozenHeaderColumnGroup: null,
  frozenFooterColumnGroup: null,
  frozenWidth: null,
  resizableColumns: false,
  columnResizeMode: 'fit',
  emptyMessage: null,
  filters: null,
  globalFilter: null,
  filterMode: 'lenient',
  filterDelay: 300,
  filterLocale: undefined,
  rowHover: false,
  showGridlines: false,
  stripedRows: false,
  onFilter: null,
  onExpand: null,
  onCollapse: null,
  onToggle: null,
  onPage: null,
  onSort: null,
  onSelect: null,
  onUnselect: null,
  onRowClick: null,
  onSelectionChange: null,
  onContextMenuSelectionChange: null,
  onColumnResizeEnd: null,
  onColReorder: null,
  onContextMenu: null
};

var TreeTable = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      value = _ref.value,
      header = _ref.header,
      footer = _ref.footer,
      style = _ref.style,
      className = _ref.className,
      tableStyle = _ref.tableStyle,
      tableClassName = _ref.tableClassName,
      expandedKeys = _ref.expandedKeys,
      first = _ref.first,
      _ref$lazy = _ref.lazy,
      lazy = _ref$lazy === void 0 ? false : _ref$lazy,
      sortField = _ref.sortField,
      sortOrder = _ref.sortOrder,
      multiSortMeta = _ref.multiSortMeta,
      _ref$sortMode = _ref.sortMode,
      sortMode = _ref$sortMode === void 0 ? "single" : _ref$sortMode,
      _ref$defaultSortOrder = _ref.defaultSortOrder,
      defaultSortOrder = _ref$defaultSortOrder === void 0 ? 1 : _ref$defaultSortOrder,
      _ref$removableSort = _ref.removableSort,
      removableSort = _ref$removableSort === void 0 ? false : _ref$removableSort,
      _ref$selectionMode = _ref.selectionMode,
      selectionMode = _ref$selectionMode === void 0 ? false : _ref$selectionMode,
      selectionKeys = _ref.selectionKeys,
      _ref$metaKeySelection = _ref.metaKeySelection,
      metaKeySelection = _ref$metaKeySelection === void 0 ? true : _ref$metaKeySelection,
      _ref$selectOnEdit = _ref.selectOnEdit,
      selectOnEdit = _ref$selectOnEdit === void 0 ? true : _ref$selectOnEdit,
      _ref$propagateSelecti = _ref.propagateSelectionUp,
      propagateSelectionUp = _ref$propagateSelecti === void 0 ? true : _ref$propagateSelecti,
      _ref$propagateSelecti2 = _ref.propagateSelectionDown,
      propagateSelectionDown = _ref$propagateSelecti2 === void 0 ? true : _ref$propagateSelecti2,
      _ref$autoLayout = _ref.autoLayout,
      autoLayout = _ref$autoLayout === void 0 ? false : _ref$autoLayout,
      rowClassName = _ref.rowClassName,
      _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? false : _ref$loading,
      _ref$tabIndex = _ref.tabIndex,
      tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
      _ref$scrollable = _ref.scrollable,
      scrollable = _ref$scrollable === void 0 ? false : _ref$scrollable,
      scrollHeight = _ref.scrollHeight,
      headerColumnGroup = _ref.headerColumnGroup,
      footerColumnGroup = _ref.footerColumnGroup,
      frozenHeaderColumnGroup = _ref.frozenHeaderColumnGroup,
      frozenFooterColumnGroup = _ref.frozenFooterColumnGroup,
      frozenWidth = _ref.frozenWidth,
      emptyMessage = _ref.emptyMessage,
      _ref$showGridlines = _ref.showGridlines,
      showGridlines = _ref$showGridlines === void 0 ? false : _ref$showGridlines,
      onExpand = _ref.onExpand,
      onCollapse = _ref.onCollapse,
      onToggle = _ref.onToggle,
      onSelect = _ref.onSelect,
      onUnselect = _ref.onUnselect,
      onSelectionChange = _ref.onSelectionChange,
      children = _ref.children;
  return /*#__PURE__*/React__default.createElement(TreeTable$1, {
    ref: ref,
    id: id,
    value: value,
    header: header,
    footer: footer,
    style: style,
    className: className,
    tableStyle: tableStyle,
    tableClassName: tableClassName,
    expandedKeys: expandedKeys,
    first: first,
    lazy: lazy,
    sortField: sortField,
    sortOrder: sortOrder,
    multiSortMeta: multiSortMeta,
    sortMode: sortMode,
    defaultSortOrder: defaultSortOrder,
    removableSort: removableSort,
    selectionMode: selectionMode ? "checkbox" : null,
    selectionKeys: selectionKeys,
    metaKeySelection: metaKeySelection,
    selectOnEdit: selectOnEdit,
    propagateSelectionUp: propagateSelectionUp,
    propagateSelectionDown: propagateSelectionDown,
    autoLayout: autoLayout,
    rowClassName: rowClassName,
    loading: loading,
    tabIndex: tabIndex,
    scrollable: scrollable,
    scrollHeight: scrollHeight,
    headerColumnGroup: headerColumnGroup,
    footerColumnGroup: footerColumnGroup,
    frozenHeaderColumnGroup: frozenHeaderColumnGroup,
    frozenFooterColumnGroup: frozenFooterColumnGroup,
    frozenWidth: frozenWidth,
    emptyMessage: emptyMessage,
    showGridlines: showGridlines,
    onExpand: onExpand,
    onCollapse: onCollapse,
    onToggle: onToggle,
    onSelect: onSelect,
    onUnselect: onUnselect,
    onSelectionChange: onSelectionChange,
    alwaysShowPaginator: false
  }, children);
});

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

var TriStateCheckbox$1 = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      focusedState = _React$useState2[0],
      setFocusedState = _React$useState2[1];

  var elementRef = React.useRef(null);

  var onClick = function onClick(event) {
    if (!props.disabled && !props.readOnly) {
      toggle(event);
    }
  };

  var toggle = function toggle(event) {
    var newValue;
    if (props.value === null || props.value === undefined) newValue = true;else if (props.value === true) newValue = false;else if (props.value === false) newValue = null;

    if (props.onChange) {
      props.onChange({
        originalEvent: event,
        value: newValue,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        target: {
          name: props.name,
          id: props.id,
          value: newValue
        }
      });
    }
  };

  var onFocus = function onFocus() {
    setFocusedState(true);
  };

  var onBlur = function onBlur() {
    setFocusedState(false);
  };

  var onKeyDown = function onKeyDown(e) {
    if (e.keyCode === 32) {
      toggle(e);
      e.preventDefault();
    }
  };

  React.useImperativeHandle(ref, function () {
    return {
      props: props,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  });
  var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
  var otherProps = ObjectUtils.findDiffKeys(props, TriStateCheckbox$1.defaultProps);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var className = classNames('p-tristatecheckbox p-checkbox p-component', props.className);
  var boxClassName = classNames('p-checkbox-box', {
    'p-highlight': (props.value || !props.value) && props.value !== null,
    'p-disabled': props.disabled,
    'p-focus': focusedState
  });
  var iconClassName = classNames('p-checkbox-icon p-c', {
    'pi pi-check': props.value === true,
    'pi pi-times': props.value === false
  });
  var ariaValueLabel = props.value ? ariaLabel('trueLabel') : props.value === false ? ariaLabel('falseLabel') : ariaLabel('nullLabel');
  var ariaChecked = props.value ? 'true' : 'false';
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends({
    ref: elementRef,
    id: props.id,
    className: className,
    style: props.style
  }, otherProps, {
    onClick: onClick
  }), /*#__PURE__*/React.createElement("div", _extends({
    className: boxClassName,
    tabIndex: props.tabIndex,
    onFocus: onFocus,
    onBlur: onBlur,
    onKeyDown: onKeyDown,
    role: "checkbox",
    "aria-checked": ariaChecked
  }, ariaProps), /*#__PURE__*/React.createElement("span", {
    className: iconClassName
  })), focusedState && /*#__PURE__*/React.createElement("span", {
    className: "p-sr-only",
    "aria-live": "polite"
  }, ariaValueLabel)), hasTooltip && /*#__PURE__*/React.createElement(Tooltip$1, _extends({
    target: elementRef,
    content: props.tooltip
  }, props.tooltipOptions)));
}));
TriStateCheckbox$1.displayName = 'TriStateCheckbox';
TriStateCheckbox$1.defaultProps = {
  __TYPE: 'TriStateCheckbox',
  id: null,
  value: null,
  style: null,
  className: null,
  disabled: false,
  readOnly: false,
  tabIndex: '0',
  tooltip: null,
  tooltipOptions: null,
  onChange: null
};

var TriStateCheckbox = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var id = _ref.id,
      inputRef = _ref.inputRef,
      inputId = _ref.inputId,
      value = _ref.value,
      name = _ref.name,
      style = _ref.style,
      className = _ref.className,
      disabled = _ref.disabled,
      tooltip = _ref.tooltip,
      tooltipOptions = _ref.tooltipOptions,
      ariaLabelledBy = _ref.ariaLabelledBy,
      onChange = _ref.onChange;
  var filteredTooltipOptions = filterTooltipOptions(tooltipOptions);
  return /*#__PURE__*/React__default.createElement(TriStateCheckbox$1, {
    ref: ref,
    id: id,
    inputRef: inputRef,
    inputId: inputId,
    value: value,
    name: name,
    style: style,
    className: className,
    disabled: disabled,
    tooltip: tooltip,
    tooltipOptions: filteredTooltipOptions,
    ariaLabelledBy: ariaLabelledBy,
    onChange: onChange
  });
});

var translations = {
  ru: {
    accept: "",
    reject: "",
    choose: "",
    upload: "",
    cancel: "",
    weekHeader: "",
    weak: "",
    firstDayOfWeek: 1,
    dayNames: ["", "", "", "", "", "", ""],
    dayNamesShort: ["", "", "", "", "", "", ""],
    dayNamesMin: ["", "", "", "", "", "", ""],
    monthNames: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthNamesShort: ["", "", "", "", "", "", "", "", "", "", "", ""],
    today: "",
    clear: "",
    dateFormat: "dd.mm.yy"
  }
};

var initLocales = function initLocales() {
  addLocale("ru", translations.ru);
};

var changeLocale = function changeLocale(language) {
  locale(language);
};

export { Accordion, AccordionTab, Avatar, Badge, BlockUI, BreadCrumb, Button, Card, Checkbox$1 as Checkbox, Chip, Chips, Column, ColumnGroup, ConnectedOverlayScrollHandler, Dash, DataTable, DatePicker, DateTimePicker, Dialog, Divider, DomHandler, Dropdown, EventBus, FileUpload, FilterMatchMode$1 as FilterMatchMode, FilterOperator, FilterService, IconUtils, Image, InputMask, InputNumber, InputSwitch, InputText, InputTextarea, Message, MessageSeverity, Money, MultiSelect, Number$1 as Number, ObjectUtils, Pagination, PanelMenu, PrimeIcons, ProgressBar, RadioButton, Row, ScrollTop, SelectButton, Skeleton, SortOrder, Spinner, TabPanel, TabView, Tag, TieredMenu, TimePicker, Toast, Tooltip, Tree, TreeTable, TriStateCheckbox, UniqueComponentId, ZIndexUtils, addLocale, ariaLabel, changeLocale, classNames, confirmDialog, confirmPopup, initLocales, locale, localeOption$1 as localeOption, localeOptions$1 as localeOptions, mask, updateLocaleOption, updateLocaleOptions };
